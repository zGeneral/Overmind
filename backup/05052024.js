// this._sources prototype was bugged and gixed
// evaluating energy needed to fix roads was extremely expensive, removed it
// const paveTicks = 1; // zgeneral 2/2024 //_.sum(activeRooms, (roomName) =>
                        //this.colony.roadLogistics.energyToRepave(roomName),
                    //);
// // this.energyToRepave(room.name) >= worker.carryCapacity //zGeneral 2/2024
// recording creep position is extremely expensive and not being used (to be verified)
            // Record previous creep positions (RoomIntel.run() is executed at end of each tick)
            // this.recordCreepPositions(room); zGeneral 2/2024 CPU OPtimization
            // if (room.my) {
            // 	this.recordCreepOccupancies(room);
            // }
// creep parking is now diabled
// getPowerBank was bugged and now being fixed.
// Overmind.visuals(); // Draw visuals // zGeneral 2/2024


// regenerated sources from power creeps are removed when the sources timer kicks off again!
// zGeneral 11/4/2023 optimize CPU - disable
// zGeneral 11/4/2023 optimize CPU - disable
// zGeneral 11/4/2023 optimize CPU - disable

//res = "X";
//_.forEach(Overmind.colonies,c=>{
//  if(c.room.mineral.mineralType == res){
//    c.room.mineral.pos.createFlag(c.room.name+"_"+res,COLOR_YELLOW,COLOR_CYAN);
//    console.log(c.room.name);
//  }
//  })

//
// _______________________________________
//   ___ ___ ._______   _______________
//  /   |   \|   \   \ /   /\_   _____/
// /    ~    \   |\   Y   /  |    __)_
// \    Y    /   | \     /   |        \
//  \___|_  /|___|  \___/   /_______  /
//        \/                        \/
// _____________ Screeps AI ______________
//

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

global.__VERSION__ = '0.6.0';
global.deref = function (ref) {
    // dereference any object from identifier
    return (
        Game.getObjectById(ref) ||
        Game.flags[ref] ||
        Game.creeps[ref] ||
        Game.spawns[ref] ||
        null
    );
};
global.derefRoomPosition = function (protoPos) {
    return new RoomPosition(protoPos.x, protoPos.y, protoPos.roomName);
};
global.NO_ACTION = 1;
global.PERMACACHE = {};
// // Assign values to the memory key aliases declared in memory.d.ts
// global._TICK = 'T';
// global._EXPIRATION = 'X';
// global._COLONY = 'C';
// global._OVERLORD = 'O';
// global._DISTANCE = 'D';
// global._RM_AVOID = 'a';
// global._RM_SOURCE = 's';
// global._RM_CONTROLLER = 'c';
// global._RM_MINERAL = 'm';
// global._RM_SKLAIRS = 'k';
//
// global._RM_IMPORTANTSTRUCTURES = 'i';
// global._RM_IS_TOWERS = 't';
// global._RM_IS_SPAWNS = 'sp';
// global._RM_IS_STORAGE = 's';
// global._RM_IS_TERMINAL = 'e';
// global._RM_IS_WALLS = 'w';
// global._RM_IS_RAMPARTS = 'r';
//
// global._RM_EXPANSIONDATA = 'e';
// global._RM_INVASIONDATA = 'v';
// global._RM_HARVEST = 'h';
// global._RM_CASUALTIES = 'd';
// global.RMEM_SAFETY = 'f';
// global._RM_PREVPOSITIONS = 'p';
// global._RM_CREEPSINROOM = 'cr';
//
// global._AMOUNT = 'a';
// global._AVG10K = 'D';
// global._AVG100K = 'H';
// global._AVG1M = 'M';
//
// global._CTRL_LEVEL = 'l';
// global._CTRL_OWNER = 'o';
// global._CTRL_RESERVATION = 'r';
// global._CTRL_RES_USERNAME = 'u';
// global._CTRL_RES_TICKSTOEND = 't';
// global._CTRL_SAFEMODE = 's';
// global._CTRL_SAFEMODE_AVAILABLE = 'sa';
// global._CTRL_SAFEMODE_COOLDOWN = 'sc';
// global._CTRL_PROGRESS = 'p';
// global._CTRL_PROGRESSTOTAL = 'pt';
//
// global._MNRL_MINERALTYPE = 't';
// global._MNRL_DENSITY = 'd';

// Modifications to Game-level functions
const _marketDeal = Game.market.deal;
Game.market.deal = function (orderId, amount, targetRoomName) {
    const response = _marketDeal(orderId, amount, targetRoomName);
    if (response == OK) {
        if (
            targetRoomName &&
            Game.rooms[targetRoomName] &&
            Game.rooms[targetRoomName].terminal &&
            Game.rooms[targetRoomName].terminal.my
        ) {
            // Mark the terminal as being blocked
            Game.rooms[targetRoomName].terminal._notReady = true;
        }
    }
    return response;
};

// Creep properties ====================================================================================================
// Boosting logic ------------------------------------------------------------------------------------------------------
Object.defineProperty(Creep.prototype, 'boosts', {
    get() {
        if (!this._boosts) {
            this._boosts = _.compact(
                _.unique(_.map(this.body, (bodyPart) => bodyPart.boost)),
            );
        }
        return this._boosts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'boostCounts', {
    get() {
        if (!this._boostCounts) {
            this._boostCounts = _.countBy(
                this.body,
                (bodyPart) => bodyPart.boost,
            );
        }
        return this._boostCounts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'approxMoveSpeed', {
    get() {
        if (this._moveSpeed == undefined) {
            const movePower = _.sum(this.body, (part) => {
                if (part.type == MOVE && part.boost) {
                    return BOOSTS.move[part.boost].fatigue;
                } else {
                    return 0;
                }
            });
            const nonMoveParts = _.sum(this.body, (part) =>
                part.type != MOVE ? 1 : 0,
            );
            this._moveSpeed = Math.max(movePower / nonMoveParts, 1); // if nonMoveParts == 0, this will be Infinity -> 1
        }
        return this._moveSpeed;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'inRampart', {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART); // this assumes hostile creeps can't stand in my ramparts
    },
    configurable: true,
});
// Permanently cached properties
PERMACACHE.bodypartCounts = PERMACACHE.bodypartCounts || {};
Object.defineProperty(Creep.prototype, 'bodypartCounts', {
    get() {
        if (PERMACACHE.bodypartCounts[this.id] === undefined) {
            PERMACACHE.bodypartCounts[this.id] = _.countBy(
                this.body,
                (part) => part.type,
            );
            _.defaults(PERMACACHE.bodypartCounts[this.id], {
                [MOVE]: 0,
                [WORK]: 0,
                [CARRY]: 0,
                [ATTACK]: 0,
                [RANGED_ATTACK]: 0,
                [TOUGH]: 0,
                [HEAL]: 0,
                [CLAIM]: 0,
            });
        }
        return PERMACACHE.bodypartCounts[this.id];
    },
    configurable: true,
});
PERMACACHE.isPlayer = PERMACACHE.isPlayer || {};
Object.defineProperty(Creep.prototype, 'isPlayer', {
    get() {
        if (PERMACACHE.isPlayer[this.id] === undefined) {
            PERMACACHE.isPlayer[this.id] =
                this.owner.username != 'Invader' &&
                this.owner.username != 'Source Keeper' &&
                this.owner.username != 'Screeps';
        }
        return PERMACACHE.isPlayer[this.id];
    },
    configurable: true,
});

Object.defineProperty(PowerCreep.prototype, 'inRampart', {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART); // this assumes hostile creeps can't stand in my ramparts
    },
    configurable: true,
});
// // Redefine some properties that creeps have so that PowerCreeps can be inserted in Zerg subclass
//
// Object.defineProperty(PowerCreep.prototype, 'body', {
// 	get() {
// 		return [];
// 	},
// 	configurable: true,
// });
//
// Object.defineProperty(PowerCreep.prototype, 'fatigue', {
// 	get() {
// 		return 0;
// 	},
// 	configurable: true,
// });
//
// Object.defineProperty(PowerCreep.prototype, 'spawning', {
// 	get() {
// 		return false;
// 	},
// 	configurable: true,
// });
//
// PowerCreep.prototype.attack = function(target: AnyCreep | Structure): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.attackController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.attackController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.build = function(target: ConstructionSite):
// 	CreepActionReturnCode | ERR_NOT_ENOUGH_RESOURCES | ERR_RCL_NOT_ENOUGH {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.claimController = function(target: StructureController): CreepActionReturnCode
// 	| ERR_FULL | ERR_GCL_NOT_ENOUGH {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.generateSafeMode = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.getActiveBodyparts = function(type: BodyPartConstant): number {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return 0;
// };
// PowerCreep.prototype.harvest = function(target: Source | Mineral | Deposit): CreepActionReturnCode
// 	| ERR_NOT_FOUND | ERR_NOT_ENOUGH_RESOURCES {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.heal = function(target: AnyCreep): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.pull = function(target: Creep): OK | ERR_NOT_OWNER | ERR_BUSY | ERR_INVALID_TARGET
// 	| ERR_NOT_IN_RANGE | ERR_NO_BODYPART {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedAttack = function(target: AnyCreep | Structure): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedHeal = function(target: AnyCreep): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedMassAttack = function(): OK | ERR_NOT_OWNER | ERR_BUSY | ERR_NO_BODYPART {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.repair = function(target: Structure): CreepActionReturnCode | ERR_NOT_ENOUGH_RESOURCES {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.reserveController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.signController = function(target: StructureController, text: string): OK | ERR_BUSY
// 	| ERR_INVALID_TARGET | ERR_NOT_IN_RANGE {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_INVALID_TARGET;
// };
// PowerCreep.prototype.upgradeController = function(target: StructureController): ScreepsReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };

// RoomObject prototypes
Object.defineProperty(RoomObject.prototype, 'ref', {
    // reference object; see globals.deref (which includes Creep)
    get: function () {
        return this.id || this.name || '';
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, 'targetedBy', {
    // List of creep names with tasks targeting this object
    get: function () {
        return Overmind.cache.targets[this.ref] || [];
    },
    configurable: true,
});
RoomObject.prototype.serialize = function () {
    const pos = {
        x: this.pos.x,
        y: this.pos.y,
        roomName: this.pos.roomName,
    };
    return {
        pos: pos,
        ref: this.ref,
    };
};
Object.defineProperty(RoomObject.prototype, 'firstEffectRemaining', {
    get() {
        var _a;
        return !this.effects
            ? 0
            : ((_a = this.effects[0]) === null || _a === void 0
                  ? void 0
                  : _a.ticksRemaining) || 0;
    },
    configurable: true,
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r =
            c < 3
                ? target
                : desc === null
                ? (desc = Object.getOwnPropertyDescriptor(target, key))
                : desc,
        d;
    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if ((d = decorators[i]))
                r =
                    (c < 3
                        ? d(r)
                        : c > 3
                        ? d(target, key, r)
                        : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// A bunch of unicode string constants
const bullet = '\u2023 ';
const rightArrow = '\u27f6';
const leftArrow = '\u27f5';
const alignedNewline =
    '\n' +
    ' '.repeat('INFO    '.length + Game.time.toString().length + ' '.length);

// Random utilities that don't belong anywhere else
function getAllRooms() {
    if (!Game._allRooms) {
        Game._allRooms = _.values(Game.rooms); // this is cleared every tick
    }
    return Game._allRooms;
}
function getOwnedRooms() {
    if (!Game._ownedRooms) {
        Game._ownedRooms = _.filter(getAllRooms(), (room) => room.my); // this is cleared every tick
    }
    return Game._ownedRooms;
}
function canClaimAnotherRoom() {
    return getOwnedRooms().length < Game.gcl.level;
}
function printRoomName(roomName, aligned = false) {
    if (aligned) {
        const msg =
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            roomName +
            '">' +
            roomName +
            '</a>';
        const extraSpaces = 'E12S34'.length - roomName.length;
        return msg + ' '.repeat(extraSpaces);
    } else {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            roomName +
            '">' +
            roomName +
            '</a>'
        );
    }
}
function color(str, color) {
    return `<font color='${color}'>${str}</font>`;
}
function componentToHex(n) {
    const hex = n.toString(16);
    return hex.length == 1 ? '0' + hex : hex;
}
function rgbToHex(r, g, b) {
    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
/**
 * Correct generalization of the modulo operator to negative numbers
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function minMax(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
/**
 * Hacky way to make any store an index type
 * https://stackoverflow.com/questions/37006008/typescript-index-signature-is-missing-in-type
 * @param store the store whose resources to sum up
 */
function sumStore(store) {
    return _.sum(storeIndex(store));
}
function storeIndex(store) {
    return store;
}
function hasMinerals(store) {
    for (const resourceType in store) {
        if (resourceType != RESOURCE_ENERGY && (store[resourceType] || 0) > 0) {
            return true;
        }
    }
    return false;
}
/**
 * Obtain the username of the player
 */
function getMyUsername() {
    for (const i in Game.rooms) {
        const room = Game.rooms[i];
        if (room.controller && room.controller.owner && room.controller.my) {
            return room.controller.owner.username;
        }
    }
    for (const i in Game.creeps) {
        const creep = Game.creeps[i];
        if (creep.owner) {
            return creep.owner.username;
        }
    }
    console.log(
        'ERROR: Could not determine username. You can set this manually in src/settings/settings_user',
    );
    return 'ERROR: Could not determine username.';
}
function isAlly(username) {
    return (
        username !== MY_USERNAME &&
        (Memory.settings.allies || []).includes(username)
    );
}
function hasJustSpawned() {
    return (
        _.keys(Overmind.colonies).length == 1 &&
        _.keys(Game.creeps).length == 0 &&
        _.keys(Game.spawns).length == 1
    );
}
function onPublicServer() {
    return Game.shard.name.includes('shard');
}
function onTrainingEnvironment() {
    return (
        !!Memory.reinforcementLearning && !!Memory.reinforcementLearning.enabled
    );
}
function getReinforcementLearningTrainingVerbosity() {
    if (Memory.reinforcementLearning) {
        if (Memory.reinforcementLearning.verbosity != undefined) {
            return Memory.reinforcementLearning.verbosity;
        }
    }
    return 0;
}
/**
 * Create column-aligned text array from object with string key/values
 */
function toColumns(obj, opts = {}) {
    _.defaults(opts, {
        padChar: ' ',
        justify: false,
    });
    const ret = [];
    const keyPadding = _.max(_.map(_.keys(obj), (str) => str.length)) + 1;
    const valPadding = _.max(_.mapValues(obj, (str) => str.length));
    for (const key in obj) {
        if (opts.justify) {
            ret.push(
                key.padRight(keyPadding, opts.padChar) +
                    obj[key].padLeft(valPadding, opts.padChar),
            );
        } else {
            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key]);
        }
    }
    return ret;
}
/**
 * Merges a list of store-like objects, summing overlapping keys. Useful for calculating assets from multiple sources
 */
function mergeSum(objects) {
    const ret = {};
    for (const object of objects) {
        for (const key in object) {
            const amount = object[key] || 0;
            if (!ret[key]) {
                ret[key] = 0;
            }
            ret[key] += amount;
        }
    }
    return ret;
}
/**
 * Returns a compact two-character encoding of the coordinate
 */
// export function compactCoordName(coord: Coord): string {
// 	return String.fromCharCode(CHARCODE_A + coord.x, CHARCODE_A + coord.y);
// }
//
// export function derefCoords(coordName: string, roomName: string): RoomPosition {
// 	const [x, y] = coordName.split(':');
// 	return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
// }
function posFromReadableName(str) {
    if (!str) return;
    const posName = _.first(str.match(/(E|W)\d+(N|S)\d+:\d+:\d+/g) || []);
    if (posName) {
        const [roomName, x, y] = posName.split(':');
        return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
    }
}
function equalXYR(pos1, pos2) {
    return (
        pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName
    );
}
/**
 * Equivalent to lodash.minBy() method
 */
function minBy(objects, iteratee) {
    let minObj;
    let minVal = Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val < minVal) {
            minVal = val;
            minObj = objects[i];
        }
    }
    return minObj;
}
/**
 * Equivalent to lodash.maxBy() method
 */
function maxBy(objects, iteratee) {
    let maxObj;
    let maxVal = -Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val > maxVal) {
            maxVal = val;
            maxObj = objects[i];
        }
    }
    return maxObj;
}
/**
 * Return whether the IVM is enabled
 */
function isIVM() {
    return typeof Game.cpu.getHeapStatistics === 'function';
}
/**
 * Generate a randomly-offset cache expiration time
 */
function getCacheExpiration(timeout, offset = 5) {
    return (
        Game.time + timeout + Math.round(Math.random() * offset * 2 - offset)
    );
}
const hexChars = '0123456789abcdef';
/**
 * Generate a random hex string of specified length
 */
function randomHex(length) {
    let result = '';
    for (let i = 0; i < length; i++) {
        result += hexChars[Math.floor(Math.random() * hexChars.length)];
    }
    return result;
}
/**
 * Compute an exponential moving average
 */
function ema(current, avg, window, zeroThreshold = 1e-9) {
    let newAvg = (current + (avg || 0) * (window - 1)) / window;
    if (zeroThreshold && Math.abs(newAvg) < zeroThreshold) {
        newAvg = 0;
    }
    return newAvg;
}
/**
 * Create a shallow copy of a 2D array
 */
function clone2DArray(a) {
    return _.map(a, (e) => e.slice());
}
/**
 * Rotate a square matrix in place clockwise by 90 degrees
 */
function rotateMatrix(matrix) {
    // reverse the rows
    matrix.reverse();
    // swap the symmetric elements
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < i; j++) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
/**
 * Return a copy of a 2D array rotated by specified number of clockwise 90 turns
 */
function rotatedMatrix(matrix, clockwiseTurns) {
    const mat = clone2DArray(matrix);
    for (let i = 0; i < clockwiseTurns; i++) {
        rotateMatrix(mat);
    }
    return mat;
}

// Global settings file containing player information
/**
 * My Screeps username; used for a variety of updating and communications purposes. (Changing this might break things.)
 */
const MUON = 'Muon';
/**
 * Your username - you shouldn't need to change this.
 */
const MY_USERNAME = getMyUsername();
/**
 * Profiling is incredibly expensive and can cause the script to time out. By setting this option, you can limit the
 * number of colonies that will be handled while profiling. Colonies above this limit do not get run.
 */
const PROFILER_COLONY_LIMIT = Math.ceil(Game.gcl.level);
/**
 * Enable this to suppress alerts of invalid flag color codes. (Don't do this unless you know what you're doing.)
 */
const SUPPRESS_INVALID_DIRECTIVE_ALERTS = false;
// export const OVERMIND_SMALL_CAPS = `⇐ǝʌᴉɥ with Overmind⇒ <${MY_USERNAME}>`;
const OVERMIND_SMALL_CAPS = `⇐Overmind⇒ <${MY_USERNAME}>`;
const DEFAULT_OVERMIND_SIGNATURE = OVERMIND_SMALL_CAPS;
/**
 * If this is enabled, Memory.bot will default to true. This will not change the mode if already set - use setMode().
 */
const DEFAULT_OPERATION_MODE = 'automatic';
/**
 * Limit how many rooms you can claim (for any shard)
 */
const MAX_OWNED_ROOMS = Infinity;
/**
 * If you are running on shard3 (CPU limit 20), only claim this many rooms
 */
const SHARD3_MAX_OWNED_ROOMS = 3;
/**
 * The amount of credits that Overmind will try to keep in the bank. Default:
 * Private servers: 1,000 (will spend aggressively)
 * Public servers: 100,000 if you are below RCL 10, otherwise 1,000,000.
 */
const RESERVE_CREDITS = onPublicServer()
    ? Game.gcl.level >= 10
        ? 1e6
        : 1e5
    : 1000;
/**
 * The global Overmind object will be re-instantiated after this many ticks. In the meantime, refresh() is used.
 */
const NEW_OVERMIND_INTERVAL = onPublicServer() ? 20 : 5;
/**
 * If this is set to true, a stripped-down version of Overmind suitable for training with my python screeps environment
 * will be run instead. The main loop will be disabled and creeps will be controlled based on serialized actions
 * communicated to them from the RL model through memory.
 * WARNING: enabling RL_TRAINING_MODE will wipe the contents of your memory!
 */
const RL_TRAINING_MODE = onTrainingEnvironment();
/**
 * Configure how much stuff gets logged to console
 * 0: no logging
 * 1: log every 100th, 101th tick
 * 2: log every tick
 */
const RL_TRAINING_VERBOSITY = getReinforcementLearningTrainingVerbosity();

var commonjsGlobal =
    typeof globalThis !== 'undefined'
        ? globalThis
        : typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
        ? global
        : typeof self !== 'undefined'
        ? self
        : {};

function createCommonjsModule(fn, module) {
    return (
        (module = { exports: {} }), fn(module, module.exports), module.exports
    );
}

// This is a modified version of screeps-profiler taken from https://github.com/samogot/screeps-profiler

let usedOnStart = 0;
let enabled = false;
let depth = 0;
let parentFn = '(tick)';

function AlreadyWrappedError() {
    this.name = 'AlreadyWrappedError';
    this.message = 'Error attempted to double wrap a function.';
    this.stack = new Error().stack;
}

function setupProfiler() {
    depth = 0; // reset depth, this needs to be done each tick.
    parentFn = '(tick)';
    Game.profiler = {
        stream(duration, filter) {
            setupMemory('stream', duration || 10, filter);
        },
        email(duration, filter) {
            setupMemory('email', duration || 100, filter);
        },
        profile(duration, filter) {
            setupMemory('profile', duration || 100, filter);
        },
        background(filter) {
            setupMemory('background', false, filter);
        },
        callgrind() {
            const id = `id${Math.random()}`;
            /* eslint-disable */
            const download = `
<script>
  var element = document.getElementById('${id}');
  if (!element) {
    element = document.createElement('a');
    element.setAttribute('id', '${id}');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,${encodeURIComponent(
        Profiler.callgrind(),
    )}');
    element.setAttribute('download', 'callgrind.out.${Game.time}');
  
    element.style.display = 'none';
    document.body.appendChild(element);
  
    element.click();
  }
</script>
      `;
            /* eslint-enable */
            console.log(
                download
                    .split('\n')
                    .map((s) => s.trim())
                    .join(''),
            );
        },
        restart() {
            if (Profiler.isProfiling()) {
                const filter = Memory.screepsProfiler.filter;
                let duration = false;
                if (!!Memory.screepsProfiler.disableTick) {
                    // Calculate the original duration, profile is enabled on the tick after the first call,
                    // so add 1.
                    duration =
                        Memory.screepsProfiler.disableTick -
                        Memory.screepsProfiler.enabledTick +
                        1;
                }
                const type = Memory.screepsProfiler.type;
                setupMemory(type, duration, filter);
            }
        },
        reset: resetMemory,
        output: Profiler.output,
    };

    overloadCPUCalc();
}

function setupMemory(profileType, duration, filter) {
    resetMemory();
    const disableTick = Number.isInteger(duration)
        ? Game.time + duration
        : false;
    if (!Memory.screepsProfiler) {
        Memory.screepsProfiler = {
            map: {},
            totalTime: 0,
            enabledTick: Game.time + 1,
            disableTick,
            type: profileType,
            filter,
        };
    }
}

function resetMemory() {
    Memory.screepsProfiler = null;
}

function overloadCPUCalc() {
    if (Game.rooms.sim) {
        usedOnStart = 0; // This needs to be reset, but only in the sim.
        Game.cpu.getUsed = function getUsed() {
            return performance.now() - usedOnStart;
        };
    }
}

function getFilter() {
    return Memory.screepsProfiler.filter;
}

const functionBlackList = [
    'getUsed', // Let's avoid wrapping this... may lead to recursion issues and should be inexpensive.
    'constructor', // es6 class constructors need to be called with `new`
];

const commonProperties = ['length', 'name', 'arguments', 'caller', 'prototype'];

function wrapFunction(name, originalFunction) {
    if (originalFunction.profilerWrapped) {
        throw new AlreadyWrappedError();
    }

    function wrappedFunction() {
        if (Profiler.isProfiling()) {
            const nameMatchesFilter = name === getFilter();
            const start = Game.cpu.getUsed();
            if (nameMatchesFilter) {
                depth++;
            }
            const curParent = parentFn;
            parentFn = name;
            let result;
            if (this && this.constructor === wrappedFunction) {
                // eslint-disable-next-line new-cap
                result = new originalFunction(...arguments);
            } else {
                result = originalFunction.apply(this, arguments);
            }
            parentFn = curParent;
            if (depth > 0 || !getFilter()) {
                const end = Game.cpu.getUsed();
                Profiler.record(name, end - start, parentFn);
            }
            if (nameMatchesFilter) {
                depth--;
            }
            return result;
        }

        if (this && this.constructor === wrappedFunction) {
            // eslint-disable-next-line new-cap
            return new originalFunction(...arguments);
        }
        return originalFunction.apply(this, arguments);
    }

    wrappedFunction.profilerWrapped = true;
    wrappedFunction.toString = () =>
        `// screeps-profiler wrapped function:\n${originalFunction.toString()}`;

    Object.getOwnPropertyNames(originalFunction).forEach((property) => {
        if (!commonProperties.includes(property)) {
            wrappedFunction[property] = originalFunction[property];
        }
    });

    return wrappedFunction;
}

function hookUpPrototypes() {
    Profiler.prototypes.forEach((proto) => {
        profileObjectFunctions(proto.val, proto.name);
    });
}

function profileObjectFunctions(object, label) {
    if (object.prototype) {
        profileObjectFunctions(object.prototype, label);
    }
    const objectToWrap = object;

    Object.getOwnPropertyNames(objectToWrap).forEach((functionName) => {
        const extendedLabel = `${label}.${functionName}`;

        const isBlackListed = functionBlackList.indexOf(functionName) !== -1;
        if (isBlackListed) {
            return;
        }

        const descriptor = Object.getOwnPropertyDescriptor(
            objectToWrap,
            functionName,
        );
        if (!descriptor) {
            return;
        }

        const hasAccessor = descriptor.get || descriptor.set;
        if (hasAccessor) {
            const configurable = descriptor.configurable;
            if (!configurable) {
                return;
            }

            const profileDescriptor = {};

            if (descriptor.get) {
                const extendedLabelGet = `${extendedLabel}:get`;
                profileDescriptor.get = profileFunction(
                    descriptor.get,
                    extendedLabelGet,
                );
            }

            if (descriptor.set) {
                const extendedLabelSet = `${extendedLabel}:set`;
                profileDescriptor.set = profileFunction(
                    descriptor.set,
                    extendedLabelSet,
                );
            }

            Object.defineProperty(
                objectToWrap,
                functionName,
                profileDescriptor,
            );
            return;
        }

        const isFunction = typeof descriptor.value === 'function';
        if (!isFunction || !descriptor.writable) {
            return;
        }
        const originalFunction = objectToWrap[functionName];
        objectToWrap[functionName] = profileFunction(
            originalFunction,
            extendedLabel,
        );
    });

    return objectToWrap;
}

function profileFunction(fn, functionName) {
    const fnName = functionName || fn.name;
    if (!fnName) {
        console.log("Couldn't find a function name for - ", fn);
        console.log('Will not profile this function.');
        return fn;
    }

    return wrapFunction(fnName, fn);
}

const Profiler = {
    printProfile() {
        console.log(Profiler.output());
    },

    emailProfile() {
        Game.notify(Profiler.output(1000));
    },

    callgrind() {
        const elapsedTicks = Game.time - Memory.screepsProfiler.enabledTick + 1;
        Memory.screepsProfiler.map['(tick)'].calls = elapsedTicks;
        Memory.screepsProfiler.map['(tick)'].time =
            Memory.screepsProfiler.totalTime;
        Profiler.checkMapItem('(root)');
        Memory.screepsProfiler.map['(root)'].calls = 1;
        Memory.screepsProfiler.map['(root)'].time =
            Memory.screepsProfiler.totalTime;
        Profiler.checkMapItem(
            '(tick)',
            Memory.screepsProfiler.map['(root)'].subs,
        );
        Memory.screepsProfiler.map['(root)'].subs[
            '(tick)'
        ].calls = elapsedTicks;
        Memory.screepsProfiler.map['(root)'].subs['(tick)'].time =
            Memory.screepsProfiler.totalTime;
        let body = `events: ns\nsummary: ${Math.round(
            Memory.screepsProfiler.totalTime * 1000000,
        )}\n`;
        for (const fnName of Object.keys(Memory.screepsProfiler.map)) {
            const fn = Memory.screepsProfiler.map[fnName];
            let callsBody = '';
            let callsTime = 0;
            for (const callName of Object.keys(fn.subs)) {
                const call = fn.subs[callName];
                const ns = Math.round(call.time * 1000000);
                callsBody += `cfn=${callName}\ncalls=${call.calls} 1\n1 ${ns}\n`;
                callsTime += call.time;
            }
            body += `\nfn=${fnName}\n1 ${Math.round(
                (fn.time - callsTime) * 1000000,
            )}\n${callsBody}`;
        }
        return body;
    },

    output(passedOutputLengthLimit) {
        const outputLengthLimit = passedOutputLengthLimit || 1000;
        if (!Memory.screepsProfiler || !Memory.screepsProfiler.enabledTick) {
            return 'Profiler not active.';
        }

        const endTick = Math.min(
            Memory.screepsProfiler.disableTick || Game.time,
            Game.time,
        );
        const startTick = Memory.screepsProfiler.enabledTick + 1;
        const elapsedTicks = endTick - startTick;
        const header = 'calls\t\ttime\t\tavg\t\tfunction';
        const footer = [
            `Avg: ${(Memory.screepsProfiler.totalTime / elapsedTicks).toFixed(
                2,
            )}`,
            `Total: ${Memory.screepsProfiler.totalTime.toFixed(2)}`,
            `Ticks: ${elapsedTicks}`,
        ].join('\t');

        const lines = [header];
        let currentLength = header.length + 1 + footer.length;
        const allLines = Profiler.lines();
        let done = false;
        while (!done && allLines.length) {
            const line = allLines.shift();
            // each line added adds the line length plus a new line character.
            if (currentLength + line.length + 1 < outputLengthLimit) {
                lines.push(line);
                currentLength += line.length + 1;
            } else {
                done = true;
            }
        }
        lines.push(footer);
        return lines.join('\n');
    },

    lines() {
        const stats = Object.keys(Memory.screepsProfiler.map)
            .map((functionName) => {
                const functionCalls = Memory.screepsProfiler.map[functionName];
                return {
                    name: functionName,
                    calls: functionCalls.calls,
                    totalTime: functionCalls.time,
                    averageTime: functionCalls.time / functionCalls.calls,
                };
            })
            .sort((val1, val2) => {
                return val2.totalTime - val1.totalTime;
            });

        const lines = stats.map((data) => {
            return [
                data.calls,
                data.totalTime.toFixed(1),
                data.averageTime.toFixed(3),
                data.name,
            ].join('\t\t');
        });

        return lines;
    },

    prototypes: [
        { name: 'Game', val: commonjsGlobal.Game },
        { name: 'Map', val: commonjsGlobal.Game.map },
        { name: 'Market', val: commonjsGlobal.Game.market },
        { name: 'PathFinder', val: commonjsGlobal.PathFinder },
        { name: 'RawMemory', val: commonjsGlobal.RawMemory },
        { name: 'ConstructionSite', val: commonjsGlobal.ConstructionSite },
        { name: 'Creep', val: commonjsGlobal.Creep },
        { name: 'Flag', val: commonjsGlobal.Flag },
        { name: 'Mineral', val: commonjsGlobal.Mineral },
        { name: 'Nuke', val: commonjsGlobal.Nuke },
        { name: 'OwnedStructure', val: commonjsGlobal.OwnedStructure },
        { name: 'CostMatrix', val: commonjsGlobal.PathFinder.CostMatrix },
        { name: 'Resource', val: commonjsGlobal.Resource },
        { name: 'Room', val: commonjsGlobal.Room },
        { name: 'RoomObject', val: commonjsGlobal.RoomObject },
        { name: 'RoomPosition', val: commonjsGlobal.RoomPosition },
        { name: 'RoomVisual', val: commonjsGlobal.RoomVisual },
        { name: 'Source', val: commonjsGlobal.Source },
        { name: 'Structure', val: commonjsGlobal.Structure },
        { name: 'StructureContainer', val: commonjsGlobal.StructureContainer },
        {
            name: 'StructureController',
            val: commonjsGlobal.StructureController,
        },
        { name: 'StructureExtension', val: commonjsGlobal.StructureExtension },
        { name: 'StructureExtractor', val: commonjsGlobal.StructureExtractor },
        {
            name: 'StructureKeeperLair',
            val: commonjsGlobal.StructureKeeperLair,
        },
        { name: 'StructureLab', val: commonjsGlobal.StructureLab },
        { name: 'StructureLink', val: commonjsGlobal.StructureLink },
        { name: 'StructureNuker', val: commonjsGlobal.StructureNuker },
        { name: 'StructureObserver', val: commonjsGlobal.StructureObserver },
        { name: 'StructurePowerBank', val: commonjsGlobal.StructurePowerBank },
        {
            name: 'StructurePowerSpawn',
            val: commonjsGlobal.StructurePowerSpawn,
        },
        { name: 'StructurePortal', val: commonjsGlobal.StructurePortal },
        { name: 'StructureRampart', val: commonjsGlobal.StructureRampart },
        { name: 'StructureRoad', val: commonjsGlobal.StructureRoad },
        { name: 'StructureSpawn', val: commonjsGlobal.StructureSpawn },
        { name: 'StructureStorage', val: commonjsGlobal.StructureStorage },
        { name: 'StructureTerminal', val: commonjsGlobal.StructureTerminal },
        { name: 'StructureTower', val: commonjsGlobal.StructureTower },
        { name: 'StructureWall', val: commonjsGlobal.StructureWall },
    ],

    checkMapItem(functionName, map = Memory.screepsProfiler.map) {
        if (!map[functionName]) {
            // eslint-disable-next-line no-param-reassign
            map[functionName] = {
                time: 0,
                calls: 0,
                subs: {},
            };
        }
    },

    record(functionName, time, parent) {
        this.checkMapItem(functionName);
        Memory.screepsProfiler.map[functionName].calls++;
        Memory.screepsProfiler.map[functionName].time += time;
        if (parent) {
            this.checkMapItem(parent);
            this.checkMapItem(
                functionName,
                Memory.screepsProfiler.map[parent].subs,
            );
            Memory.screepsProfiler.map[parent].subs[functionName].calls++;
            Memory.screepsProfiler.map[parent].subs[functionName].time += time;
        }
    },

    endTick() {
        if (Game.time >= Memory.screepsProfiler.enabledTick) {
            const cpuUsed = Game.cpu.getUsed();
            Memory.screepsProfiler.totalTime += cpuUsed;
            Profiler.report();
        }
    },

    report() {
        if (Profiler.shouldPrint()) {
            Profiler.printProfile();
        } else if (Profiler.shouldEmail()) {
            Profiler.emailProfile();
        }
    },

    isProfiling() {
        if (!enabled || !Memory.screepsProfiler) {
            return false;
        }
        return (
            !Memory.screepsProfiler.disableTick ||
            Game.time <= Memory.screepsProfiler.disableTick
        );
    },

    type() {
        return Memory.screepsProfiler.type;
    },

    shouldPrint() {
        const streaming = Profiler.type() === 'stream';
        const profiling = Profiler.type() === 'profile';
        const onEndingTick = Memory.screepsProfiler.disableTick === Game.time;
        return streaming || (profiling && onEndingTick);
    },

    shouldEmail() {
        return (
            Profiler.type() === 'email' &&
            Memory.screepsProfiler.disableTick === Game.time
        );
    },
};

var screepsProfiler = {
    wrap(callback) {
        if (enabled) {
            setupProfiler();
        }

        if (Profiler.isProfiling()) {
            usedOnStart = Game.cpu.getUsed();

            // Commented lines are part of an on going experiment to keep the profiler
            // performant, and measure certain types of overhead.

            // var callbackStart = Game.cpu.getUsed();
            const returnVal = callback();
            // var callbackEnd = Game.cpu.getUsed();
            Profiler.endTick();
            // var end = Game.cpu.getUsed();

            // var profilerTime = (end - start) - (callbackEnd - callbackStart);
            // var callbackTime = callbackEnd - callbackStart;
            // var unaccounted = end - profilerTime - callbackTime;
            // console.log('total-', end, 'profiler-', profilerTime, 'callbacktime-',
            // callbackTime, 'start-', start, 'unaccounted', unaccounted);
            return returnVal;
        }

        return callback();
    },

    enable() {
        enabled = true;
        hookUpPrototypes();
    },

    output: Profiler.output,
    callgrind: Profiler.callgrind,

    registerObject: profileObjectFunctions,
    registerFN: profileFunction,
    registerClass: profileObjectFunctions,
};

function profile(target, key, _descriptor) {
    {
        return;
    }
}

var Cartographer_1;
const ROOMTYPE_SOURCEKEEPER = 'SK';
const ROOMTYPE_CORE = 'CORE';
const ROOMTYPE_CONTROLLER = 'CTRL';
const ROOMTYPE_ALLEY = 'ALLEY';
const ROOMTYPE_CROSSROAD = 'CROSSROAD';
PERMACACHE.cartographerRoomTypes = PERMACACHE.cartographerRoomTypes || {};
/**
 * Cartographer: provides helper methods related to Game.map. A few of these methods have been modified from BonzAI
 * codebase, although I have introduced new methods of my own over time as well.
 */
let Cartographer = (Cartographer_1 = class Cartographer {
    /**
     * Lists all rooms up to and including a given distance away, including roomName
     */
    static findRoomsInRange(roomName, depth) {
        return _.flatten(_.values(this.recursiveRoomSearch(roomName, depth)));
    }
    /**
     * Lists all rooms at exactly a given distance away, including roomName
     */
    static findRoomsAtRange(roomName, depth) {
        return this.recursiveRoomSearch(roomName, depth)[depth];
    }
    /**
     * Recursively enumerate all rooms from a root node using depth first search to a maximum depth
     */
    static recursiveRoomSearch(roomName, maxDepth) {
        const visitedRooms = this._recursiveRoomSearch(
            roomName,
            0,
            maxDepth,
            {},
        );
        const roomDepths = {};
        for (const room in visitedRooms) {
            const depth = visitedRooms[room];
            if (!roomDepths[depth]) {
                roomDepths[depth] = [];
            }
            roomDepths[depth].push(room);
        }
        return roomDepths;
    }
    /**
     * The recursive part of recursiveRoomSearch. Yields inverted results mapping roomName to depth.
     */
    static _recursiveRoomSearch(roomName, depth, maxDepth, visited) {
        if (visited[roomName] == undefined) {
            visited[roomName] = depth;
        } else {
            visited[roomName] = Math.min(depth, visited[roomName]);
        }
        const neighbors = _.values(Game.map.describeExits(roomName));
        if (depth < maxDepth) {
            for (const neighbor of neighbors) {
                // Visit the neighbor if not already done or if this would be a more direct route
                if (
                    visited[neighbor] == undefined ||
                    depth + 1 < visited[neighbor]
                ) {
                    this._recursiveRoomSearch(
                        neighbor,
                        depth + 1,
                        maxDepth,
                        visited,
                    );
                }
            }
        }
        return visited;
    }
    /**
     * Get the type of the room
     */
    static roomType(roomName) {
        if (!PERMACACHE.cartographerRoomTypes[roomName]) {
            let roomType;
            const coords = Cartographer_1.getRoomCoordinates(roomName);
            if (coords.x % 10 === 0 && coords.y % 10 === 0) {
                roomType = ROOMTYPE_CROSSROAD;
            } else if (coords.x % 10 === 0 || coords.y % 10 === 0) {
                roomType = ROOMTYPE_ALLEY;
            } else if (
                coords.x % 10 != 0 &&
                coords.x % 5 === 0 &&
                coords.y % 10 != 0 &&
                coords.y % 5 === 0
            ) {
                roomType = ROOMTYPE_CORE;
            } else if (
                coords.x % 10 <= 6 &&
                coords.x % 10 >= 4 &&
                coords.y % 10 <= 6 &&
                coords.y % 10 >= 4
            ) {
                roomType = ROOMTYPE_SOURCEKEEPER;
            } else {
                roomType = ROOMTYPE_CONTROLLER;
            }
            PERMACACHE.cartographerRoomTypes[roomName] = roomType;
        }
        return PERMACACHE.cartographerRoomTypes[roomName];
    }
    /**
     * Get the name of a room offset from the anchor room
     */
    static findRelativeRoomName(roomName, xDelta, yDelta) {
        const coords = this.getRoomCoordinates(roomName);
        let xDir = coords.xDir;
        if (xDir === 'W') {
            xDelta = -xDelta;
        }
        let yDir = coords.yDir;
        if (yDir === 'N') {
            yDelta = -yDelta;
        }
        let x = coords.x + xDelta;
        let y = coords.y + yDelta;
        if (x < 0) {
            x = Math.abs(x) - 1;
            xDir = this.oppositeDir(xDir);
        }
        if (y < 0) {
            // noinspection JSSuspiciousNameCombination
            y = Math.abs(y) - 1;
            yDir = this.oppositeDir(yDir);
        }
        return xDir + x + yDir + y;
    }
    /**
     * Find the relative x and y offsets of two rooms
     */
    static findRoomCoordDeltas(origin, otherRoom) {
        const originCoords = this.getRoomCoordinates(origin);
        const otherCoords = this.getRoomCoordinates(otherRoom);
        let xDelta = otherCoords.x - originCoords.x;
        if (originCoords.xDir !== otherCoords.xDir) {
            xDelta = otherCoords.x + originCoords.x + 1;
        }
        let yDelta = otherCoords.y - originCoords.y;
        if (originCoords.yDir !== otherCoords.yDir) {
            yDelta = otherCoords.y + originCoords.y + 1;
        }
        // normalize direction
        if (originCoords.xDir === 'W') {
            xDelta = -xDelta;
        }
        if (originCoords.yDir === 'N') {
            yDelta = -yDelta;
        }
        return { x: xDelta, y: yDelta };
    }
    /**
     * Returns the direction (not magnitude) of a room from an origin room
     */
    static findRelativeRoomDir(origin, otherRoom) {
        const coordDeltas = this.findRoomCoordDeltas(origin, otherRoom);
        // noinspection JSSuspiciousNameCombination
        if (Math.abs(coordDeltas.x) == Math.abs(coordDeltas.y)) {
            if (coordDeltas.x > 0) {
                if (coordDeltas.y > 0) {
                    return 2;
                } else {
                    return 4;
                }
            } else if (coordDeltas.x < 0) {
                if (coordDeltas.y > 0) {
                    return 8;
                } else {
                    return 6;
                }
            } else {
                return 0;
            }
        } else {
            // noinspection JSSuspiciousNameCombination
            if (Math.abs(coordDeltas.x) > Math.abs(coordDeltas.y)) {
                if (coordDeltas.x > 0) {
                    return 3;
                } else {
                    return 7;
                }
            } else {
                if (coordDeltas.y > 0) {
                    return 1;
                } else {
                    return 5;
                }
            }
        }
    }
    /**
     * Return the opposite direction, e.g. "W" => "E"
     */
    static oppositeDir(dir) {
        switch (dir) {
            case 'W':
                return 'E';
            case 'E':
                return 'W';
            case 'N':
                return 'S';
            case 'S':
                return 'N';
            default:
                return 'error';
        }
    }
    /**
     * Get the coordinates from a room name
     */
    static getRoomCoordinates(roomName) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = match[2];
        const yDir = match[3];
        const y = match[4];
        return {
            x: Number(x),
            y: Number(y),
            xDir: xDir,
            yDir: yDir,
        };
    }
});
Cartographer = Cartographer_1 = __decorate([profile], Cartographer);
// Register on global for debugging
global.Cartographer = Cartographer;

Object.defineProperty(RoomPosition.prototype, 'print', {
    get() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.roomName +
            '">[' +
            this.roomName +
            ', ' +
            this.x +
            ', ' +
            this.y +
            ']</a>'
        );
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'printPlain', {
    get() {
        return `[${this.roomName}, ${this.x}, ${this.y}]`;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'room', {
    get: function () {
        return Game.rooms[this.roomName];
    },
    configurable: true,
});
RoomPosition.prototype.toCoord = function () {
    return { x: this.x, y: this.y };
};
Object.defineProperty(RoomPosition.prototype, 'readableName', {
    // identifier for the pos, used in caching
    get: function () {
        return this.roomName + ':' + this.x + ':' + this.y;
    },
    configurable: true,
});
// Object.defineProperty(RoomPosition.prototype, 'coordName', { // name, but without the roomName
// 	get         : function() {
// 		return this.x + ':' + this.y;
// 	},
// 	configurable: true,
// });
RoomPosition.prototype.lookForStructure = function (structureType) {
    return _.find(
        this.lookFor(LOOK_STRUCTURES),
        (s) => s.structureType === structureType,
    );
};
RoomPosition.prototype.getOffsetPos = function (dx, dy) {
    let roomName = this.roomName;
    let x = this.x + dx;
    if (x < 0 || x > 49) {
        const dxRoom = Math.floor(x / 50);
        x = mod(x, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, dxRoom, 0);
    }
    let y = this.y + dy;
    if (y < 0 || y > 49) {
        const dyRoom = Math.floor(y / 50);
        y = mod(y, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, 0, dyRoom);
    }
    return new RoomPosition(x, y, roomName);
};
// RoomPosition.prototype.findInRange_fast = function<T extends HasPos>(objects: T[], range: number): T[] {
// 	return _.filter(objects, o => this.inRangeToXY(o.pos.x, o.pos.y, range));
// }
Object.defineProperty(RoomPosition.prototype, 'isEdge', {
    // if the position is at the edge of a room
    get: function () {
        return this.x === 0 || this.x === 49 || this.y === 0 || this.y === 49;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'isVisible', {
    // if the position is in a defined room
    get: function () {
        return Game.rooms[this.roomName] != undefined;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'rangeToEdge', {
    // range to the nearest room edge
    get: function () {
        return _.min([this.x, 49 - this.x, this.y, 49 - this.y]);
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'roomCoords', {
    get: function () {
        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.roomName);
        let x = parseInt(parsed[1], 10);
        let y = parseInt(parsed[2], 10);
        if (this.roomName.includes('W')) x = -x;
        if (this.roomName.includes('N')) y = -y;
        return { x: x, y: y };
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'neighbors', {
    get: function () {
        const adjPos = [];
        for (const dx of [-1, 0, 1]) {
            for (const dy of [-1, 0, 1]) {
                if (!(dx == 0 && dy == 0)) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (0 < x && x < 49 && 0 < y && y < 49) {
                        adjPos.push(new RoomPosition(x, y, this.roomName));
                    }
                }
            }
        }
        return adjPos;
    },
    configurable: true,
});
RoomPosition.prototype.inRangeToPos = function (pos, range) {
    return (
        this.roomName === pos.roomName &&
        (pos.x - this.x < 0 ? this.x - pos.x : pos.x - this.x) <= range &&
        (pos.y - this.y < 0 ? this.y - pos.y : pos.y - this.y) <= range
    );
};
RoomPosition.prototype.inRangeToXY = function (x, y, range) {
    return (
        (x - this.x < 0 ? this.x - x : x - this.x) <= range &&
        (y - this.y < 0 ? this.y - y : y - this.y) <= range
    );
};
RoomPosition.prototype.getRangeToXY = function (x, y) {
    return Math.max(
        x - this.x < 0 ? this.x - x : x - this.x,
        y - this.y < 0 ? this.y - y : y - this.y,
    );
};
RoomPosition.prototype.getPositionsInRange = function (
    range,
    includeWalls = false,
    includeEdges = false,
) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.getPositionsAtRange = function (
    range,
    includeWalls = false,
    includeEdges = false,
) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            if (Math.max(Math.abs(dx), Math.abs(dy)) < range) {
                continue;
            }
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.isWalkable = function (ignoreCreeps = false) {
    // Is terrain passable?
    if (
        Game.map.getRoomTerrain(this.roomName).get(this.x, this.y) ==
        TERRAIN_MASK_WALL
    ) {
        return false;
    }
    if (this.isVisible) {
        // Are there creeps?
        if (ignoreCreeps == false && this.lookFor(LOOK_CREEPS).length > 0) {
            return false;
        }
        // Are there structures?
        if (
            _.filter(this.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable)
                .length > 0
        ) {
            return false;
        }
    }
    return true;
};
RoomPosition.prototype.availableNeighbors = function (ignoreCreeps = false) {
    return _.filter(this.neighbors, (pos) => pos.isWalkable(ignoreCreeps));
};
RoomPosition.prototype.getPositionAtDirection = function (
    direction,
    range = 1,
) {
    let dx = 0;
    let dy = 0;
    switch (direction) {
        case 1:
            dy = -range;
            break;
        case 2:
            dy = -range;
            dx = range;
            break;
        case 3:
            dx = range;
            break;
        case 4:
            dx = range;
            dy = range;
            break;
        case 5:
            dy = range;
            break;
        case 6:
            dy = range;
            dx = -range;
            break;
        case 7:
            dx = -range;
            break;
        case 8:
            dx = -range;
            dy = -range;
            break;
    }
    return this.getOffsetPos(dx, dy);
};
// Object.defineProperty(RoomPosition.prototype, 'availableAdjacentSpots', {
// 	get: function () {
// 		if (this.isVisible) {
// 			let spots: RoomPosition[] = [];
// 			for (let spot of this.adjacentSpots) {
// 				let structures = this.look;
// 				if (Game.map.getTerrainAt(neighbor) != 'wall') {
// 					// Doesn't include constructed walls
// 					spots.push(neighbor);
// 				}
// 			}
// 			return spots;
// 		} else {
// 			return this.adjacentSpots; // Assume there's nothing there
// 		}
// 	}
// });
// Get an estimate for the distance to another room position in a possibly different room
RoomPosition.prototype.getMultiRoomRangeTo = function (pos) {
    if (this.roomName == pos.roomName) {
        return this.getRangeTo(pos);
    } else {
        const from = this.roomCoords;
        const to = pos.roomCoords;
        const dx = Math.abs(50 * (to.x - from.x) + pos.x - this.x);
        const dy = Math.abs(50 * (to.y - from.y) + pos.y - this.y);
        return _.max([dx, dy]);
    }
};
RoomPosition.prototype.findClosestByLimitedRange = function (
    objects,
    rangeLimit,
    opts,
) {
    const objectsInRange = this.findInRange(objects, rangeLimit, opts);
    return this.findClosestByRange(objectsInRange, opts);
};
RoomPosition.prototype.findClosestByMultiRoomRange = function (objects) {
    return minBy(objects, (obj) => this.getMultiRoomRangeTo(obj.pos));
};
// This should only be used within a single room
RoomPosition.prototype.findClosestByRangeThenPath = function (objects) {
    const distances = _.map(objects, (obj) => this.getRangeTo(obj));
    const minDistance = _.min(distances);
    if (minDistance > 4) {
        return this.findClosestByRange(objects);
    } else {
        const closestObjects = _.filter(
            objects,
            (obj) => this.getRangeTo(obj) == minDistance,
        );
        return this.findClosestByPath(closestObjects); // don't clutter up pathing.distance cached values
    }
};

RoomVisual.prototype.infoBox = function (info, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    let pointer = [
        [0.9, -0.25],
        [0.9, 0.25],
        [0.3, 0.0],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    // Draw arrow
    this.poly(pointer, {
        fill: undefined,
        stroke: opts.color,
        opacity: opts.opacity,
        strokeWidth: 0.0,
    });
    // // Draw box
    // this.rect(x + 0.9, y - 0.8 * opts.textsize,
    // 	0.55 * opts.textsize * _.max(_.map(info, line => line.length)), info.length * opts.textsize,
    // 	{
    // 		fill   : undefined,
    // 		opacity: opts.opacity
    // 	});
    // Draw vertical bar
    const x0 = x + 0.9;
    const y0 = y - 0.8 * opts.textsize;
    this.line(x0, y0, x0, y0 + info.length * opts.textsize, {
        color: opts.color,
    });
    // Draw text
    let dy = 0;
    for (const line of info) {
        this.text(line, x + 1, y + dy, {
            color: opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.multitext = function (textLines, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    // // Draw vertical bar
    // let x0 = x + 0.9;
    // let y0 = y - 0.8 * opts.textsize;
    // this.line(x0, y0, x0, y0 + textLines.length * opts.textsize, {
    // 	color: opts.color,
    // });
    // Draw text
    let dy = 0;
    for (const line of textLines) {
        this.text(line, x, y + dy, {
            color: opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.box = function (x, y, w, h, style) {
    return this.line(x, y, x + w, y, style)
        .line(x + w, y, x + w, y + h, style)
        .line(x + w, y + h, x, y + h, style)
        .line(x, y + h, x, y, style);
};
// Taken from https://github.com/screepers/RoomVisual with slight modification: ========================================
const colors = {
    gray: '#555555',
    light: '#AAAAAA',
    road: '#666',
    energy: '#FFE87B',
    power: '#F53547',
    dark: '#181818',
    outline: '#8FBB93',
    speechText: '#000000',
    speechBackground: '#aebcc4',
    infoBoxGood: '#09ff00',
    infoBoxBad: '#ff2600',
};
const speechSize = 0.5;
const speechFont = 'Times New Roman';
RoomVisual.prototype.structure = function (x, y, type, opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    switch (type) {
        case STRUCTURE_EXTENSION:
            this.circle(x, y, {
                radius: 0.5,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.35,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: '#CCCCCC',
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_POWER_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: colors.power,
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_LINK: {
            // let osize = 0.3;
            // let isize = 0.2;
            let outer = [
                [0.0, -0.5],
                [0.4, 0.0],
                [0.0, 0.5],
                [-0.4, 0.0],
            ];
            let inner = [
                [0.0, -0.3],
                [0.25, 0.0],
                [0.0, 0.3],
                [-0.25, 0.0],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.poly(inner, {
                fill: colors.gray,
                stroke: false,
                opacity: opts.opacity,
            });
            break;
        }
        case STRUCTURE_TERMINAL: {
            let outer = [
                [0.0, -0.8],
                [0.55, -0.55],
                [0.8, 0.0],
                [0.55, 0.55],
                [0.0, 0.8],
                [-0.55, 0.55],
                [-0.8, 0.0],
                [-0.55, -0.55],
            ];
            let inner = [
                [0.0, -0.65],
                [0.45, -0.45],
                [0.65, 0.0],
                [0.45, 0.45],
                [0.0, 0.65],
                [-0.45, 0.45],
                [-0.65, 0.0],
                [-0.45, -0.45],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.poly(inner, {
                fill: colors.light,
                stroke: false,
                opacity: opts.opacity,
            });
            this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                fill: colors.gray,
                stroke: colors.dark,
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            break;
        }
        case STRUCTURE_LAB:
            this.circle(x, y - 0.025, {
                radius: 0.55,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x, y - 0.025, {
                radius: 0.4,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                fill: colors.dark,
                stroke: false,
                opacity: opts.opacity,
            });
            {
                let box = [
                    [-0.45, 0.3],
                    [-0.45, 0.55],
                    [0.45, 0.55],
                    [0.45, 0.3],
                ];
                box = relPoly(x, y, box);
                this.poly(box, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity,
                });
            }
            break;
        case STRUCTURE_TOWER:
            this.circle(x, y, {
                radius: 0.6,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity,
            });
            this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                fill: colors.light,
                stroke: colors.dark,
                strokeWidth: 0.07,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_ROAD:
            this.circle(x, y, {
                radius: 0.175,
                fill: colors.road,
                stroke: false,
                opacity: opts.opacity,
            });
            if (!this.roads) this.roads = [];
            this.roads.push([x, y]);
            break;
        case STRUCTURE_RAMPART:
            this.circle(x, y, {
                radius: 0.65,
                fill: '#434C43',
                stroke: '#5D735F',
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_WALL:
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.dark,
                stroke: colors.light,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_STORAGE:
            const storageOutline = relPoly(x, y, [
                [-0.45, -0.55],
                [0, -0.65],
                [0.45, -0.55],
                [0.55, 0],
                [0.45, 0.55],
                [0, 0.65],
                [-0.45, 0.55],
                [-0.55, 0],
                [-0.45, -0.55],
            ]);
            this.poly(storageOutline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity,
            });
            this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_OBSERVER:
            this.circle(x, y, {
                fill: colors.dark,
                radius: 0.45,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x + 0.225, y, {
                fill: colors.outline,
                radius: 0.2,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_NUKER:
            let outline = [
                [0, -1],
                [-0.47, 0.2],
                [-0.5, 0.5],
                [0.5, 0.5],
                [0.47, 0.2],
                [0, -1],
            ];
            outline = relPoly(x, y, outline);
            this.poly(outline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity,
            });
            let inline = [
                [0, -0.8],
                [-0.4, 0.2],
                [0.4, 0.2],
                [0, -0.8],
            ];
            inline = relPoly(x, y, inline);
            this.poly(inline, {
                stroke: colors.outline,
                strokeWidth: 0.01,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_CONTAINER:
            this.rect(x - 0.225, y - 0.3, 0.45, 0.6, {
                fill: 'yellow',
                opacity: opts.opacity,
                stroke: colors.dark,
                strokeWidth: 0.1,
            });
            break;
        default:
            this.circle(x, y, {
                fill: colors.light,
                radius: 0.35,
                stroke: colors.dark,
                strokeWidth: 0.2,
                opacity: opts.opacity,
            });
            break;
    }
    return this;
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1],
];
RoomVisual.prototype.connectRoads = function (opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    const color = opts.color || colors.road || 'white';
    if (!this.roads) return;
    // this.text(this.roads.map(r=>r.join(',')).join(' '),25,23)
    this.roads.forEach((r) => {
        // this.text(`${r[0]},${r[1]}`,r[0],r[1],{ size: 0.2 })
        for (let i = 1; i <= 4; i++) {
            const d = dirs[i];
            const c = [r[0] + d[0], r[1] + d[1]];
            const rd = _.some(this.roads, (r) => r[0] == c[0] && r[1] == c[1]);
            // this.text(`${c[0]},${c[1]}`,c[0],c[1],{ size: 0.2, color: rd?'green':'red' })
            if (rd) {
                this.line(r[0], r[1], c[0], c[1], {
                    color: color,
                    width: 0.35,
                    opacity: opts.opacity,
                });
            }
        }
    });
    return this;
};
RoomVisual.prototype.speech = function (text, x, y, opts = {}) {
    const background = !!opts.background
        ? opts.background
        : colors.speechBackground;
    const textcolor = !!opts.textcolor ? opts.textcolor : colors.speechText;
    // noinspection PointlessBooleanExpressionJS
    const textstyle = !!opts.textstyle ? opts.textstyle : false;
    const textsize = !!opts.textsize ? opts.textsize : speechSize;
    const textfont = !!opts.textfont ? opts.textfont : speechFont;
    const opacity = !!opts.opacity ? opts.opacity : 1;
    let fontstring = '';
    if (textstyle) {
        fontstring = textstyle + ' ';
    }
    fontstring += textsize + ' ' + textfont;
    let pointer = [
        [-0.2, -0.8],
        [0.2, -0.8],
        [0, -0.3],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: background,
        stroke: background,
        opacity: opacity,
        strokeWidth: 0.0,
    });
    this.text(text, x, y - 1, {
        color: textcolor,
        backgroundColor: background,
        backgroundPadding: 0.1,
        opacity: opacity,
        font: fontstring,
    });
    return this;
};
RoomVisual.prototype.animatedPosition = function (x, y, opts = {}) {
    const color = !!opts.color ? opts.color : 'blue';
    const opacity = !!opts.opacity ? opts.opacity : 0.5;
    let radius = !!opts.radius ? opts.radius : 0.75;
    const frames = !!opts.frames ? opts.frames : 6;
    const angle = (((Game.time % frames) * 90) / frames) * (Math.PI / 180);
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    const sizeMod = Math.abs((Game.time % frames) - frames / 2) / 10;
    radius += radius * sizeMod;
    const points = [
        rotate(0, -radius, s, c, x, y),
        rotate(radius, 0, s, c, x, y),
        rotate(0, radius, s, c, x, y),
        rotate(-radius, 0, s, c, x, y),
        rotate(0, -radius, s, c, x, y),
    ];
    this.poly(points, { stroke: color, opacity: opacity });
    return this;
};
function rotate(x, y, s, c, px, py) {
    const xDelta = x * c - y * s;
    const yDelta = x * s + y * c;
    return { x: px + xDelta, y: py + yDelta };
}
function relPoly(x, y, poly) {
    return poly.map((p) => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
RoomVisual.prototype.test = function () {
    const demopos = [19, 24];
    this.clear();
    this.structure(demopos[0] + 0, demopos[1] + 0, STRUCTURE_LAB);
    this.structure(demopos[0] + 1, demopos[1] + 1, STRUCTURE_TOWER);
    this.structure(demopos[0] + 2, demopos[1] + 0, STRUCTURE_LINK);
    this.structure(demopos[0] + 3, demopos[1] + 1, STRUCTURE_TERMINAL);
    this.structure(demopos[0] + 4, demopos[1] + 0, STRUCTURE_EXTENSION);
    this.structure(demopos[0] + 5, demopos[1] + 1, STRUCTURE_SPAWN);
    this.animatedPosition(demopos[0] + 7, demopos[1]);
    this.speech('This is a test!', demopos[0] + 10, demopos[1], {
        opacity: 0.7,
    });
    // this.infoBox(['This is', 'a test', 'mmmmmmmmmmmmm'], demopos[0] + 15, demopos[1]);
    return this;
};
const ColorSets = {
    white: ['#ffffff', '#4c4c4c'],
    grey: ['#b4b4b4', '#4c4c4c'],
    red: ['#ff7b7b', '#592121'],
    yellow: ['#fdd388', '#5d4c2e'],
    green: ['#00f4a2', '#236144'],
    blue: ['#50d7f9', '#006181'],
    purple: ['#a071ff', '#371383'],
};
const ResourceColors = {
    [RESOURCE_ENERGY]: ColorSets.yellow,
    [RESOURCE_POWER]: ColorSets.red,
    [RESOURCE_HYDROGEN]: ColorSets.grey,
    [RESOURCE_OXYGEN]: ColorSets.grey,
    [RESOURCE_UTRIUM]: ColorSets.blue,
    [RESOURCE_LEMERGIUM]: ColorSets.green,
    [RESOURCE_KEANIUM]: ColorSets.purple,
    [RESOURCE_ZYNTHIUM]: ColorSets.yellow,
    [RESOURCE_CATALYST]: ColorSets.red,
    [RESOURCE_GHODIUM]: ColorSets.white,
    [RESOURCE_HYDROXIDE]: ColorSets.grey,
    [RESOURCE_ZYNTHIUM_KEANITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_LEMERGITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_HYDRIDE]: ColorSets.blue,
    [RESOURCE_UTRIUM_OXIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_HYDRIDE]: ColorSets.purple,
    [RESOURCE_KEANIUM_OXIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_HYDRIDE]: ColorSets.green,
    [RESOURCE_LEMERGIUM_OXIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_OXIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_HYDRIDE]: ColorSets.white,
    [RESOURCE_GHODIUM_OXIDE]: ColorSets.white,
    [RESOURCE_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_GHODIUM_ALKALIDE]: ColorSets.white,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: ColorSets.white,
};
RoomVisual.prototype.resource = function (
    type,
    x,
    y,
    size = 0.25,
    opacity = 1,
) {
    if (type == RESOURCE_ENERGY || type == RESOURCE_POWER) {
        this._fluid(type, x, y, size, opacity);
    } else if (
        [
            RESOURCE_CATALYST,
            RESOURCE_HYDROGEN,
            RESOURCE_OXYGEN,
            RESOURCE_LEMERGIUM,
            RESOURCE_UTRIUM,
            RESOURCE_ZYNTHIUM,
            RESOURCE_KEANIUM,
        ].includes(type)
    ) {
        this._mineral(type, x, y, size, opacity);
    } else if (ResourceColors[type] != undefined) {
        this._compound(type, x, y, size, opacity);
    } else {
        return ERR_INVALID_ARGS;
    }
    return OK;
};
RoomVisual.prototype._fluid = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.text(type[0], x, y - size * 0.1, {
        font: size * 1.5,
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0,
        opacity: opacity,
    });
};
RoomVisual.prototype._mineral = function (
    type,
    x,
    y,
    size = 0.25,
    opacity = 1,
) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.circle(x, y, {
        radius: size * 0.8,
        fill: ResourceColors[type][1],
        opacity: opacity,
    });
    this.text(type, x, y + size * 0.03, {
        font: 'bold ' + size * 1.25 + ' arial',
        color: ResourceColors[type][0],
        backgroundColor: ResourceColors[type][1],
        backgroundPadding: 0,
        opacity: opacity,
    });
};
RoomVisual.prototype._compound = function (
    type,
    x,
    y,
    size = 0.25,
    opacity = 1,
) {
    const label = type.replace('2', '₂');
    this.text(label, x, y, {
        font: 'bold ' + size * 1 + ' arial',
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0.3 * size,
        opacity: opacity,
    });
};

// Room prototypes - commonly used room properties and methods
// Logging =============================================================================================================
Object.defineProperty(Room.prototype, 'print', {
    get() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.name +
            '">' +
            this.name +
            '</a>'
        );
    },
    configurable: true,
});
// Room properties =====================================================================================================
Object.defineProperty(Room.prototype, 'my', {
    get() {
        return this.controller && this.controller.my;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isAllyColony', {
    get() {
        return (
            this.controller &&
            !this.controller.my &&
            isAlly(_.get(this.controller, ['owner', 'username']))
        );
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isAllyOutpost', {
    get() {
        return (
            this.controller &&
            !this.controller.my &&
            isAlly(_.get(this.controller, ['reservation', 'username']))
        );
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'notMe', {
    get() {
        var _a;
        return (
            this.controller &&
            !this.controller.my &&
            (this.controller.owner ||
                ((_a = this.controller) === null || _a === void 0
                    ? void 0
                    : _a.reservation))
        );
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isColony', {
    get() {
        return Overmind.colonies[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isOutpost', {
    get() {
        return Overmind.colonyMap[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'owner', {
    get() {
        return this.controller && this.controller.owner
            ? this.controller.owner.username
            : undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'reservedByMe', {
    get() {
        return (
            this.controller &&
            this.controller.reservation &&
            this.controller.reservation.username == MY_USERNAME
        );
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'signedByMe', {
    get() {
        return (
            this.controller &&
            this.controller.sign &&
            this.controller.sign.text == Memory.settings.signature
        );
    },
    configurable: true,
});
// Room properties: creeps =============================================================================================
// Creeps physically in the room

// Test property for myCreeps using cached data
Object.defineProperty(Room.prototype, 'myCachedCreeps', {
    get() {
        const creepIds = global.creepCache.myCreeps[this.name] || [];
        return creepIds.map(id => Game.getObjectById(id));
    },
    configurable: true,
});


Object.defineProperty(Room.prototype, 'creeps', { // zGeneral - Profiled to be 0.3 CPU
    get() {
        if (!this._creeps) {
            this._creeps = this.find(FIND_MY_CREEPS);
        }
        return this._creeps;
    },
    configurable: true,
});


Object.defineProperty(Room.prototype, 'hostiles', {
    get() {
        if (!this._hostiles) {
            this._hostiles = this.find(FIND_HOSTILE_CREEPS, {
                filter: (creep) => !isAlly(creep.owner.username),
            });
        }
        return this._hostiles;
    },
    configurable: true,
});

Object.defineProperty(Room.prototype, 'friendlies', {
    get() {
        if (!this._friendlies) {
            this._friendlies = this.find(FIND_HOSTILE_CREEPS, {
                filter: (creep) => isAlly(creep.owner.username),
            });
        }
        return this._friendlies;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'invaders', {
    get() {
        if (!this._invaders) {
            this._invaders = _.filter(
                this.hostiles,
                (creep) => creep.owner.username == 'Invader',
            );
        }
        return this._invaders;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'sourceKeepers', {
    get() {
        if (!this._sourceKeepers) {
            this._sourceKeepers = _.filter(
                this.hostiles,
                (creep) => creep.owner.username == 'Source Keeper',
            );
        }
        return this._sourceKeepers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'playerHostiles', {
    get() {
        if (!this._playerHostiles) {
            this._playerHostiles = _.filter(
                this.hostiles,
                (creep) => creep.isPlayer,
            ); 
        }
        return this._playerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousHostiles', {
    get() {
        if (!this._dangerousHostiles) {
            if (this.my) {
                this._dangerousHostiles = _.filter(
                    this.hostiles,
                    (creep) =>
                        creep.getActiveBodyparts(ATTACK) > 0 ||
                        creep.getActiveBodyparts(RANGED_ATTACK) > 0 ||
                        creep.getActiveBodyparts(WORK) > 0,
                );
            } else {
                this._dangerousHostiles = _.filter(
                    this.hostiles,
                    (creep) =>
                        creep.getActiveBodyparts(ATTACK) > 0 ||
                        creep.getActiveBodyparts(RANGED_ATTACK) > 0,
                );
            }
        }
        return this._dangerousHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousPlayerHostiles', {
    get() {
        if (!this._dangerousPlayerHostiles) {
            if (this.my) {
                this._dangerousPlayerHostiles = _.filter(
                    this.playerHostiles,
                    (creep) =>
                        creep.getActiveBodyparts(ATTACK) > 0 ||
                        creep.getActiveBodyparts(RANGED_ATTACK) > 0 ||
                        creep.getActiveBodyparts(WORK) > 0,
                );
            } else {
                this._dangerousPlayerHostiles = _.filter(
                    this.playerHostiles,
                    (creep) =>
                        creep.getActiveBodyparts(ATTACK) > 0 ||
                        creep.getActiveBodyparts(RANGED_ATTACK) > 0,
                );
            }
        }
        return this._dangerousPlayerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'fleeDefaults', {
    get() {
        if (!this._fleeDefaults) {
            this._fleeDefaults = [
                ...this.dangerousHostiles,
                ..._.filter(
                    this.keeperLairs,
                    (l) => (l.ticksToSpawn || Infinity) <= 10,
                ),
            ];
        }
        return this._fleeDefaults;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, 'structures', { // zGeneral - profiled to be 0.2
    get() {
        if (!this._allStructures) {
            this._allStructures = this.find(FIND_STRUCTURES);
        }
        return this._allStructures;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, 'hostileStructures', {
    get() {
        if (!this._hostileStructures) {
            this._hostileStructures = this.find(FIND_HOSTILE_STRUCTURES, {
                filter: (s) =>
                    s.hitsMax && !isAlly(_.get(s, ['owner', 'username'])),
            });
        }
        return this._hostileStructures;
    },
    configurable: true,
});
// Room properties: flags ==============================================================================================
// Flags physically in this room
Object.defineProperty(Room.prototype, 'flags', {
    get() {
        if (!this._flags) {
            this._flags = this.find(FIND_FLAGS);
        }
        return this._flags;
    },
    configurable: true,
});
// Room properties: structures =========================================================================================
Object.defineProperty(Room.prototype, 'constructionSites', {
    get() {
        if (!this._constructionSites) {
            this._constructionSites = this.find(FIND_MY_CONSTRUCTION_SITES);
        }
        return this._constructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'allConstructionSites', {
    get() {
        if (!this._allConstructionSites) {
            this._allConstructionSites = this.find(FIND_CONSTRUCTION_SITES);
        }
        return this._allConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'hostileConstructionSites', {
    get() {
        if (!this._hostileConstructionSites) {
            this._hostileConstructionSites = this.find(
                FIND_HOSTILE_CONSTRUCTION_SITES,
                {
                    filter: (csite) => !isAlly(csite.owner.username),
                },
            );
        }
        return this._hostileConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'allyConstructionSites', {
    get() {
        if (!this._allyConstructionSites) {
            this._allyConstructionSites = this.find(
                FIND_HOSTILE_CONSTRUCTION_SITES,
                {
                    filter: (csite) => isAlly(csite.owner.username),
                },
            );
        }
        return this._allyConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'tombstones', {
    get() {
        if (!this._tombstones) {
            this._tombstones = this.find(FIND_TOMBSTONES);
        }
        return this._tombstones;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'ruins', {
    get() {
        if (!this._ruins) {
            this._ruins = this.find(FIND_RUINS);
        }
        return this._ruins;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'drops', {
    get() {
        if (!this._drops) {
            this._drops = _.groupBy(
                this.find(FIND_DROPPED_RESOURCES),
                (r) => r.resourceType,
            );
        }
        return this._drops;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedEnergy', {
    get() {
        return this.drops[RESOURCE_ENERGY] || [];
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedPower', {
    get() {
        return this.drops[RESOURCE_POWER] || [];
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'powerCreeps', {
    get() {
        if (!this._powerCreeps) {
            this._powerCreeps = this.find(FIND_POWER_CREEPS);
        }
        return this._powerCreeps;
    },
    configurable: true,
});

// Intra- and inter-tick structure caching, adapted from semperRabbit's IVM module
const roomStructureIDs = {};
const roomStructuresExpiration = {};
const multipleList = [
    STRUCTURE_SPAWN,
    STRUCTURE_EXTENSION,
    STRUCTURE_ROAD,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_KEEPER_LAIR,
    STRUCTURE_PORTAL,
    STRUCTURE_LINK,
    STRUCTURE_TOWER,
    STRUCTURE_LAB,
    STRUCTURE_CONTAINER,
    STRUCTURE_POWER_BANK,
];
const singleList = [
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_NUKER,
    STRUCTURE_FACTORY,
    STRUCTURE_INVADER_CORE, // zGeneral 1/10/2023
];
const notRepairable = [
    STRUCTURE_KEEPER_LAIR,
    STRUCTURE_PORTAL,
    STRUCTURE_POWER_BANK,
    STRUCTURE_INVADER_CORE,
];
const STRUCTURE_TIMEOUT = onPublicServer() ? 50 : 10;
Room.prototype._refreshStructureCache = function () {
    // if cache is expired or doesn't exist
    if (
        !roomStructuresExpiration[this.name] ||
        !roomStructureIDs[this.name] ||
        Game.time > roomStructuresExpiration[this.name]
    ) {
        roomStructuresExpiration[this.name] = getCacheExpiration(
            STRUCTURE_TIMEOUT,
        );
        roomStructureIDs[this.name] = _.mapValues(
            _.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType),
            (structures) => _.map(structures, (s) => s.id),
        );
    }
};
multipleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type + 's', {
        get: function () {
            if (this['_' + type + 's']) {
                return this['_' + type + 's'];
            } else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return (this['_' + type + 's'] = _.compact(
                        _.map(
                            roomStructureIDs[this.name][type],
                            Game.getObjectById,
                        ),
                    ));
                } else {
                    return (this['_' + type + 's'] = []);
                }
            }
        },
        configurable: true,
    });
});
singleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type, {
        get: function () {
            if (this['_' + type]) {
                return this['_' + type];
            } else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return (this['_' + type] = Game.getObjectById(
                        roomStructureIDs[this.name][type][0],
                    ));
                } else {
                    return (this['_' + type] = undefined);
                }
            }
        },
        configurable: true,
    });
});
Object.defineProperty(Room.prototype, 'storageUnits', {
    get() {
        if (!this._storageUnits) {
            this._storageUnits = _.compact([
                this.storage,
                this.terminal,
            ]).concat(this.containers);
        }
        return this._storageUnits;
    },
    configurable: true,
});

Object.defineProperty(Room.prototype, 'sources', { // updated method took 2 CPU
    get() {
        
        if (!this._sources) {
			this._sources = this.find(FIND_SOURCES);
		}
        return this._sources;
    },
    configurable: true,
});
/*
Object.defineProperty(Room.prototype, 'sources', {
    get() {
        const startCpu = Game.cpu.getUsed();
        if (!this._sources) {
            // Check if source IDs for this room are stored
            if (false && global.mySourceIDs[this.name]) {
                // Retrieve source objects from stored IDs
                this._sources = global.mySourceIDs[this.name].map(id => Game.getObjectById(id)).filter(source => source !== null);
                
            } else {
                // Fallback to finding sources the normal way
                this._sources = this.find(FIND_SOURCES);
                // Consider caching these newly found source IDs in Memory for future optimization
            }
        }
        const cpuUsed = Game.cpu.getUsed() - startCpu;
        global.profiling.creeps.calls += 1;
        global.profiling.creeps.cpuUsed += cpuUsed;
        return this._sources;
    },
    configurable: true,
});
*/
/*
Object.defineProperty(Room.prototype, 'mineral', {
    get() {
        if (!this._mineral) {
            this._mineral = this.find(FIND_MINERALS)[0];
        }
        return this._mineral;
    },
    configurable: true,
});
*/
// zGeneral 2/2024 revised for CPU performance
Object.defineProperty(Room.prototype, 'mineral', {
    get() {
        
        
        if (!this._mineral) {
            this._mineral = this.find(FIND_MINERALS)[0];
        }

        return this._mineral;
    },
    configurable: true,
});



Object.defineProperty(Room.prototype, 'repairables', {
    get() {
        if (!this._repairables) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].repairables) {
                return (this._repairables = _.compact(
                    _.map(
                        roomStructureIDs[this.name].repairables,
                        Game.getObjectById,
                    ),
                ));
            } else {
                let repairables = [];
                for (const structureType of singleList) {
                    if (this[structureType]) {
                        repairables.push(this[structureType]);
                    }
                }
                for (const structureType of multipleList) {
                    if (
                        structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART &&
                        structureType != STRUCTURE_ROAD &&
                        !notRepairable.includes(structureType)
                    ) {
                        repairables = repairables.concat(
                            this[structureType + 's'],
                        );
                    }
                }
                roomStructureIDs[this.name].repairables = _.map(
                    repairables,
                    (s) => s.id,
                );
                return (this._repairables = repairables);
            }
        }
        return this._repairables;
    },
    configurable: true,
});
// TODO: this is expensive and easy to over-use. Perhaps remove this.
Object.defineProperty(Room.prototype, 'walkableRamparts', {
    get() {
        if (!this._walkableRamparts) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].walkableRamparts) {
                return (this._walkableRamparts = _.compact(
                    _.map(
                        roomStructureIDs[this.name].walkableRamparts,
                        Game.getObjectById,
                    ),
                ));
            } else {
                const walkableRamparts = _.filter(this.ramparts, (r) =>
                    r.pos.isWalkable(true),
                );
                roomStructureIDs[this.name].walkableRamparts = _.map(
                    walkableRamparts,
                    (r) => r.id,
                );
                return (this._walkableRamparts = walkableRamparts);
            }
        }
        return this._walkableRamparts;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'rechargeables', {
    get() {
        if (!this._rechargeables) {
            this._rechargeables = [
                ...this.storageUnits,
                ...this.droppedEnergy,
                ...this.tombstones,
                ...this.ruins,
            ];
        }
        return this._rechargeables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'barriers', {
    get() {
        if (!this._barriers) {
            this._barriers = [].concat(this.ramparts, this.constructedWalls);
        }
        return this._barriers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'walls', {
    get() {
        return this.constructedWalls;
    },
    configurable: true,
});

// All structure prototypes
PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(Structure.prototype, 'isWalkable', {
    get() {
        if (PERMACACHE.structureWalkability[this.id] !== undefined) {
            return PERMACACHE.structureWalkability[this.id];
        }
        if (this.structureType === STRUCTURE_RAMPART) {
            return this.my || this.isPublic;
        } else {
            PERMACACHE.structureWalkability[this.id] =
                this.structureType == STRUCTURE_ROAD ||
                this.structureType == STRUCTURE_CONTAINER ||
                this.structureType == STRUCTURE_PORTAL;
            return PERMACACHE.structureWalkability[this.id];
        }
    },
    configurable: true,
});
// monkey-patch OwnedStructure.isActive to include some caching since it's actually pretty expensive
// const _OwnedStructureIsActive = OwnedStructure.prototype.isActive;
OwnedStructure.prototype._isActive = OwnedStructure.prototype.isActive;
// OwnedStructure.prototype.isActive = function() {
// 	// Do a quick check to see if the room is owned by same owner of structure and/or if it's RCL 8
// 	if (this.room.controller) {
// 		const thisOwner = this.owner ? this.owner.username : 'noThisOwner';
// 		const controllerOwner = this.room.controller.owner ? this.room.controller.username : 'noControllerOwner';
// 		if (thisOwner != controllerOwner) { // if it's not owned by room owner, it's not active
// 			return false;
// 		}
// 		const level = this.room.controller.level || 0;
// 		if (level == 8) { // everything is active at RCL 8
// 			return true;
// 		}
// 	}
// 	// Otherwise use cached value or call this.inActive()
// 	if (this._isActiveValue == undefined) {
// 		this._isActiveValue = this._isActive();
// 	}
// 	return this._isActiveValue;
// };
// Container prototypes ================================================================================================
Object.defineProperty(StructureContainer.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
// Controller prototypes ===============================================================================================
Object.defineProperty(StructureController.prototype, 'reservedByMe', {
    get: function () {
        return this.reservation && this.reservation.username == MY_USERNAME;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByMe', {
    get: function () {
        return (
            this.sign &&
            this.sign.username == MY_USERNAME &&
            Game.time - this.sign.time < 250000
        );
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByScreeps', {
    get: function () {
        return this.sign && this.sign.username == 'Screeps';
    },
    configurable: true,
});
StructureController.prototype.needsReserving = function (reserveBuffer) {
    return (
        !this.reservation ||
        (this.reservedByMe && this.reservation.ticksToEnd < reserveBuffer)
    );
};
// Extension prototypes ================================================================================================
Object.defineProperty(StructureExtension.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureExtension.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Link prototypes =====================================================================================================
Object.defineProperty(StructureLink.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'storeCapacity', {
    // forwards-backwards compatibility
    get() {
        return this.energyCapacity;
    },
    configurable: true,
});
// Nuker prototypes ====================================================================================================
// PowerSpawn prototypes ===============================================================================================
// Spawn prototypes ====================================================================================================
Object.defineProperty(StructureSpawn.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureSpawn.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
Object.defineProperty(Store.prototype, 'contents', {
    get() {
        return Object.entries(this);
    },
    configurable: true,
});
// Storage prototypes ==================================================================================================
Object.defineProperty(StructureStorage.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
// Terminal prototypes =================================================================================================
Object.defineProperty(StructureTerminal.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isReady', {
    // the terminal is ready to send or deal
    get() {
        return this.cooldown == 0 && !this._notReady;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'hasReceived', {
    // terminal received this tick via send/deal
    get() {
        return this._hasReceived;
    },
    configurable: true,
});
const _terminalSend = StructureTerminal.prototype.send;
StructureTerminal.prototype.send = function (
    resourceType,
    amount,
    destination,
    description,
) {
    const response = _terminalSend.call(
        this,
        resourceType,
        amount,
        destination,
        description,
    );
    if (response == OK) {
        this._notReady = true;
        if (Game.rooms[destination] && Game.rooms[destination].terminal) {
            Game.rooms[destination].terminal._hasReceived = true;
        }
    }
    return response;
};
// Tower prototypes
Object.defineProperty(StructureTower.prototype, 'isFull', {
    // if this container-like object is full
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTower.prototype, 'isEmpty', {
    // if this container-like object is empty
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Tombstone prototypes ================================================================================================
Object.defineProperty(Tombstone.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});

String.prototype.padRight = function (length, char = ' ') {
    return this + char.repeat(Math.max(length - this.length, 0));
};
String.prototype.padLeft = function (length, char = ' ') {
    return char.repeat(Math.max(length - this.length, 0)) + this;
};
Number.prototype.toPercent = function (decimals = 0) {
    return (this * 100).toFixed(decimals) + '%';
};
Number.prototype.truncate = function (decimals) {
    const re = new RegExp('(\\d+\\.\\d{' + decimals + '})(\\d)'),
        m = this.toString().match(re);
    return m ? parseFloat(m[1]) : this.valueOf();
};
PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(ConstructionSite.prototype, 'isWalkable', {
    get() {
        if (PERMACACHE.structureWalkability[this.id] === undefined) {
            PERMACACHE.structureWalkability[this.id] =
                this.structureType == STRUCTURE_ROAD ||
                this.structureType == STRUCTURE_CONTAINER ||
                this.structureType == STRUCTURE_RAMPART;
        }
        return PERMACACHE.structureWalkability[this.id];
    },
    configurable: true,
});

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
    '',
);

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
var encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError('Must be between 0 and 63: ' + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
var decode = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'

    var zero = 48; // '0'
    var nine = 57; // '9'

    var plus = 43; // '+'
    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode == plus) {
        return 62;
    }

    // 63: /
    if (charCode == slash) {
        return 63;
    }

    // Invalid base64 digit.
    return -1;
};

var base64 = {
    encode: encode,
    decode: decode,
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
var encode$1 = function base64VLQ_encode(aValue) {
    var encoded = '';
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
        if (aIndex >= strLen) {
            throw new Error('Expected more digits in base 64 VLQ value.');
        }

        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));
        }

        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};

var base64Vlq = {
    encode: encode$1,
    decode: decode$1,
};

var util = createCommonjsModule(function (module, exports) {
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
            return aArgs[aName];
        } else if (arguments.length === 3) {
            return aDefaultValue;
        } else {
            throw new Error('"' + aName + '" is a required argument.');
        }
    }
    exports.getArg = getArg;

    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;

    function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
            return null;
        }
        return {
            scheme: match[1],
            auth: match[2],
            host: match[3],
            port: match[4],
            path: match[5],
        };
    }
    exports.urlParse = urlParse;

    function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
            url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
            url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
            url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
            url += ':' + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
            url += aParsedUrl.path;
        }
        return url;
    }
    exports.urlGenerate = urlGenerate;

    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */
    function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
            if (!url.path) {
                return aPath;
            }
            path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);

        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
            part = parts[i];
            if (part === '.') {
                parts.splice(i, 1);
            } else if (part === '..') {
                up++;
            } else if (up > 0) {
                if (part === '') {
                    // The first part is blank if the path is absolute. Trying to go
                    // above the root is a no-op. Therefore we can remove all '..' parts
                    // directly after the root.
                    parts.splice(i + 1, up);
                    up = 0;
                } else {
                    parts.splice(i, 2);
                    up--;
                }
            }
        }
        path = parts.join('/');

        if (path === '') {
            path = isAbsolute ? '/' : '.';
        }

        if (url) {
            url.path = path;
            return urlGenerate(url);
        }
        return path;
    }
    exports.normalize = normalize;

    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */
    function join(aRoot, aPath) {
        if (aRoot === '') {
            aRoot = '.';
        }
        if (aPath === '') {
            aPath = '.';
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
            aRoot = aRootUrl.path || '/';
        }

        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
        }

        if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
        }

        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
        }

        var joined =
            aPath.charAt(0) === '/'
                ? aPath
                : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

        if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
        }
        return joined;
    }
    exports.join = join;

    exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    };

    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */
    function relative(aRoot, aPath) {
        if (aRoot === '') {
            aRoot = '.';
        }

        aRoot = aRoot.replace(/\/$/, '');

        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
            var index = aRoot.lastIndexOf('/');
            if (index < 0) {
                return aPath;
            }

            // If the only part of the root that is left is the scheme (i.e. http://,
            // file:///, etc.), one or more slashes (/), or simply nothing at all, we
            // have exhausted all components, so the path is not relative to the root.
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath;
            }

            ++level;
        }

        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;

    var supportsNullProto = (function () {
        var obj = Object.create(null);
        return !('__proto__' in obj);
    })();

    function identity(s) {
        return s;
    }

    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */
    function toSetString(aStr) {
        if (isProtoString(aStr)) {
            return '$' + aStr;
        }

        return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;

    function fromSetString(aStr) {
        if (isProtoString(aStr)) {
            return aStr.slice(1);
        }

        return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;

    function isProtoString(s) {
        if (!s) {
            return false;
        }

        var length = s.length;

        if (length < 9 /* "__proto__".length */) {
            return false;
        }

        if (
            s.charCodeAt(length - 1) !== 95 /* '_' */ ||
            s.charCodeAt(length - 2) !== 95 /* '_' */ ||
            s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 4) !== 116 /* 't' */ ||
            s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
            s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
            s.charCodeAt(length - 8) !== 95 /* '_' */ ||
            s.charCodeAt(length - 9) !== 95 /* '_' */
        ) {
            return false;
        }

        for (var i = length - 10; i >= 0; i--) {
            if (s.charCodeAt(i) !== 36 /* '$' */) {
                return false;
            }
        }

        return true;
    }

    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */
    function compareByOriginalPositions(
        mappingA,
        mappingB,
        onlyCompareOriginal,
    ) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;

    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */
    function compareByGeneratedPositionsDeflated(
        mappingA,
        mappingB,
        onlyCompareGenerated,
    ) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
        }

        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
            return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
            return 0;
        }

        if (aStr1 === null) {
            return 1; // aStr2 !== null
        }

        if (aStr2 === null) {
            return -1; // aStr1 !== null
        }

        if (aStr1 > aStr2) {
            return 1;
        }

        return -1;
    }

    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
            return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

    /**
     * Strip any JSON XSSI avoidance prefix from the string (as documented
     * in the source maps specification), and then parse the string as
     * JSON.
     */
    function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    }
    exports.parseSourceMapInput = parseSourceMapInput;

    /**
     * Compute the URL of a source given the the source root, the source's
     * URL, and the source map's URL.
     */
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || '';

        if (sourceRoot) {
            // This follows what Chrome does.
            if (
                sourceRoot[sourceRoot.length - 1] !== '/' &&
                sourceURL[0] !== '/'
            ) {
                sourceRoot += '/';
            }
            // The spec says:
            //   Line 4: An optional source root, useful for relocating source
            //   files on a server or removing repeated values in the
            //   “sources” entry.  This value is prepended to the individual
            //   entries in the “source” field.
            sourceURL = sourceRoot + sourceURL;
        }

        // Historically, SourceMapConsumer did not take the sourceMapURL as
        // a parameter.  This mode is still somewhat supported, which is why
        // this code block is conditional.  However, it's preferable to pass
        // the source map URL to SourceMapConsumer, so that this function
        // can implement the source URL resolution algorithm as outlined in
        // the spec.  This block is basically the equivalent of:
        //    new URL(sourceURL, sourceMapURL).toString()
        // ... except it avoids using URL, which wasn't available in the
        // older releases of node still supported by this library.
        //
        // The spec says:
        //   If the sources are not absolute URLs after prepending of the
        //   “sourceRoot”, the sources are resolved relative to the
        //   SourceMap (like resolving script src in a html document).
        if (sourceMapURL) {
            var parsed = urlParse(sourceMapURL);
            if (!parsed) {
                throw new Error('sourceMapURL could not be parsed');
            }
            if (parsed.path) {
                // Strip the last path component, but keep the "/".
                var index = parsed.path.lastIndexOf('/');
                if (index >= 0) {
                    parsed.path = parsed.path.substring(0, index + 1);
                }
            }
            sourceURL = join(urlGenerate(parsed), sourceURL);
        }

        return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
});
var util_1 = util.getArg;
var util_2 = util.urlParse;
var util_3 = util.urlGenerate;
var util_4 = util.normalize;
var util_5 = util.join;
var util_6 = util.isAbsolute;
var util_7 = util.relative;
var util_8 = util.toSetString;
var util_9 = util.fromSetString;
var util_10 = util.compareByOriginalPositions;
var util_11 = util.compareByGeneratedPositionsDeflated;
var util_12 = util.compareByGeneratedPositionsInflated;
var util_13 = util.parseSourceMapInput;
var util_14 = util.computeSourceURL;

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== 'undefined';

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap
        ? this._set.size
        : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }

    throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};

var ArraySet_1 = ArraySet;

var arraySet = {
    ArraySet: ArraySet_1,
};

var binarySearch = createCommonjsModule(function (module, exports) {
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
            // Found the element we are looking for.
            return mid;
        } else if (cmp > 0) {
            // Our needle is greater than aHaystack[mid].
            if (aHigh - mid > 1) {
                // The element is in the upper half.
                return recursiveSearch(
                    mid,
                    aHigh,
                    aNeedle,
                    aHaystack,
                    aCompare,
                    aBias,
                );
            }

            // The exact needle element was not found in this haystack. Determine if
            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1;
            } else {
                return mid;
            }
        } else {
            // Our needle is less than aHaystack[mid].
            if (mid - aLow > 1) {
                // The element is in the lower half.
                return recursiveSearch(
                    aLow,
                    mid,
                    aNeedle,
                    aHaystack,
                    aCompare,
                    aBias,
                );
            }

            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
                return mid;
            } else {
                return aLow < 0 ? -1 : aLow;
            }
        }
    }

    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
            return -1;
        }

        var index = recursiveSearch(
            -1,
            aHaystack.length,
            aNeedle,
            aHaystack,
            aCompare,
            aBias || exports.GREATEST_LOWER_BOUND,
        );
        if (index < 0) {
            return -1;
        }

        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                break;
            }
            --index;
        }

        return index;
    };
});
var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
var binarySearch_3 = binarySearch.search;

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
        // (1) Partitioning.
        //
        // The partitioning chooses a pivot between `p` and `r` and moves all
        // elements that are less than or equal to the pivot to the before it, and
        // all the elements that are greater than it after it. The effect is that
        // once partition is done, the pivot is in the exact place it will be when
        // the array is put in sorted order, and it will not need to be moved
        // again. This runs in O(n) time.

        // Always choose a random pivot so that an input array which is reverse
        // sorted does not cause O(n^2) running time.
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;

        swap(ary, pivotIndex, r);
        var pivot = ary[r];

        // Immediately after `j` is incremented in this loop, the following hold
        // true:
        //
        //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
        //
        //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
        for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
                i += 1;
                swap(ary, i, j);
            }
        }

        swap(ary, i + 1, j);
        var q = i + 1;

        // (2) Recurse on each half.

        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
    }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
};

var quickSort = {
    quickSort: quickSort_1,
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var ArraySet$1 = arraySet.ArraySet;

var quickSort$1 = quickSort.quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null
        ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
        : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }

        return this.__generatedMappings;
    },
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }

        return this.__originalMappings;
    },
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(
    aStr,
    index,
) {
    var c = aStr.charAt(index);
    return c === ';' || c === ',';
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
) {
    throw new Error('Subclasses must implement _parseMappings');
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
    aCallback,
    aContext,
    aOrder,
) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
        case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
        default:
            throw new Error('Unknown order of iteration.');
    }

    var sourceRoot = this.sourceRoot;
    mappings
        .map(function (mapping) {
            var source =
                mapping.source === null
                    ? null
                    : this._sources.at(mapping.source);
            source = util.computeSourceURL(
                sourceRoot,
                source,
                this._sourceMapURL,
            );
            return {
                source: source,
                generatedLine: mapping.generatedLine,
                generatedColumn: mapping.generatedColumn,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name:
                    mapping.name === null ? null : this._names.at(mapping.name),
            };
        }, this)
        .forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(
    aArgs,
) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0),
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
        return [];
    }

    var mappings = [];

    var index = this._findMapping(
        needle,
        this._originalMappings,
        'originalLine',
        'originalColumn',
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND,
    );
    if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while (mapping && mapping.originalLine === originalLine) {
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(
                        mapping,
                        'lastGeneratedColumn',
                        null,
                    ),
                });

                mapping = this._originalMappings[++index];
            }
        } else {
            var originalColumn = mapping.originalColumn;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while (
                mapping &&
                mapping.originalLine === line &&
                mapping.originalColumn == originalColumn
            ) {
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(
                        mapping,
                        'lastGeneratedColumn',
                        null,
                    ),
                });

                mapping = this._originalMappings[++index];
            }
        }
    }

    return mappings;
};

var SourceMapConsumer_1 = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }

    sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function (source) {
            return sourceRoot &&
                util.isAbsolute(sourceRoot) &&
                util.isAbsolute(source)
                ? util.relative(sourceRoot, source)
                : source;
        });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet$1.fromArray(names.map(String), true);
    this._sources = ArraySet$1.fromArray(sources, true);

    this._absoluteSources = this._sources.toArray().map(function (s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
            return i;
        }
    }

    return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
    aSourceMap,
    aSourceMapURL,
) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = (smc._names = ArraySet$1.fromArray(
        aSourceMap._names.toArray(),
        true,
    ));
    var sources = (smc._sources = ArraySet$1.fromArray(
        aSourceMap._sources.toArray(),
        true,
    ));
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot,
    );
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = (smc.__generatedMappings = []);
    var destOriginalMappings = (smc.__originalMappings = []);

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;

            if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }

            destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
    }

    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
        return this._absoluteSources.slice();
    },
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
        if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ',') {
            index++;
        } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;

            // Because each offset is encoded relative to the previous one,
            // many segments often have the same encoding. We can exploit this
            // fact by caching the parsed variable length fields of each segment,
            // allowing us to avoid a second parse if we encounter the same
            // segment again.
            for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                }
            }
            str = aStr.slice(index, end);

            segment = cachedSegments[str];
            if (segment) {
                index += str.length;
            } else {
                segment = [];
                while (index < end) {
                    base64Vlq.decode(aStr, index, temp);
                    value = temp.value;
                    index = temp.rest;
                    segment.push(value);
                }

                if (segment.length === 2) {
                    throw new Error('Found a source, but no line and column');
                }

                if (segment.length === 3) {
                    throw new Error('Found a source and line, but no column');
                }

                cachedSegments[str] = segment;
            }

            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;

            if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];

                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;

                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;

                if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                }
            }

            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
                originalMappings.push(mapping);
            }
        }
    }

    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort$1(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
    aNeedle,
    aMappings,
    aLineName,
    aColumnName,
    aComparator,
    aBias,
) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
        throw new TypeError(
            'Line must be greater than or equal to 1, got ' +
                aNeedle[aLineName],
        );
    }
    if (aNeedle[aColumnName] < 0) {
        throw new TypeError(
            'Column must be greater than or equal to 0, got ' +
                aNeedle[aColumnName],
        );
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];

            if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
            }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
    }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(
    aArgs,
) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column'),
    };

    var index = this._findMapping(
        needle,
        this._generatedMappings,
        'generatedLine',
        'generatedColumn',
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
    );

    if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(
                    this.sourceRoot,
                    source,
                    this._sourceMapURL,
                );
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
                name = this._names.at(name);
            }
            return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name,
            };
        }
    }

    return {
        source: null,
        line: null,
        column: null,
        name: null,
    };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
        return false;
    }
    return (
        this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) {
            return sc == null;
        })
    );
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
    aSource,
    nullOnMissing,
) {
    if (!this.sourcesContent) {
        return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
        return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, '');
        if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }

        if (
            (!url.path || url.path == '/') &&
            this._sources.has('/' + relativeSource)
        ) {
            return this.sourcesContent[
                this._sources.indexOf('/' + relativeSource)
            ];
        }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(
    aArgs,
) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
        return {
            line: null,
            column: null,
            lastColumn: null,
        };
    }

    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column'),
    };

    var index = this._findMapping(
        needle,
        this._originalMappings,
        'originalLine',
        'originalColumn',
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
    );

    if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
            return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
            };
        }
    }

    return {
        line: null,
        column: null,
        lastColumn: null,
    };
};

var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();

    var lastOffset = {
        line: -1,
        column: 0,
    };
    this._sections = sections.map(function (s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error(
                'Support for url field in sections not implemented.',
            );
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');

        if (
            offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
        ) {
            throw new Error(
                'Section offsets must be ordered and non-overlapping.',
            );
        }
        lastOffset = offset;

        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1,
            },
            consumer: new SourceMapConsumer(
                util.getArg(s, 'map'),
                aSourceMapURL,
            ),
        };
    });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
            for (
                var j = 0;
                j < this._sections[i].consumer.sources.length;
                j++
            ) {
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    },
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(
    aArgs,
) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column'),
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function (needle, section) {
            var cmp =
                needle.generatedLine - section.generatedOffset.generatedLine;
            if (cmp) {
                return cmp;
            }

            return (
                needle.generatedColumn - section.generatedOffset.generatedColumn
            );
        },
    );
    var section = this._sections[sectionIndex];

    if (!section) {
        return {
            source: null,
            line: null,
            column: null,
            name: null,
        };
    }

    return section.consumer.originalPositionFor({
        line:
            needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column:
            needle.generatedColumn -
            (section.generatedOffset.generatedLine === needle.generatedLine
                ? section.generatedOffset.generatedColumn - 1
                : 0),
        bias: aArgs.bias,
    });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
    });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(
    aSource,
    nullOnMissing,
) {
    for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
            return content;
        }
    }
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(
    aArgs,
) {
    for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (
            section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) ===
            -1
        ) {
            continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
            var ret = {
                line:
                    generatedPosition.line +
                    (section.generatedOffset.generatedLine - 1),
                column:
                    generatedPosition.column +
                    (section.generatedOffset.generatedLine ===
                    generatedPosition.line
                        ? section.generatedOffset.generatedColumn - 1
                        : 0),
            };
            return ret;
        }
    }

    return {
        line: null,
        column: null,
    };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(
    aStr,
    aSourceRoot,
) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];

            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(
                section.consumer.sourceRoot,
                source,
                this._sourceMapURL,
            );
            this._sources.add(source);
            source = this._sources.indexOf(source);

            var name = null;
            if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
            }

            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
                source: source,
                generatedLine:
                    mapping.generatedLine +
                    (section.generatedOffset.generatedLine - 1),
                generatedColumn:
                    mapping.generatedColumn +
                    (section.generatedOffset.generatedLine ===
                    mapping.generatedLine
                        ? section.generatedOffset.generatedColumn - 1
                        : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name,
            };

            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
            }
        }
    }

    quickSort$1(
        this.__generatedMappings,
        util.compareByGeneratedPositionsDeflated,
    );
    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
};

var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

var sourceMapConsumer = {
    SourceMapConsumer: SourceMapConsumer_1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1,
};

var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;

var Log_1;
var LogLevels;
(function (LogLevels) {
    LogLevels[(LogLevels['ERROR'] = 0)] = 'ERROR';
    LogLevels[(LogLevels['WARNING'] = 1)] = 'WARNING';
    LogLevels[(LogLevels['ALERT'] = 2)] = 'ALERT';
    LogLevels[(LogLevels['INFO'] = 3)] = 'INFO';
    LogLevels[(LogLevels['DEBUG'] = 4)] = 'DEBUG';
})(LogLevels || (LogLevels = {}));
/**
 * Default debug level for log output
 */
const LOG_LEVEL = LogLevels.INFO;
/**
 * Prepend log output with current tick number.
 */
const LOG_PRINT_TICK = true;
/**
 * Prepend log output with source line.
 */
const LOG_PRINT_LINES = false;
/**
 * Maximum padding for source links (for aligning log output).
 */
const LOG_MAX_PAD = 100;
// <caller> (<source>:<line>:<column>)
const stackLineRe = /([^ ]*) \(([^:]*):([0-9]*):([0-9]*)\)/;
const FATAL = -1;
const fatalColor = '#d65156';
function resolve(fileLine) {
    const split = stackLineRe.exec(_.trim(fileLine));
    if (!split || !Log.sourceMap) {
        return { compiled: fileLine, final: fileLine };
    }
    const pos = {
        column: parseInt(split[4], 10),
        line: parseInt(split[3], 10),
    };
    const original = Log.sourceMap.originalPositionFor(pos);
    const line = `${split[1]} (${original.source}:${original.line})`;
    const out = {
        caller: split[1],
        compiled: fileLine,
        final: line,
        line: original.line,
        original: line,
        path: original.source,
    };
    return out;
}
function makeVSCLink(pos) {
    {
        return pos.final;
    }
}
function tooltip(str, tooltip) {
    return `<abbr title='${tooltip}'>${str}</abbr>`;
}
function time() {
    return color(Game.time.toString(), 'gray');
}
function debug(thing, ...args) {
    if (thing.memory && thing.memory.debug) {
        this.debug(`${thing.name} @ ${thing.pos.print}: `, args);
    }
}
/**
 * Log provides methods for displaying pretty-printed text into the Screeps console
 */
let Log = (Log_1 = class Log {
    constructor() {
        this._maxFileString = 0;
        _.defaultsDeep(Memory, {
            settings: {
                log: {
                    level: LOG_LEVEL,
                    showSource: LOG_PRINT_LINES,
                    showTick: LOG_PRINT_TICK,
                },
            },
        });
    }
    static loadSourceMap() {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const map = require('main.js.map');
            if (map) {
                Log_1.sourceMap = new SourceMapConsumer$1(map);
            }
        } catch (err) {
            console.log('Source mapping deprecated.');
        }
    }
    get level() {
        return Memory.settings.log.level;
    }
    setLogLevel(value) {
        let changeValue = true;
        switch (value) {
            case LogLevels.ERROR:
                console.log(
                    `Logging level set to ${value}. Displaying: ERROR.`,
                );
                break;
            case LogLevels.WARNING:
                console.log(
                    `Logging level set to ${value}. Displaying: ERROR, WARNING.`,
                );
                break;
            case LogLevels.ALERT:
                console.log(
                    `Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT.`,
                );
                break;
            case LogLevels.INFO:
                console.log(
                    `Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO.`,
                );
                break;
            case LogLevels.DEBUG:
                console.log(
                    `Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO, DEBUG.`,
                );
                break;
            default:
                console.log(
                    `Invalid input: ${value}. Loging level can be set to integers between ` +
                        LogLevels.ERROR +
                        ' and ' +
                        LogLevels.DEBUG +
                        ', inclusive.',
                );
                changeValue = false;
                break;
        }
        if (changeValue) {
            Memory.settings.log.level = value;
        }
    }
    get showSource() {
        return Memory.settings.log.showSource;
    }
    set showSource(value) {
        Memory.settings.log.showSource = value;
    }
    get showTick() {
        return Memory.settings.log.showTick;
    }
    set showTick(value) {
        Memory.settings.log.showTick = value;
    }
    trace(error) {
        if (this.level >= LogLevels.ERROR && error.stack) {
            console.log(this.resolveStack(error.stack));
        }
        return this;
    }
    throw(e) {
        console.log.apply(
            this,
            this.buildArguments(FATAL).concat([
                color(e.toString(), fatalColor),
            ]),
        );
    }
    error(...args) {
        if (this.level >= LogLevels.ERROR) {
            console.log.apply(
                this,
                this.buildArguments(LogLevels.ERROR).concat(
                    [].slice.call(args),
                ),
            );
        }
        return undefined;
    }
    warning(...args) {
        if (this.level >= LogLevels.WARNING) {
            console.log.apply(
                this,
                this.buildArguments(LogLevels.WARNING).concat(
                    [].slice.call(args),
                ),
            );
        }
        return undefined;
    }
    alert(...args) {
        if (this.level >= LogLevels.ALERT) {
            console.log.apply(
                this,
                this.buildArguments(LogLevels.ALERT).concat(
                    [].slice.call(args),
                ),
            );
        }
        return undefined;
    }
    notify(message) {
        this.alert(message);
        Game.notify(message);
        return undefined;
    }
    info(...args) {
        if (this.level >= LogLevels.INFO) {
            console.log.apply(
                this,
                this.buildArguments(LogLevels.INFO).concat([].slice.call(args)),
            );
        }
        return undefined;
    }
    debug(...args) {
        if (this.level >= LogLevels.DEBUG) {
            console.log.apply(
                this,
                this.buildArguments(LogLevels.DEBUG).concat(
                    [].slice.call(args),
                ),
            );
        }
    }
    debugCreep(creep, ...args) {
        if (creep.memory && creep.memory.debug) {
            this.debug(`${creep.name} @ ${creep.pos.print}: `, args);
        }
    }
    printObject(obj) {
        console.log.apply(
            this,
            this.buildArguments(LogLevels.DEBUG).concat(JSON.stringify(obj)),
        );
    }
    getFileLine(upStack = 4) {
        const stack = new Error('').stack;
        if (stack) {
            const lines = stack.split('\n');
            if (lines.length > upStack) {
                const originalLines = _.drop(lines, upStack).map(resolve);
                const hoverText = _.map(originalLines, 'final').join('&#10;');
                return this.adjustFileLine(
                    originalLines[0].final,
                    tooltip(makeVSCLink(originalLines[0]), hoverText),
                );
            }
        }
        return '';
    }
    buildArguments(level) {
        const out = [];
        switch (level) {
            case LogLevels.ERROR:
                out.push(color('ERROR  ', 'red'));
                break;
            case LogLevels.WARNING:
                out.push(color('WARNING', 'orange'));
                break;
            case LogLevels.ALERT:
                out.push(color('ALERT  ', 'yellow'));
                break;
            case LogLevels.INFO:
                out.push(color('INFO   ', 'green'));
                break;
            case LogLevels.DEBUG:
                out.push(color('DEBUG  ', 'gray'));
                break;
            case FATAL:
                out.push(color('FATAL  ', fatalColor));
                break;
        }
        if (this.showTick) {
            out.push(time());
        }
        if (this.showSource && level <= LogLevels.ERROR) {
            out.push(this.getFileLine());
        }
        return out;
    }
    resolveStack(stack) {
        if (!Log_1.sourceMap) {
            return stack;
        }
        return _.map(stack.split('\n').map(resolve), 'final').join('\n');
    }
    adjustFileLine(visibleText, line) {
        const newPad = Math.max(visibleText.length, this._maxFileString);
        this._maxFileString = Math.min(newPad, LOG_MAX_PAD);
        return `|${_.padRight(
            line,
            line.length + this._maxFileString - visibleText.length,
            ' ',
        )}|`;
    }
});
Log = Log_1 = __decorate([profile], Log);
{
    Log.loadSourceMap();
}
const log = new Log();

/**
 * Creep tasks setup instructions
 *
 * Javascript:
 * 1. In main.js:   require("tasks/prototypes.js");
 * 2. As needed:    var Tasks = require("<path to Tasks.js>");
 *
 * Typescript:
 * 1. In main.ts:   import "./tasks/prototypes";
 * 2. As needed:    import {Tasks} from "<path to Tasks.ts>"
 *
 * If you use Travler, change all occurrences of creep.moveTo() to creep.goTo()
 */
/**
 * An abstract class for encapsulating creep actions. This generalizes the concept of "do action X to thing Y until
 * condition Z is met" and saves a lot of convoluted and duplicated code in creep logic. A Task object contains
 * the necessary logic for traveling to a target, performing a task, and realizing when a task is no longer sensible
 * to continue.
 */
let Task = class Task {
    constructor(taskName, target, options = {}) {
        // Parameters for the task
        this.name = taskName;
        this._creep = {
            name: '',
        };
        if (target) {
            // Handles edge cases like when you're done building something and target disappears
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        } else {
            this._target = {
                ref: '',
                _pos: {
                    x: -1,
                    y: -1,
                    roomName: '',
                },
            };
        }
        this._parent = null;
        this.settings = {
            targetRange: 1,
            workOffRoad: false,
            oneShot: false,
            timeout: Infinity,
            blind: true,
        };
        this.tick = Game.time;
        this.options = options;
        this.data = {};
    }
    /**
     * Get a serialized ProtoTask from the current task
     */
    get proto() {
        return {
            name: this.name,
            _creep: this._creep,
            _target: this._target,
            _parent: this._parent,
            tick: this.tick,
            options: this.options,
            data: this.data,
        };
    }
    /**
     * Set the current task from a serialized ProtoTask
     */
    set proto(protoTask) {
        // Don't write to this.name; used in task switcher
        this._creep = protoTask._creep;
        this._target = protoTask._target;
        this._parent = protoTask._parent;
        this.tick = protoTask.tick;
        this.options = protoTask.options;
        this.data = protoTask.data;
    }
    /**
     * Return the wrapped creep which is executing this task
     */
    get creep() {
        // Get task's own creep by its name
        // Returns zerg wrapper instead of creep to use monkey-patched functions
        return Overmind.zerg[this._creep.name];
    }
    /**
     * Set the creep which is executing this task
     */
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
    }
    /**
     * Dereferences the saved target position; useful for situations where you might lose vision
     */
    get targetPos() {
        // refresh if you have visibility of the target
        if (!this._targetPos) {
            if (this.target) {
                this._target._pos = this.target.pos;
            }
            this._targetPos = derefRoomPosition(this._target._pos);
        }
        return this._targetPos;
    }
    /**
     * Get the Task's parent
     */
    get parent() {
        return this._parent ? initializeTask(this._parent) : null;
    }
    /**
     * Set the Task's parent
     */
    set parent(parentTask) {
        this._parent = parentTask ? parentTask.proto : null;
        // If the task is already assigned to a creep, update their memory
        if (this.creep) {
            this.creep.task = this;
        }
    }
    /**
     * Return a list of [this, this.parent, this.parent.parent, ...] as tasks
     */
    get manifest() {
        const manifest = [this];
        let parent = this.parent;
        while (parent) {
            manifest.push(parent);
            parent = parent.parent;
        }
        return manifest;
    }
    /**
     * Return a list of [this.target, this.parent.target, ...] without fully instantiating the list of tasks
     */
    get targetManifest() {
        const targetRefs = [this._target.ref];
        let parent = this._parent;
        while (parent) {
            targetRefs.push(parent._target.ref);
            parent = parent._parent;
        }
        return _.map(targetRefs, (ref) => deref(ref));
    }
    /**
     * Return a list of [this.targetPos, this.parent.targetPos, ...] without fully instantiating the list of tasks
     */
    get targetPosManifest() {
        const targetPositions = [this._target._pos];
        let parent = this._parent;
        while (parent) {
            targetPositions.push(parent._target._pos);
            parent = parent._parent;
        }
        return _.map(targetPositions, (protoPos) =>
            derefRoomPosition(protoPos),
        );
    }
    /**
     * Fork the task, assigning a new task to the creep with this task as its parent
     */
    fork(newTask) {
        newTask.parent = this;
        if (this.creep) {
            this.creep.task = newTask;
        }
        return newTask;
    }
    /**
     * Test if the task is valid; if it is not, automatically remove task and transition to parent
     */
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask =
                this.isValidTask() &&
                Game.time - this.tick < this.settings.timeout;
        }
        let validTarget = false;
        if (this.target) {
            validTarget = this.isValidTarget();
        } else if (
            (this.settings.blind || this.options.blind) &&
            !Game.rooms[this.targetPos.roomName]
        ) {
            // If you can't see the target's room but you have blind enabled, then that's okay
            validTarget = true;
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask && validTarget) {
            return true;
        } else {
            // Switch to parent task if there is one
            this.finish();
            const isValid = this.parent ? this.parent.isValid() : false;
            return isValid;
        }
    }
    /**
     * Move to within range of the target
     */
    moveToTarget(range = this.settings.targetRange) {
        return this.creep.goTo(this.targetPos, { range: range });
    }
    /**
     * Moves to the next position on the agenda if specified - call this in some tasks after work() is completed
     */
    moveToNextPos() {
        if (this.options.nextPos) {
            const nextPos = derefRoomPosition(this.options.nextPos);
            return this.creep.goTo(nextPos);
        }
    }
    /**
     * Return expected number of ticks until creep arrives at its first destination
     */
    get eta() {
        if (this.creep && this.creep.memory._go && this.creep.memory._go.path) {
            return this.creep.memory._go.path.length;
        }
    }
    /**
     * Execute this task each tick. Returns nothing unless work is done.
     */
    run() {
        if (this.isWorking) {
            delete this.creep.memory._go;
            // if (this.settings.workOffRoad) { // this is disabled as movement priorities makes it unnecessary
            // 	// Move to somewhere nearby that isn't on a road
            // 	this.creep.park(this.targetPos, true);
            // }
            const result = this.work();
            if (this.settings.oneShot && result === OK) {
                this.finish();
            }
            return result;
        } else {
            this.moveToTarget();
        }
    }
    /**
     * Return whether the creep is currently performing its task action near the target
     */
    get isWorking() {
        return (
            this.creep.pos.inRangeToPos(
                this.targetPos,
                this.settings.targetRange,
            ) && !this.creep.pos.isEdge
        );
    }
    /**
     * Finalize the task and switch to parent task (or null if there is none)
     */
    finish() {
        this.moveToNextPos();
        if (this.creep) {
            this.creep.task = this.parent;
        } else {
            log.debug(
                `No creep executing ${this.name}! Proto: ${JSON.stringify(
                    this.proto,
                )}`,
            );
        }
    }
};
Task = __decorate([profile], Task);

const attackTaskName = 'attack';
let TaskAttack = class TaskAttack extends Task {
    constructor(target, options = {}) {
        super(attackTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (
            this.creep.getActiveBodyparts(ATTACK) > 0 ||
            this.creep.getActiveBodyparts(RANGED_ATTACK) > 0
        );
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        const creep = this.creep;
        const target = this.target;
        let attackReturn = 0;
        let rangedAttackReturn = 0;
        if (creep.getActiveBodyparts(ATTACK) > 0) {
            if (creep.pos.isNearTo(target)) {
                attackReturn = creep.attack(target);
            } else {
                attackReturn = this.moveToTarget(1); // approach target if you also have attack parts
            }
        }
        if (
            creep.pos.inRangeTo(target, 3) &&
            creep.getActiveBodyparts(RANGED_ATTACK) > 0
        ) {
            rangedAttackReturn = creep.rangedAttack(target);
        }
        if (attackReturn == OK && rangedAttackReturn == OK) {
            return OK;
        } else {
            if (attackReturn != OK) {
                return rangedAttackReturn;
            } else {
                return attackReturn;
            }
        }
    }
};
TaskAttack = __decorate([profile], TaskAttack);

const buildTaskName = 'build';
let TaskBuild = class TaskBuild extends Task {
    constructor(target, options = {}) {
        super(buildTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return (
            this.target &&
            this.target.my &&
            this.target.progress < this.target.progressTotal
        );
    }
    work() {
        // Fixes issue #9 - workers freeze if creep sitting on square
        if (this.target && !this.target.isWalkable) {
            const creepOnTarget = this.target.pos.lookFor(LOOK_CREEPS)[0];
            if (creepOnTarget) {
                const zerg = Overmind.zerg[creepOnTarget.name];
                if (zerg) {
                    this.creep.say('move pls');
                    zerg.moveOffCurrentPos();
                }
            }
        }
        return this.creep.build(this.target);
    }
};
TaskBuild = __decorate([profile], TaskBuild);

const claimTaskName = 'claim';
let TaskClaim = class TaskClaim extends Task {
    constructor(target, options = {}) {
        super(claimTaskName, target, options);
        this.target = target;
        // Settings
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(CLAIM) > 0;
    }
    isValidTarget() {
        return this.target != null && (!this.target.room || !this.target.owner);
    }
    work() {
        return this.creep.claimController(this.target);
    }
};
TaskClaim = __decorate([profile], TaskClaim);

const dismantleTaskName = 'dismantle';
let TaskDismantle = class TaskDismantle extends Task {
    constructor(target, options = {}) {
        super(dismantleTaskName, target, options);
        this.target = target;
        this.settings.timeout = 200;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(WORK) > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.dismantle(this.target);
    }
};
TaskDismantle = __decorate([profile], TaskDismantle);

var TaskDrop_1;
const dropTaskName = 'drop';
let TaskDrop = (TaskDrop_1 = class TaskDrop extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        if (target instanceof RoomPosition) {
            super(TaskDrop_1.taskName, { ref: '', pos: target }, options);
        } else {
            super(TaskDrop_1.taskName, { ref: '', pos: target.pos }, options);
        }
        // Settings
        this.settings.targetRange = 0;
        this.settings.oneShot = true;
        // Data
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        // It's necessary to override task.isValid() for tasks which do not have a RoomObject target
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        } else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return this.creep.drop(this.data.resourceType, this.data.amount);
    }
});
TaskDrop.taskName = 'drop';
TaskDrop = TaskDrop_1 = __decorate([profile], TaskDrop);

const fortifyTaskName = 'fortify';
let TaskFortify = class TaskFortify extends Task {
    constructor(target, hitsMax, options = {}) {
        super(fortifyTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.timeout = 100; // Don't want workers to fortify indefinitely
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
        this.data.hitsMax = hitsMax;
    }
    isValidTask() {
        return this.creep.carry.energy > 0; // Times out once creep is out of energy
    }
    isValidTarget() {
        return (
            this.target &&
            this.target.hits < (this.data.hitsMax || this.target.hitsMax)
        );
    }
    work() {
        return this.creep.repair(this.target);
    }
};
TaskFortify = __decorate([profile], TaskFortify);

const generateSafeModeTaskName = 'generateSafeMode';
let TaskGenerateSafeMode = class TaskGenerateSafeMode extends Task {
    constructor(target, options = {}) {
        super(generateSafeModeTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        return this.creep.carry[RESOURCE_GHODIUM] >= 1000;
    }
    isValidTarget() {
        // Allows targeting other players for allies
        return this.target != null && !!this.target.owner;
    }
    work() {
        return this.creep.generateSafeMode(this.target);
    }
};
TaskGenerateSafeMode = __decorate([profile], TaskGenerateSafeMode);

const RESOURCES_ALL_EXCEPT_ENERGY = _.without(RESOURCES_ALL, RESOURCE_ENERGY);
const BOOSTS_T3 = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,

    RESOURCE_CATALYZED_LEMERGIUM_ACID, // zGeneral 12/07/2022
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,

    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
];
const BOOSTS_T2 = [
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,

    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,

    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
];
const BOOSTS_T1 = [
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,

    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,

    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
];
const INTERMEDIATE_REACTANTS = [
    RESOURCE_HYDROXIDE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
];
const BASE_RESOURCES = [
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
];
const _baseResourcesLookup = _.zipObject(
    BASE_RESOURCES,
    _.map(BASE_RESOURCES, (i) => true),
);
const RESOURCE_IMPORTANCE = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,

    RESOURCE_CATALYZED_LEMERGIUM_ACID, // zGeneral 12/07/2022
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,

    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_OPS,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_GHODIUM,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_POWER,
    RESOURCE_ENERGY,
];
const REAGENTS = {
    // Tier 3
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: [
        RESOURCE_GHODIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_GHODIUM_ACID]: [
        RESOURCE_GHODIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: [
        RESOURCE_ZYNTHIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: [
        RESOURCE_ZYNTHIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],

    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: [
        RESOURCE_LEMERGIUM_ACID,
        RESOURCE_CATALYST,
    ],

    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: [
        RESOURCE_LEMERGIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],

    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: [
        RESOURCE_KEANIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_KEANIUM_ACID]: [
        RESOURCE_KEANIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_UTRIUM_ACID]: [RESOURCE_UTRIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: [
        RESOURCE_UTRIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    // Tier 2
    [RESOURCE_GHODIUM_ACID]: [RESOURCE_GHODIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_HYDROXIDE],

    [RESOURCE_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_HYDRIDE, RESOURCE_HYDROXIDE],

    [RESOURCE_LEMERGIUM_ALKALIDE]: [
        RESOURCE_LEMERGIUM_OXIDE,
        RESOURCE_HYDROXIDE,
    ],

    [RESOURCE_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ACID]: [RESOURCE_KEANIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ACID]: [RESOURCE_UTRIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_OXIDE, RESOURCE_HYDROXIDE],
    // Tier 1
    [RESOURCE_GHODIUM_HYDRIDE]: [RESOURCE_GHODIUM, RESOURCE_HYDROGEN],
    [RESOURCE_GHODIUM_OXIDE]: [RESOURCE_GHODIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_HYDRIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_OXIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN],

    [RESOURCE_LEMERGIUM_HYDRIDE]: [RESOURCE_LEMERGIUM, RESOURCE_HYDROGEN],
    [RESOURCE_LEMERGIUM_OXIDE]: [RESOURCE_LEMERGIUM, RESOURCE_OXYGEN],

    [RESOURCE_KEANIUM_OXIDE]: [RESOURCE_KEANIUM, RESOURCE_OXYGEN],
    [RESOURCE_KEANIUM_HYDRIDE]: [RESOURCE_KEANIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_HYDRIDE]: [RESOURCE_UTRIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_OXIDE]: [RESOURCE_UTRIUM, RESOURCE_OXYGEN],
    // Tier 0
    [RESOURCE_GHODIUM]: [RESOURCE_ZYNTHIUM_KEANITE, RESOURCE_UTRIUM_LEMERGITE],
    [RESOURCE_HYDROXIDE]: [RESOURCE_OXYGEN, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_KEANITE]: [RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM],
    [RESOURCE_UTRIUM_LEMERGITE]: [RESOURCE_UTRIUM, RESOURCE_LEMERGIUM],
};
const MINERAL_COMPOUNDS_ALL = _.keys(REAGENTS).concat(BASE_RESOURCES);
const _mineralCompoundsAllLookup = _.zipObject(
    MINERAL_COMPOUNDS_ALL,
    _.map(MINERAL_COMPOUNDS_ALL, (i) => true),
);
const BOOST_PARTS = {
    UH: ATTACK,
    UO: WORK,
    KH: CARRY,
    KO: RANGED_ATTACK,
    LH: WORK,
    LO: HEAL,
    ZH: WORK,
    ZO: MOVE,
    GH: WORK,
    GO: TOUGH,
    UH2O: ATTACK,
    UHO2: WORK,
    KH2O: CARRY,
    KHO2: RANGED_ATTACK,
    LH2O: WORK,
    LHO2: HEAL,
    ZH2O: WORK,
    ZHO2: MOVE,
    GH2O: WORK,
    GHO2: TOUGH,
    XUH2O: ATTACK,
    XUHO2: WORK,
    XKH2O: CARRY,
    XKHO2: RANGED_ATTACK,
    XLH2O: WORK,
    XLHO2: HEAL,
    XZH2O: WORK,
    XZHO2: MOVE,
    XGH2O: WORK,
    XGHO2: TOUGH,
};
const BoostTypeBodyparts = {
    attack: ATTACK,
    carry: CARRY,
    ranged: RANGED_ATTACK,
    heal: HEAL,
    move: MOVE,
    tough: TOUGH,
    harvest: WORK,
    construct: WORK,
    dismantle: WORK,
    upgrade: WORK,
};
const BOOST_TIERS = {
    attack: {
        T1: 'UH',
        T2: 'UH2O',
        T3: 'XUH2O',
    },
    carry: {
        T1: 'KH',
        T2: 'KH2O',
        T3: 'XKH2O',
    },
    ranged: {
        T1: 'KO',
        T2: 'KHO2',
        T3: 'XKHO2',
    },
    heal: {
        T1: 'LO',
        T2: 'LHO2',
        T3: 'XLHO2',
    },
    move: {
        T1: 'ZO',
        T2: 'ZHO2',
        T3: 'XZHO2',
    },
    tough: {
        T1: 'GO',
        T2: 'GHO2',
        T3: 'XGHO2',
    },
    harvest: {
        T1: 'UO',
        T2: 'UHO2',
        T3: 'XUHO2',
    },
    construct: {
        T1: 'LH',
        T2: 'LH2O',
        T3: 'XLH2O',
    },
    dismantle: {
        T1: 'ZH',
        T2: 'ZH2O',
        T3: 'XZH2O',
    },
    upgrade: {
        T1: 'GH',
        T2: 'GH2O',
        T3: 'XGH2O',
    },
};
// This inverts the second-level values from above, so you get an object that looks like:
// { attack: { UH: T1, UH2O: T2, XUH2O: T3 }, carry: { ... } ... }
const _boostTypesTierLookup = _.mapValues(BOOST_TIERS, (boostType) =>
    _.invert(boostType),
);
// This inverts the second-level values from above, so you get an object that looks like:
// { attack: { UH: T1, UH2O: T2, XUH2O: T3 }, carry: { ... } ... }
const _boostTierLookupAllTypes = _.extend(
    {},
    ..._.values(_boostTypesTierLookup),
);
const COMMODITIES_ALL = [
    // Compressed mineral compounds
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY,
    // Higher commodities
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    // Basic regional commodities
    RESOURCE_WIRE,
    RESOURCE_CELL,
    RESOURCE_ALLOY,
    RESOURCE_CONDENSATE,
    // Mechanical chain
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
    // Biological chain
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
    // Electronic chain
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
    // Mystical chain
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE,
];
const _commoditiesLookup = _.zipObject(
    COMMODITIES_ALL,
    _.map(COMMODITIES_ALL, (i) => true),
);
const DEPOSITS_ALL = [
    RESOURCE_SILICON,
    RESOURCE_BIOMASS,
    RESOURCE_METAL,
    RESOURCE_MIST,
];
const ALL_ZERO_ASSETS = _.zipObject(
    RESOURCES_ALL,
    _.map(RESOURCES_ALL, (i) => 0),
);

const getBoostedTaskName = 'getBoosted';
const MIN_LIFETIME_FOR_BOOST = 0.85;
let TaskGetBoosted = class TaskGetBoosted extends Task {
    constructor(target, boostType, partCount, options = {}) {
        super(getBoostedTaskName, target, options);
        this.target = target;
        // Settings
        this.data.resourceType = boostType;
        this.data.amount = partCount;
    }
    isValidTask() {
        const lifetime = _.any(this.creep.body, (part) => part.type == CLAIM)
            ? CREEP_CLAIM_LIFE_TIME
            : CREEP_LIFE_TIME;
        if (
            this.creep.ticksToLive &&
            this.creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * lifetime
        ) {
            return false; // timeout after this amount of lifespan has passed
        }
        // else if (BOOST_PARTS[this.data.resourceType] == MOVE &&
        // this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]) >= this.creep.body.length / 2) {
        // 	Game.notify(`Bad boosting of move on creep ${this.creep}, invalid task.`);
        // 	return false;
        // }
        const partCount =
            this.data.amount ||
            this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]);
        return (
            (this.creep.boostCounts[this.data.resourceType] || 0) < partCount
        );
    }
    isValidTarget() {
        const partCount =
            this.data.amount ||
            this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]);
        return (
            this.target &&
            this.target.mineralType == this.data.resourceType &&
            this.target.mineralAmount >= LAB_BOOST_MINERAL * partCount &&
            this.target.energy >= LAB_BOOST_ENERGY * partCount
        );
    }
    work() {
        if (this.creep.spawning) {
            return ERR_INVALID_TARGET;
        }
        const partCount =
            this.data.amount ||
            this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]);
        // if (BOOST_PARTS[this.data.resourceType] == MOVE && partCount >= this.creep.body.length / 2){
        // 	Game.notify(`Bad boosting of move on creep ${this.creep}, exiting work.`);
        // 	return ERR_INVALID_TARGET;
        // }
        if (
            this.target.mineralType == this.data.resourceType &&
            this.target.mineralAmount >= LAB_BOOST_MINERAL * partCount &&
            this.target.energy >= LAB_BOOST_ENERGY * partCount
        ) {
            const result = this.target.boostCreep(
                deref(this._creep.name),
                this.data.amount,
            );
            log.info(
                `Lab@${this.target.pos.print}: boosting creep ${this.creep.print} with ${this.target.mineralType}!` +
                    ` Response: ${result}`,
            );
            return result;
        } else {
            return ERR_NOT_FOUND;
        }
    }
};
TaskGetBoosted = __decorate([profile], TaskGetBoosted);

const getRenewedTaskName = 'getRenewed';
let TaskGetRenewed = class TaskGetRenewed extends Task {
    constructor(target, options = {}) {
        super(getRenewedTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        const hasClaimPart =
            _.filter(this.creep.body, (part) => part.type == CLAIM).length > 0;
        const lifetime = hasClaimPart ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        return (
            this.creep.ticksToLive != undefined &&
            this.creep.ticksToLive < 0.9 * lifetime
        );
    }
    isValidTarget() {
        return this.target.my && !this.target.spawning;
    }
    work() {
        return this.target.renewCreep(this.creep.creep);
    }
};
TaskGetRenewed = __decorate([profile], TaskGetRenewed);

// Type guards library: this allows for instanceof - like behavior for much lower CPU cost. Each type guard
// differentiates an ambiguous input by recognizing one or more unique properties.
// export interface EnergyStructure extends Structure {
// 	energy: number;
// 	energyCapacity: number;
// }
// export interface StoreStructure extends Structure {
// 	store: StoreDefinition;
// 	storeCapacity: number;
// }
// export function isEnergyStructure(obj: RoomObject): obj is EnergyStructure {
// 	return (<EnergyStructure>obj).energy != undefined && (<EnergyStructure>obj).energyCapacity != undefined;
// }
//
// export function isStoreStructure(obj: RoomObject): obj is StoreStructure {
// 	return (<StoreStructure>obj).store != undefined && (<StoreStructure>obj).storeCapacity != undefined;
// }
function isStructure(obj) {
    return obj.structureType != undefined;
}
function isOwnedStructure(structure) {
    return structure.owner != undefined;
}
function isSource(obj) {
    return obj.energy != undefined;
}
function isTombstone(obj) {
    return obj.deathTime != undefined;
}
function isRuin(obj) {
    return obj.destroyTime != undefined;
}
function isResource(obj) {
    return obj.amount != undefined;
}
function hasPos(obj) {
    return obj.pos != undefined;
}
function isCreep(obj) {
    return obj.fatigue != undefined;
}
function isPowerCreep(obj) {
    return obj.powers != undefined;
}
function isAnyZerg(thing) {
    return thing.isAnyZerg || false;
}
function isStandardZerg(creep) {
    return creep.isStandardZerg || false;
}
function isPowerZerg(creep) {
    return creep.isPowerZerg || false;
}
function isCombatZerg(zerg) {
    return zerg.isCombatZerg || false;
}

const goToTaskName = 'goTo';
let TaskGoTo = class TaskGoTo extends Task {
    constructor(target, options = {}) {
        if (hasPos(target)) {
            super(goToTaskName, { ref: '', pos: target.pos }, options);
        } else {
            super(goToTaskName, { ref: '', pos: target }, options);
        }
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(
            this.targetPos,
            this.settings.targetRange,
        );
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        } else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoTo = __decorate([profile], TaskGoTo);

const goToRoomTaskName = 'goToRoom';
let TaskGoToRoom = class TaskGoToRoom extends Task {
    constructor(roomName, options = {}) {
        super(
            goToRoomTaskName,
            { ref: '', pos: new RoomPosition(25, 25, roomName) },
            options,
        );
        // Settings
        this.settings.targetRange = 23; // Target is almost always controller flag, so range of 2 is acceptable
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(
            this.targetPos,
            this.settings.targetRange,
        );
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        } else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoToRoom = __decorate([profile], TaskGoToRoom);

const harvestTaskName = 'harvest';
let TaskHarvest = class TaskHarvest extends Task {
    constructor(target, options = {}) {
        super(harvestTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        var _a;
        if (
            (_a = this.target.room) === null || _a === void 0
                ? void 0
                : _a.notMe
        ) {
            return false;
        }
        return sumStore(this.creep.carry) < this.creep.carryCapacity * 0.95;
    }
    isValidTarget() {
        if (isSource(this.target)) {
            return this.target.energy > 0;
        } else {
            return this.target.mineralAmount > 0;
        }
    }
    work() {
        return this.creep.harvest(this.target);
    }
};
TaskHarvest = __decorate([profile], TaskHarvest);

const healTaskName = 'heal';
let TaskHeal = class TaskHeal extends Task {
    constructor(target, options = {}) {
        super(healTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(HEAL) > 0;
    }
    isValidTarget() {
        return (
            this.target &&
            this.target.hits < this.target.hitsMax &&
            this.target.my
        );
    }
    work() {
        if (this.creep.pos.isNearTo(this.target)) {
            return this.creep.heal(this.target);
        } else {
            this.moveToTarget(1);
        }
        return this.creep.rangedHeal(this.target);
    }
};
TaskHeal = __decorate([profile], TaskHeal);

// Invalid task assigned if instantiation fails.
const invalidTarget = {
    ref: '',
    pos: {
        x: 25,
        y: 25,
        roomName: 'W6N1',
    },
};
let TaskInvalid = class TaskInvalid extends Task {
    constructor() {
        super('INVALID', invalidTarget);
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        return OK;
    }
};
TaskInvalid = __decorate([profile], TaskInvalid);

const meleeAttackTaskName = 'meleeAttack';
let TaskMeleeAttack = class TaskMeleeAttack extends Task {
    constructor(target, options = {}) {
        super(meleeAttackTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(ATTACK) > 0;
    }
    isValidTarget() {
        const target = this.target;
        return target && target.hits > 0; // && target.my == false);
    }
    work() {
        return this.creep.attack(this.target);
    }
};
TaskMeleeAttack = __decorate([profile], TaskMeleeAttack);

const pickupTaskName = 'pickup';
let TaskPickup = class TaskPickup extends Task {
    constructor(target, options = {}) {
        super('pickup', target, options);
        this.target = target;
        this.settings.oneShot = true;
    }
    isValidTask() {
        return sumStore(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        return this.target && this.target.amount > 0;
    }
    work() {
        return this.creep.pickup(this.target);
    }
};
TaskPickup = __decorate([profile], TaskPickup);

const rangedAttackTaskName = 'rangedAttack';
let TaskRangedAttack = class TaskRangedAttack extends Task {
    constructor(target, options = {}) {
        super(rangedAttackTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(RANGED_ATTACK) > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.rangedAttack(this.target);
    }
};
TaskRangedAttack = __decorate([profile], TaskRangedAttack);

var CreepSetup_1;
/* Return the cost of an entire array of body parts */
function bodyCost(bodyparts) {
    return _.sum(bodyparts, (part) => BODYPART_COST[part]);
}
function patternCost(setup) {
    return bodyCost(setup.bodySetup.pattern);
}
/**
 * The CreepSetup class contains methods for flexibly generating creep body arrays when needed for spawning
 */
let CreepSetup = (CreepSetup_1 = class CreepSetup {
    constructor(roleName, bodySetup = {}, boosts) {
        this.role = roleName;
        // Defaults for a creep setup
        _.defaults(bodySetup, {
            pattern: [],
            sizeLimit: Infinity,
            prefix: [],
            suffix: [],
            proportionalPrefixSuffix: false,
            ordered: true,
        });
        this.bodySetup = bodySetup;
        this.boosts = boosts || [];
        this.cache = {};
    }
    /**
     * Returns a new CreepSetup instance which is a copy of the existing setup but with boosts applied. This allows
     * you to easily make boosted versions of the default setups in setups.ts without modifying the original objects.
     */
    static boosted(setup, boosts) {
        return new CreepSetup_1(setup.role, setup.bodySetup, boosts);
    }
    /**
     * Generate the body and best boosts for a requested creep
     */
    create(colony, useCache = false) {
        // If you're allowed to use a cached result (e.g. for estimating wait times), return that
        if (
            useCache &&
            this.cache[colony.name] &&
            Game.time < this.cache[colony.name].expiration
        ) {
            return this.cache[colony.name].result;
        }
        // Otherwise recompute
        const body = this.generateBody(colony.room.energyCapacityAvailable);
        const bodyCounts = _.countBy(body);
        const boosts = [];
        if (this.boosts.length > 0 && colony.evolutionChamber) {
            for (const boostType of this.boosts) {
                const numParts = bodyCounts[BoostTypeBodyparts[boostType]];
                const bestBoost = colony.evolutionChamber.bestBoostAvailable(
                    boostType,
                    numParts * LAB_BOOST_MINERAL,
                );
                if (bestBoost) {
                    boosts.push(bestBoost);
                }
            }
        }
        const result = {
            body: body,
            boosts: boosts,
        };
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    /**
     * Generate the largest body of a given pattern that can be made from a room, subject to limitations from maxRepeats
     */
    generateBody(availableEnergy) {
        let patternCost, patternLength, numRepeats;
        const prefix = this.bodySetup.prefix;
        const suffix = this.bodySetup.suffix;
        let body = [];
        // calculate repetitions
        if (this.bodySetup.proportionalPrefixSuffix) {
            // if prefix and suffix are to be kept proportional to body size
            patternCost =
                bodyCost(prefix) +
                bodyCost(this.bodySetup.pattern) +
                bodyCost(suffix);
            patternLength =
                prefix.length + this.bodySetup.pattern.length + suffix.length;
            const energyLimit = Math.floor(availableEnergy / patternCost); // max number of repeats room can produce
            const maxPartLimit = Math.floor(MAX_CREEP_SIZE / patternLength); // max repetitions resulting in <50 parts
            numRepeats = Math.min(
                energyLimit,
                maxPartLimit,
                this.bodySetup.sizeLimit,
            );
        } else {
            // if prefix and suffix don't scale
            const extraCost = bodyCost(prefix) + bodyCost(suffix);
            patternCost = bodyCost(this.bodySetup.pattern);
            patternLength = this.bodySetup.pattern.length;
            const energyLimit = Math.floor(
                (availableEnergy - extraCost) / patternCost,
            );
            const maxPartLimit = Math.floor(
                (MAX_CREEP_SIZE - prefix.length - suffix.length) /
                    patternLength,
            );
            numRepeats = Math.min(
                energyLimit,
                maxPartLimit,
                this.bodySetup.sizeLimit,
            );
        }
        // build the body
        if (this.bodySetup.proportionalPrefixSuffix) {
            // add the prefix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(prefix);
            }
        } else {
            body = body.concat(prefix);
        }
        if (this.bodySetup.ordered) {
            // repeated body pattern
            for (const part of this.bodySetup.pattern) {
                for (let i = 0; i < numRepeats; i++) {
                    body.push(part);
                }
            }
        } else {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(this.bodySetup.pattern);
            }
        }
        if (this.bodySetup.proportionalPrefixSuffix) {
            // add the suffix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(suffix);
            }
        } else {
            body = body.concat(suffix);
        }
        // return it
        return body;
    }
    generateMaxedBody() {
        // TODO hardcoded for our current cap with extensions missing
        return this.generateBody(11100);
    }
    /**
     * Returns the number of parts that a body will have if made from a given colony
     */
    getBodyPotential(partType, colony) {
        // let energyCapacity = Math.max(colony.room.energyCapacityAvailable,
        // 							  colony.incubator ? colony.incubator.room.energyCapacityAvailable : 0);
        let energyCapacity = colony.room.energyCapacityAvailable;
        if (colony.spawnGroup) {
            const colonies = _.compact(
                _.map(
                    colony.spawnGroup.memory.colonies,
                    (name) => Overmind.colonies[name],
                ),
            );
            energyCapacity = _.max(
                _.map(
                    colonies,
                    (colony) => colony.room.energyCapacityAvailable,
                ),
            );
        }
        const body = this.generateBody(energyCapacity);
        return _.filter(body, (part) => part == partType).length;
    }
});
CreepSetup = CreepSetup_1 = __decorate([profile], CreepSetup);

var CombatCreepSetup_1;
const allZeroParts = () => ({
    move: 0,
    attack: 0,
    ranged: 0,
    heal: 0,
    tough: 0,
    work: 0,
    carry: 0,
    claim: 0,
});
// This re-declaration is needed to get typings to work since typed-screeps has a hard-on for over-typing things
const BOOST_EFFECTS = BOOSTS;
const BODYPART_COSTS = _.extend(_.clone(BODYPART_COST), {
    ranged: BODYPART_COST[RANGED_ATTACK],
});
/**
 * This class creates body plans for combat creeps, especially ones where the body may depend on the available boosts.
 * It extends my old CreepSetup class for backward compatibility; going forward, I will use this class for most
 * CombatOverlord creep requests while I use the old system for standard Overlord creep requests.
 */
let CombatCreepSetup = (CombatCreepSetup_1 = class CombatCreepSetup /*extends CreepSetup*/ {
    constructor(roleName, opts, bodyGenerator) {
        // super(roleName, {}, []);
        this.role = roleName;
        this.opts = opts;
        this.bodyGenerator = bodyGenerator;
        this.cache = {};
    }
    /**
     * Generate the body and boosts for a requested creep
     */
    create(colony, useCache = false) {
        // If you're allowed to use a cached result (e.g. for estimating wait times), return that
        if (
            useCache &&
            this.cache[colony.name] &&
            Game.time < this.cache[colony.name].expiration
        ) {
            return this.cache[colony.name].result;
        }
        // Otherwise recompute
        const result = this.bodyGenerator(colony, this.opts);
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    // /**
    //  * Here for legacy purposes to that this can extend the old CreepSetup class, but you never want to use this!
    //  */
    // generateBody(availableEnergy: number): BodyPartConstant[] {
    // 	log.error(`CombatCreepSetup.generateBody() should not be used!`);
    // 	return [];
    // }
    /**
     * Returns an object with the best boosts available for each type of boost requested. The object will only have
     * keys for boosts which are requested in opts.boosts and for which opts.bodyRatio has non-zero entries, and
     * if a boost is requested but not available, the key will be present but the value will be undefined.
     */
    static getBestBoostsAvailable(colony, opts) {
        const availableBoosts = {};
        if (colony.evolutionChamber) {
            if (opts.bodyRatio.tough && opts.boosts.includes('tough')) {
                const toughBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.tough || 0);
                availableBoosts.tough = colony.evolutionChamber.bestBoostAvailable(
                    'tough',
                    toughBoostNeeded,
                );
            }
            if (opts.bodyRatio.heal && opts.boosts.includes('heal')) {
                const healBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.heal || 0);
                availableBoosts.heal = colony.evolutionChamber.bestBoostAvailable(
                    'heal',
                    healBoostNeeded,
                );
            }
            if (opts.bodyRatio.ranged && opts.boosts.includes('ranged')) {
                const rangedBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.ranged || 0);
                availableBoosts.ranged = colony.evolutionChamber.bestBoostAvailable(
                    'ranged',
                    rangedBoostNeeded,
                );
            }
            if (opts.bodyRatio.attack && opts.boosts.includes('attack')) {
                const attackBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.attack || 0);
                availableBoosts.attack = colony.evolutionChamber.bestBoostAvailable(
                    'attack',
                    attackBoostNeeded,
                );
            }
            if (opts.bodyRatio.carry && opts.boosts.includes('carry')) {
                const carryBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.carry || 0);
                availableBoosts.carry = colony.evolutionChamber.bestBoostAvailable(
                    'carry',
                    carryBoostNeeded,
                );
            }
            if (opts.bodyRatio.work && opts.boosts.includes('dismantle')) {
                const dismantleBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.dismantle = colony.evolutionChamber.bestBoostAvailable(
                    'dismantle',
                    dismantleBoostNeeded,
                );
            }
            if (opts.bodyRatio.work && opts.boosts.includes('upgrade')) {
                const upgradeBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.upgrade = colony.evolutionChamber.bestBoostAvailable(
                    'upgrade',
                    upgradeBoostNeeded,
                );
            }
            if (opts.bodyRatio.work && opts.boosts.includes('construct')) {
                const constructBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.construct = colony.evolutionChamber.bestBoostAvailable(
                    'construct',
                    constructBoostNeeded,
                );
            }
            if (opts.bodyRatio.work && opts.boosts.includes('harvest')) {
                const harvestBoostNeeded =
                    LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.harvest = colony.evolutionChamber.bestBoostAvailable(
                    'harvest',
                    harvestBoostNeeded,
                );
            }
            if (opts.boosts.includes('move')) {
                const moveBoostNeeded = (LAB_BOOST_MINERAL * 50) / 3; // T1 most boost lets you do move ratio of 2 : 1
                availableBoosts.move = colony.evolutionChamber.bestBoostAvailable(
                    'move',
                    moveBoostNeeded,
                );
            }
        }
        if (
            _.sum(opts.boosts, (b) =>
                ['dismantle', 'upgrade', 'construct', 'harvest'].includes(b)
                    ? 1
                    : 0,
            ) > 1
        ) {
            log.warning(
                `Multiple boost types requested for work part! opts.boosts: ${print(
                    opts.boosts,
                )}`,
            );
        }
        return availableBoosts;
    }
    /**
     * Generates a body counts based on a body ratio and a required move ratio (which depends on the available boosts
     * for the generating colony). If carryPartsAreWeighted=true, all carry parts are assumed to be full for the
     * purposes of computing move speed.
     */
    static generateBodyCounts(
        colony,
        opts,
        moveRatio,
        rootPart,
        partPriorities,
        unweightedCarryParts = false,
    ) {
        if (partPriorities.includes(rootPart)) {
            log.error(
                `generateBodyCounts() error: part priorities ${partPriorities} cannot ` +
                    `include root part ${rootPart}`,
            );
            return allZeroParts();
        }
        const bodyRatio = _.defaults(_.clone(opts.bodyRatio), allZeroParts());
        const maxParts = _.defaults(_.clone(opts.maxParts), allZeroParts());
        // Compute the most expensive part you may need to add to the body
        const nonZeroParts = _.filter(
            _.keys(opts.bodyRatio),
            (part) => opts.bodyRatio[part] > 0,
        );
        const maxPartCost = _.max(
            _.map(nonZeroParts, (part) => BODYPART_COSTS[part]),
        );
        // Initialize body counts object
        const bodyCounts = {
            move: 1,
            attack: bodyRatio.attack > 0 ? 1 : 0,
            ranged: bodyRatio.ranged > 0 ? 1 : 0,
            heal: bodyRatio.heal > 0 ? 1 : 0,
            tough: bodyRatio.tough > 0 ? 1 : 0,
            work: bodyRatio.work > 0 ? 1 : 0,
            carry: bodyRatio.carry > 0 ? 1 : 0,
            claim: bodyRatio.claim > 0 ? 1 : 0,
        };
        // Initialize cost of starting body counts
        let cost = 0;
        for (const part in bodyCounts) {
            cost += bodyCounts[part] * BODYPART_COSTS[part];
        }
        // Keep adding stuff until you run out of space on the body or out of energy capacity in the room
        while (
            _.sum(bodyCounts) < MAX_CREEP_SIZE &&
            cost <= colony.room.energyCapacityAvailable - maxPartCost
        ) {
            // Highest priority is add move parts to maintain the target move speed
            const weightedParts = unweightedCarryParts
                ? _.sum(bodyCounts) - bodyCounts.move - bodyCounts.carry
                : _.sum(bodyCounts) - bodyCounts.move;
            if (weightedParts >= moveRatio * bodyCounts.move) {
                bodyCounts.move++;
                cost += BODYPART_COST[MOVE];
            } else {
                // If any non-root parts are below the target ratio and below the maxParts limit, add them
                let nonRootPartAdded = false;
                for (const part of partPriorities) {
                    if (
                        bodyCounts[part] < maxParts[part] &&
                        bodyCounts[part] / bodyCounts[rootPart] <
                            bodyRatio[part] / bodyRatio[rootPart]
                    ) {
                        bodyCounts[part]++;
                        cost += BODYPART_COSTS[part];
                        nonRootPartAdded = true;
                        break;
                    }
                }
                // Otherwise add another root part
                if (!nonRootPartAdded) {
                    bodyCounts[rootPart]++;
                    cost += BODYPART_COSTS[rootPart];
                }
            }
        }
        return bodyCounts;
    }
    /**
     * Generate a body array from a count of body parts. Body is ordered as:
     * - TOUGH -> CARRY -> MOVE -> RANGED -> WORK -> ATTACK -> CLAIM -> HEAL if opts.putMoveFirstInBody is true
     * - TOUGH -> CARRY -> RANGED -> WORK -> ATTACK -> HEAL -> CLAIM -> MOVE if opts.putMoveFirstInBody is false
     * - The final MOVE part is always put at the end of the body array
     */
    static arrangeBodyParts(partialBodyCounts, opts) {
        const bodyCounts = _.defaults(partialBodyCounts, {
            move: 1,
            attack: 0,
            ranged: 0,
            heal: 0,
            tough: 0,
            work: 0,
            carry: 0,
            claim: 0,
        });
        const body = [];
        _.forEach(_.range(bodyCounts.tough), (i) => body.push(TOUGH));
        if (opts.putMoveFirstInBody) {
            _.forEach(_.range(bodyCounts.carry), (i) => body.push(CARRY));
            _.forEach(_.range(bodyCounts.move - 1), (i) => body.push(MOVE));
            _.forEach(_.range(bodyCounts.ranged), (i) =>
                body.push(RANGED_ATTACK),
            );
            _.forEach(_.range(bodyCounts.work), (i) => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), (i) => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), (i) => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.heal), (i) => body.push(HEAL));
        } else {
            _.forEach(_.range(bodyCounts.carry), (i) => body.push(CARRY));
            _.forEach(_.range(bodyCounts.ranged), (i) =>
                body.push(RANGED_ATTACK),
            );
            _.forEach(_.range(bodyCounts.work), (i) => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), (i) => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), (i) => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.move - 1), (i) => body.push(MOVE));
            _.forEach(_.range(bodyCounts.heal), (i) => body.push(HEAL));
        }
        body.push(MOVE);
        return body;
    }
    /**
     * Creates a body plan for a creep with body ratios based around melee attack parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateMeleeAttackerBody(colony, opts) {
        if (!opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No attack!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`,
            );
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.ranged) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires ranged body!`,
            );
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_MELEE = { attack: 50, tough: 10, heal: 2 };
        opts.maxParts.attack =
            opts.maxParts.attack || DEFAULT_MAX_PARTS_MELEE.attack;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_MELEE.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_MELEE.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need attack to be defined for bodyRatio and maxParts
        opts.bodyRatio.attack = opts.bodyRatio.attack || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = 'attack';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around ranged attack parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateRangedAttackerBody(colony, opts) {
        if (!opts.bodyRatio.ranged) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No ranged!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`,
            );
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`,
            );
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_RANGED = { ranged: 40, tough: 10, heal: 20 };
        opts.maxParts.ranged =
            opts.maxParts.ranged || DEFAULT_MAX_PARTS_RANGED.ranged;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_RANGED.tough;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_RANGED.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need ranged to be defined for bodyRatio and maxParts
        opts.bodyRatio.ranged = opts.bodyRatio.ranged || 1;
        const rootPart = 'ranged';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around claim parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateInfestorBody(colony, opts) {
        if (!opts.bodyRatio.heal) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No heal!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`,
            );
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`,
            );
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_CLAIM = { heal: 20, tough: 10, claim: 10 };
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_CLAIM.heal;
        opts.maxParts.claim =
            opts.maxParts.claim || DEFAULT_MAX_PARTS_CLAIM.claim;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_CLAIM.tough;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need heal to be defined for bodyRatio and maxParts
        opts.bodyRatio.heal = opts.bodyRatio.heal || 1;
        const rootPart = 'claim';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around heal parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateHealerBody(colony, opts) {
        if (!opts.bodyRatio.heal) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No heal!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`,
            );
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`,
            );
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_HEAL = { heal: 40, tough: 10, ranged: 30 };
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_HEAL.heal;
        opts.maxParts.ranged =
            opts.maxParts.ranged || DEFAULT_MAX_PARTS_HEAL.ranged;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_HEAL.tough;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need heal to be defined for bodyRatio and maxParts
        opts.bodyRatio.heal = opts.bodyRatio.heal || 1;
        const rootPart = 'heal';
        const partPriorities = ['tough', 'ranged'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around work parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateDismantlerBody(colony, opts) {
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(
                `Bad opts.bodyRatio: ${opts.bodyRatio}; using attack parts requires melee body!`,
            );
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_DISMANTLER = {
            work: 40,
            tough: 10,
            ranged: 10,
            heal: 2,
        };
        opts.maxParts.work =
            opts.maxParts.work || DEFAULT_MAX_PARTS_DISMANTLER.work;
        opts.maxParts.ranged =
            opts.maxParts.ranged || DEFAULT_MAX_PARTS_DISMANTLER.ranged;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_DISMANTLER.tough;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_DISMANTLER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need work to be defined for bodyRatio and maxParts
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = 'work';
        const partPriorities = ['tough', 'ranged', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around work parts. Move speed for this method
     * assumes that all carry parts are empty, as you won't move an upgrader with energy. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateUpgraderBody(colony, opts) {
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_UPGRADER = {
            work: 50,
            tough: 10,
            carry: 20,
            heal: 2,
        };
        opts.maxParts.work =
            opts.maxParts.work || DEFAULT_MAX_PARTS_UPGRADER.work;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_UPGRADER.tough;
        opts.maxParts.carry =
            opts.maxParts.carry || DEFAULT_MAX_PARTS_UPGRADER.carry;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_UPGRADER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need work to be defined for bodyRatio and maxParts
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = 'work';
        const partPriorities = ['tough', 'carry', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
            true,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around carry parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateCarrierBody(colony, opts) {
        if (!opts.bodyRatio.carry) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No carry!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_CARRIER = { carry: 50, tough: 10, heal: 3 };
        opts.maxParts.carry =
            opts.maxParts.attack || DEFAULT_MAX_PARTS_CARRIER.carry;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_CARRIER.tough;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_CARRIER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(
            colony,
            opts,
        );
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio =
            (availableBoosts.move
                ? BOOST_EFFECTS.move[availableBoosts.move].fatigue
                : 1) * opts.moveSpeed;
        // We need carry to be defined for bodyRatio and maxParts
        opts.bodyRatio.carry = opts.bodyRatio.carry || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = 'carry';
        const partPriorities = ['tough', 'heal'];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(
            colony,
            opts,
            moveRatio,
            rootPart,
            partPriorities,
        );
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
});
CombatCreepSetup = CombatCreepSetup_1 = __decorate([profile], CombatCreepSetup);
/**
 * Creates a body for a zergling (melee attacker). Takes an object of possible options:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 3:1 attack:tough ratio will be used up to 10 tough parts
 * - If opts.healing is true, up to 2 heal parts will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class ZerglingSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const zerglingBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: true,
            bodyRatio: {
                attack: 30,
                tough: opts.armored ? 10 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? ['attack', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, zerglingBodyOpts);
        super(
            Roles.melee,
            bodyOpts,
            CombatCreepSetup.generateMeleeAttackerBody,
        );
    }
}
/**
 * Creates a body for a infestor. Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 1:1 claim:tough ratio will be used up to 10 tough parts
 * - If opts.healing is true (default), a 1:2 claim:heal ratio will be used up to 20 heal parts
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class InfestorSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: true,
            armored: true,
            healing: true,
            bodyOpts: {},
        });
        const healerBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                claim: 5,
                heal: opts.healing ? 10 : 0,
                tough: opts.armored ? 10 : 0,
            },
            maxParts: { heal: 20, tough: 10, claim: 10 },
            boosts: opts.boosted ? ['tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, healerBodyOpts);
        super(Roles.claim, bodyOpts, CombatCreepSetup.generateInfestorBody);
    }
}
/**
 * Creates a body for a hydralisk (ranged attacker which may have some healing). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 ranged:tough ratio will be used up to 8 tough parts
 * - If opts.healing is true (default), a 3:1 ranged:heal ratio will be used up to 10 heal parts
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class HydraliskSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: true,
            bodyOpts: {},
        });
        const hydraliskBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                ranged: 12,
                tough: opts.armored ? 4 : 0,
                heal: opts.healing ? 4 : 0,
            },
            maxParts: { ranged: 30, tough: 10, heal: 12 }, // heal was 10 zGeneral 28/9/2023
            boosts: opts.boosted ? ['ranged', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, hydraliskBodyOpts);
        super(
            Roles.ranged,
            bodyOpts,
            CombatCreepSetup.generateRangedAttackerBody,
        );
    }
}
/**
 * Creates a body for a transfuser (healer which may have some ranged attack parts). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 heal:tough ratio will be used up to 8 tough parts
 * - If opts.withRanged is true, a 3:1 heal:ranged ratio will be used up to 10 ranged parts
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class TransfuserSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            withRanged: false,
            bodyOpts: {},
        });
        const healerBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                heal: 12,
                tough: opts.armored ? 3 : 0,
                ranged: opts.withRanged ? 4 : 0,
            },
            maxParts: { heal: 30, tough: 8, ranged: 10 },
            boosts: opts.boosted ? ['ranged', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, healerBodyOpts);
        super(Roles.healer, bodyOpts, CombatCreepSetup.generateHealerBody);
    }
}
/**
 * Creates a body for a lurker (dismantler which may have some ranged or healing). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 work:tough ratio will be used up to 10 tough parts
 * - If opts.withRanged is true, a 3:1 work:ranged ratoi will be used up to 10 ranged parts
 * - If opts.healing is true, up to 2 heal parts may be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class LurkerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const lurkerBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                work: 24,
                tough: opts.armored ? 6 : 0,
                ranged: opts.withRanged ? 8 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { work: 30, tough: 10, ranged: 10, heal: 2 },
            boosts: opts.boosted
                ? ['dismantle', 'ranged', 'tough', 'heal', 'move']
                : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, lurkerBodyOptions);
        super(
            Roles.dismantler,
            bodyOpts,
            CombatCreepSetup.generateDismantlerBody,
        );
    }
}
/**
 * Creates a body for a ravager (melee bunker defender with 0.5 move speed). Takes an object of possible options:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 3:1 attack:tough ratio will be used up to 10 tough parts
 * - If opts.healing is true, up to 2 heal parts will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class RavagerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 0.5,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const ravagerBodyDefaults = {
            moveSpeed: opts.moveSpeed || 0.5,
            putMoveFirstInBody: true,
            bodyRatio: {
                attack: 30,
                tough: opts.armored ? 10 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? ['attack', 'tough', 'heal', 'move'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, ravagerBodyDefaults);
        super(
            Roles.bunkerDefender,
            bodyOpts,
            CombatCreepSetup.generateMeleeAttackerBody,
        );
    }
}
/**
 * Creates a body for a remote upgrader. Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted to max level
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class RemoteUpgraderSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, bodyOpts: {} });
        const remoteUpgraderBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { work: 8, carry: 1 },
            maxParts: { work: 40, carry: 10 },
            boosts: opts.boosted ? ['upgrade', 'carry', 'move'] : [],
        };
        const bodyOpts = _.defaults(
            opts.bodyOpts || {},
            remoteUpgraderBodyOptions,
        );
        super(Roles.upgrader, bodyOpts, CombatCreepSetup.generateUpgraderBody);
    }
}
/**
 * Creates a body for a remote upgrader. Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted to max level
 * - If opts.healing is true, up to 2 heal part will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class CarrierSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            healing: false,
            bodyOpts: {},
        });
        const carrierBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { carry: 1, heal: opts.healing ? 0.01 : 0 },
            maxParts: { carry: 40, heal: opts.healing ? 1 : 0 },
            boosts: opts.boosted ? ['carry', 'move', 'heal'] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, carrierBodyOptions);
        super(Roles.transport, bodyOpts, CombatCreepSetup.generateCarrierBody);
    }
}
global.CombatCreepSetup = CombatCreepSetup;
global.DefaultCombatCreepSetups = {
    zergling: ZerglingSetup,
    hydralisk: HydraliskSetup,
    transfuser: TransfuserSetup,
    lurker: LurkerSetup,
    ravager: RavagerSetup,
    remoteUpgrader: RemoteUpgraderSetup,
    carrier: CarrierSetup,
};

/**
 * A mapping of role types to string constants used for naming creeps and accessing them by role
 */
const Roles = {
    // Civilian roles
    drone: 'drone',
    filler: 'filler',
    claim: 'infestor',
    pioneer: 'pioneer',
    manager: 'manager',
    queen: 'queen',
    scout: 'changeling',
    transport: 'transport',
    worker: 'worker',
    upgrader: 'upgrader',
    praiser: 'praiser',
    // Combat roles
    guardMelee: 'broodling',
    melee: 'zergling',
    siege: 'baneling',
    ranged: 'hydralisk',
    rangedDistractor: 'babbylisk',
    healer: 'transfuser',
    dismantler: 'lurker',
    bunkerDefender: 'ravager',
    drill: 'drill',
    coolant: 'coolant',
    roomPoisoner: 'poisoner',
    strongholdKiller: 'strongman',
    rangedPair: 'hydralisk',
    // inter shard
    interShardScout: 'tumor',
    interShardClaim: 'viper',
    interShardPioneer: 'nydus',
    interShardHauler: 'carrier',
};
/**
 * This object contains categorized default body setups for various types of creeps
 */
const Setups = {
    drones: {
        extractor: new CreepSetup(Roles.drone, {
            pattern: [WORK, WORK, MOVE],
            sizeLimit: Infinity,
            prefix: [CARRY, CARRY],
        }),
        miners: {
            default: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 3,
            }),
            standard: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    WORK,
                ],
                sizeLimit: 1,
            }),
            first: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, MOVE],
                sizeLimit: 1,
            }),
            standardCPU: new CreepSetup(Roles.drone, {
                // pattern  : [WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE, WORK],
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    CARRY,
                    CARRY,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 1,
            }),
            linkOptimized: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    CARRY,
                    CARRY,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 1,
            }),
            emergency: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 1,
            }),
            double: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 2,
            }),
            sourceKeeper: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 1,
            }),
            regenSource: new CreepSetup(Roles.drone, {
                // zGeneral modified to maximize performance - check if it works on RCL7 7/2023
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    CARRY,
                    CARRY,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 1,
            }),
        },
    },
    fillers: {
        first: new CreepSetup(Roles.filler, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: 1,
        }),
        second: new CreepSetup(Roles.filler, {
            pattern: [CARRY, MOVE],
            sizeLimit: 3,
        }),
        third: new CreepSetup(Roles.filler, {
            pattern: [CARRY, MOVE],
            sizeLimit: 6,
        }),
    },
    infestors: {
        claim: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 1,
        }),
        fastClaim: new CreepSetup(Roles.claim, {
            pattern: [MOVE, MOVE, MOVE, MOVE, CLAIM, MOVE],
            sizeLimit: 1,
        }),
        reserve: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
        controllerAttacker: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
        boostedControllerAttacker: new CreepSetup(Roles.claim, {
            pattern: [TOUGH, HEAL, HEAL, CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
    },
    pioneer: new CreepSetup(Roles.pioneer, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: Infinity,
    }),
    managers: {
        default: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, CARRY, CARRY, MOVE],
            sizeLimit: 3,
        }),
        twoPart: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: 8,
        }),
        stationary: new CreepSetup(Roles.manager, {
            pattern: [CARRY], // zGeneral 2/2024
            sizeLimit: 50,
        }),
        stationary_work: new CreepSetup(Roles.manager, {
            pattern: [WORK, WORK, WORK, WORK, CARRY, CARRY],
            sizeLimit: 8,
        }),
    },
    queens: {
        default: new CreepSetup(Roles.queen, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.queen, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    scout: new CreepSetup(Roles.scout, {
        pattern: [MOVE],
        sizeLimit: 1,
    }),
    transporters: {
        default: new CreepSetup(Roles.transport, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.transport, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        boosted: new CarrierSetup({ boosted: true }),
    },
    workers: {
        // TODO: implement inhouse workers to reinforce bunker
        inhouse: new CreepSetup(Roles.worker, {
            pattern: [WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        emergency: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: 1,
        }),
    },
    upgraders: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        default_boosted: new CreepSetup(
            Roles.upgrader,
            {
                pattern: [WORK, WORK, WORK, CARRY, MOVE],
                sizeLimit: Infinity,
            },
            ['upgrade'],
        ),
        rcl8: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }),
        rcl8_boosted: new CreepSetup(
            Roles.upgrader,
            {
                pattern: [WORK, WORK, WORK, CARRY, MOVE],
                sizeLimit: 5,
            },
            ['upgrade'],
        ),
        remote: new CreepSetup(Roles.upgrader, {
            pattern: [
                WORK,
                WORK,
                WORK,
                WORK,
                CARRY,
                CARRY,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
        remote_boosted: new RemoteUpgraderSetup({ boosted: true }),
    },
    roomPoisoner: new CreepSetup(Roles.roomPoisoner, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: 4,
    }),
    praisers: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    interShard: {
        scout: new CreepSetup(Roles.interShardScout, {
            pattern: [MOVE],
            sizeLimit: 1,
        }),
        claim: new CreepSetup(Roles.interShardClaim, {
            pattern: [CLAIM, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: 1,
        }),
        pioneer: new CreepSetup(Roles.interShardPioneer, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        pioneerBoosted: new CreepSetup(
            Roles.interShardPioneer,
            {
                pattern: [WORK, WORK, WORK, CARRY, MOVE],
                sizeLimit: Infinity,
            },
            // TODO: make two types of pioneers depending on colony boostrap need
            // TODO: one for 'upgrade' where there is nothing to build
            // TODO: one for 'construct' whem there are a lot of construction work
            ['move', 'upgrade'],
        ),
        hauler: new CreepSetup(Roles.interShardHauler, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        haulerBoosted: new CreepSetup(
            Roles.interShardHauler,
            {
                pattern: [CARRY, CARRY, CARRY, CARRY, MOVE],
                sizeLimit: Infinity,
            },
            // TODO: make two types of pioneers depending on colony boostrap need
            // TODO: one for 'upgrade' where there is nothing to build
            // TODO: one for 'construct' whem there are a lot of construction work
            ['move', 'carry'],
        ),
    },
};
/**
 * This object contains default body setups for various types of combat-related creeps
 */
const CombatSetups = {
    /**
     * Zerglings are melee-only creeps (with exception of sourceKeeper setup)
     */
    zerglings: {
        // default: new CreepSetup(Roles.melee, {
        // 	pattern  : [ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // limitedDefault: new CreepSetup(Roles.melee, {
        // 	pattern  : [ATTACK, MOVE],
        // 	sizeLimit: 5,
        // }),
        //
        // armored: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_defense: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_armor: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_strongArmor: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        default: new ZerglingSetup(),
        healing: new ZerglingSetup({ healing: true }),
        boosted: {
            default: new ZerglingSetup({ boosted: true }),
            armored: new ZerglingSetup({ boosted: true, armored: true }),
            armoredHealing: new ZerglingSetup({
                boosted: true,
                armored: true,
                healing: true,
            }),
        },
        /*sourceKeeper: new CreepSetup(Roles.melee, {
            pattern: [
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                HEAL,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),*/
        sourceKeeper: new CreepSetup(Roles.melee, {
            pattern: [
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,

                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,

                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
            ],
            sizeLimit: 1,
        }),
    },
    /**
     * Hydralisks are ranged creeps which may have a small amount of healing
     */
    hydralisks: {
        default: new HydraliskSetup(),
        early: new CreepSetup(Roles.ranged, {
            pattern: [RANGED_ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        pita: new CreepSetup(Roles.ranged, {
            pattern: [RANGED_ATTACK, MOVE],
            sizeLimit: 1,
        }),
        distraction: new CreepSetup(Roles.ranged, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
            sizeLimit: 1,
        }),
        noHeal: new HydraliskSetup({ healing: false }),
        boosted: {
            default: new HydraliskSetup({ boosted: true }),
            armored: new HydraliskSetup({ boosted: true, armored: true }),
            noHeal: new HydraliskSetup({ boosted: true, healing: false }),
        },
        colony_4: new CreepSetup(Roles.ranged, {
            pattern: [
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                HEAL,
            ],
            sizeLimit: Infinity,
        }),
        colony_6: new CreepSetup(Roles.ranged, {
            pattern: [
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                HEAL,
                HEAL,
                HEAL,
            ],
            sizeLimit: Infinity,
        }),
        boosted_T3: new CreepSetup(Roles.ranged, {
            pattern: [
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                MOVE,
                MOVE,
                HEAL,
                HEAL,
                HEAL,
            ],
            sizeLimit: Infinity,
        }),
        // early: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // distraction: new CreepSetup(Roles.ranged, {
        // 	pattern  : [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
        // 	sizeLimit: 1,
        // }),
        //
        // default: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE,
        // 				MOVE, HEAL, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_old: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
        // 				MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // siege: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // siege_T3: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
        // 				MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        sourceKeeper: new CreepSetup(Roles.ranged, {
            pattern: [
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Healers (transfusers) are creeps which only do healing
     */
    transfusers: {
        default: new TransfuserSetup(),
        armored: new CreepSetup(Roles.healer, {
            pattern: [TOUGH, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        drain: new CreepSetup(Roles.healer, {
            pattern: [TOUGH, TOUGH, MOVE, MOVE, HEAL, MOVE],
            sizeLimit: Infinity,
        }),
        boosted: {
            default: new TransfuserSetup({ boosted: true }),
            armored: new TransfuserSetup({ boosted: true, armored: true }),
        },
    },
    /**
     * Broodlings are primarily melee creeps which may have a small amount of healing
     */
    broodlings: {
        early: new CreepSetup(Roles.guardMelee, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.guardMelee, {
            pattern: [
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                HEAL,
            ],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Pure melee raw power creeps that should never leave the bunker. These are the final guards for a room
     */
    bunkerDefender: {
        default: new RavagerSetup(),
        boosted: new RavagerSetup({ boosted: true }),
    },
    /**
     * Dismantlers (lurkers) are creeps with work parts for dismantle sieges
     */
    dismantlers: {
        default: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, MOVE],
            sizeLimit: Infinity,
        }),
        attackDismantlers: new CreepSetup(Roles.dismantler, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        strong: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, WORK, MOVE],
            sizeLimit: Infinity,
        }),
        slow: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, WORK, WORK, WORK, MOVE, MOVE, CARRY],
            sizeLimit: Infinity,
        }),
        fast: new CreepSetup(Roles.dismantler, {
            pattern: [
                WORK,
                WORK,
                WORK,
                WORK,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                CARRY,
                CARRY,
                CARRY,
                CARRY,
            ],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_armored_T3: new CreepSetup(Roles.dismantler, {
            pattern: [
                TOUGH,
                TOUGH,
                WORK,
                WORK,
                WORK,
                WORK,
                WORK,
                WORK,
                MOVE,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
    },
    distractors: {
        ranged: new CreepSetup(Roles.rangedDistractor, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
            sizeLimit: 1,
        }),
    },
    drill: {
        default: new CreepSetup(Roles.drill, {
            pattern: [
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE,
                TOUGH,TOUGH,
                ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,
                ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,ATTACK, ATTACK,
                ATTACK, ATTACK],
            sizeLimit: 1,
        }),
    },
    coolant: {
        default: new CreepSetup(Roles.coolant, {
            pattern: [MOVE, HEAL],
            sizeLimit: Infinity,
        }),
        small: new CreepSetup(Roles.coolant, {
            pattern: [MOVE, HEAL],
            sizeLimit: 16,
        }),
    },
    strongholdKiller: {
        // SK deal 200 RA, gotta avoid, levels
        1: new CreepSetup(Roles.strongholdKiller, {
            // 180 damage after tough so 2 tough, 4 healing, 34 RA
            pattern: [
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        2: new CreepSetup(Roles.strongholdKiller, {
            // 360 damage after tough so 4 tough, 8 healing, 28 RA
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        3: new CreepSetup(Roles.strongholdKiller, {
            // 540 damage after tough so 6 tough, 12 healing, 22 RA
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        4: new CreepSetup(Roles.strongholdKiller, {
            // 720 damage after tough so 8 tough, 15 healing, 17RA - 15*250+17*150+50*11 = 6.8k
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
    },
    infestors: {
        boosted: {
            default: new InfestorSetup({ boosted: true }),
        },
    },
};

/**
 * Returns destination.pos if destination has a position, or destination if destination is a RoomPosition
 */
function normalizePos(destination) {
    return destination.pos || destination;
}
/**
 * Returns if the coordinate is at the edge of a room. Does not explicitly check if the position is an exit tile.
 */
function isExit(pos) {
    return pos.x == 0 || pos.y == 0 || pos.x == 49 || pos.y == 49;
}
/**
 * Checks if the coordinates of two room positions are the same
 */
function sameCoord(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y;
}
/**
 * Returns the number of move parts and number of weight-generating parts in a creep
 */
function getCreepWeightInfo(creep, analyzeCarry = true) {
    // Compute number of weighted and unweighted bodyparts
    const unweightedParts = analyzeCarry ? [MOVE, CARRY] : [MOVE];
    const bodyParts = _.countBy(creep.body, (p) =>
        _.contains(unweightedParts, p.type) ? p.type : 'weighted',
    );
    bodyParts.move = bodyParts.move || 0;
    bodyParts.weighted = bodyParts.weighted || 0;
    if (analyzeCarry && bodyParts[CARRY]) {
        bodyParts.weighted += Math.ceil(
            (bodyParts[CARRY] * creep.store.getUsedCapacity()) /
                creep.store.getCapacity(),
        );
    }
    // Account for boosts
    for (const part of creep.body) {
        if (part.type == MOVE && part.boost) {
            bodyParts.move += BOOSTS.move[part.boost].fatigue - 1;
        }
    }
    return bodyParts;
}
/**
 * Get terrain costs which take into account a creep's individual fatigue stats
 */
function getTerrainCosts(creep) {
    const data = getCreepWeightInfo(creep);
    const fatigueRatio = data.weighted / data.move;
    return {
        plainCost: Math.max(Math.ceil(fatigueRatio), 1),
        swampCost: Math.max(Math.ceil(5 * fatigueRatio), 1),
    };
}

/**
 * screeps-packrat
 * ---------------
 * Lightning-fast and memory-efficient serialization of Screeps IDs, Coords, and RoomPositions
 * Code written by Muon as part of Overmind Screeps AI. Feel free to adapt as desired.
 * Package repository: https://github.com/bencbartlett/screeps-packrat
 *
 * Plain JS version is available in the #share-thy-code channel on the Screeps Slack.
 *
 * To use: import desired functions from module, or import entire module on main and use functions from global.
 * To benchmark: import tests file, PackratTests.run()
 *
 * Exported functions (available on global):
 *
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 * |         function         |                  description                   | execution time* | memory reduction** |
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 * | packId                   | packs a game object id into 6 chars            | 500ns           | -75%               |
 * | unpackId                 | unpacks 6 chars into original format           | 1.3us           |                    |
 * | packIdList               | packs a list of ids into a single string       | 500ns/id        | -81%               |
 * | unpackIdList             | unpacks a string into a list of ids            | 1.2us/id        |                    |
 * | packPos                  | packs a room position into 2 chars             | 150ns           | -90%               |
 * | unpackPos                | unpacks 2 chars into a room position           | 600ns           |                    |
 * | packPosList              | packs a list of room positions into a string   | 150ns/pos       | -95%               |
 * | unpackPosList            | unpacks a string into a list of room positions | 1.5us/pos       |                    |
 * | packCoord                | packs a coord (e.g. {x:25,y:25}) as a string   | 150ns           | -80%               |
 * | unpackCoord              | unpacks a string into a coord                  | 60-150ns        |                    |
 * | packCoordList            | packs a list of coords as a string             | 120ns/coord     | -94%               |
 * | unpackCoordList          | unpacks a string into a list of coords         | 100ns/coord     |                    |
 * | unpackCoordAsPos         | unpacks string + room name into a pos          | 500ns           |                    |
 * | unpackCoordListAsPosList | unpacks string + room name into a list of pos  | 500ns/coord     |                    |
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 *
 *  * Execution time measured on shard2 public servers and may vary on different machines or shards.
 * ** Memory reduction for list functions is the asymptotic limit of lists containing many entries. Lower reductions
 *    can be expected for smaller lists.
 *
 */
/**
 * Convert a standard 24-character hex id in screeps to a compressed UTF-16 encoded string of length 6.
 *
 * Benchmarking: average of 500ns to execute on shard2 public server, reduce stringified size by 75%
 */
function packId(id) {
    return (
        String.fromCharCode(parseInt(id.substr(0, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(4, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(8, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(12, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(16, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(20, 4), 16))
    );
}
/**
 * Convert a compressed six-character UTF-encoded id back into the original 24-character format.
 *
 * Benchmarking: average of 1.3us to execute on shard2 public server
 */
function unpackId(packedId) {
    let id = '';
    let current;
    for (let i = 0; i < 6; ++i) {
        current = packedId.charCodeAt(i);
        id += (current >>> 8).toString(16).padStart(2, '0');
        id += (current & 0xff).toString(16).padStart(2, '0');
    }
    return id;
}
/**
 * Packs a list of ids as a utf-16 string. This is better than having a list of packed coords, as it avoids
 * extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 500ns per id to execute on shard2 public server, reduce stringified size by 81%
 */
function packIdList(ids) {
    let str = '';
    for (let i = 0; i < ids.length; ++i) {
        str += packId(ids[i]);
    }
    return str;
}
/**
 * Unpacks a list of ids stored as a utf-16 string.
 *
 * Benchmarking: average of 1.2us per id to execute on shard2 public server.
 */
function unpackIdList(packedIds) {
    const ids = [];
    for (let i = 0; i < packedIds.length; i += 6) {
        ids.push(unpackId(packedIds.substr(i, 6)));
    }
    return ids;
}
/**
 * Packs a coord as a single utf-16 character. The seemingly strange choice of encoding value ((x << 6) | y) + 65 was
 * chosen to be fast to compute (x << 6 | y is significantly faster than 50 * x + y) and to avoid control characters,
 * as "A" starts at character code 65.
 *
 * Benchmarking: average of 150ns to execute on shard2 public server, reduce stringified size by 80%
 */
function packCoord(coord) {
    return String.fromCharCode(((coord.x << 6) | coord.y) + 65);
}
/**
 * Unpacks a coord stored as a single utf-16 character
 *
 * Benchmarking: average of 60ns-100ns to execute on shard2 public server
 */
function unpackCoord(char) {
    const xShiftedSixOrY = char.charCodeAt(0) - 65;
    return {
        x: (xShiftedSixOrY & 0b111111000000) >>> 6,
        y: xShiftedSixOrY & 0b000000111111,
    };
}
/**
 * Unpacks a coordinate and creates a RoomPosition object from a specified roomName
 *
 * Benchmarking: average of 500ns to execute on shard2 public server
 */
function unpackCoordAsPos(packedCoord, roomName) {
    const coord = unpackCoord(packedCoord);
    return new RoomPosition(coord.x, coord.y, roomName);
}
/**
 * Packs a list of coords as a utf-16 string. This is better than having a list of packed coords, as it avoids
 * extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 120ns per coord to execute on shard2 public server, reduce stringified size by 94%
 */
function packCoordList(coords) {
    let str = '';
    for (let i = 0; i < coords.length; ++i) {
        str += String.fromCharCode(((coords[i].x << 6) | coords[i].y) + 65);
    }
    return str;
}
/**
 * Unpacks a list of coords stored as a utf-16 string
 *
 * Benchmarking: average of 100ns per coord to execute on shard2 public server
 */
function unpackCoordList(chars) {
    const coords = [];
    let xShiftedSixOrY;
    for (let i = 0; i < chars.length; ++i) {
        xShiftedSixOrY = chars.charCodeAt(i) - 65;
        coords.push({
            x: (xShiftedSixOrY & 0b111111000000) >>> 6,
            y: xShiftedSixOrY & 0b000000111111,
        });
    }
    return coords;
}
/**
 * Unpacks a list of coordinates and creates a list of RoomPositions from a specified roomName
 *
 * Benchmarking: average of 500ns per coord to execute on shard2 public server
 */
function unpackCoordListAsPosList(packedCoords, roomName) {
    const positions = [];
    let coord;
    for (let i = 0; i < packedCoords.length; ++i) {
        // Each coord is saved as a single character; unpack each and insert the room name to get the positions list
        coord = unpackCoord(packedCoords[i]);
        positions.push(new RoomPosition(coord.x, coord.y, roomName));
    }
    return positions;
}
PERMACACHE._packedRoomNames = PERMACACHE._packedRoomNames || {};
PERMACACHE._unpackedRoomNames = PERMACACHE._unpackedRoomNames || {};
/**
 * Packs a roomName as a single utf-16 character. Character values are stored on permacache.
 */
function packRoomName(roomName) {
    if (PERMACACHE._packedRoomNames[roomName] === undefined) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = Number(match[2]);
        const yDir = match[3];
        const y = Number(match[4]);
        let quadrant;
        if (xDir == 'W') {
            if (yDir == 'N') {
                quadrant = 0;
            } else {
                quadrant = 1;
            }
        } else {
            if (yDir == 'N') {
                quadrant = 2;
            } else {
                quadrant = 3;
            }
        }
        // y is 6 bits, x is 6 bits, quadrant is 2 bits
        const num = ((quadrant << 12) | (x << 6) | y) + 65;
        const char = String.fromCharCode(num);
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._packedRoomNames[roomName];
}
/**
 * Packs a roomName as a single utf-16 character. Character values are stored on permacache.
 */
function unpackRoomName(char) {
    if (PERMACACHE._unpackedRoomNames[char] === undefined) {
        const num = char.charCodeAt(0) - 65;
        const { q, x, y } = {
            q: (num & 0b11000000111111) >>> 12,
            x: (num & 0b00111111000000) >>> 6,
            y: num & 0b00000000111111,
        };
        let roomName;
        switch (q) {
            case 0:
                roomName = 'W' + x + 'N' + y;
                break;
            case 1:
                roomName = 'W' + x + 'S' + y;
                break;
            case 2:
                roomName = 'E' + x + 'N' + y;
                break;
            case 3:
                roomName = 'E' + x + 'S' + y;
                break;
            default:
                roomName = 'ERROR';
        }
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._unpackedRoomNames[char];
}
/**
 * Packs a RoomPosition as a pair utf-16 characters. The seemingly strange choice of encoding value ((x << 6) | y) + 65
 * was chosen to be fast to compute (x << 6 | y is significantly faster than 50 * x + y) and to avoid control
 * characters, as "A" starts at character code 65.
 *
 * Benchmarking: average of 150ns to execute on shard2 public server, reduce stringified size by 90%
 */
function packPos(pos) {
    return packCoord(pos) + packRoomName(pos.roomName);
}
/**
 * Unpacks a RoomPosition stored as a pair of utf-16 characters.
 *
 * Benchmarking: average of 600ns to execute on shard2 public server.
 */
function unpackPos(chars) {
    const { x, y } = unpackCoord(chars[0]);
    return new RoomPosition(x, y, unpackRoomName(chars[1]));
}
/**
 * Packs a list of RoomPositions as a utf-16 string. This is better than having a list of packed RoomPositions, as it
 * avoids extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 150ns per position to execute on shard2 public server, reduce stringified size by 95%
 */
function packPosList(posList) {
    let str = '';
    for (let i = 0; i < posList.length; ++i) {
        str += packPos(posList[i]);
    }
    return str;
}
/**
 * Unpacks a list of RoomPositions stored as a utf-16 string.
 *
 * Benchmarking: average of 1.5us per position to execute on shard2 public server.
 */
function unpackPosList(chars) {
    const posList = [];
    for (let i = 0; i < chars.length; i += 2) {
        posList.push(unpackPos(chars.substr(i, 2)));
    }
    return posList;
}
// Useful to register these functions on global
global.packId = packId;
global.unpackId = unpackId;
global.packIdList = packIdList;
global.unpackIdList = unpackIdList;
global.packCoord = packCoord;
global.unpackCoord = unpackCoord;
global.unpackCoordAsPos = unpackCoordAsPos;
global.packCoordList = packCoordList;
global.unpackCoordList = unpackCoordList;
global.unpackCoordListAsPosList = unpackCoordListAsPosList;
global.packPos = packPos;
global.unpackPos = unpackPos;
global.packPosList = packPosList;
global.unpackPosList = unpackPosList;
class PackratTests {
    static testIdPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting ids...`);
        start = Game.cpu.getUsed();
        const allIds = [];
        for (const name in Game.creeps) {
            const id = Game.creeps[name].id;
            if (!id) {
                console.log(`Game.creeps.${name} has no id: ${id}! wtf`);
            } else {
                allIds.push();
            }
        }
        for (const id in Game.structures) {
            if (!id) {
                console.log(`Game.structures has an undefined id: ${id}! wtf`);
            } else {
                allIds.push(id);
            }
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing id encoding...`);
        start = Game.cpu.getUsed();
        const idsPacked = [];
        for (let i = 0, len = allIds.length; i < len; ++i) {
            idsPacked.push(packId(allIds[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / idsPacked.length}`,
        );
        console.log(
            `Unpacked len: ${JSON.stringify(allIds).length} | Packed len: ${
                JSON.stringify(idsPacked).length
            }`,
        );
        console.log(`Testing listId encoding...`);
        start = Game.cpu.getUsed();
        const idsListPacked = packIdList(allIds);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / (idsListPacked.length / 6)
            }`,
        );
        console.log(`List-packed len: ${JSON.stringify(idsListPacked).length}`);
        console.log(`Testing id decoding...`);
        start = Game.cpu.getUsed();
        const idsUnpacked = [];
        for (let i = 0, len = idsPacked.length; i < len; ++i) {
            idsUnpacked.push(unpackId(idsPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / idsUnpacked.length}`,
        );
        console.log(`Testing id list-decoding...`);
        start = Game.cpu.getUsed();
        const idsListUnpacked = unpackIdList(idsListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / idsListUnpacked.length
            }`,
        );
        console.log(`Verifying equality...`);
        let idsEqual = true;
        for (let i = 0; i < allIds.length; i++) {
            if (idsUnpacked[i] != allIds[i]) {
                console.log(
                    `Unpacked id not equal! orig: ${allIds[i]}; unpacked: ${idsUnpacked[i]}`,
                );
                idsEqual = false;
                break;
            }
            if (idsListUnpacked[i] != allIds[i]) {
                console.log(
                    `Unpacked id not equal! orig: ${allIds[i]}; listUnpacked: ${idsListUnpacked[i]}`,
                );
                idsEqual = false;
                break;
            }
        }
        console.log(`Retrieved ids are equal: ${idsEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testCoordPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allCoord = [];
        for (const name in Game.creeps) {
            const pos = Game.creeps[name].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        for (const id in Game.structures) {
            const pos = Game.structures[id].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing coord encoding...`);
        start = Game.cpu.getUsed();
        const coordPacked = [];
        for (let i = 0, len = allCoord.length; i < len; ++i) {
            coordPacked.push(packCoord(allCoord[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / coordPacked.length}`,
        );
        console.log(`Unpacked len: ${JSON.stringify(allCoord).length}`);
        console.log(`Packed len: ${JSON.stringify(coordPacked).length}`);
        console.log(`Testing listCoord encoding...`);
        start = Game.cpu.getUsed();
        const coordListPacked = packCoordList(allCoord);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / coordListPacked.length
            }`,
        );
        console.log(
            `List-packed len: ${JSON.stringify(coordListPacked).length}`,
        );
        console.log(`Testing coord decoding...`);
        start = Game.cpu.getUsed();
        const coordUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordUnpacked.push(unpackCoord(coordPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / coordUnpacked.length}`,
        );
        console.log(`Testing listCoord decoding...`);
        start = Game.cpu.getUsed();
        const coordListUnpacked = unpackCoordList(coordListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / coordListUnpacked.length
            }`,
        );
        console.log(`Testing coord to pos decoding...`);
        start = Game.cpu.getUsed();
        const coordAsPosUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordAsPosUnpacked.push(unpackCoordAsPos(coordPacked[i], 'W10N10'));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / coordAsPosUnpacked.length
            }`,
        );
        console.log(`Testing listCoord to posList decoding...`);
        start = Game.cpu.getUsed();
        const coordListAsPosListUnpacked = unpackCoordListAsPosList(
            coordListPacked,
            'W10N10',
        );
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / coordListAsPosListUnpacked.length
            }`,
        );
        let posEqual = true;
        for (let i = 0; i < allCoord.length; i++) {
            if (
                !(
                    allCoord[i].x == coordAsPosUnpacked[i].x &&
                    allCoord[i].y == coordAsPosUnpacked[i].y
                )
            ) {
                console.log(
                    `Unpacked pos not equal! orig: ${JSON.stringify(
                        allCoord[i],
                    )}; ` +
                        `unpacked: ${JSON.stringify(coordAsPosUnpacked[i])}`,
                );
                posEqual = false;
                break;
            }
            if (
                !(
                    allCoord[i].x == coordListAsPosListUnpacked[i].x &&
                    allCoord[i].y == coordListAsPosListUnpacked[i].y
                )
            ) {
                console.log(
                    `Unpacked pos not equal! orig: ${JSON.stringify(
                        allCoord[i],
                    )}; ` +
                        `unpacked: ${JSON.stringify(
                            coordListAsPosListUnpacked[i],
                        )}`,
                );
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved coords are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testPosPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allPos = [];
        for (const name in Game.creeps) {
            allPos.push(Game.creeps[name].pos);
        }
        for (const id in Game.structures) {
            allPos.push(Game.structures[id].pos);
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing pos encoding...`);
        start = Game.cpu.getUsed();
        const posPacked = [];
        for (let i = 0, len = allPos.length; i < len; ++i) {
            posPacked.push(packPos(allPos[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / posPacked.length}`,
        );
        console.log(`Unpacked len: ${JSON.stringify(allPos).length}`);
        console.log(`Packed len: ${JSON.stringify(posPacked).length}`);
        console.log(`Testing listPos encoding...`);
        start = Game.cpu.getUsed();
        const posListPacked = packPosList(allPos);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / (posListPacked.length / 2)
            }`,
        );
        console.log(`List-packed len: ${JSON.stringify(posListPacked).length}`);
        console.log(`Testing pos decoding...`);
        start = Game.cpu.getUsed();
        const posUnpacked = [];
        for (let i = 0, len = posPacked.length; i < len; ++i) {
            posUnpacked.push(unpackPos(posPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${elapsed / posUnpacked.length}`,
        );
        console.log(`Testing listPos decoding...`);
        start = Game.cpu.getUsed();
        const posListUnpacked = unpackPosList(posListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(
            `Time elapsed: ${elapsed}; avg: ${
                elapsed / posListUnpacked.length
            }`,
        );
        let posEqual = true;
        for (let i = 0; i < allPos.length; i++) {
            if (!allPos[i].isEqualTo(posUnpacked[i])) {
                console.log(
                    `Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posUnpacked[i]}`,
                );
                posEqual = false;
                break;
            }
            if (!allPos[i].isEqualTo(posListUnpacked[i])) {
                console.log(
                    `Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posListUnpacked[i]}`,
                );
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved pos are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static run() {
        PackratTests.testIdPacker();
        PackratTests.testCoordPacker();
        PackratTests.testPosPacker();
    }
}
global.PackratTests = PackratTests;

/* tslint:disable: max-line-length */
const asciiLogoSmall = [
    '  ___ ___ ._______   _______________',
    ' /   |   \\|   \\   \\ /   /\\_   _____/',
    '/    ~    \\   |\\   Y   /  |    __)_ ',
    '\\    Y    /   | \\     /   |        \\',
    ' \\___|_  /|___|  \\___/   /_______  /',
    '       \\/                        \\/ ',
];
const asciiLogoRL = [
    ' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/',
    '....... R E I N F O R C E M E N T   L E A R N I N G .......',
];
const _logoComponents = {
    black: {
        style: { fill: '#000000', stroke: '#000000', strokeWidth: 0 },
        points: [
            [-4.4, -0.34],
            [-3.44, -1.04],
            [-3.08, -1.04],
            [-2.78, -0.82],
            [-2.7, -0.6],
            [-2.92, -0.24],
            [-3.36, -0.24],
            [-3.58, -0.5],
            [-3.8, -0.28],
            [-4.14, 0.42],
            [-4.22, 1.24],
            [-3.6, 0.42],
            [-2.98, 0.46],
            [-2.84, 0.72],
            [-2.9, 1.02],
            [-3.26, 1.22],
            [-3.68, 1.12],
            [-3.72, 1.22],
            [-3.76, 2.18],
            [-3.58, 2.9],
            [-3.22, 1.8],
            [-2.72, 1.66],
            [-2.4, 2.08],
            [-2.64, 2.44],
            [-3.1, 2.42],
            [-3.1, 2.86],
            [-2.86, 3.4],
            [-2.52, 3.74],
            [-2.58, 3.08],
            [-2.34, 2.86],
            [-1.98, 2.82],
            [-1.48, 3.12],
            [-1.34, 3.72],
            [-1.64, 4.16],
            [-2.08, 4.32],
            [-2.78, 4.24],
            [-3.4, 3.84],
            [-3.02, 4.34],
            [-2.56, 4.6],
            [-0.94, 4.78],
            [4.0e-2, 4.5],
            [0.86, 3.9],
            [-0.44, 3.18],
            [-0.46, 2.86],
            [0.88, 2.84],
            [2.02, 3.2],
            [3.1, 2.22],
            [4.18, 0.6],
            [4.54, -1],
            [3.84, 0],
            [3.5, 0.12],
            [3.18, 2.0e-2],
            [3.14, -0.46],
            [3.38, -0.6],
            [3.82, -0.5],
            [4, -0.94],
            [4.08, -1.88],
            [3.96, -2.6],
            [3.56, -1.54],
            [3.16, -1.22],
            [2.78, -1.28],
            [2.6, -1.6],
            [2.7, -1.88],
            [2.96, -2.02],
            [3.4, -1.92],
            [3.46, -2.12],
            [3.38, -2.98],
            [2.9, -3.98],
            [2.52, -4.32],
            [2.7, -3.58],
            [2.54, -2.82],
            [2.22, -2.38],
            [1.7, -2.36],
            [1.48, -2.64],
            [1.56, -3.1],
            [2.18, -3.24],
            [1.94, -3.9],
            [1.2, -4.62],
            [0.14, -5.14],
            [0.88, -4.18],
            [0.9, -3.54],
            [0.66, -3.04],
            [0.3, -2.82],
            [-0.14, -2.9],
            [-0.2, -3.42],
            [0.28, -3.66],
            [-0.38, -4.16],
            [-1.26, -4.32],
            [-2.4, -4.22],
            [-1.64, -4.02],
            [-1.08, -3.64],
            [-0.82, -3.04],
            [-0.88, -2.56],
            [-1.12, -2.4],
            [-1.5, -2.44],
            [-1.68, -2.7],
            [-1.56, -3.12],
            [-1.84, -3.2],
            [-2.72, -3.16],
            [-3.44, -2.84],
            [-3.98, -2.34],
            [-3.38, -2.5],
            [-2.48, -2.36],
            [-2.12, -2.12],
            [-2.06, -1.7],
            [-2.18, -1.52],
            [-2.56, -1.44],
            [-2.82, -1.6],
            [-2.84, -2.06],
            [-3.38, -1.84],
            [-4.06, -1.18],
            [-4.4, -0.36],
        ],
    },
    blue: {
        style: { fill: '#6482B0', stroke: '#6482B0', strokeWidth: 0 },
        points: [
            [-2.48, -0.72],
            [-1.5, -0.34],
            [-1.18, -0.88],
            [-0.74, -1.24],
            [-6.0e-2, -1.46],
            [0.54, -1.44],
            [0.94, -1.34],
            [1.82, -0.46],
            [2.74, -0.9],
            [2.92, -0.42],
            [3.02, 0.32],
            [2.9, 1.02],
            [2.52, 1.86],
            [1.94, 2.5],
            [1.2, 2.94],
            [0.82, 2.02],
            [1.32, 1.72],
            [1.56, 1.48],
            [1.8, 1.1],
            [1.98, 0.44],
            [1.94, 0],
            [1.8, -0.46],
            [0.94, -1.36],
            [1.34, -2.3],
            [0.5, -2.54],
            [-0.12, -2.54],
            [-0.86, -2.36],
            [-1.38, -2.1],
            [-1.82, -1.76],
            [-2.26, -1.22],
            [-2.48, -0.74],
        ],
    },
    red: {
        style: { fill: '#EA3747', stroke: '#EA3747', strokeWidth: 0 },
        points: [
            [0.94, -1.3],
            [1.28, -1.08],
            [1.58, -0.78],
            [1.78, -0.46],
            [2.7, -0.92],
            [2.72, -1],
            [2.44, -1.46],
            [2.02, -1.9],
            [1.42, -2.28],
            [0.94, -1.32],
        ],
    },
    pink: {
        style: { fill: '#FF0080', stroke: '#FF0080', strokeWidth: 0 },
        points: [
            [-1.4, 0.32],
            [-0.92, 0.2],
            [-0.46, -6.0e-2],
            [-8.0e-2, -0.5],
            [0.12, -0.98],
            [0.14, -1.18],
            [0.2, -1.18],
            [0.22, -0.98],
            [0.4, -0.54],
            [0.8, -6.0e-2],
            [1.26, 0.2],
            [1.74, 0.32],
            [1.62, 0.3],
            [1.62, 0.36],
            [1.26, 0.44],
            [0.78, 0.72],
            [0.38, 1.22],
            [0.18, 1.84],
            [-6.0e-2, 1.18],
            [-0.46, 0.7],
            [-0.92, 0.44],
            [-1.38, 0.34],
        ],
    },
    lgray: {
        style: { fill: '#ABB7C5', stroke: '#ABB7C5', strokeWidth: 0 },
        points: [
            [-2.64, 1.04],
            [-2.34, 1.78],
            [-2.06, 2.18],
            [-1.56, 2.64],
            [-0.98, 2.96],
            [-0.62, 3.08],
            [-0.52, 3.06],
            [-0.28, 2.06],
            [-0.72, 1.88],
            [-1.06, 1.62],
            [-1.36, 1.26],
            [-1.58, 0.76],
            [-2.56, 0.94],
            [-2.64, 1.02],
        ],
    },
    purple: {
        style: { fill: '#2F0092', stroke: '#2F0092', strokeWidth: 0 },
        points: [
            [-1.48, 0.4],
            [-1.38, -0.24],
            [-1.04, -0.8],
            [-0.46, -1.2],
            [0.22, -1.32],
            [0.14, -1.24],
            [0.1, -0.94],
            [-8.0e-2, -0.52],
            [-0.42, -0.1],
            [-0.84, 0.16],
            [-1.4, 0.3],
            [-0.94, 0.44],
            [-0.34, 0.82],
            [4.0e-2, 1.4],
            [0.18, 1.88],
            [0.32, 1.36],
            [0.72, 0.78],
            [1.28, 0.44],
            [1.74, 0.34],
            [1.06, 0.1],
            [0.6, -0.26],
            [0.24, -0.94],
            [0.2, -1.24],
            [0.28, -1.32],
            [0.74, -1.22],
            [1.18, -0.98],
            [1.46, -0.7],
            [1.72, -0.24],
            [1.82, 0.26],
            [1.78, 0.68],
            [1.6, 1.14],
            [1.28, 1.54],
            [0.84, 1.82],
            [0.46, 1.94],
            [0.18, 1.98],
            [-0.46, 1.84],
            [-0.82, 1.64],
            [-1.22, 1.2],
            [-1.4, 0.82],
            [-1.46, 0.4],
        ],
    },
    dgray: {
        style: { fill: '#303030', stroke: '#303030', strokeWidth: 0 },
        points: [
            [-2.42, 0.52],
            [-2.4, -8.0e-2],
            [-2.28, -0.56],
            [-1.52, -0.3],
            [-1.62, 0.24],
            [-1.58, 0.7],
            [-0.2, 2.06],
            [0.34, 2.1],
            [0.8, 2.02],
            [1.06, 2.7],
            [1.04, 2.78],
            [0.54, 2.92],
            [6.0e-2, 2.94],
            [-0.42, 2.86],
            [-0.22, 2.06],
            [-0.26, 2.08],
            [-1.6, 0.7],
            [-2.36, 0.86],
            [-2.4, 0.52],
        ],
    },
};
const _logoText = {
    V: {
        coords: [75, 500],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-3.94, -3.7],
            [-3.72, -3.86],
            [-3.58, -3.68],
            [-1, 2.54],
            [-0.62, 2.9],
            [-0.16, 2.96],
            [0.46, 2.6],
            [3.1, -3.72],
            [3.38, -3.82],
            [3.4, -3.56],
            [0.86, 2.52],
            [0.48, 3.04],
            [0, 3.26],
            [-0.66, 3.22],
            [-1.26, 2.72],
            [-3.92, -3.68],
        ],
    },
    E: {
        coords: [500, 880],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.28, 0.52],
            [-4.1, 1.3],
            [-3.7, 2.04],
            [-3.12, 2.64],
            [-2.4, 3.06],
            [-1.64, 3.26],
            [1.4, 3.2],
            [1.4, 3],
            [1.16, 2.9],
            [-1.5, 2.92],
            [-2.2, 2.76],
            [-3.14, 2.16],
            [-3.76, 1.2],
            [-3.92, 0.52],
            [-3.84, -0.12],
            [0.84, -0.12],
            [0.96, -0.24],
            [0.78, -0.48],
            [-3.9, -0.48],
            [-3.92, -1.12],
            [-3.7, -1.94],
            [-3.26, -2.62],
            [-2.6, -3.16],
            [-1.46, -3.52],
            [1.38, -3.56],
            [1.4, -3.8],
            [1.2, -3.88],
            [-1.42, -3.88],
            [-2.82, -3.44],
            [-3.88, -2.36],
            [-4.28, -1.12],
            [-4.26, 0.52],
        ],
    },
    R1: {
        coords: [850, 1000],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.36, 3.1],
            [-4.36, -2.56],
            [-4.26, -2.96],
            [-3.82, -3.56],
            [-3.38, -3.8],
            [-1.88, -3.88],
            [-1.78, -3.5],
            [-3.2, -3.48],
            [-3.58, -3.3],
            [-3.88, -2.94],
            [-4, -2.54],
            [-4, 0.3],
            [-1.78, 0.36],
            [-1.9, 0.38],
            [-1.96, 0.72],
            [-1.78, 0.74],
            [-3.98, 0.74],
            [-3.98, 3.06],
            [-4.1, 3.26],
            [-4.3, 3.24],
            [-4.34, 3.1],
        ],
    },
    R2: {
        coords: [1000, 1200],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.78, 0.74],
            [-4.78, 0.36],
            [-3.1, 0.36],
            [-2.22, -2.0e-2],
            [-1.62, -0.78],
            [-1.46, -1.78],
            [-1.74, -2.58],
            [-2.38, -3.22],
            [-3.28, -3.52],
            [-4.78, -3.5],
            [-4.7, -3.86],
            [-4.78, -3.88],
            [-3.12, -3.86],
            [-2.12, -3.48],
            [-1.62, -3.02],
            [-1.26, -2.42],
            [-1.1, -1.78],
            [-1.2, -0.88],
            [-1.56, -0.18],
            [-2.04, 0.3],
            [-2.64, 0.62],
            [-3.4, 0.8],
            [-1.22, 2.96],
            [-1.22, 3.24],
            [-1.44, 3.26],
            [-3.94, 0.74],
            [-4.76, 0.72],
        ],
    },
    M: {
        coords: [1200, 1799],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-3.82, 3.14],
            [-3.6, 3.28],
            [-3.48, 3.08],
            [-2.52, -3.48],
            [-2.26, -3.52],
            [-2.1, -3.34],
            [0.28, 3.04],
            [0.56, 3.26],
            [0.9, 3.28],
            [1.3, 2.92],
            [3.62, -3.34],
            [3.88, -3.54],
            [4.14, -3.3],
            [5.02, 3.16],
            [5.28, 3.26],
            [4.44, -3.4],
            [4.28, -3.7],
            [3.98, -3.84],
            [3.56, -3.76],
            [3.34, -3.48],
            [1.02, 2.78],
            [0.78, 2.98],
            [0.52, 2.82],
            [-1.88, -3.6],
            [-2.24, -3.84],
            [-2.78, -3.68],
            [-3.8, 3.12],
        ],
    },
    I: {
        coords: [1750, 1850],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.58, 3.1],
            [-4.32, 3.26],
            [-4.2, 3.06],
            [-4.2, -3.66],
            [-4.46, -3.86],
            [-4.58, -3.7],
            [-4.56, 3.1],
        ],
    },
    N: {
        coords: [1850, 2250],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.46, 3.16],
            [-4.46, -3.4],
            [-4.34, -3.66],
            [-3.88, -3.88],
            [-3.4, -3.64],
            [1.52, 2.74],
            [1.84, 2.96],
            [2.12, 2.64],
            [2.12, -3.76],
            [2.36, -3.82],
            [2.42, 2.8],
            [2.28, 3.08],
            [1.66, 3.26],
            [1.38, 3.08],
            [-3.62, -3.4],
            [-3.96, -3.54],
            [-4.16, -3.28],
            [-4.16, 3.16],
            [-4.44, 3.18],
        ],
    },
    D: {
        coords: [2250, 2700],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [
            [-4.12, 1.82],
            [-3.76, 2.78],
            [-2.8, 3.28],
            [-0.36, 3.24],
            [0.3, 3.04],
            [1.14, 2.5],
            [1.78, 1.68],
            [2.08, 0.84],
            [2.04, -1.6],
            [1.68, -2.44],
            [1.06, -3.16],
            [0.28, -3.64],
            [-0.56, -3.86],
            [-2.88, -3.86],
            [-3, -3.82],
            [-2.92, -3.48],
            [-0.32, -3.46],
            [0.52, -3.12],
            [1.2, -2.52],
            [1.6, -1.84],
            [1.78, -1.1],
            [1.78, 0.54],
            [1.38, 1.68],
            [0.68, 2.42],
            [-0.38, 2.88],
            [-2.78, 2.92],
            [-3.5, 2.54],
            [-3.74, 1.98],
            [-3.74, -2.58],
            [-3.46, -3.18],
            [-2.94, -3.48],
            [-3.06, -3.82],
            [-3.72, -3.42],
            [-4.08, -2.72],
            [-4.1, 1.8],
        ],
    },
};
const logoX = 2.5; // x-position of logo
const logoY = 3.0; // y position of logo
const logoScale = 0.6;
const logoComponents = _.mapValues(_logoComponents, (c) => ({
    style: c.style,
    points: _.map(c.points, (xy) => [
        logoX + logoScale * xy[0],
        logoY + logoScale * xy[1],
    ]),
}));
const textX = logoX + 5.6 * logoScale; // x-position of logo
const textY = logoY + 0.5 * logoScale; // y position of logo
const textScale = 0.6 * logoScale;
const charScale = 0.052 * textScale;
let offset = 0;
const logoText = _.mapValues(_logoText, function (c) {
    const ret = {
        style: c.style,
        points: _.map(c.points, (xy) => [
            textX + textScale * (offset + xy[0]),
            textY + textScale * xy[1],
        ]),
    };
    offset += charScale * (c.coords[1] - c.coords[0]);
    return ret;
});

var Visualizer_1;
const TEXT_COLOR = '#c9c9c9';
const TEXT_SIZE = 0.8;
const CHAR_WIDTH = TEXT_SIZE * 0.4;
const CHAR_HEIGHT = TEXT_SIZE * 0.9;
/**
 * The Visualizer contains many static methods for drawing room visuals and displaying information through a GUI
 */
let Visualizer = (Visualizer_1 = class Visualizer {
    static get enabled() {
        return Memory.settings.enableVisuals;
    }
    static textStyle(size = 1, style = {}) {
        return _.defaults(style, {
            color: TEXT_COLOR,
            align: 'left',
            font: `${size * TEXT_SIZE} Trebuchet MS`,
            opacity: 0.8,
        });
    }
    static circle(pos, color = 'red', opts = {}) {
        _.defaults(opts, {
            fill: color,
            radius: 0.35,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).circle(pos.x, pos.y, opts);
    }
    static rect(pos, color = 'red', opts = {}) {
        _.defaults(opts, {
            fill: color,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).rect(pos.x, pos.y, 1, 1, opts);
    }
    static marker(pos, opts = {}) {
        return new RoomVisual(pos.roomName).animatedPosition(
            pos.x,
            pos.y,
            opts,
        );
    }
    static annotate(text, pos, roomName) {
        const location = {
            x: pos.x,
            y: pos.y,
            roomName: pos.roomName || roomName,
        };
        Visualizer_1.text(text, location, 0.6, {
            color: 'white',
            backgroundColor: 'black',
        });
    }
    static drawStructureMap(structureMap) {
        if (!this.enabled) return;
        const vis = {};
        for (const structureType in structureMap) {
            for (const pos of structureMap[structureType]) {
                if (!vis[pos.roomName]) {
                    vis[pos.roomName] = new RoomVisual(pos.roomName);
                }
                vis[pos.roomName].structure(pos.x, pos.y, structureType);
            }
        }
        for (const roomName in vis) {
            vis[roomName].connectRoads();
        }
    }
    static drawLayout(layout, anchor, opts = {}) {
        if (!this.enabled) return;
        _.defaults(opts, { opacity: 0.5 });
        const vis = new RoomVisual(anchor.roomName);
        for (const structureType in layout[8].buildings) {
            for (const pos of layout[8].buildings[structureType].pos) {
                const dx = pos.x - layout.data.anchor.x;
                const dy = pos.y - layout.data.anchor.y;
                vis.structure(
                    anchor.x + dx,
                    anchor.y + dy,
                    structureType,
                    opts,
                );
            }
        }
        vis.connectRoads(opts);
    }
    static drawRoads(positoins) {
        const pointsByRoom = _.groupBy(positoins, (pos) => pos.roomName);
        for (const roomName in pointsByRoom) {
            const vis = new RoomVisual(roomName);
            for (const pos of pointsByRoom[roomName]) {
                vis.structure(pos.x, pos.y, STRUCTURE_ROAD);
            }
            vis.connectRoads();
        }
    }
    static drawPath(path, style) {
        const pointsByRoom = _.groupBy(path, (pos) => pos.roomName);
        for (const roomName in pointsByRoom) {
            new RoomVisual(roomName).poly(pointsByRoom[roomName], style);
        }
    }
    static displayCostMatrix(
        matrix,
        roomName,
        opts = { dots: true, displayZero: true },
    ) {
        opts = _.defaults(opts, { dots: true, displayZero: true });
        const vis = new RoomVisual(roomName);
        let x, y, cost, percentOfMax;
        let color;
        const maxVal = MatrixLib.getMaxValue(matrix) + 1;
        if (opts.dots) {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (cost > 0) {
                        percentOfMax = Math.round((255 * cost) / maxVal);
                        color = rgbToHex(
                            255,
                            255 - percentOfMax,
                            255 - percentOfMax,
                        );
                        vis.circle(x, y, {
                            radius: matrix.get(x, y) / maxVal / 2,
                            fill: color,
                        });
                    }
                }
            }
        } else {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (opts.displayZero || cost != 0) {
                        percentOfMax = Math.round((255 * cost) / maxVal);
                        color = rgbToHex(
                            255,
                            255 - percentOfMax,
                            255 - percentOfMax,
                        );
                        vis.text(matrix.get(x, y).toString(), x, y + 0.25, {
                            color: color,
                        });
                    }
                }
            }
        }
    }
    static showInfo(info, calledFrom, opts = {}) {
        if (calledFrom.room) {
            return calledFrom.room.visual.infoBox(
                info,
                calledFrom.pos.x,
                calledFrom.pos.y,
                opts,
            );
        } else {
            return new RoomVisual(calledFrom.pos.roomName).infoBox(
                info,
                calledFrom.pos.x,
                calledFrom.pos.y,
                opts,
            );
        }
    }
    static section(title, pos, width, height) {
        const vis = new RoomVisual(pos.roomName);
        vis.rect(pos.x, pos.y - CHAR_HEIGHT, width, 1.1 * CHAR_HEIGHT, {
            opacity: 0.15,
        });
        vis.box(
            pos.x,
            pos.y - CHAR_HEIGHT,
            width,
            height + (1.1 + 0.25) * CHAR_HEIGHT,
            { color: TEXT_COLOR },
        );
        vis.text(title, pos.x + 0.25, pos.y - 0.05, this.textStyle());
        return { x: pos.x + 0.25, y: pos.y + 1.1 * CHAR_HEIGHT };
    }
    static infoBox(header, content, pos, width) {
        // const vis = new RoomVisual(pos.roomName);
        // vis.rect(pos.x, pos.y - charHeight, width, 1.1 * charHeight, {opacity: 0.15});
        // vis.box(pos.x, pos.y - charHeight, width, ((content.length || 1) + 1.1 + .25) * charHeight,
        // 		{color: textColor});
        // vis.text(header, pos.x + .25, pos.y - .05, this.textStyle());
        const height = CHAR_HEIGHT * (content.length || 1);
        const { x, y } = this.section(header, pos, width, height);
        if (content.length > 0) {
            if (_.isArray(content[0])) {
                this.table(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName,
                });
            } else {
                this.multitext(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName,
                });
            }
        }
        // return pos.y - charHeight + ((content.length || 1) + 1.1 + .25) * charHeight + 0.1;
        const spaceBuffer = 0.5;
        return y + height + spaceBuffer;
    }
    static text(text, pos, size = 1, style = {}) {
        new RoomVisual(pos.roomName).text(
            text,
            pos.x,
            pos.y,
            this.textStyle(size, style),
        );
    }
    static barGraph(progress, pos, width = 7, scale = 1) {
        const vis = new RoomVisual(pos.roomName);
        let percent;
        let mode;
        if (typeof progress === 'number') {
            percent = progress;
            mode = 'percent';
        } else {
            percent = progress[0] / progress[1];
            mode = 'fraction';
        }
        // Draw frame
        vis.box(
            pos.x,
            pos.y - CHAR_HEIGHT * scale,
            width,
            1.1 * scale * CHAR_HEIGHT,
            { color: TEXT_COLOR },
        );
        vis.rect(
            pos.x,
            pos.y - CHAR_HEIGHT * scale,
            percent * width,
            1.1 * scale * CHAR_HEIGHT,
            {
                fill: TEXT_COLOR,
                opacity: 0.4,
                strokeWidth: 0,
            },
        );
        // Draw text
        if (mode == 'percent') {
            vis.text(
                `${Math.round(100 * percent)}%`,
                pos.x + width / 2,
                pos.y - 0.1 * CHAR_HEIGHT,
                this.textStyle(1, { align: 'center' }),
            );
        } else {
            const [num, den] = progress;
            vis.text(
                `${num}/${den}`,
                pos.x + width / 2,
                pos.y - 0.1 * CHAR_HEIGHT,
                this.textStyle(1, { align: 'center' }),
            );
        }
    }
    static table(data, pos) {
        if (data.length == 0) {
            return;
        }
        const colPadding = 4;
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Determine column locations
        const columns = Array(_.first(data).length).fill(0);
        for (const entries of data) {
            for (let i = 0; i < entries.length - 1; i++) {
                columns[i] = Math.max(columns[i], entries[i].length);
            }
        }
        // // Draw header and underline
        // vis.text(header, pos.x, pos.y, style);
        // vis.line(pos.x, pos.y + .3 * charHeight,
        // 	pos.x + charWidth * _.sum(columns) + colPadding * columns.length, pos.y + .25 * charHeight, {
        // 			 color: textColor
        // 		 });
        // Draw text
        // let dy = 1.5 * charHeight;
        let dy = 0;
        for (const entries of data) {
            let dx = 0;
            for (const i in entries) {
                vis.text(entries[i], pos.x + dx, pos.y + dy, style);
                dx += CHAR_WIDTH * (columns[i] + colPadding);
            }
            dy += CHAR_HEIGHT;
        }
    }
    static multitext(lines, pos) {
        if (lines.length == 0) {
            return;
        }
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Draw text
        let dy = 0;
        for (const line of lines) {
            vis.text(line, pos.x, pos.y + dy, style);
            dy += CHAR_HEIGHT;
        }
    }
    static drawHUD() {
        // Draw Overmind logo
        //new RoomVisual().multitext(asciiLogoSmall, 0, 0, {
        //    textfont: 'monospace',
        //});
        // // Display CPU Information
        // new RoomVisual().text('CPU:' + ' bucket:' + Game.cpu.bucket +
        // 					  ' tickLimit:' + Game.cpu.tickLimit, column, row, style);
    }
    /* Draws the Overmind logo using component coordinates extracted with Mathematica. This  uses about 0.2 CPU/tick */
    static drawLogo() {
        /*
        new RoomVisual().poly(logoComponents.black.points, logoComponents.black.style)
                        .poly(logoComponents.dgray.points, logoComponents.dgray.style)
                        .poly(logoComponents.lgray.points, logoComponents.lgray.style)
                        .poly(logoComponents.blue.points, logoComponents.blue.style)
                        .poly(logoComponents.red.points, logoComponents.red.style)
                        .poly(logoComponents.purple.points, logoComponents.purple.style)
                        .poly(logoComponents.pink.points, logoComponents.pink.style)
                        .poly(logoText.V.points, logoText.V.style)
                        .poly(logoText.E.points, logoText.E.style)
                        .poly(logoText.R1.points, logoText.R1.style)
                        .poly(logoText.R2.points, logoText.R2.style)
                        .poly(logoText.M.points, logoText.M.style)
                        .poly(logoText.I.points, logoText.I.style)
                        .poly(logoText.N.points, logoText.N.style)
                        .poly(logoText.D.points, logoText.D.style);
        */
        Visualizer_1.text(
            `Colonies: ${_.keys(Overmind.colonies).length} | Creeps: ${
                _.keys(Game.creeps).length
            }`,
            { x: 1, y: 10 },
            0.93,
        );
    }
    static drawNotifications(notificationMessages) {
        // const vis = new RoomVisual();
        const x = 10.5;
        const y = 4;
        if (notificationMessages.length == 0) {
            notificationMessages = ['No notifications'];
        }
        const maxStringLength = _.max(
            _.map(notificationMessages, (msg) => msg.length),
        );
        const width = Math.max(11, 1.2 * CHAR_WIDTH * maxStringLength);
        this.infoBox('Notifications', notificationMessages, { x, y }, width);
    }
    // static colonyReport(colonyName: string, text: string[]) {
    // 	if (!this.enabled) return;
    // 	new RoomVisual(colonyName).multitext(text, 0, 4, {textfont: 'monospace', textsize: 0.75});
    // }
    static drawGraphs() {
        this.text(`CPU`, { x: 1, y: 4 });
        this.barGraph(Memory.stats.persistent.avgCPU / Game.cpu.limit, {
            x: 2.75,
            y: 4,
        });
        this.text(`BKT`, { x: 1, y: 5 });
        this.barGraph(Game.cpu.bucket / 10000, { x: 2.75, y: 5 });
        this.text(`GCL`, { x: 1, y: 6 });
        this.barGraph(Game.gcl.progress / Game.gcl.progressTotal, {
            x: 2.75,
            y: 6,
        });
    }
    // This typically takes about 0.3-0.6 CPU in total
    static visuals() {
        this.drawHUD();
        this.drawGraphs();
        // this.drawNotifications();
    }
});
Visualizer = Visualizer_1 = __decorate([profile], Visualizer);

/* tslint:disable:no-bitwise prefer-for-of */
var MatrixLib_1;
const getDefaultMatrixOptions = () => ({
    roomName: 'none',
    roomVisibile: false,
    explicitTerrainCosts: false,
    terrainCosts: {
        plainCost: 1,
        swampCost: 5,
    },
    roadCost: 'auto',
    blockExits: false,
    avoidSK: true,
    allowPortals: false,
    ignoreStructures: false,
    obstacles: '',
    swarmWidth: 1,
    swarmHeight: 1,
});
PERMACACHE.terrainMatrices = PERMACACHE.terrainMatrices || {};
PERMACACHE.blockedExitsMatrices = PERMACACHE.blockedExitsMatrices || {}; // zGeneral 1/10/2023

const MatrixCache = {};
/**
 * MatrixLib contains an assortment of CostMatrix-related manipulation functions. I use C-style loops in most of this
 * library because even though they are ugly af, they are significantly (~20x!) faster than _.forEach or
 * for (const thing of things) { } loops.
 */
let MatrixLib = (MatrixLib_1 = class MatrixLib {
    static getMatrix(roomName, opts, volatileOpts = {}) {
        // Copy the opts objects because we don't want to back-modify it
        opts = _.defaults(_.cloneDeep(opts), getDefaultMatrixOptions());
        volatileOpts = _.cloneDeep(volatileOpts);
        // Populate roomName and roomVisible properties
        const room = Game.rooms[roomName];
        opts.roomName = roomName;
        opts.roomVisibile = !!room;
        // Generate a hash to look up any previously cached matrices
        const hash = MatrixLib_1.generateMatrixOptionsHash(opts);
        // Volatile hash gets added to hash; if no volatile options are specified; use empty string to not change hash
        const volatileHash = _.isEmpty(volatileOpts)
            ? ''
            : MatrixLib_1.generateMatrixOptionsHash(volatileOpts);
        // If you have previously cached this matrix with volatile properties and it's still valid, return that
        // If no volatile opts are specified; the method will usually return from this block of code
        if (MatrixCache[hash + volatileHash]) {
            const expiration =
                MatrixCache[hash + volatileHash].expiration || Infinity;
            const invalidateCondition =
                MatrixCache[hash + volatileHash].invalidateCondition ||
                (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash + volatileHash];
            } else {
                return MatrixCache[hash + volatileHash].matrix;
            }
        }
        let matrix;
        let expiration;
        let invalidateCondition;
        // If you've previously cached a matrix with the same non-volatile opts; start from there and then modify it
        if (MatrixCache[hash]) {
            expiration = MatrixCache[hash].expiration || Infinity;
            invalidateCondition =
                MatrixCache[hash].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash];
                matrix = undefined;
            } else {
                matrix = MatrixCache[hash].matrix;
            }
        }
        // Otherwise we'll build a base matrix for the non-volatile options, cache it, then modify it for volatile opts
        if (matrix === undefined) {
            if (room) {
                matrix = MatrixLib_1.generateCostMatrixForRoom(room, opts);
                const roomOwner = RoomIntel.roomOwnedBy(roomName);
                if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
                    expiration = Game.time + 10;
                } else if (roomOwner && !isAlly(roomOwner)) {
                    expiration = Game.time + 25;
                } else {
                    expiration = Game.time + 100;
                }
                if (opts.ignoreStructures) {
                    invalidateCondition = () => false;
                } else {
                    // Invalidate the path if the number of structures in the room changes
                    const numStructures = room.structures.length;
                    invalidateCondition = () =>
                        Game.rooms[roomName] &&
                        Game.rooms[roomName].structures.length != numStructures;
                }
            } else {
                matrix = MatrixLib_1.generateCostMatrixForInvisibleRoom(
                    roomName,
                    opts,
                );
                const roomOwner = RoomIntel.roomOwnedBy(roomName);
                if (roomOwner && !isAlly(roomOwner)) {
                    expiration = Game.time + 100;
                } else {
                    expiration = Game.time + 1000;
                }
                invalidateCondition = () => false;
            }
            // Cache the results for the non-volatile options
            MatrixCache[hash] = {
                matrix: matrix,
                generated: Game.time,
                expiration: expiration,
                invalidateCondition: invalidateCondition,
            };
        }
        // If there's no modifications we need to make, we're done, so return the matrix
        if (_.isEmpty(volatileOpts)) {
            return MatrixCache[hash].matrix;
        }
        // Otherwise, clone the matrix and apply volatile modifications, then cache it for this tick
        const clonedMatrix = matrix.clone();
        MatrixLib_1.applyVolatileModifications(
            clonedMatrix,
            opts,
            volatileOpts,
        );
        // Cache the results for the non-volatile options
        MatrixCache[hash + volatileHash] = {
            matrix: clonedMatrix,
            generated: Game.time,
            expiration: Game.time + 1,
            invalidateCondition: () => false,
        };
        return MatrixCache[hash + volatileHash].matrix;
    }
    /**
     * Generate a deterministic string hash that you can store a costmatrix with
     */
    static generateMatrixOptionsHash(opts) {
        return JSON.stringify(opts, Object.keys(opts).sort());
    }
    /**
     * Applies modificaitons to account for volatile options. Make sure to clone the matrix before passing it to this!
     */
    static applyVolatileModifications(clonedMatrix, opts, volatileOpts) {
        const room = Game.rooms[opts.roomName];
        // Block creep positions
        if (volatileOpts.blockCreeps) {
            if (room) {
                if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
                    MatrixLib_1.blockAfterMaxPooling(
                        clonedMatrix,
                        room.find(FIND_CREEPS),
                        opts.swarmWidth,
                        opts.swarmHeight,
                    );
                } else {
                    // use soft-block to avoid creeps but not result in unpathable errors
                    MatrixLib_1.softBlock(
                        clonedMatrix,
                        room.find(FIND_CREEPS),
                        opts.roomName,
                        100,
                    );
                }
            }
        }
        return clonedMatrix;
    }
    /**
     * Generates a cost matrix for a visible room based on the fully-specified matrix options
     */
    static generateCostMatrixForRoom(room, opts) {
        const matrix = new PathFinder.CostMatrix();
        // Explicitly specify the terrain costs if needed
        if (opts.explicitTerrainCosts) {
            MatrixLib_1.addTerrainCosts(matrix, room.name, opts.terrainCosts);
        }
        // Set road costs, usually to plainCost / 2
        if (opts.roadCost != 'ignore') {
            if (opts.roadCost == 'auto') {
                opts.roadCost = Math.ceil(opts.terrainCosts.plainCost / 2);
            }
            for (const road of room.roads) {
                matrix.set(road.pos.x, road.pos.y, opts.roadCost);
            }
        }
        // Mark the exits as unpathable
        if (opts.blockExits) {
            MatrixLib_1.blockExits(room.name, matrix);
        }
        // Avoid source keepers
        if (
            opts.avoidSK &&
            Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER
        ) {
            // Skip this step if we've been harvesting from the room for a while
            const skDirective = _.find(
                Overmind.overseer.getDirectivesInRoom(room.name),
                (dir) => dir.directiveName == 'outpostSK',
            ); // had to do this ungly thing due to circular dependency problems :(
            // const skDirective = _.first(DirectiveSKOutpost.findInRoom(roomName));
            if (!(skDirective && skDirective.age > 2500)) {
                const keeperLairInfo = RoomIntel.getKeeperLairInfo(room.name);
                const chillPositions = _.compact(
                    _.map(keeperLairInfo || [], (info) => info.chillPos),
                );
                const blockPositions = [
                    ..._.map(room.sourceKeepers, (keeper) => keeper.pos),
                    ..._.map(
                        room.keeperLairs.filter(
                            (lair) => (lair.ticksToSpawn || Infinity) < 100,
                        ),
                        (lair) => lair.pos,
                    ),
                    ...chillPositions,
                ];
                MatrixLib_1.blockWithinRange(matrix, blockPositions, 3);
            }
        }
        // Block or soft-block portals
        if (opts.allowPortals) {
            MatrixLib_1.softBlock(
                matrix,
                room.portals,
                room.name,
                MatrixLib_1.settings.portalCost,
            );
        } else {
            MatrixLib_1.block(matrix, room.portals);
        }
        // Block structure positions
        if (!opts.ignoreStructures) {
            const impassibleStructures = _.filter(
                room.structures,
                (s) => !s.isWalkable,
            );
            const impassibleConstructionSites = _.filter(
                room.constructionSites,
                (c) => !c.isWalkable,
            );
            const alliedConstructionSites = _.filter(
                room.hostileConstructionSites,
                (c) => isAlly(c.owner.username),
            );
            const blockPositions = _.map(
                [
                    ...impassibleStructures,
                    ...impassibleConstructionSites,
                    ...alliedConstructionSites,
                ],
                (s) => s.pos,
            );
            MatrixLib_1.block(matrix, blockPositions);
        }
        // Block any other obstacles that might be specified
        if (opts.obstacles.length > 0) {
            const obstacles = _.filter(
                unpackPosList(opts.obstacles),
                (pos) => pos.roomName == room.name,
            );
            MatrixLib_1.block(matrix, obstacles);
        }
        // Finally, as the very last step, we apply a smear to account for swarm size if greater than 1x1
        if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
            if (!opts.explicitTerrainCosts) {
                log.error(
                    `Swarm matrix generation requires opts.explicitTerrainCosts! opts: ${JSON.stringify(
                        opts,
                    )}`,
                );
            }
            MatrixLib_1.applyMovingMaxPool(
                matrix,
                opts.swarmWidth,
                opts.swarmHeight,
            );
        }
        // Tada!
        return matrix;
    }
    /**
     * Generates a cost matrix for an invisible room based on the fully-specified matrix options
     */
    static generateCostMatrixForInvisibleRoom(roomName, opts) {
        const matrix = new PathFinder.CostMatrix();
        // Explicitly specify the terrain costs if needed
        if (opts.explicitTerrainCosts) {
            MatrixLib_1.addTerrainCosts(matrix, roomName, opts.terrainCosts);
        }
        // Set road costs, usually to plainCost / 2
        if (opts.roadCost !== undefined);
        // Mark the exits as unpathable
        if (opts.blockExits) {
            MatrixLib_1.blockExits(roomName, matrix);
        }
        // Avoid source keepers
        if (
            opts.avoidSK &&
            Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER
        ) {
            // Skip this step if we've been harvesting from the room for a while
            const skDirective = _.find(
                Overmind.overseer.getDirectivesInRoom(roomName),
                (dir) => dir.directiveName == 'outpostSK',
            ); // had to do this ungly thing due to circular dependency problems :(
            // const skDirective = _.first(DirectiveSKOutpost.findInRoom(roomName));
            if (!(skDirective && skDirective.age > 2500)) {
                const keeperLairInfo = RoomIntel.getKeeperLairInfo(roomName);
                const chillPositions = _.compact(
                    _.map(keeperLairInfo || [], (info) => info.chillPos),
                );
                MatrixLib_1.blockWithinRange(matrix, chillPositions, 3);
            }
        }
        // Block or soft-block portals
        const portalPositions = _.map(
            RoomIntel.getPortalInfo(roomName),
            (portalInfo) => portalInfo.pos,
        );
        if (opts.allowPortals) {
            MatrixLib_1.softBlock(
                matrix,
                portalPositions,
                roomName,
                MatrixLib_1.settings.portalCost,
            );
        } else {
            MatrixLib_1.block(matrix, portalPositions);
        }
        // Block positions of structures you remember
        if (!opts.ignoreStructures) {
            const owner = RoomIntel.roomOwnedBy(roomName) || '_noOwner_';
            const info = RoomIntel.getImportantStructureInfo(roomName);
            if (info) {
                if (!isAlly(owner)) {
                    MatrixLib_1.block(matrix, info.rampartPositions);
                }
                MatrixLib_1.block(matrix, info.wallPositions);
                MatrixLib_1.block(matrix, info.towerPositions);
                MatrixLib_1.block(matrix, info.spawnPositions);
                if (info.storagePos)
                    MatrixLib_1.block(matrix, [info.storagePos]);
                if (info.terminalPos) {
                    MatrixLib_1.block(matrix, [info.terminalPos]);
                }
            }
        }
        // Block any other obstacles that might be specified
        if (opts.obstacles.length > 0) {
            const obstacles = _.filter(
                unpackPosList(opts.obstacles),
                (pos) => pos.roomName == roomName,
            );
            MatrixLib_1.block(matrix, obstacles);
        }
        // Finally, as the very last step, we apply a smear to account for swarm size if greater than 1x1
        if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
            if (!opts.explicitTerrainCosts) {
                log.error(
                    `Swarm matrix generation requires opts.explicitTerrainCosts! opts: ${JSON.stringify(
                        opts,
                    )}`,
                );
            }
            MatrixLib_1.applyMovingMaxPool(
                matrix,
                opts.swarmWidth,
                opts.swarmHeight,
            );
        }
        // Tada!
        return matrix;
    }
    /**
     * Adds two matrices in-place on the first matrix. This method modifies the first matrix and does not modify the
     * second matrix. This method accesses the non-api CostMatrix._bits property so it may break in the future if they
     * modify the mechanics of cost matrices. See this file for details:
     * https://github.com/screeps/engine/blob/master/src/game/path-finder.js
     */
    static addMatrices(matrixToModify, addCosts) {
        for (let i = 0; i < 2500; i++) {
            matrixToModify._bits[i] = Math.min(
                Math.max(0, matrixToModify._bits[i] + addCosts._bits[i]),
                255,
            );
        }
        return matrixToModify;
    }
    /**
     * Quickly fills an entire matrix with a value. This method accesses the non-api CostMatrix._bits property so
     * it may break in the future if they modify the mechanics of cost matrices. See this file for details:
     * https://github.com/screeps/engine/blob/master/src/game/path-finder.js
     */
    static fillMatrix(matrixToModify, value) {
        value = Math.min(Math.max(0, value), 255);
        matrixToModify._bits.fill(value);
        return matrixToModify;
    }
    /**
     * Blocks all specified positions, setting their cost to 0xff
     */
    static block(matrix, positions) {
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            matrix.set(pos.x, pos.y, 0xff);
        }
        return matrix;
    }
    /**
     * Sets the cost of all positions to a value if walls are not present and if the value is above the current value
     */
    static softBlock(matrix, positions, roomName, cost) {
        let pos;
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL) continue;
            matrix.set(pos.x, pos.y, Math.max(cost, matrix.get(pos.x, pos.y)));
        }
        return matrix;
    }
    /**
     * Blocks all squares within a range (inclusive) of a list of positions, setting their cost to 0xff
     */
    static blockWithinRange(matrix, positions, range) {
        let x, y;
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = positions[i];
            for (let dx = -range; dx <= range; dx++) {
                x = pos.x + dx;
                if (x < 0 || x > 49) continue;
                for (let dy = -range; dy <= range; dy++) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) continue;
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    /**
     * Sets impassible structure positions to 0xff
     */
    static blockImpassibleStructures(matrix, room) {
        const impassibleStuctures = _.filter(
            room.find(FIND_STRUCTURES),
            (s) => !s.isWalkable,
        );
        const blockPositions = _.map(impassibleStuctures, (s) => s.pos);
        MatrixLib_1.block(matrix, blockPositions);
        return matrix;
    }
    /**
     * Adds a pyramid-shaped potential to the cost matrix centered around the target position and extending to a
     * specified range with a maximum cost. MaxCost must be divisible by range+1 or an error is thrown. If
     * includeTerrainCosts=true (by default) then if the cost for a square is zero, the terrain cost of the tile is
     * added using default costs of {plain: 1, swamp: 5}. For example, the relevant portion of the return matrix of
     * MatrixLib.addPyramidPotential(zeroMatrix, pos, range=2, maxCost=6) is:
     *
     *     0 0 0 0 0 0 0
     *     0 2 2 2 2 2 0
     *     0 2 4 4 4 2 0
     *     0 2 4 6 4 2 0
     *     0 2 4 4 4 2 0
     *     0 2 2 2 2 2 0
     *     0 0 0 0 0 0 0
     */
    static addPyramidPotential(
        matrix,
        pos,
        range,
        maxCost,
        includeTerrain = true, // don't use includeTerrain with explicitTerrainCosts!
        terrainCosts = { plainCost: 1, swampCost: 5 },
    ) {
        if (Math.floor(maxCost / range) != maxCost / range) {
            log.error(
                `MatrixLib.addPyramidPotential: maxCost must be divisible by (range+1)!`,
            );
            return matrix;
        }
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        const slope = maxCost / (range + 1);
        let x, y, dx, dy, r, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) continue;
                const terrain = Game.map.getRoomTerrain(pos.roomName);
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        } else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                r = Math.max(Math.abs(dx), Math.abs(dy));
                cost += slope * (range + 1 - r);
                matrix.set(x, y, cost); // cost can exceed 0xff since it is min-maxed in backend
            }
        }
        return matrix;
    }
    /**
     * Adds a square potential with a specified center and range. If includeTerrainCosts=true (by default) then if the
     * cost for a square is zero, the terrain cost of the tile is added using default costs of {plain: 1, swamp: 5}.
     */
    static addSquarePotential(
        matrix,
        pos,
        range,
        addCost,
        includeTerrain = true, // don't use includeTerrain with explicitTerrainCosts!
        terrainCosts = { plainCost: 1, swampCost: 5 },
    ) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) continue;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) continue;
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        } else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                matrix.set(x, y, addCost + cost); // cost can exceed 0xff since it is min-maxed in backend
            }
        }
        return matrix;
    }
    /**
     * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height
     * window (indexed from upper left corner). This is basically a 2D max-pool operation except that the pooling
     * window moves with the max-kernel.
     * -> This method requires that terrain be explicitly specified in the matrix!
     */
    static applyMovingMaxPool(matrix, width, height) {
        // Since we're moving in increasing order of x, y, we don't need to clone the matrix
        let x, y, dx, dy;
        let maxCost, cost;
        for (x = 0; x <= 50 - width; x++) {
            for (y = 0; y <= 50 - height; y++) {
                maxCost = matrix.get(x, y);
                for (dx = 0; dx < width; dx++) {
                    for (dy = 0; dy < height; dy++) {
                        // Don't need 0 <= x,y <= 49 safety checks here since 0 <= x <= (50 - w + (w-1)) = 49
                        cost = matrix.get(x + dx, y + dy);
                        if (cost > maxCost) maxCost = cost;
                    }
                }
                matrix.set(x, y, maxCost);
            }
        }
        return matrix;
    }
    /**
     * Blocks all specified positions for a swarm cost matrix that has already been "smeared" by
     * MatrixLib.applyMovingMaxPool().
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrian costs.
     */
    static blockAfterMaxPooling(matrix, positions, width, height) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49) continue;
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) continue;
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    /**
     * Sets the effective cost of all specified positions for a swarm cost matrix that has already been "smeared" by
     * MatrixLib.applyMovingMaxPool(). The cost for each tile is the maximum of the set cost and the current cost.
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrain costs.
     * Example -----------------------------------------------------------------------------------------------------
     * Start       SetCost     MaxPool    |    Start       MaxPool     SetToMaxCostAfterMaxPooling
     * 0 0 0 0     0 0 0 0     1 5 5 0    |    0 0 0 0     1 2 2 0     1 5 5 0
     * 0 1 2 0     0 1 5 0     9 9 5 0    |    0 1 2 0     9 9 2 0     9 9 5 0
     * 0 9 0 0     0 9 5 0     9 9 5 1    |    0 9 0 0     9 9 1 1     9 9 5 1
     * 0 0 0 1     0 0 0 1     0 0 1 1    |    0 0 0 1     0 0 1 1     0 0 1 1
     */
    static setToMaxCostAfterMaxPooling(matrix, positions, width, height, cost) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49) continue;
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) continue;
                    if (matrix.get(x, y) < cost) {
                        matrix.set(x, y, cost);
                    }
                }
            }
        }
        return matrix;
    }
    /**
     * Adds an extra cost to the effective specified positions for a swarm cost matrix that has already been "smeared"
     * by MatrixLib.applyMovingMaxPool(). The cost is added on top of what is already there to any tiles which have a
     * lower existing cost than the new value. Tiles in overlapping cost-adding windows will have the maximum of the
     * costs added to their value, not the total of the costs.
     * -> This method will not always produce the same results as setting the cost first and then smearing!
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrain costs.
     * Example -----------------------------------------------------------------------------------------------------
     * Start       AddCost     MaxPool    |    Start       MaxPool     AddCostAfterMaxPooling
     * 0 0 0 0     0 0 0 0     1 7 7 0    |    0 0 0 0     1 2 2 0     1 7 7 0
     * 0 1 2 0     0 1 7 0     9 9 7 0    |    0 1 2 0     9 9 2 0     9 9 7 0
     * 0 9 0 0     0 9 5 0     9 9 5 1    |    0 9 0 0     9 9 1 1     9 9 6 1
     * 0 0 0 1     0 0 0 1     0 0 1 1    |    0 0 0 1     0 0 1 1     0 0 1 1
     */
    static addCostAfterMaxPooling(matrix, positions, width, height, cost) {
        const addMatrix = new PathFinder.CostMatrix();
        MatrixLib_1.setToMaxCostAfterMaxPooling(
            addMatrix,
            positions,
            width,
            height,
            cost,
        );
        MatrixLib_1.addMatrices(matrix, addMatrix);
        return matrix;
    }
    /**
     * Sets the cost of all walkable positions within range of a target position or object. If add=true, adds the cost
     * to the existing cost of the tile. If the cost for a square is zero, the terrain cost of the tile is added
     * using implicit costs of {plain: 1, swamp: 5}
     */
    static setInRange(
        matrix,
        pos,
        range,
        cost,
        addDefaultTerrainCosts = false,
    ) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, currentCost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) continue;
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) continue;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) continue;
                currentCost = matrix.get(x, y);
                if (currentCost === 0) {
                    if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                        currentCost += 10;
                    } else {
                        currentCost += 2;
                    }
                }
                // if (currentCost >= 0xff || currentCost > cost) continue; // not necessary, done in backend
                matrix.set(
                    x,
                    y,
                    addDefaultTerrainCosts ? cost + currentCost : cost,
                );
            }
        }
        return matrix;
    }
    /**
     * Get a matrix of explicit terrain cost values for a room given specified movement costs. The matrix is stored
     * in the permacache. By default, a cloned matrix is returned which you may safely modify, but if you know what
     * you are doing, you can set skipClone=true.
     */
    static getTerrainMatrix(roomName, terrainCosts, skipClone = false) {
        const key = `${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            // This takes about 0.2 to 0.4 CPU to generate
            const matrix = new PathFinder.CostMatrix();
            const terrain = Game.map.getRoomTerrain(roomName);
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    switch (terrain.get(x, y)) {
                        case TERRAIN_MASK_SWAMP:
                            matrix.set(x, y, terrainCosts.swampCost);
                            break;
                        case TERRAIN_MASK_WALL:
                            matrix.set(x, y, 0xff);
                            break;
                        default:
                            // plain
                            matrix.set(x, y, terrainCosts.plainCost);
                            break;
                    }
                }
            }
            PERMACACHE.terrainMatrices[key] = matrix;
        }
        if (skipClone) {
            // be careful with this!
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    /**
     * Get a cloned copy of the cost matrix for a room with specified options
     */
    static getSwarmTerrainMatrix(
        roomName,
        terrainCosts,
        width,
        height,
        exitCost = 10,
        skipClone = false,
    ) {
        const key = `s_${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}_${width}_${height}_${exitCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            const terrainMatrix = MatrixLib_1.getTerrainMatrix(
                roomName,
                terrainCosts,
            );
            MatrixLib_1.setExitCosts(terrainMatrix, roomName, exitCost);
            MatrixLib_1.applyMovingMaxPool(terrainMatrix, width, height);
            PERMACACHE.terrainMatrices[key] = terrainMatrix;
        }
        if (skipClone) {
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    /**
     * Adds the terrain costs to an existing cost matrix
     */
    static addTerrainCosts(matrix, roomName, terrainCosts) {
        const terrainMatrix = MatrixLib_1.getTerrainMatrix(
            roomName,
            terrainCosts,
            true,
        );
        MatrixLib_1.addMatrices(matrix, terrainMatrix);
        return matrix;
    }
    /**
     * Blocks all tiles at the edge of the room. If rangeToEdge is specified, block all tiles within that range of
     * the edge.
     */
    static blockExits(roomName, matrix, rangeToEdge = 0) {
        // Generate a unique key for this call to blockExits, based on the parameters including roomName.
        const key = `b_${roomName}_${rangeToEdge}`;

        // Check if a matrix for this key is already in PERMACACHE.
        if (PERMACACHE.blockedExitsMatrices[key] === undefined) {
            // If not, generate a new matrix, block the exits, and store it in PERMACACHE.
            const newMatrix = matrix.clone(); // Assuming you need a new instance of the matrix
            for (
                let x = rangeToEdge;
                x < 50 - rangeToEdge;
                x += 49 - rangeToEdge * 2
            ) {
                for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                    newMatrix.set(x, y, 0xff);
                }
            }
            for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
                for (
                    let y = rangeToEdge;
                    y < 50 - rangeToEdge;
                    y += 49 - rangeToEdge * 2
                ) {
                    newMatrix.set(x, y, 0xff);
                }
            }
            PERMACACHE.blockedExitsMatrices[key] = newMatrix;
        }

        // Return the cached matrix from PERMACACHE.
        return PERMACACHE.blockedExitsMatrices[key].clone(); // Assuming you need to return a new instance of the matrix
    }
    /**
     * Sets the cost of all walkable tiles at the edge of the room. If rangeToEdge is specified, set the cost of
     * all walkable terrain tiles within that range of the edge.
     */
    static setExitCosts(matrix, roomName, cost, rangeToEdge = 0) {
        const terrain = Game.map.getRoomTerrain(roomName);
        for (
            let x = rangeToEdge;
            x < 50 - rangeToEdge;
            x += 49 - rangeToEdge * 2
        ) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (
                let y = rangeToEdge;
                y < 50 - rangeToEdge;
                y += 49 - rangeToEdge * 2
            ) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        return matrix;
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockMyCreeps(matrix, room) {
        _.forEach(room.creeps, (creep) => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    /**
     * Sets hostile creep positions to impassible
     */
    static blockHostileCreeps(matrix, room) {
        _.forEach(room.hostiles, (hostile) => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    /**
     * Sets allied creep positions to impassible
     */
    static blockAlliedCreeps(matrix, room) {
        _.forEach(room.friendlies, (hostile) => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockAllCreeps(matrix, room) {
        _.forEach(room.find(FIND_CREEPS), (creep) => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    /**
     * Sets road positions to 1 if cost is less than 0xfe
     */
    static preferRoads(matrix, room) {
        _.forEach(room.roads, (road) => {
            if (matrix.get(road.pos.x, road.pos.y) < 0xfe) {
                matrix.set(road.pos.x, road.pos.y, 1);
            }
        });
    }
    /**
     * Generates and caches a rampart mask for the room with 0x00 where there are ramparts and 0xff everywhere else.
     * If onlyMy=true, then only ramparts that are owned by me are counted.
     * -> This method does not take rampart walkability into account (if there are structures under the rampart)
     */
    static getRampartMask(room, onlyMy = true, value = 0xff) {
        const key = `rampartMask_${room.name}_onlymy_${onlyMy}`;
        let matrix;
        let expiration;
        let invalidateCondition;
        if (MatrixCache[key]) {
            expiration = MatrixCache[key].expiration || Infinity;
            invalidateCondition =
                MatrixCache[key].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[key];
                matrix = undefined;
            } else {
                matrix = MatrixCache[key].matrix;
            }
        }
        if (!matrix) {
            matrix = new PathFinder.CostMatrix();
            MatrixLib_1.fillMatrix(matrix, 0xff);
            const ramparts = onlyMy
                ? _.filter(room.ramparts, (rampart) => rampart.my)
                : room.ramparts;
            for (const rampart of ramparts) {
                matrix.set(rampart.pos.x, rampart.pos.y, 0);
            }
        }
        const numRamparts = room.ramparts.length; // this doesn't account for onlyMy option but I think this is okay
        MatrixCache[key] = {
            matrix: matrix,
            generated: Game.time,
            expiration: Game.time + 100,
            invalidateCondition: () =>
                Game.rooms[room.name] &&
                Game.rooms[room.name].ramparts.length != numRamparts,
        };
        return MatrixCache[key].matrix;
    }
    /**
     * Sets walkable rampart positions to 1 if cost is less than 0xfe
     * TODO: maybe increasing cost elsewhere would be better than decreasing cost in ramparts
     */
    static setWalkableRampartCostToOne(matrix, room) {
        _.forEach(room.walkableRamparts, (rampart) => {
            if (matrix.get(rampart.pos.x, rampart.pos.y) < 0xfe) {
                matrix.set(rampart.pos.x, rampart.pos.y, 1);
            }
        });
    }
    /**
     * Blocks all non-rampart positions in the room. If onlyMy=true, then only my rampart positions are blocked
     */
    static blockNonRamparts(matrix, room, onlyMy = true) {
        const mask = MatrixLib_1.getRampartMask(room, onlyMy);
        MatrixLib_1.addMatrices(matrix, mask);
    }
    /**
     * Gets the rows of a CostMatrix and returns as a list of 50 Uint8Arrays
     */
    static getRows(matrix) {
        const rows = [];
        for (let y = 0; y < 50; ++y) {
            rows.push(new Uint8Array(50));
            for (let x = 0; x < 50; ++x) {
                rows[y][x] = matrix.get(x, y);
            }
        }
        return rows;
    }
    /**
     * Gets the columns of a CostMatrix and returns as a list of 50 Uint8Arrays
     */
    static getColumns(matrix) {
        const columns = [];
        for (let x = 0; x < 50; ++x) {
            columns.push(new Uint8Array(50));
            for (let y = 0; y < 50; ++y) {
                columns[x][y] = matrix.get(x, y);
            }
        }
        return columns;
    }
    /**
     * Returns the maximum value of any matrix element
     */
    static getMaxValue(matrix) {
        return _.max(matrix._bits);
    }
    /**
     * Prints the values of a CostMatrix to the console. This is pretty expensive!
     */
    static print(matrix, opts = { equalSpacing: true, useColorMap: true }) {
        // Figure out how big the largest value in a column is so we can align them right
        const longestNumPerColumn = _.map(
            MatrixLib_1.getColumns(matrix),
            (column) => _.max(_.map(column, (n) => n.toString().length)),
        );
        if (opts.equalSpacing) {
            const longestNum = _.max(longestNumPerColumn);
            for (let i = 0; i < longestNumPerColumn.length; ++i) {
                longestNumPerColumn[i] = longestNum;
            }
        }
        const maxVal = MatrixLib_1.getMaxValue(matrix);
        let msg = '';
        let num, percentOfMax, numAsStr;
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                num = matrix.get(x, y);
                numAsStr = matrix
                    .get(x, y)
                    .toString()
                    .padEnd(longestNumPerColumn[x] + 1);
                if (opts.useColorMap && maxVal > 0) {
                    percentOfMax = Math.round((255 * num) / maxVal);
                    msg += color(
                        numAsStr,
                        rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax),
                    );
                } else {
                    msg += numAsStr;
                }
            }
            msg += '\n';
        }
        console.log(msg);
    }
    /**
     * Visualizes the cost matrix as a room visual. Shortcut to Visualizer.displayCostMatrix()
     */
    static visualize(matrix, roomName) {
        Visualizer.displayCostMatrix(matrix, roomName);
    }
});
MatrixLib.settings = {
    portalCost: 20,
};
MatrixLib.testMatrices = {
    checkerboard: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y) % 2);
            }
        }
        return matrix;
    },
    checkerboard2: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y + 1) % 2);
            }
        }
        return matrix;
    },
    xIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x);
            }
        }
        return matrix;
    },
    yIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, y);
            }
        }
        return matrix;
    },
    diagonalIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x + y);
            }
        }
        return matrix;
    },
};
MatrixLib = MatrixLib_1 = __decorate([profile], MatrixLib);
global.MatrixCache = MatrixCache;
global.MatrixLib = MatrixLib;

var Pathing_1;
const FIND_EXIT_PORTAL = 42;
const DEFAULT_MAXOPS = 20000; // default timeout for pathfinding
const MatrixTypes = {
    direct: 'dir',
    default: 'def',
    sk: 'sk',
    obstacle: 'obst',
    preferRampart: 'preframp',
    nearRampart: 'nearRamp',
};
const getDefaultPathOptions = () => ({
    range: 1,
    terrainCosts: { plainCost: 1, swampCost: 5 },
    roadCost: 'auto',
    ignoreCreeps: true,
    maxOps: DEFAULT_MAXOPS,
    maxRooms: 20,
    avoidSK: false,
    allowPortals: true,
    usePortalThreshold: 10,
    portalsMustBeInRange: 6,
    ensurePath: false,
});
/**
 * Selects the properties of PathOptions that are also on MatrixOptions.
 */
const _defaultMatrixOptionsKeys = _.keys(getDefaultMatrixOptions());
function getMatrixOptsFromPathOpts(opts) {
    const matrixOpts = _.pick(opts, _defaultMatrixOptionsKeys);
    if (opts.obstacles) {
        // might need to sort this string if I start adding nondeterministic obstacles
        matrixOpts.obstacles = packPosList(opts.obstacles);
    }
    return matrixOpts;
}
function pathOptsToMatrixAndVolatileOpts(opts) {
    const matrixOpts = getMatrixOptsFromPathOpts(opts);
    const volatileMatrixOpts = {};
    if (opts.blockCreeps) volatileMatrixOpts.blockCreeps = opts.blockCreeps;
    return [matrixOpts, volatileMatrixOpts];
}
/**
 * Module for pathing-related operations.
 */
let Pathing = (Pathing_1 = class Pathing {
    // Room avoidance methods ==========================================================================================
    /**
     * Check if the room should be avoiding when calculating routes
     */
    static shouldAvoid(roomName) {
        return (
            Memory.rooms[roomName] && Memory.rooms[roomName]['a' /* AVOID */]
        );
        // TODO - make more sophisticated, move to RoomIntel
    }
    /**
     * Update memory on whether a room should be avoided based on controller owner
     */
    static updateRoomStatus(room) {
        if (!room) {
            return;
        }
        if (room.controller) {
            if (
                room.controller.owner &&
                !(room.controller.my || isAlly(room.owner || '')) &&
                room.towers.length > 0
            ) {
                room.memory['a' /* AVOID */] = true;
            } else if (
                (!room.controller.reservation ||
                    room.controller.reservation.username === MY_USERNAME ||
                    isAlly(room.owner || '')) &&
                room.memory['a' /* AVOID */] === true
            ) {
                delete room.memory['a' /* AVOID */];
                // if (room.memory.expansionData == false) delete room.memory.expansionData;
            }
        } else {
            if (
                Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER &&
                room.invaderCore
            ) {
                if (
                    !room.invaderCore.ticksToDeploy ||
                    room.invaderCore.ticksToDeploy < 300
                ) {
                    room.memory['a' /* AVOID */] = true;
                } else {
                    room.memory['a' /* AVOID */] = false;
                }
            }
        }
    }
    // Pathfinding and room callback methods ===========================================================================
    /**
     * Find a path from origin to destination
     */
    static findPath(origin, destination, opts = {}) {
        _.defaults(opts, getDefaultPathOptions());
        // check to see whether findRoute should be used
        const linearDistance = Game.map.getRoomLinearDistance(
            origin.roomName,
            destination.roomName,
        );
        if (
            opts.maxRooms &&
            linearDistance > opts.maxRooms &&
            !opts.allowPortals
        ) {
            log.warning(
                `Pathing from ${origin.print} to ${destination.print} exceeds max room specification ` +
                    `of ${opts.maxRooms}!`,
            );
        }
        let route = opts.route;
        if (
            !route &&
            (opts.useFindRoute == true ||
                (opts.useFindRoute === undefined && linearDistance >= 3))
        ) {
            const foundRoute = this.findRoute(
                origin.roomName,
                destination.roomName,
                opts,
            );
            if (foundRoute != ERR_NO_PATH) {
                route = foundRoute;
            }
        }
        const destinationGoal = {
            pos: destination,
            range: opts.range,
        };
        const callback = (roomName) =>
            Pathing_1.roomCallback(roomName, origin, destination, route, opts);
        let ret;
        // Did the route use portals?
        const portalExitStepIndex = _.findIndex(
            route || [],
            (step) => step.exit == FIND_EXIT_PORTAL,
        );
        const usesPortals = portalExitStepIndex != -1; // index is -1 if not found
        let portalUsed;
        if (usesPortals) {
            // If we traversed a portal we need to call pathfinder twice and merge the two paths
            const portalEntranceStepIndex = portalExitStepIndex - 1;
            const portalEntraceRoom =
                portalEntranceStepIndex < 0
                    ? origin.roomName
                    : route[portalExitStepIndex - 1].room;
            const portals = RoomIntel.getPortalInfo(portalEntraceRoom);
            const portalGoals = _.map(portals, (portal) => ({
                pos: portal.pos,
                range: 0,
            }));
            const path1ret = PathFinder.search(origin, portalGoals, {
                maxOps: opts.maxOps,
                maxRooms: opts.maxRooms,
                plainCost: opts.terrainCosts.plainCost,
                swampCost: opts.terrainCosts.swampCost,
                roomCallback: callback,
            });
            // if the path is incomplete then we'll let it get handled at the end of this method
            if (!path1ret.incomplete) {
                const lastPosInPath = _.last(path1ret.path);
                const usedPortal = _.find(portals, (portal) =>
                    portal.pos.isEqualTo(lastPosInPath),
                );
                if (usedPortal) {
                    portalUsed = usedPortal;
                    const portalDest = usedPortal.destination;
                    const path2ret = PathFinder.search(
                        portalDest,
                        destinationGoal,
                        {
                            maxOps: opts.maxOps,
                            maxRooms: opts.maxRooms,
                            plainCost: opts.terrainCosts.plainCost,
                            swampCost: opts.terrainCosts.swampCost,
                            roomCallback: callback,
                        },
                    );
                    ret = {
                        path: path1ret.path
                            .concat([usedPortal.destination])
                            .concat(path2ret.path),
                        ops: path1ret.ops + path2ret.ops,
                        cost: path1ret.ops + path2ret.ops,
                        incomplete: path1ret.incomplete || path2ret.incomplete,
                    };
                } else {
                    log.error(
                        `Pathing: No Portal pos in ${JSON.stringify(
                            path1ret.path,
                        )}! (Why?)`,
                    );
                    ret = path1ret;
                }
            } else {
                log.error(
                    `Pathing: Incomplete first half of pathing from ${origin.print} to nearest portal!`,
                );
                ret = path1ret;
            }
        } else {
            ret = PathFinder.search(origin, destinationGoal, {
                maxOps: opts.maxOps,
                maxRooms: opts.maxRooms,
                plainCost: opts.terrainCosts.plainCost,
                swampCost: opts.terrainCosts.swampCost,
                roomCallback: callback,
            });
        }
        if (
            ret.incomplete &&
            opts.ensurePath &&
            linearDistance <= 3 &&
            !opts.route
        ) {
            // handle case where pathfinder failed at a short distance due to not using findRoute
            // can happen for situations where the creep would have to take an uncommonly indirect path
            // options.allowedRooms and options.routeCallback can also be used to handle this situation
            const useRoute = this.findRoute(
                origin.roomName,
                destination.roomName,
                opts,
            );
            if (useRoute != ERR_NO_PATH) {
                log.warning(
                    `Pathing: findPath from ${origin.print} to ${destination.print} failed without ` +
                        `specified route. Trying again with route: ${JSON.stringify(
                            useRoute,
                        )}.`,
                );
                opts.route = useRoute;
                ret = this.findPath(origin, destination, opts);
                if (ret.incomplete) {
                    log.error(
                        `Pathing: second attempt from ${origin.print} to ${destination.print} ` +
                            `was unsuccessful!`,
                    );
                }
            } else {
                log.error(
                    `Pathing: findPath from ${origin.print} to ${destination.print} failed and route could ` +
                        `not be explicitly computed!`,
                );
            }
        }
        return {
            path: ret.path,
            incomplete: ret.incomplete,
            ops: ret.ops,
            cost: ret.cost,
            route: route,
            usesPortals: usesPortals,
            portalUsed: portalUsed,
        };
    }
    /**
     * Find a viable sequence of rooms to narrow down Pathfinder algorithm
     */
    static findRoute(origin, destination, opts = {}) {
        _.defaults(opts, getDefaultPathOptions());
        const linearDistance = Game.map.getRoomLinearDistance(
            origin,
            destination,
        );
        const maxRooms = opts.maxRooms || linearDistance + 10;
        const myZoneStatus = RoomIntel.getMyZoneStatus();
        if (RoomIntel.getRoomStatus(destination).status != myZoneStatus) {
            return ERR_NO_PATH;
        }
        // This takes a portal room near the origin and spits out the best destination room of all portals in the room
        const getBestPortalDestination = (portalRoom) => {
            const portalInfo = RoomIntel.getPortalInfo(portalRoom);
            if (portalInfo.length == 0) {
                return;
            }
            const bestPortalDest = _(portalInfo)
                .map((portal) => portal.destination.roomName)
                .unique()
                .min((portalDest) =>
                    Game.map.getRoomLinearDistance(portalDest, destination),
                );
            return bestPortalDest;
        };
        // Route finder callback for portal searching
        const callback = (roomName) => {
            const rangeToRoom = Game.map.getRoomLinearDistance(
                origin,
                roomName,
            );
            if (rangeToRoom > maxRooms) {
                // room is too far out of the way
                return Infinity;
            }
            if (
                !opts.allowHostile &&
                this.shouldAvoid(roomName) &&
                roomName !== destination &&
                roomName !== origin
            ) {
                // room is marked as "avoid" in room memory
                return Infinity;
            }
            if (RoomIntel.getRoomStatus(roomName).status != myZoneStatus) {
                return Infinity; // can't path outside of your local newbie/respawn zone
            }
            return 1;
            // TODO: include better pathing heuristics here such as average terrain value or avg pathing btw 2 points
        };
        let route = Game.map.findRoute(origin, destination, {
            routeCallback: callback,
        });
        if (
            opts.allowPortals &&
            (route == ERR_NO_PATH ||
                route.length >= (opts.usePortalThreshold || 1))
        ) {
            // Narrow down a list of portal rooms that could possibly lead to the destination
            const validPortalRooms = _.filter(
                RoomIntel.memory.portalRooms,
                (roomName) => {
                    // Is the first leg of the trip too far?
                    const originToPortal = Game.map.getRoomLinearDistance(
                        origin,
                        roomName,
                    );
                    if (originToPortal > opts.maxRooms) return false;
                    if (
                        opts.portalsMustBeInRange &&
                        originToPortal > opts.portalsMustBeInRange
                    ) {
                        return false;
                    }
                    // Are there intra-shard portals here?
                    const bestPortalDestination = getBestPortalDestination(
                        roomName,
                    );
                    if (!bestPortalDestination) return false;
                    // Is the first + second leg of the trip too far?
                    const portalToDestination = Game.map.getRoomLinearDistance(
                        destination,
                        bestPortalDestination,
                    );
                    return (
                        originToPortal + portalToDestination <= opts.maxRooms
                    );
                },
            );
            // Figure out which portal room is the best one to use
            const portalCallback = (roomName) => {
                if (
                    !opts.allowHostile &&
                    this.shouldAvoid(roomName) &&
                    roomName !== destination &&
                    roomName !== origin
                ) {
                    // room is marked as "avoid" in room memory
                    return Infinity;
                }
                if (RoomIntel.getRoomStatus(roomName).status != myZoneStatus) {
                    return Infinity; // can't path outside of your local newbie/respawn zone
                }
                return 1;
            };
            const bestPortalRoom = minBy(validPortalRooms, (portalRoom) => {
                const bestPortalDestination = getBestPortalDestination(
                    portalRoom,
                ); // room def has portal
                const originToPortalRoute = Game.map.findRoute(
                    origin,
                    portalRoom,
                    {
                        routeCallback: portalCallback,
                    },
                );
                const portalToDestinationRoute = Game.map.findRoute(
                    bestPortalDestination,
                    destination,
                    { routeCallback: portalCallback },
                );
                if (
                    originToPortalRoute != ERR_NO_PATH &&
                    portalToDestinationRoute != ERR_NO_PATH
                ) {
                    const portalRouteLength =
                        originToPortalRoute.length +
                        portalToDestinationRoute.length;
                    const directRouteLength =
                        route != ERR_NO_PATH ? route.length : Infinity;
                    if (portalRouteLength < directRouteLength) {
                        return portalRouteLength;
                    } else {
                        return false; // no sense using portals if it make the route even longer
                    }
                } else {
                    return false;
                }
            });
            if (bestPortalRoom) {
                const portalDest = getBestPortalDestination(bestPortalRoom);
                const originToPortalRoute = Game.map.findRoute(
                    origin,
                    bestPortalRoom,
                    {
                        routeCallback: portalCallback,
                    },
                );
                const portalToDestinationRoute = Game.map.findRoute(
                    portalDest,
                    destination,
                    { routeCallback: portalCallback },
                );
                // This will always be true but gotta check so TS doesn't complain...
                if (
                    originToPortalRoute != ERR_NO_PATH &&
                    portalToDestinationRoute != ERR_NO_PATH
                ) {
                    route = [
                        ...originToPortalRoute,
                        { exit: FIND_EXIT_PORTAL, room: portalDest },
                        ...portalToDestinationRoute,
                    ];
                    // if (origin == 'E26S47') console.log('PORTAL ROUTE:', print(route));
                }
            }
        }
        if (route == ERR_NO_PATH) {
            log.warning(
                `Pathing: couldn't findRoute from ${origin} to ${destination} ` +
                    `with opts ${JSON.stringify(opts)}!`,
            );
            return ERR_NO_PATH;
        } else {
            return route;
        }
    }
    /**
     * Find a path from origin to destination
     */
    static findSwarmPath(origin, destination, width, height, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            maxOps: 2 * DEFAULT_MAXOPS,
            range: 1,
        });
        // Make copies of the destination offset for where anchor could be
        const destinations = this.getPosWindow(destination, -width, -height);
        const callback = (roomName) =>
            this.swarmRoomCallback(roomName, width, height, options);
        return PathFinder.search(
            origin,
            _.map(destinations, (pos) => ({ pos: pos, range: options.range })),
            {
                maxOps: options.maxOps,
                maxRooms: options.maxRooms,
                plainCost: 1,
                swampCost: 5,
                roomCallback: callback,
            },
        );
    }
    /**
     * Get a window of offset RoomPositions from an anchor position and a window width and height
     */
    static getPosWindow(anchor, width, height) {
        const positions = [];
        for (const dx of _.range(0, width, width < 0 ? -1 : 1)) {
            for (const dy of _.range(0, height, height < 0 ? -1 : 1)) {
                positions.push(anchor.getOffsetPos(dx, dy));
            }
        }
        return positions;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findShortestPath(startPos, endPos, opts = {}) {
        _.defaults(opts, opts);
        const ret = this.findPath(startPos, endPos, opts);
        if (ret.incomplete) {
            log.alert(
                `Pathing: incomplete path from ${startPos.print} to ${endPos.print}!`,
            );
        }
        return ret;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findPathToRoom(startPos, roomName, options = {}) {
        options.range = 23;
        const ret = this.findPath(
            startPos,
            new RoomPosition(25, 25, roomName),
            options,
        );
        if (ret.incomplete) {
            log.alert(
                `Pathing: incomplete path from ${startPos.print} to ${roomName}!`,
            );
        }
        return ret;
    }
    /**
     * Default room callback, which automatically determines the most appropriate callback method to use
     */
    static roomCallback(roomName, origin, destination, route, opts) {
        if (roomName != origin.roomName && roomName != destination.roomName) {
            if (
                route &&
                !_.any(route, (routePart) => routePart.room == roomName)
            ) {
                return false; // only allowed to visit these rooms if route is specified
            }
            if (!opts.allowHostile && this.shouldAvoid(roomName)) {
                return false; // don't go through hostile rooms
            }
        }
        const [
            matrixOpts,
            volatileMatrixOpts,
        ] = pathOptsToMatrixAndVolatileOpts(opts);
        const matrix = MatrixLib.getMatrix(
            roomName,
            matrixOpts,
            volatileMatrixOpts,
        );
        if (opts.modifyRoomCallback && Game.rooms[roomName]) {
            // Return a modified copy the matrix
            return opts.modifyRoomCallback(
                Game.rooms[roomName],
                matrix.clone(),
            );
        } else {
            // No modifications necessary; return the matrix
            return matrix;
        }
    }
    static swarmRoomCallback(roomName, width, height, opts) {
        const matrixOpts = {
            explicitTerrainCosts: true,
            ignoreStructures: opts.ignoreStructures,
            swarmWidth: width,
            swarmHeight: height,
        };
        const volatileMatrixOpts = {};
        if (opts.blockCreeps) volatileMatrixOpts.blockCreeps = opts.blockCreeps;
        const matrix = MatrixLib.getMatrix(
            roomName,
            matrixOpts,
            volatileMatrixOpts,
        );
        if (opts.displayCostMatrix) {
            Visualizer.displayCostMatrix(matrix, roomName);
        }
        return matrix;
    }
    static kitingRoomCallback(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return Pathing_1.getKitingMatrix(room);
        } else {
            // have no vision
            return true;
        }
    }
    /**
     * Get a kiting path within a room
     */
    static findKitingPath(creepPos, fleeFrom, opts = {}) {
        _.defaults(opts, {
            fleeRange: 5,
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        const fleeFromPos = _.map(fleeFrom, (flee) => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, (pos) => {
            return { pos: pos, range: opts.fleeRange };
        });
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: opts.terrainCosts.plainCost,
            swampCost: opts.terrainCosts.swampCost,
            flee: true,
            roomCallback: Pathing_1.kitingRoomCallback,
            maxRooms: 1,
        });
    }
    /**
     * Get a flee path possibly leaving the room; generally called further in advance of kitingPath
     */
    static findFleePath(creepPos, fleeFrom, opts = {}) {
        _.defaults(opts, {
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        if (opts.fleeRange == undefined) {
            opts.fleeRange = opts.terrainCosts.plainCost > 1 ? 20 : 10;
        }
        const fleeFromPos = _.map(fleeFrom, (flee) => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, (pos) => {
            return { pos: pos, range: opts.fleeRange };
        });
        const callback = (roomName) => {
            if (
                !opts.allowHostile &&
                this.shouldAvoid(roomName) &&
                roomName != creepPos.roomName
            ) {
                return false;
            }
            const [
                matrixOpts,
                volatileMatrixOpts,
            ] = pathOptsToMatrixAndVolatileOpts(opts);
            const matrix = MatrixLib.getMatrix(
                roomName,
                matrixOpts,
                volatileMatrixOpts,
            );
            // Modify cost matrix if needed
            if (opts.modifyRoomCallback && Game.rooms[roomName]) {
                return opts.modifyRoomCallback(
                    Game.rooms[roomName],
                    matrix.clone(),
                );
            } else {
                return matrix;
            }
        };
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: opts.terrainCosts.plainCost,
            swampCost: opts.terrainCosts.swampCost,
            flee: true,
            roomCallback: callback,
        });
    }
    // Cost matrix retrieval functions =================================================================================
    // /**
    //  * Get a cloned copy of the cost matrix for a room with specified options
    //  */
    // static getCostMatrix(room: Room, options: PathOptions, clone = true): CostMatrix {
    // 	let matrix: CostMatrix;
    // 	if (options.avoidSK) {
    // 		matrix = this.getSkMatrix(room);
    // 	} else if (options.ignoreStructures) {
    // 		matrix = new PathFinder.CostMatrix();
    // 	} else {
    // 		matrix = this.getDefaultMatrix(room);
    // 	}
    // 	if (options.ignoreCreeps == false) {
    // 		matrix = this.getCreepMatrix(room, matrix);
    // 	}
    // 	// Register other obstacles
    // 	if (options.obstacles && options.obstacles.length > 0) {
    // 		matrix = matrix.clone();
    // 		for (const obstacle of options.obstacles) {
    // 			if (obstacle && obstacle.roomName == room.name) {
    // 				matrix.set(obstacle.x, obstacle.y, 0xff);
    // 			}
    // 		}
    // 	}
    // 	if (clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix;
    // }
    // static getSwarmDefaultMatrix(room: Room, width: number, height: number,
    // 							 options: SwarmMoveOptions = {}, clone = true): CostMatrix {
    // 	let matrix = $.costMatrix(room.name, `swarm${width}x${height}`, () => {
    // 		const mat = this.getTerrainMatrix(room.name).clone();
    // 		this.blockImpassibleStructures(mat, room);
    // 		this.setExitCosts(mat, room.name, options.exitCost || 10);
    // 		this.applyMovingMaximum(mat, width, height);
    // 		return mat;
    // 	}, 25);
    // 	if (options.ignoreCreeps == false) {
    // 		matrix = matrix.clone();
    // 		this.blockHostileCreeps(matrix, room); // todo: need to smear again?
    // 	}
    // 	if (clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix;
    // }
    // private static getCostMatrixForInvisibleRoom(roomName: string, options: PathOptions,
    // 											 clone = true): CostMatrix {
    // 	let matrix: CostMatrix | undefined;
    // 	if (options.avoidSK) {
    // 		matrix = $.costMatrixRecall(roomName, MatrixTypes.sk);
    // 	} else {
    // 		matrix = $.costMatrixRecall(roomName, MatrixTypes.default);
    // 	}
    // 	// Hm, we haven't found any previously cached matrices; let's see if we can get stuff from room intel
    // 	if (!matrix) {
    // 		const roomInfo = RoomIntel.getAllRoomObjectInfo(roomName);
    // 		if (roomInfo) {
    // 			// Cool let's set walkability based on what we remember
    // 			matrix = new PathFinder.CostMatrix();
    // 			const structureData = roomInfo.importantStructures;
    // 			if (structureData) {
    // 				const structures = _.compact([structureData.storagePos,
    // 											  structureData.terminalPos,
    // 											  ...structureData.towerPositions,
    // 											  ...structureData.spawnPositions,
    // 											  ...structureData.wallPositions,
    // 											  ...structureData.rampartPositions]) as RoomPosition[];
    // 				_.forEach(structures, pos => matrix!.set(pos.x, pos.y, 0xff));
    // 			}
    // 			const portals = roomInfo.portals;
    // 			_.forEach(portals, portal => matrix!.set(portal.pos.x, portal.pos.y, PORTAL_COST));
    // 			const skLairs = roomInfo.skLairs;
    //
    // 			if (skLairs.length > 0) {
    // 				// The source keepers usually hang out by the closest mineral or source but sometimes on lair
    // 				const avoidRange = 5;
    // 				const terrain = Game.map.getRoomTerrain(roomName);
    // 				const blockThese = _.compact([...roomInfo.sources,
    // 											  roomInfo.mineral,
    // 											  ...roomInfo.skLairs]) as HasPos[];
    // 				_.forEach(blockThese, thing => {
    // 					let x, y: number;
    // 					for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 						for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 							x = thing.pos.x + dx;
    // 							y = thing.pos.y + dy;
    // 							if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 								const cost = SK_COST * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 								matrix!.set(thing.pos.x + dx, thing.pos.y + dy, cost);
    // 							}
    // 						}
    // 					}
    // 				});
    // 			}
    // 		}
    // 	}
    // 	// Register other obstacles
    // 	if (matrix && options.obstacles && options.obstacles.length > 0) {
    // 		matrix = matrix.clone();
    // 		for (const obstacle of options.obstacles) {
    // 			if (obstacle && obstacle.roomName == roomName) {
    // 				matrix.set(obstacle.x, obstacle.y, 0xff);
    // 			}
    // 		}
    // 	}
    // 	if (matrix && clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix!;
    // }
    // Cost matrix generation functions ================================================================================
    // /**
    //  * Get a matrix of explicit terrain values for a room
    //  */
    // static getTerrainMatrix(roomName: string, costs: TerrainCosts = {plainCost: 1, swampCost: 5}): CostMatrix {
    // 	return $.costMatrix(roomName, `terrain:${costs.plainCost}:${costs.swampCost}`, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		const terrain = Game.map.getRoomTerrain(roomName);
    // 		for (let y = 0; y < 50; ++y) {
    // 			for (let x = 0; x < 50; ++x) {
    // 				switch (terrain.get(x, y)) {
    // 					case TERRAIN_MASK_SWAMP:
    // 						matrix.set(x, y, costs.swampCost);
    // 						break;
    // 					case TERRAIN_MASK_WALL:
    // 						matrix.set(x, y, 0xff);
    // 						break;
    // 					default: // plain
    // 						matrix.set(x, y, costs.plainCost);
    // 						break;
    // 				}
    // 			}
    // 		}
    // 		return matrix;
    // 	}, 10000);
    // }
    // /**
    //  * Default matrix for a room, setting impassable structures and constructionSites to impassible
    //  */
    // static getDefaultMatrix(room: Room): CostMatrix {
    // 	return $.costMatrix(room.name, MatrixTypes.default, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		// Set passability of structure positions
    // 		const impassibleStructures: Structure[] = [];
    // 		_.forEach(room.find(FIND_STRUCTURES), (s: Structure) => {
    // 			if (s.structureType == STRUCTURE_ROAD) {
    // 				matrix.set(s.pos.x, s.pos.y, 1);
    // 			} else if (!s.isWalkable) {
    // 				impassibleStructures.push(s);
    // 			}
    // 		});
    // 		_.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
    // 		const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
    // 		_.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, PORTAL_COST));
    // 		// Set passability of construction sites
    // 		_.forEach(room.find(FIND_CONSTRUCTION_SITES), (site: ConstructionSite) => {
    // 			if (site.my && !site.isWalkable) {
    // 				matrix.set(site.pos.x, site.pos.y, 0xff);
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    //
    //
    // /**
    //  * Default matrix for a room, setting impassable structures and constructionSites to impassible, ignoring roads
    //  */
    // static getDirectMatrix(room: Room): CostMatrix { // TODO: deprecated
    // 	return $.costMatrix(room.name, MatrixTypes.direct, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		// Set passability of structure positions
    // 		const impassibleStructures: Structure[] = [];
    // 		_.forEach(room.find(FIND_STRUCTURES), (s: Structure) => {
    // 			if (!s.isWalkable) {
    // 				impassibleStructures.push(s);
    // 			}
    // 		});
    // 		_.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
    // 		const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
    // 		_.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));
    // 		// Set passability of construction sites
    // 		_.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site: ConstructionSite) => {
    // 			if (!site.isWalkable) {
    // 				matrix.set(site.pos.x, site.pos.y, 0xff);
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    //
    // /**
    //  * Avoids creeps in a room
    //  */
    // static getCreepMatrix(room: Room, fromMatrix?: CostMatrix): CostMatrix {
    // 	if (room._creepMatrix) {
    // 		return room._creepMatrix;
    // 	}
    // 	let matrix: CostMatrix;
    // 	if (fromMatrix) {
    // 		matrix = fromMatrix.clone();
    // 		_.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST));
    // 		return matrix;
    // 	}
    // 	matrix = this.getDefaultMatrix(room).clone();
    // 	_.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST)); // don't block off entirely
    // 	room._creepMatrix = matrix;
    // 	return room._creepMatrix;
    // }
    /**
     * Kites around hostile creeps in a room
     */
    static getKitingMatrix(room) {
        if (room._kitingMatrix) {
            return room._kitingMatrix;
        }
        const matrix = MatrixLib.getMatrix(room.name, {}).clone();
        const avoidCreeps = room.dangerousHostiles;
        _.forEach(avoidCreeps, (avoidCreep) =>
            MatrixLib.addSquarePotential(matrix, avoidCreep.pos, 3, 30),
        );
        // // || c.getActiveBodyparts(HEAL) > 0);
        // const terrain = Game.map.getRoomTerrain(room.name);
        // _.forEach(avoidCreeps, avoidCreep => {
        // 	let cost: number;
        // 	for (let dx = -3; dx <= 3; dx++) {
        // 		for (let dy = -3; dy <= 3; dy++) {
        // 			const x = avoidCreep.pos.x + dx;
        // 			const y = avoidCreep.pos.y + dy;
        // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL && matrix.get(x, y) != 1) { // if wall and no tunnel
        // 				cost = matrix.get(x, y);
        // 				cost += 40 - (10 * Math.max(Math.abs(dx), Math.abs(dy)));
        // 				matrix.set(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy, cost);
        // 			}
        // 		}
        // 	}
        // });
        room._kitingMatrix = matrix;
        return room._kitingMatrix;
    }
    // /**
    //  * Avoids source keepers in a room
    //  */
    // private static getSkMatrix(room: Room): CostMatrix {
    // 	if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) {
    // 		return this.getDefaultMatrix(room);
    // 	}
    // 	return $.costMatrix(room.name, MatrixTypes.sk, () => {
    // 		const matrix = this.getDefaultMatrix(room).clone();
    // 		if (room.sourceKeepers.length > 0) {
    // 			// const blockThese = _.compact([...room.sources, room.mineral, ...room.keeperLairs]) as HasPos[];
    // 			// _.forEach(blockThese, thing => {
    // 			// 	for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 			// 		for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 			// 			const cost = SK_COST / 5 * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 			// 			matrix!.set(thing.pos.x + dx, thing.pos.y + dy, cost);
    // 			// 		}
    // 			// 	}
    // 			// });
    // 			const terrain = Game.map.getRoomTerrain(room.name);
    // 			const avoidRange = 5;
    // 			_.forEach(room.sourceKeepers, sourceKeeper => {
    // 				let x, y: number;
    // 				for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 					for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 						x = sourceKeeper.pos.x + dx;
    // 						y = sourceKeeper.pos.y + dy;
    // 						if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 							const cost = SK_COST * 2 * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 							matrix.set(x, y, cost);
    // 						}
    // 					}
    // 				}
    // 			});
    // 		}
    // 		return matrix;
    // 	});
    // }
    // /**
    //  * Avoid locations in melee range of ramparts
    //  * @param room
    //  */
    // private static getNearRampartsMatrix(room: Room): CostMatrix {
    // 	return $.costMatrix(room.name, MatrixTypes.nearRampart, () => {
    // 		const matrix = this.getDefaultMatrix(room).clone();
    // 		const avoidRange = 1;
    // 		_.forEach(room.ramparts, rampart => {
    // 			for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 				for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 					matrix.set(rampart.pos.x + dx, rampart.pos.y + dy, 0xfe);
    // 				}
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    // /* Avoids source keepers in a room */
    // private static getInvisibleSkMatrix(roomName: string): CostMatrix {
    // 	let matrix = new PathFinder.CostMatrix();
    // 	if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
    // 		if (Memory.rooms[roomName] && Memory.rooms[roomName].SKlairs != undefined) {
    //
    // 			const avoidRange = 5;
    // 			const lairs: RoomPosition[] = _.map(Memory.rooms[roomName].SKlairs!,
    // 												saved => derefCoords(saved.c, roomName));
    // 			_.forEach(lairs, lair => {
    // 				for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 					for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 						matrix.set(lair.x + dx, lair.y + dy, 0xff);
    // 					}
    // 				}
    // 			});
    // 		}
    // 	}
    // 	return matrix;
    // }
    // In-place CostMatrix manipulation routines =======================================================================
    /**
     * Sets impassible structure positions to 0xff
     */
    static blockImpassibleStructures(matrix, room) {
        _.forEach(room.find(FIND_STRUCTURES), (s) => {
            if (!s.isWalkable) {
                if (s.structureType == STRUCTURE_PORTAL) {
                    matrix.set(s.pos.x, s.pos.y, 0xfe);
                } else {
                    matrix.set(s.pos.x, s.pos.y, 0xff);
                }
            }
        });
    }
    // /**
    //  * Explicitly blocks off walls for a room
    //  */
    // static blockImpassibleTerrain(matrix: CostMatrix, roomName: string) {
    // 	const terrain = Game.map.getRoomTerrain(roomName);
    // 	for (let y = 0; y < 50; ++y) {
    // 		for (let x = 0; x < 50; ++x) {
    // 			if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, 0xff);
    // 			}
    // 		}
    // 	}
    // }
    // /**
    //  * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height
    //  * window (indexed from upper left corner). This requires that terrain be explicitly specified in the matrix!
    //  */
    // static applyMovingMaxPool(matrix: CostMatrix, width: number, height: number) {
    // 	// Since we're moving in increasing order of x, y, we don't need to clone the matrix
    // 	let x, y, dx, dy: number;
    // 	let maxCost, cost: number;
    // 	for (x = 0; x <= 50 - width; x++) {
    // 		for (y = 0; y <= 50 - height; y++) {
    // 			maxCost = matrix.get(x, y);
    // 			for (dx = 0; dx <= width - 1; dx++) {
    // 				for (dy = 0; dy <= height - 1; dy++) {
    // 					cost = matrix.get(x + dx, y + dy);
    // 					if (cost > maxCost) {
    // 						maxCost = cost;
    // 					}
    // 				}
    // 			}
    // 			matrix.set(x, y, maxCost);
    // 		}
    // 	}
    // }
    // static setCostsInRange(matrix: CostMatrix, pos: RoomPosition | HasPos, range: number, cost = 30, add = false) {
    // 	pos = normalizePos(pos);
    // 	const terrain = Game.map.getRoomTerrain(pos.roomName);
    //
    // 	for (let dx = -range; dx <= range; dx++) {
    // 		const x = pos.x + dx;
    // 		if (x < 0 || x > 49) continue;
    // 		for (let dy = -range; dy <= range; dy++) {
    // 			const y = pos.y + dy;
    // 			if (y < 0 || y > 49) continue;
    // 			const posTerrain = terrain.get(x, y);
    // 			if (posTerrain === TERRAIN_MASK_WALL) {
    // 				continue;
    // 			}
    // 			let currentCost = matrix.get(x, y);
    // 			if (currentCost === 0) {
    // 				if (posTerrain === TERRAIN_MASK_SWAMP) {
    // 					currentCost += 10;
    // 				} else {
    // 					currentCost += 2;
    // 				}
    // 			}
    // 			if (currentCost >= 0xff || currentCost > cost) continue;
    // 			matrix.set(x, y, add ? Math.min(cost + currentCost, 200) : cost);
    // 		}
    // 	}
    // }
    // static blockExits(matrix: CostMatrix, rangeToEdge = 0) {
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
    // 			matrix.set(x, y, 0xff);
    // 		}
    // 	}
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
    // 			matrix.set(x, y, 0xff);
    // 		}
    // 	}
    // }
    //
    // static setExitCosts(matrix: CostMatrix, roomName: string, cost: number, rangeToEdge = 0) {
    // 	const terrain = Game.map.getRoomTerrain(roomName);
    //
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
    // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, cost);
    // 			}
    // 		}
    // 	}
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
    // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, cost);
    // 			}
    // 		}
    // 	}
    // }
    /**
     * Serialize a path as a string of move directions
     */
    static serializePath(startPos, path, color = 'orange') {
        let serializedPath = '';
        let lastPosition = startPos;
        for (const position of path) {
            if (position.roomName == lastPosition.roomName) {
                new RoomVisual(position.roomName).line(position, lastPosition, {
                    color: color,
                    lineStyle: 'dashed',
                });
                serializedPath += lastPosition.getDirectionTo(position);
            }
            lastPosition = position;
        }
        return serializedPath;
    }
    static nextDirectionInPath(creep) {
        const moveData = creep.memory._go;
        if (!moveData || !moveData.path || moveData.path.length == 0) {
            return;
        }
        return Number.parseInt(moveData.path[0], 10);
    }
    static nextPositionInPath(creep) {
        const nextDir = this.nextDirectionInPath(creep);
        if (!nextDir) {
            return;
        }
        return this.positionAtDirection(creep.pos, nextDir);
    }
    static oppositeDirection(direction) {
        switch (direction) {
            case TOP:
                return BOTTOM;
            case TOP_LEFT:
                return BOTTOM_RIGHT;
            case LEFT:
                return RIGHT;
            case BOTTOM_LEFT:
                return TOP_RIGHT;
            case BOTTOM:
                return TOP;
            case BOTTOM_RIGHT:
                return TOP_LEFT;
            case RIGHT:
                return LEFT;
            case TOP_RIGHT:
                return BOTTOM_LEFT;
        }
    }
    /**
     * Returns a position at a direction from origin
     */
    static positionAtDirection(origin, direction) {
        const offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];
        const offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];
        const x = origin.x + offsetX[direction];
        const y = origin.y + offsetY[direction];
        if (x > 49 || x < 0 || y > 49 || y < 0) {
            return;
        }
        return new RoomPosition(x, y, origin.roomName);
    }
    // static savePath(path: RoomPosition[]): void {
    // 	const savedPath: CachedPath = {
    // 		path  : path,
    // 		length: path.length,
    // 		tick  : Game.time
    // 	};
    // 	const originName = _.first(path).name;
    // 	const destinationName = _.last(path).name;
    // 	if (!Memory.pathing.paths[originName]) {
    // 		Memory.pathing.paths[originName] = {};
    // 	}
    // 	Memory.pathing.paths[originName][destinationName] = savedPath;
    // }
    // Distance and path weight calculations ===========================================================================
    /**
     * Calculate and/or cache the length of the shortest path between two points.
     * Cache is probabilistically cleared in Mem
     */
    static distance(pos1, pos2) {
        // zGen - updated from bogden
        const [name1, name2] = [packPos(pos1), packPos(pos2)].sort(); // path length is the same in either direction
        if (!Memory.pathing.distances[name1]) {
            Memory.pathing.distances[name1] = {};
        }
        if (Memory.pathing.distances[name1][name2] === -1) {
            log.debug(
                `PATHING: tried to re-get invalid cached distance ${pos1.print} to ${pos2.print}!`,
            );
            return;
        }
        if (!Memory.pathing.distances[name1][name2]) {
            const ret = this.findPath(pos1, pos2);
            if (!ret.incomplete) {
                Memory.pathing.distances[name1][name2] = ret.path.length;
            } else {
                log.error(
                    `PATHING: could not compute distance from ${pos1.print} to ${pos2.print}!`,
                );
                Memory.pathing.distances[name1][name2] = -1;
            }
        }
        return Memory.pathing.distances[name1][name2];
    }
    // static calculatePathWeight(startPos: RoomPosition, endPos: RoomPosition, options: MoveOptions = {}): number {
    // 	_.defaults(options, {
    // 		range: 1,
    // 	});
    // 	const ret = this.findPath(startPos, endPos, options);
    // 	let weight = 0;
    // 	for (const pos of ret.path) {
    // 		if (!pos.room) { // If you don't have vision, assume there are roads
    // 			weight += 1;
    // 		} else {
    // 			if (pos.lookForStructure(STRUCTURE_ROAD)) {
    // 				weight += 1;
    // 			} else {
    // 				const terrain = pos.lookFor(LOOK_TERRAIN)[0];
    // 				if (terrain == 'plain') {
    // 					weight += 2;
    // 				} else if (terrain == 'swamp') {
    // 					weight += 10;
    // 				}
    // 			}
    // 		}
    // 	}
    // 	return weight;
    // }
    // /**
    //  * Calculates and/or caches the weighted distance for the most efficient path. Weight is sum of tile weights:
    //  * Road = 1, Plain = 2, Swamp = 10. Cached weights are cleared in Mem occasionally.
    //  */
    // static weightedDistance(arg1: RoomPosition, arg2: RoomPosition): number {
    // 	const [pos1, pos2] = _.sortBy([arg1, arg2], pos => packPos(pos)); // alphabetize since path lengths are the same
    // 	if (!Memory.pathing.weightedDistances[pos1.name]) {
    // 		Memory.pathing.weightedDistances[pos1.name] = {};
    // 	}
    // 	if (!Memory.pathing.weightedDistances[pos1.name][pos2.name]) {
    // 		Memory.pathing.weightedDistances[pos1.name][pos2.name] = this.calculatePathWeight(pos1, pos2);
    // 	}
    // 	return Memory.pathing.weightedDistances[pos1.name][pos2.name];
    // }
    /**
     * Whether another object in the same room can be reached from the current position.
     * This method is very expensive and kind of stupid, so use it sparingly!
     */
    static isReachable(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(
                `isReachable() should only be used within a single room!`,
            );
            return false;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, (obstacle) => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            } else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) =>
            roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(
            startPos,
            { pos: endPos, range: options.range },
            {
                maxOps: options.maxOps,
                plainCost: 1,
                swampCost: 5,
                maxRooms: 1,
                roomCallback: callback,
            },
        );
        if (ret.incomplete) {
            return false;
        } else {
            for (const pos of ret.path) {
                if (matrix.get(pos.x, pos.y) > 100) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Like isReachable(), but returns the first position which should be cleared to find a path to destination
     */
    static findBlockingPos(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(
                `findBlockingPos() should only be used within a single room!`,
            );
            return undefined;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, (obstacle) => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            } else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) =>
            roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(
            startPos,
            { pos: endPos, range: options.range },
            {
                maxOps: options.maxOps,
                plainCost: 1,
                swampCost: 5,
                maxRooms: 1,
                roomCallback: callback,
            },
        );
        for (const pos of ret.path) {
            if (matrix.get(pos.x, pos.y) > 100) {
                return pos;
            }
        }
    }
    /**
     * Find the first walkable position in the room, spiraling outward from the center
     */
    static findPathablePosition(roomName, clearance = { width: 1, height: 1 }) {
        const terrain = Game.map.getRoomTerrain(roomName);
        let x, y;
        let allClear;
        for (let radius = 0; radius < 23; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = 25 + dx;
                    y = 25 + dy;
                    allClear = true;
                    for (let w = 0; w < clearance.width; w++) {
                        for (let h = 0; h < clearance.height; h++) {
                            if (
                                terrain.get(x + w, y + h) === TERRAIN_MASK_WALL
                            ) {
                                allClear = false;
                            }
                        }
                    }
                    if (allClear) {
                        return new RoomPosition(x, y, roomName);
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, 'cannotFindPathablePosition');
    }
});
Pathing = Pathing_1 = __decorate([profile], Pathing);
// Register global instance
global.Pathing = Pathing;

function applyDistanceTransform(foregroundPixels, oob = 255) {
    const dist = foregroundPixels;
    // Variables to represent the 3x3 neighborhood of a pixel.
    let UL, U, UR;
    let L, mid, R;
    let BL, B, BR;
    let x, y, value;
    for (y = 0; y < 50; ++y) {
        for (x = 0; x < 50; ++x) {
            if (foregroundPixels.get(x, y) !== 0) {
                UL = dist.get(x - 1, y - 1);
                U = dist.get(x, y - 1);
                UR = dist.get(x + 1, y - 1);
                L = dist.get(x - 1, y);
                if (y == 0) {
                    UL = oob;
                    U = oob;
                    UR = oob;
                }
                if (x == 0) {
                    UL = oob;
                    L = oob;
                }
                if (x == 49) {
                    UR = oob;
                }
                dist.set(x, y, Math.min(UL, U, UR, L, 254) + 1);
            }
        }
    }
    for (y = 49; y >= 0; --y) {
        for (x = 49; x >= 0; --x) {
            mid = dist.get(x, y);
            R = dist.get(x + 1, y);
            BL = dist.get(x - 1, y + 1);
            B = dist.get(x, y + 1);
            BR = dist.get(x + 1, y + 1);
            if (y == 49) {
                BL = oob;
                B = oob;
                BR = oob;
            }
            if (x == 49) {
                R = oob;
                BR = oob;
            }
            if (x == 0) {
                BL = oob;
            }
            value = Math.min(mid, R + 1, BL + 1, B + 1, BR + 1);
            dist.set(x, y, value);
        }
    }
    return dist;
}
// Compute a cost matrix for walkable pixels in a room
function walkablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    const terrain = Game.map.getRoomTerrain(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
function distanceTransform(roomName) {
    return applyDistanceTransform(walkablePixelsForRoom(roomName));
}

// Compute a hash of a block of code and register with Overmind
function assimilationLocked(code) {
    // This stuff has been disabled by reggaemuffin :p
}

const CACHE_TIMEOUT = 50;
const SHORT_CACHE_TIMEOUT = 10;
const COSTMATRIX_TIMEOUT = 10000; // zGeneral 3/2024 was 20
/**
 * The GlobalCache ($) module saves frequently accessed deserialized objects in temporary, volatile global memory
 */
let $ = class $ {
    // $ = cash = cache... get it? :D
    static structures(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 's' + key;
        if (
            !_cache.structures[cacheKey] ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            _cache.structures[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        } else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                _cache.structures[cacheKey] = _.compact(
                    _.map(_cache.structures[cacheKey] || [], (s) =>
                        Game.getObjectById(s.id),
                    ),
                );
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        return _cache.structures[cacheKey];
    }
    static number(saver, key, callback, timeout = SHORT_CACHE_TIMEOUT) {
        const cacheKey = saver.ref + '#' + key;
        if (
            _cache.numbers[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            _cache.numbers[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        }
        return _cache.numbers[cacheKey];
    }
    static numberRecall(saver, key) {
        const cacheKey = saver.ref + '#' + key;
        return _cache.numbers[cacheKey];
    }
    // static pos(saver: { ref: string }, key: string, callback: () => RoomPosition, timeout ?: number): RoomPosition;
    static pos(saver, key, callback, timeout) {
        const cacheKey = saver.ref + 'p' + key;
        if (
            _cache.roomPositions[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            _cache.roomPositions[cacheKey] = callback();
            if (!timeout) timeout = CACHE_TIMEOUT;
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        }
        return _cache.roomPositions[cacheKey];
    }
    static list(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 'l' + key;
        if (
            _cache.lists[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            _cache.lists[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        }
        return _cache.lists[cacheKey];
    }
    /**
     * Caches a CostMatrix computation. Times out quickly, but you can use $.costMatrixRecall() to pull the value for
     * an invisible room without triggering a recalc
     */
    static costMatrix(roomName, key, callback, timeout = COSTMATRIX_TIMEOUT) {
        const cacheKey = roomName + 'm' + key;
        if (
            _cache.costMatrices[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            // console.log(`[Cache Miss] Recaching costMatrix for room: ${roomName}`)
            _cache.costMatrices[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        } else {
            // console.log(`[Cache Hit] Using cached costMatrix for room: ${roomName}`);
        }
        return _cache.costMatrices[cacheKey];
    }
    /**
     * Returns the value of a previously cached CostMatrix without triggering a cache expiration and recalc
     */
    static costMatrixRecall(roomName, key) {
        const cacheKey = roomName + 'm' + key; // \Geb: bugfix PR#194
        return _cache.costMatrices[cacheKey];
    }
    static path(fromPos, toPos, opts /*todo*/) {
        // TODO
        return [];
    }
    static set(thing, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = thing.ref + '$' + key;
        if (
            !_cache.things[cacheKey] ||
            Game.time > _cache.expiration[cacheKey]
        ) {
            // Recache if new entry or entry is expired
            _cache.things[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(
                timeout,
                Math.ceil(timeout / 10),
            );
        } else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                if (_.isArray(_cache.things[cacheKey])) {
                    _cache.things[cacheKey] = _.compact(
                        _.map(_cache.things[cacheKey], (s) =>
                            Game.getObjectById(s.id),
                        ),
                    );
                } else {
                    _cache.things[cacheKey] = Game.getObjectById(
                        _cache.things[cacheKey].id,
                    );
                }
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        thing[key] = _cache.things[cacheKey];
    }
    static refresh(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (thing[key]) {
                if (_.isArray(thing[key])) {
                    thing[key] = _.compact(
                        _.map(thing[key], (s) => Game.getObjectById(s.id)),
                    );
                } else {
                    thing[key] = Game.getObjectById(thing[key].id);
                }
            }
        });
    }
    static refreshObject(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (_.isObject(thing[key])) {
                for (const prop in thing[key]) {
                    if (_.isArray(thing[key][prop])) {
                        thing[key][prop] = _.compact(
                            _.map(thing[key][prop], (s) =>
                                Game.getObjectById(s.id),
                            ),
                        );
                    } else {
                        thing[key][prop] = Game.getObjectById(
                            thing[key][prop].id,
                        );
                    }
                }
            }
        });
    }
    static refreshRoom(thing) {
        thing.room = Game.rooms[thing.room.name];
    }
};
$ = __decorate([profile], $);

var Stats_1;
/**
 * Operational statistics, stored in Memory.stats, will be updated every (this many) ticks
 */
const LOG_STATS_INTERVAL = 10;
function customProfile(target, key, _descriptor) {
    // case of method decorator
    const originalMethod = _descriptor.value;
    if (!originalMethod) {
        return;
    }
    _descriptor.value = function () {
        var _a;
        const context = this;
        const args = arguments;
        const name = `${
            (_a =
                this === null || this === void 0
                    ? void 0
                    : this.constructor) === null || _a === void 0
                ? void 0
                : _a.name
        }:${key}`;
        return Stats.profileCustom(name, () =>
            originalMethod.apply(context, args),
        );
    };
}
let Stats = (Stats_1 = class Stats {
    static clean() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const protectedKeys = ['persistent'];
            for (const key in Memory.stats) {
                if (!protectedKeys.includes(key)) {
                    delete Memory.stats[key];
                }
            }
        }
    }
    static logIntent(type) {
        this.intents += 1;
        if (!this.intentsByType[type]) {
            this.intentsByType[type] = 0;
        }
        this.intentsByType[type]++;
    }
    static log(key, value, truncateNumbers = true) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            if (truncateNumbers && value != undefined) {
                const decimals = 5;
                if (typeof value == 'number') {
                    value = value.truncate(decimals);
                } else {
                    for (const i in value) {
                        value[i] = value[i].truncate(decimals);
                    }
                }
            }
            Mem.setDeep(Memory.stats, key, value);
        }
    }
    // static accumulate(key: string, value: number): void {
    // 	if (!Memory.stats[key]) {
    // 		Memory.stats[key] = 0;
    // 	}
    // 	Memory.stats[key] += value;
    // }
    static profile(key, callback) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const prevIntents = this.intents;
            const startTime = Game.cpu.getUsed();
            callback();
            const endTime = Game.cpu.getUsed() - startTime;
            const endIntents = this.intents - prevIntents;
            const endTimeWithoutIntents = endTime - 0.22 * endIntents;
            Stats_1.log(`profiler.${key}`, endTimeWithoutIntents);
            // console.log(`profiler.${key}`, endTime.toFixed(2), (0.22 * endIntents).toFixed(2), endTimeWithoutIntents.toFixed(2)); // zgeneral 2/24
        } else {
            callback();
        }
    }
    static profileCustom(key, callback) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const prevIntents = this.intents;
            const startTime = Game.cpu.getUsed();
            const result = callback();
            const endTime = Game.cpu.getUsed() - startTime;
            const endIntents = this.intents - prevIntents;
            const endTimeWithoutIntents = endTime - 0.22 * endIntents;
            if (!this.currentProfiling[key]) {
                this.currentProfiling[key] = {
                    time: 0,
                    count: 0,
                    intents: 0,
                };
            }
            this.currentProfiling[key].time += endTimeWithoutIntents;
            this.currentProfiling[key].count++;
            this.currentProfiling[key].intents += endIntents;
            return result;
        } else {
            return callback();
        }
    }
    static profileWithCount(key, callback, count) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const prevIntents = this.intents;
            const startTime = Game.cpu.getUsed();
            callback();
            const endTime = Game.cpu.getUsed() - startTime;
            const endIntents = this.intents - prevIntents;
            const endTimeWithoutIntents = endTime - 0.22 * endIntents;
            Stats_1.log(`profiler.${key}`, {
                time: endTimeWithoutIntents,
                count,
            });
        } else {
            callback();
        }
    }
    static run() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            // Record IVM heap statistics
            Memory.stats['cpu.heapStatistics'] = Game.cpu.getHeapStatistics();
            // Log GCL
            this.log('gcl.progress', Game.gcl.progress);
            this.log('gcl.progressTotal', Game.gcl.progressTotal);
            this.log('gcl.level', Game.gcl.level);
            // Log memory usage
            this.log('memory.used', RawMemory.get().length);
            // Log CPU
            this.log('cpu.limit', Game.cpu.limit);
            this.log('cpu.bucket', Game.cpu.bucket);
        }
        const used = Game.cpu.getUsed();
        this.log('cpu.getUsed', used);
        Memory.stats.persistent.avgCPU = ema(
            used,
            Memory.stats.persistent.avgCPU,
            100,
        );
        Memory.stats.persistent.empireAge = Memory.tick;
        Memory.stats.persistent.build = Memory.build;
    }
    static beginTick() {
        this.intents = 0;
        this.intentsByType = {};
        this.currentProfiling = {};
    }
    static endTick() {
        this.log('intents', this.intents);
        this.log('intentCPU', this.intents * 0.22);
        this.log('intentsByType', this.intentsByType);
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            Mem.setDeep(
                Memory.stats,
                'profiler.current',
                this.currentProfiling,
            );
        }
    }
});
Stats.intents = 0;
Stats.intentsByType = {};
Stats.currentProfiling = {};
Stats = Stats_1 = __decorate([profile], Stats);

var Mem_1;
var Autonomy;
(function (Autonomy) {
    Autonomy[(Autonomy['ManualExtreme'] = -1)] = 'ManualExtreme';
    Autonomy[(Autonomy['Manual'] = 0)] = 'Manual';
    Autonomy[(Autonomy['SemiAutomatic'] = 1)] = 'SemiAutomatic';
    Autonomy[(Autonomy['Automatic'] = 2)] = 'Automatic';
})(Autonomy || (Autonomy = {}));
function getAutonomyLevel() {
    switch (Memory.settings.operationMode) {
        case 'manual_extreme':
            return Autonomy.ManualExtreme;
        case 'manual':
            return Autonomy.Manual;
        case 'semiautomatic':
            return Autonomy.SemiAutomatic;
        case 'automatic':
            return Autonomy.Automatic;
        default:
            log.warning(
                `ERROR: ${Memory.settings.operationMode} is not a valid operation mode! ` +
                    `Defaulting to ${DEFAULT_OPERATION_MODE}; use setMode() to change.`,
            );
            Memory.settings.operationMode = DEFAULT_OPERATION_MODE;
            return getAutonomyLevel();
    }
}
let lastMemory;
let lastTime = 0;
const MAX_BUCKET = 10000;
const HEAP_CLEAN_FREQUENCY = 200;
const BUCKET_CLEAR_CACHE = 7000;
const BUCKET_CPU_HALT = 4000;
/**
 * This module contains a number of low-level memory clearing and caching functions
 */
let Mem = (Mem_1 = class Mem {
    static shouldRun() {
        let shouldRun = true;
        if (!isIVM()) {
            log.warning(
                `Overmind requires isolated-VM to run. Change settings at screeps.com/a/#!/account/runtime`,
            );
            shouldRun = false;
        }
        if (Game.cpu.bucket < 500) {
            if (
                _.keys(Game.spawns).length > 1 &&
                !Memory.resetBucket &&
                !Memory.haltTick
            ) {
                // don't run CPU reset routine at very beginning or if it's already triggered
                log.warning(
                    `CPU bucket is critically low (${Game.cpu.bucket})! Starting CPU reset routine.`,
                );
                Memory.resetBucket = true;
                Memory.haltTick = Game.time + 1; // reset global next tick
            } else {
                log.info(
                    `CPU bucket is too low (${Game.cpu.bucket}). Postponing operation until bucket reaches 500.`,
                );
            }
            shouldRun = false;
        }
        if (Memory.resetBucket) {
            if (Game.cpu.bucket < MAX_BUCKET - Game.cpu.limit) {
                log.info(
                    `Operation suspended until bucket recovery. Bucket: ${Game.cpu.bucket}/${MAX_BUCKET}`,
                );
                shouldRun = false;
            } else {
                delete Memory.resetBucket;
            }
        }
        if (Memory.haltTick) {
            if (Memory.haltTick == Game.time) {
                if (Game.cpu.halt) {
                    // this is undefined on non-IVM
                    Memory.build--; // don't count this reset as a build
                    Game.cpu.halt();
                }
                shouldRun = false;
            } else if (Memory.haltTick < Game.time) {
                delete Memory.haltTick;
            }
        }
        return shouldRun;
    }
    /**
     * Attempt to load the parsed memory from a previous tick to avoid parsing costs
     */
    static load() {
        if (lastTime && lastMemory && Game.time == lastTime + 1) {
            delete global.Memory;
            global.Memory = lastMemory;
            RawMemory._parsed = lastMemory;
        } else {
            // noinspection BadExpressionStatementJS
            /* tslint:disable:no-unused-expression */
            Memory.rooms; // forces parsing
            /* tslint:enable:no-unused-expression */
            lastMemory = RawMemory._parsed;
            Memory.stats.persistent.lastMemoryReset = Game.time;
        }
        lastTime = Game.time;
        // Handle global time
        if (!global.GLOBAL_AGE) {
            global.GLOBAL_AGE = 0;
        }
        global.GLOBAL_AGE++;
        Memory.stats.persistent.globalAge = global.GLOBAL_AGE;
    }
    static garbageCollect(quick) {
        if (global.gc) {
            // sometimes garbage collection isn't available
            const start = Game.cpu.getUsed();
            global.gc(quick);
            log.debug(
                `Running ${quick ? 'quick' : 'FULL'} garbage collection. ` +
                    `Elapsed time: ${Game.cpu.getUsed() - start}.`,
            );
        } else {
            log.debug(
                `Manual garbage collection is unavailable on this server.`,
            );
        }
    }
    /**
     * Wrap a parent memory object with a key name and set the default properties for the child memory object if needed
     */
    static wrap(memory, memName, getDefaults = () => ({})) {
        if (memory[memName] === undefined) {
            memory[memName] = getDefaults();
        } else if (Game.time == LATEST_GLOBAL_RESET_TICK) {
            // mem defaults would only change with a global reset
            _.defaultsDeep(memory[memName], getDefaults());
        }
        // if (deep) {
        // 	_.defaultsDeep(memory[memName], defaults);
        // } else {
        // 	_.defaults(memory[memName], defaults);
        // }
        return memory[memName];
    }
    static _setDeep(object, keys, value) {
        const key = _.first(keys);
        keys = _.drop(keys);
        if (keys.length == 0) {
            // at the end of the recursion
            object[key] = value;
            return;
        } else {
            if (!object[key]) {
                object[key] = {};
            }
            return Mem_1._setDeep(object[key], keys, value);
        }
    }
    /**
     * Recursively set a value of an object given a dot-separated key, adding intermediate properties as necessary
     * Ex: Mem.setDeep(Memory.colonies, 'E1S1.miningSites.siteID.stats.uptime', 0.5)
     */
    static setDeep(object, keyString, value) {
        const keys = keyString.split('.');
        return Mem_1._setDeep(object, keys, value);
    }
    static getDefaultMemory() {
        return {
            tick: Game.time,
            build: 0,
            assimilator: {},
            Overmind: {},
            combatPlanner: {},
            profiler: {},
            overseer: {},
            segmenter: {},
            roomIntel: {},
            colonies: {},
            rooms: {},
            creeps: {},
            powerCreeps: {},
            flags: {},
            spawns: {},
            pathing: { distances: {} },
            constructionSites: {},
            stats: { persistent: {} },
            playerCreepTracker: {},
            settings: {
                signature: DEFAULT_OVERMIND_SIGNATURE,
                operationMode: DEFAULT_OPERATION_MODE,
                log: {},
                enableVisuals: true,
                resourceCollectionMode: 0,
                allies: [
                    MY_USERNAME,
                    'reggaemuffin',
                    'Davaned',
                    'zGeneral',
                    'Muon',
                ],
                bucketThresholds: {
                    visuals: 5000,
                    powerCollection: 8500,
                    autoAttack: 8000,
                    autoPoison: 8750,
                    terminalNetwork: 9500,
                    randomWalkScouts: 9800,
                    newOutposts: 9500,
                },
                intervals: {
                    registerLogisticsRequests: 10,
                    handleBootstrapping: 10,
                    handleOutpostDefense: 10,
                    handleColonyInvasions: 10,
                    handleNukeResponse: 10,
                },
                powerProcessing: {
                    minEnergy: 100000,
                    fullThrottle: 500000,
                },
                powerCollection: {
                    enabled: true,
                    maxRange: 5,
                    minPower: 5000,
                },
                autoPoison: {
                    enabled: false,
                    maxRange: 4,
                    maxConcurrent: 1,
                },
                autoAttack: {
                    enable: true,
                    autoAttackWhiteList: [],
                    autoAttackWatchList: [],
                },
                scatterShotFrequency: 3,
            },
        };
    }
    static format() {
        // Format the memory as needed, done once every global reset
        _.defaultsDeep(Memory, Mem_1.getDefaultMemory());
        // Increment build counter (if global reset is due to CPU halt, the count will have been decremented)
        Memory.build++;
        // Make global memory
        this.initGlobalMemory();
    }
    static initGlobalMemory() {
        const defaultGlobalCache = {
            accessed: {},
            expiration: {},
            structures: {},
            numbers: {},
            lists: {},
            costMatrices: {},
            roomPositions: {},
            things: {},
        };
        global._cache = defaultGlobalCache;
    }
    static clean() {
        // Clean the memory of non-existent objects every tick
        this.cleanHeap();
        this.cleanCreeps();
        this.cleanFlags();
        this.cleanColonies();
        this.cleanPathingMemory();
        this.cleanConstructionSites();
        Stats.clean();
    }
    /**
     * Attempt to clear some things out of the global heap to prevent increasing CPU usage
     */
    static cleanHeap() {
        if (Game.time % HEAP_CLEAN_FREQUENCY == HEAP_CLEAN_FREQUENCY - 3) {
            if (
                Game.cpu.bucket < BUCKET_CPU_HALT &&
                Game.cpu.halt !== undefined
            ) {
                Memory.build--; // don't count this reset as a build
                Game.cpu.halt();
            } else if (Game.cpu.bucket < BUCKET_CLEAR_CACHE) {
                delete global._cache;
                this.initGlobalMemory();
            }
        }
    }
    static cleanCreeps() {
        // Clear memory for non-existent creeps
        for (const name in Memory.creeps) {
            if (!Game.creeps[name]) {
                delete Memory.creeps[name];
                delete global[name];
            }
        }
    }
    static cleanFlags() {
        // Clear memory for non-existent flags
        for (const name in Memory.flags) {
            if (!Game.flags[name]) {
                delete Memory.flags[name];
                delete global[name];
            }
        }
    }
    static cleanColonies() {
        // Clear memory of dead colonies
        for (const name in Memory.colonies) {
            const room = Game.rooms[name];
            if (!(room && room.my)) {
                // Delete only if "persistent" is not set - use case: praise rooms
                if (!Memory.colonies[name].persistent) {
                    delete Memory.colonies[name];
                    delete global[name];
                }
            }
        }
    }
    static cleanConstructionSites() {
        // Remove ancient construction sites
        if (Game.time % 20 == 0) {
            const CONSTRUCTION_SITE_TIMEOUT = 100000; // sites time out after this long
            const UNBUILT_CONSTRUCTION_SITE_TIMEOUT = 1000; // sites that haven't made any progress time out
            // Add constructionSites to memory and remove really old ones
            for (const id in Game.constructionSites) {
                const site = Game.constructionSites[id];
                if (!Memory.constructionSites[id]) {
                    Memory.constructionSites[id] = Game.time;
                } else if (
                    Game.time - Memory.constructionSites[id] >=
                    CONSTRUCTION_SITE_TIMEOUT
                ) {
                    site.remove();
                } else if (
                    site.progress == 0 &&
                    Game.time - Memory.constructionSites[id] >=
                        UNBUILT_CONSTRUCTION_SITE_TIMEOUT
                ) {
                    site.remove();
                }
                // Remove duplicate construction sites that get placed on top of existing structures due to caching
                if (
                    site &&
                    site.pos.isVisible &&
                    site.pos.lookForStructure(site.structureType)
                ) {
                    site.remove();
                }
            }
            // Remove dead constructionSites from memory
            for (const id in Memory.constructionSites) {
                if (!Game.constructionSites[id]) {
                    delete Memory.constructionSites[id];
                }
            }
        }
    }
    static cleanPathingMemory() {
        const CLEAN_FREQUENCY = 5;
        if (Game.time % CLEAN_FREQUENCY == 0) {
            const distanceCleanProbability = 0.001 * CLEAN_FREQUENCY;
            // Randomly clear some cached path lengths
            for (const pos1Name in Memory.pathing.distances) {
                if (_.isEmpty(Memory.pathing.distances[pos1Name])) {
                    delete Memory.pathing.distances[pos1Name];
                } else {
                    for (const pos2Name in Memory.pathing.distances[pos1Name]) {
                        if (Math.random() < distanceCleanProbability) {
                            delete Memory.pathing.distances[pos1Name][pos2Name];
                        }
                    }
                }
            }
            // // Randomly clear weighted distances
            // for (const pos1Name in Memory.pathing.weightedDistances) {
            // 	if (_.isEmpty(Memory.pathing.weightedDistances[pos1Name])) {
            // 		delete Memory.pathing.weightedDistances[pos1Name];
            // 	} else {
            // 		for (const pos2Name in Memory.pathing.weightedDistances[pos1Name]) {
            // 			if (Math.random() < weightedDistanceCleanProbability) {
            // 				delete Memory.pathing.weightedDistances[pos1Name][pos2Name];
            // 			}
            // 		}
            // 	}
            // }
        }
    }
});
Mem = Mem_1 = __decorate([profile], Mem);

var Abathur_1;
const REACTION_PRIORITIES = [
    BOOST_TIERS.construct.T1,
    RESOURCE_HYDROXIDE,
    BOOST_TIERS.construct.T2,
    BOOST_TIERS.construct.T3,
    // T1 Boosts
    BOOST_TIERS.attack.T1,
    ///////////////////////////////////////////////BOOST_TIERS.heal.T1, // zgeneral 13/07/2022 remove heal, stop heal
    BOOST_TIERS.ranged.T1,
    BOOST_TIERS.move.T1,
    //BOOST_TIERS.construct.T1, //zgeneral 5/7/2022
    // BOOST_TIERS.dismantle.T1, // zgeneral 5/7/2022
    // BOOST_TIERS.carry.T1,
    // BOOST_TIERS.harvest.T1, // not used yet
    BOOST_TIERS.tough.T1,
    // BOOST_TIERS.upgrade.T1,
    // Reaction intermediates + ghodium
    RESOURCE_GHODIUM,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    // RESOURCE_HYDROXIDE, //zgeneral 5/7/2022
    // T2 Boosts
    BOOST_TIERS.attack.T2,
    ////////////////////////////////////////////////BOOST_TIERS.heal.T2,
    BOOST_TIERS.ranged.T2,
    BOOST_TIERS.move.T2,
    // BOOST_TIERS.construct.T2,
    // BOOST_TIERS.dismantle.T2, // zgeneral 5/7/2022
    // BOOST_TIERS.carry.T2,
    // BOOST_TIERS.harvest.T2, // not used yet
    BOOST_TIERS.tough.T2,
    // BOOST_TIERS.upgrade.T2,
    // T3 Boosts
    BOOST_TIERS.attack.T3,
    ////////////////////////////////////////////////BOOST_TIERS.heal.T3,
    BOOST_TIERS.ranged.T3,
    BOOST_TIERS.move.T3,
    // BOOST_TIERS.construct.T3,
    // BOOST_TIERS.dismantle.T3, // zgeneral 5/7/2022
    // BOOST_TIERS.carry.T3,
    // BOOST_TIERS.harvest.T3, // not used yet
    BOOST_TIERS.tough.T3,
    // BOOST_TIERS.upgrade.T3,
    // Other boosts I don't use as much
    //BOOST_TIERS.construct.T2, // zgeneral 5/7/2022
    //BOOST_TIERS.construct.T3, // zgeneral 5/7/2022
    BOOST_TIERS.carry.T1,
    BOOST_TIERS.carry.T2,
    BOOST_TIERS.carry.T3,
    // BOOST_TIERS.upgrade.T1, // zgeneral 5/7/2022
    // BOOST_TIERS.upgrade.T2, // zgeneral 5/7/2022
    // BOOST_TIERS.upgrade.T3, // zgeneral 5/7/2022
];
/**
 * Abathur is responsible for the evolution of the swarm and directs global production of minerals. Abathur likes
 * efficiency, XGHO2, and high lab uptime, and dislikes pronouns.
 */
let Abathur = (Abathur_1 = class Abathur {
    // Helper methods for identifying different types of resources
    static isMineralOrCompound(resource) {
        return !!_mineralCompoundsAllLookup[resource];
    }
    static isBaseMineral(resource) {
        return !!_baseResourcesLookup[resource];
    }
    static isIntermediateReactant(resource) {
        return INTERMEDIATE_REACTANTS.includes(resource);
    }
    static isBoost(resource) {
        return !!BOOST_PARTS[resource];
    }
    static isAttackBoost(resource) {
        return !!_boostTypesTierLookup.attack[resource];
    }
    static isRangedBoost(resource) {
        return !!_boostTypesTierLookup.ranged[resource];
    }
    static isHealBoost(resource) {
        return !!_boostTypesTierLookup.heal[resource];
    }
    static isToughBoost(resource) {
        return !!_boostTypesTierLookup.tough[resource];
    }
    static isMoveBoost(resource) {
        return !!_boostTypesTierLookup.move[resource];
    }
    static isDismantleBoost(resource) {
        return !!_boostTypesTierLookup.dismantle[resource];
    }
    static isConstructBoost(resource) {
        return !!_boostTypesTierLookup.construct[resource];
    }
    static isUpgradeBoost(resource) {
        return !!_boostTypesTierLookup.upgrade[resource];
    }
    static isHarvestBoost(resource) {
        return !!_boostTypesTierLookup.harvest[resource];
    }
    static isCarryBoost(resource) {
        return !!_boostTypesTierLookup.carry[resource];
    }
    static isDepositResource(resource) {
        return DEPOSITS_ALL.includes(resource);
    }
    static isCommodity(resource) {
        return !!_commoditiesLookup[resource];
    }
    static getBoostTier(boost) {
        return _boostTierLookupAllTypes[boost] || 'notaboost';
    }
    /**
     * Recursively enumerate the base ingredients required to synthesize a unit of the specified compound,
     * e.g. Abathur.enumerateReactionBaseIngredients("XGH2O") = Z,K,U,L,H,O,H,X
     */
    static enumerateReactionBaseIngredients(mineral) {
        if (BASE_RESOURCES.includes(mineral)) {
            return [mineral];
        } else if (REAGENTS[mineral]) {
            return Abathur_1.enumerateReactionBaseIngredients(
                REAGENTS[mineral][0],
            ).concat(
                Abathur_1.enumerateReactionBaseIngredients(
                    REAGENTS[mineral][1],
                ),
            );
        } else {
            return [];
        }
    }
    // Reaction scheduling =============================================================================================
    /**
     * Compute the next reaction that a colony should undertake based on local and global stockpiles of all target
     * compounds.
     */
    static getNextReaction(colony) {
        const BATCH_SIZE = Abathur_1.settings.batchSize;
        const globalAssets = Overmind.terminalNetwork.getAssets();
        const numColonies = _.filter(
            getAllColonies(),
            (colony) => !!colony.terminal,
        ).length;
        let possibleReactions = REACTION_PRIORITIES;
        if (colony.labs.length < 10) {
            // don't make the really long cooldown stuff if you don't have all labs
            possibleReactions = _.filter(
                possibleReactions,
                (resource) => (REACTION_TIME[resource] || Infinity) <= 30,
            );
        }
        // Want to build up a stockpile of high tier boosts, but also to maintain and utilize a stockpile of the
        // cheaper stuff before we start building up higher tier boosts, which have declining returns
        let nextTargetResource;
        const ingredientsUnavailable = {}; // track what we can't make to save CPU
        const maxAmountOfEachBoostPerColony = 50000;
        const maxBatches = Math.ceil(
            maxAmountOfEachBoostPerColony / BATCH_SIZE,
        );
        for (const batchNum of _.range(1, maxBatches)) {
            nextTargetResource = _.find(possibleReactions, (resource) => {
                // If we've already figured out we can't make this in a previous pass then skip it
                if (ingredientsUnavailable[resource]) return false;
                const tier = Abathur_1.getBoostTier(resource);
                // Get 2 labs' worth of a stockpile before you start making T2 boosts
                if (
                    tier == 'T2' &&
                    batchNum * BATCH_SIZE < 2 * LAB_MINERAL_CAPACITY
                ) {
                    return false;
                }
                // Get 3 labs' worth of a stockpile before you start making T3 boosts
                if (
                    tier == 'T3' &&
                    batchNum * BATCH_SIZE < 3 * LAB_MINERAL_CAPACITY
                ) {
                    return false;
                }
                // Don't need to stockpile a ton of reaction intermediates or ghodium
                if (
                    resource == RESOURCE_GHODIUM ||
                    Abathur_1.isIntermediateReactant(resource)
                ) {
                    // If the colony already has more of this this intermediate than it wants, skip it
                    if (
                        colony.assets[resource] >
                        Overmind.terminalNetwork.thresholds(colony, resource)
                            .target
                    ) {
                        return false;
                    }
                }
                // Otherwise, we're allowed to make more of this, so figure out what we should and can make
                const globalShortage =
                    globalAssets[resource] / numColonies <
                    (batchNum - 3) * BATCH_SIZE;
                const localShortage =
                    colony.assets[resource] < batchNum * BATCH_SIZE;
                if (globalShortage || localShortage) {
                    // Do we have enough ingredients (or can we obtain enough) to make this step of the reaction?
                    const [reagent1, reagent2] = REAGENTS[resource];
                    const reagent1Available =
                        colony.assets[reagent1] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(
                            colony,
                            reagent1,
                            BATCH_SIZE,
                        );
                    const reagent2Available =
                        colony.assets[reagent2] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(
                            colony,
                            reagent2,
                            BATCH_SIZE,
                        );
                    if (reagent1Available && reagent2Available) {
                        return true;
                    } else {
                        ingredientsUnavailable[resource] = true; // canObtainResource() is expensive; cache it
                    }
                }
                // We can't make this thing :(
                return false;
            });
            if (nextTargetResource) break;
        }
        if (nextTargetResource) {
            return { mineralType: nextTargetResource, amount: BATCH_SIZE };
        }
    }
    // private static canReceiveBasicMineralsForReaction(mineralQuantities: { [resourceType: string]: number },
    // 												  amount: number): boolean {
    // 	for (const mineral in mineralQuantities) {
    // 		if (!Abathur.someColonyHasExcess(<ResourceConstant>mineral, mineralQuantities[mineral])) {
    // 			return false;
    // 		}
    // 	}
    // 	return true;
    // }
    // private static canBuyBasicMineralsForReaction(mineralQuantities: { [resourceType: string]: number }): boolean {
    // 	if (Game.market.credits < TraderJoe.settings.market.credits.canBuyAbove) {
    // 		return false;
    // 	}
    // 	for (const mineral in mineralQuantities) {
    // 		let maxPrice = maxMarketPrices[mineral] || maxMarketPrices.default;
    // 		if (!onPublicServer()) {
    // 			maxPrice = Infinity;
    // 		}
    // 		if (Overmind.tradeNetwork.priceOf(<ResourceConstant>mineral) > maxPrice) {
    // 			return false;
    // 		}
    // 	}
    // 	return true;
    // }
    // private static stockAmount(resource: ResourceConstant): number {
    // 	return 0; // (wantedStockAmounts[resource] || priorityStockAmounts[resource] || baseStockAmounts[resource] || 0);
    // }
    // private static hasExcess(colony: Colony, mineralType: ResourceConstant, excessAmount = 0): boolean {
    // 	return colony.assets[mineralType] - excessAmount > Abathur.stockAmount(mineralType);
    // }
    // private static someColonyHasExcess(mineralType: ResourceConstant, excessAmount = 0): boolean {
    // 	return _.any(getAllColonies(), colony => Abathur.hasExcess(colony, mineralType, excessAmount));
    // }
    /**
     * Generate a queue of reactions to produce the most needed compound
     */
    // private static getReactionQueue(colony: Colony, verbose = false): Reaction[] {
    // 	// Compute the reaction queue for the highest priority item that you should be and can be making
    // 	const stocksToCheck = [priorityStockAmounts, wantedStockAmounts];
    // 	for (const stocks of stocksToCheck) {
    // 		for (const resourceType in stocks) {
    // 			const amountOwned = colony.assets[resourceType];
    // 			const amountNeeded = stocks[resourceType];
    // 			if (amountOwned < amountNeeded) { // if there is a shortage of this resource
    // 				const reactionQueue = Abathur.buildReactionQueue(colony, <ResourceConstant>resourceType,
    // 																 amountNeeded - amountOwned, verbose);
    // 				const missingBaseMinerals = Abathur.getMissingBasicMinerals(colony, reactionQueue);
    // 				if (!_.any(missingBaseMinerals)
    // 					|| this.canReceiveBasicMineralsForReaction(missingBaseMinerals, amountNeeded + 1000)
    // 					|| this.canBuyBasicMineralsForReaction(missingBaseMinerals)) {
    // 					return reactionQueue;
    // 				} else {
    // 					if (verbose) console.log(`Missing minerals for ${resourceType}: ${JSON.stringify(missingBaseMinerals)}`);
    // 				}
    // 			}
    // 		}
    // 	}
    // 	// If there's nothing you can make, sleep for 100 ticks
    // 	// this.memory.sleepUntil = Game.time + Abathur.settings.sleepTime;
    // 	return [];
    // }
    /**
     * Build a reaction queue for a target compound
     */
    static buildReactionQueue(colony, mineral, amount, verbose = false) {
        amount = Abathur_1.settings.batchSize; // minMax(amount, Abathur.settings.minBatchSize, Abathur.settings.maxBatchSize);
        if (verbose) {
            console.log(
                `Abathur@${colony.room.print}: building reaction queue for ${amount} ${mineral}`,
            );
        }
        let reactionQueue = [];
        for (const ingredient of Abathur_1.enumerateReactionProducts(mineral)) {
            let productionAmount = amount;
            if (ingredient != mineral) {
                if (verbose) {
                    console.log(
                        `productionAmount: ${productionAmount}, assets: ${colony.assets[ingredient]}`,
                    );
                }
                productionAmount = Math.max(
                    productionAmount - colony.assets[ingredient],
                    0,
                );
            }
            productionAmount = Math.min(
                productionAmount,
                Abathur_1.settings.batchSize,
            );
            reactionQueue.push({
                mineralType: ingredient,
                amount: productionAmount,
            });
        }
        if (verbose) {
            console.log(`Pre-trim queue: ${JSON.stringify(reactionQueue)}`);
        }
        reactionQueue = Abathur_1.trimReactionQueue(reactionQueue);
        if (verbose) {
            console.log(`Post-trim queue: ${JSON.stringify(reactionQueue)}`);
        }
        reactionQueue = _.filter(reactionQueue, (rxn) => rxn.amount > 0);
        if (verbose) {
            console.log(`Final queue: ${JSON.stringify(reactionQueue)}`);
        }
        return reactionQueue;
    }
    /**
     * Trim a reaction queue, reducing the amounts of precursor compounds which need to be produced
     */
    static trimReactionQueue(reactionQueue) {
        // Scan backwards through the queue and reduce the production amount of subsequently baser resources as needed
        reactionQueue.reverse();
        for (const reaction of reactionQueue) {
            const [ing1, ing2] = REAGENTS[reaction.mineralType];
            const precursor1 = _.findIndex(
                reactionQueue,
                (rxn) => rxn.mineralType == ing1,
            );
            const precursor2 = _.findIndex(
                reactionQueue,
                (rxn) => rxn.mineralType == ing2,
            );
            for (const index of [precursor1, precursor2]) {
                if (index != -1) {
                    if (reactionQueue[index].amount == 0) {
                        reactionQueue[index].amount = 0;
                    } else {
                        reactionQueue[index].amount = Math.min(
                            reaction.amount,
                            reactionQueue[index].amount,
                        );
                    }
                }
            }
        }
        reactionQueue.reverse();
        return reactionQueue;
    }
    /**
     * Figure out which basic minerals are missing and how much
     */
    static getMissingBasicMinerals(colony, reactionQueue, verbose = false) {
        const requiredBasicMinerals = Abathur_1.getRequiredBasicMinerals(
            reactionQueue,
        );
        if (verbose) {
            console.log(
                `Required basic minerals: ${JSON.stringify(
                    requiredBasicMinerals,
                )}`,
            );
        }
        if (verbose) console.log(`assets: ${JSON.stringify(colony.assets)}`);
        const missingBasicMinerals = {};
        for (const mineralType in requiredBasicMinerals) {
            const amountMissing =
                requiredBasicMinerals[mineralType] - colony.assets[mineralType];
            if (amountMissing > 0) {
                missingBasicMinerals[mineralType] = amountMissing;
            }
        }
        if (verbose) {
            console.log(
                `Missing basic minerals: ${JSON.stringify(
                    missingBasicMinerals,
                )}`,
            );
        }
        return missingBasicMinerals;
    }
    /**
     * Get the required amount of basic minerals for a reaction queue
     */
    static getRequiredBasicMinerals(reactionQueue) {
        const requiredBasicMinerals = {
            [RESOURCE_HYDROGEN]: 0,
            [RESOURCE_OXYGEN]: 0,
            [RESOURCE_UTRIUM]: 0,
            [RESOURCE_KEANIUM]: 0,
            [RESOURCE_LEMERGIUM]: 0,
            [RESOURCE_ZYNTHIUM]: 0,
            [RESOURCE_CATALYST]: 0,
        };
        for (const reaction of reactionQueue) {
            const ingredients = REAGENTS[reaction.mineralType];
            for (const ingredient of ingredients) {
                if (!REAGENTS[ingredient]) {
                    // resource is base mineral
                    requiredBasicMinerals[ingredient] += reaction.amount;
                }
            }
        }
        return requiredBasicMinerals;
    }
    /**
     * Recursively generate a list of outputs from reactions required to generate a compound
     */
    static enumerateReactionProducts(mineral) {
        if (!REAGENTS[mineral] || _.isEmpty(mineral)) {
            return [];
        } else {
            return Abathur_1.enumerateReactionProducts(
                REAGENTS[mineral][0],
            ).concat(
                Abathur_1.enumerateReactionProducts(REAGENTS[mineral][1]),
                mineral,
            );
        }
    }
});
Abathur.settings = {
    batchSize: 1600,
};
Abathur = Abathur_1 = __decorate([profile], Abathur);
global.Abathur = Abathur;

var TraderJoe_1;
const getDefaultTraderMemory = () => ({
    cache: {
        sell: {},
        buy: {},
        energyPrice: {
            sell: 0.1,
            buy: 0.1,
        },
        history: {},
        tick: 0,
        enabled: true,
    },
    canceledOrders: [],
});
const getDefaultTraderStats = () => ({
    credits: 0,
    bought: {},
    sold: {},
});
// Maximum prices I'm willing to pay to buy various resources - based on shard2 market data in June 2018
// (might not always be up to date)
// export const maxMarketPrices: { [resourceType: string]: number } = {
// 	default                          : 5.0,
// 	[RESOURCE_HYDROGEN]              : 0.3,
// 	[RESOURCE_OXYGEN]                : 0.25,
// 	[RESOURCE_UTRIUM]                : 0.3,
// 	[RESOURCE_LEMERGIUM]             : 0.25,
// 	[RESOURCE_KEANIUM]               : 0.25,
// 	[RESOURCE_ZYNTHIUM]              : 0.25,
// 	[RESOURCE_CATALYST]              : 0.5,
// 	[RESOURCE_ENERGY]                : 0.05,
// 	[RESOURCE_CATALYZED_GHODIUM_ACID]: 1.2,
// };
const ERR_NO_ORDER_TO_BUY_FROM = -101;
const ERR_NO_ORDER_TO_SELL_TO = -102;
const ERR_INSUFFICIENT_ENERGY_IN_TERMINAL = -103; // ERR_NOT_ENOUGH_ENERGY is same as ERR_NOT_ENOUGH_RESOURCES
const ERR_NOT_ENOUGH_MARKET_DATA = -104;
const ERR_TOO_MANY_ORDERS_OF_TYPE = -105;
const ERR_SELL_DIRECT_PRICE_TOO_LOW = -106;
const ERR_BUY_DIRECT_PRICE_TOO_HIGH = -107;
const ERR_CREDIT_THRESHOLDS = -108;
const ERR_DONT_BUY_REACTION_INTERMEDIATES = -109;
const ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS = -110;
const defaultTradeOpts = {
    preferDirect: false,
    flexibleAmount: true,
    ignoreMinAmounts: false,
    ignorePriceChecksForDirect: false,
    dryRun: false,
};
/**
 * The trade network controls resource acquisition and disposal on the player market.
 */
let TraderJoe = (TraderJoe_1 = class TraderJoe {
    constructor() {
        this.name = 'TradeNetwork';
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(
            Memory.Overmind,
            'trader',
            getDefaultTraderMemory,
        );
        this.stats = Mem.wrap(
            Memory.stats.persistent,
            'trader',
            getDefaultTraderStats,
        );
        this.notifications = [];
        this.ordersPlacedThisTick = 0;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert('TradeNetwork:', args);
        }
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    /**
     * Returns the approximate price of a mineral - shouldn't be used for optimizing prices, just as a ballpark
     * feasibility estimate
     */
    priceOf(mineralType) {
        if (this.memory.cache.history[mineralType]) {
            return this.memory.cache.history[mineralType].avg;
        } else {
            return Infinity;
        }
    }
    /**
     * Builds a cache for market - this is very expensive; use infrequently
     */
    buildMarketCache(verbose = false, orderThreshold = 1000) {
        this.debug('Building market cache');
        this.invalidateMarketCache();
        const myActiveOrderIDs = _.map(
            _.filter(Game.market.orders, (order) => order.active),
            (order) => order.id,
        );
        const allOrders = Game.market.getAllOrders(
            (order) =>
                !myActiveOrderIDs.includes(order.id) &&
                order.amount >= orderThreshold,
        ); // don't include tiny orders
        const groupedBuyOrders = _.groupBy(
            _.filter(allOrders, (o) => o.type == ORDER_BUY),
            (o) => o.resourceType,
        );
        const groupedSellOrders = _.groupBy(
            _.filter(allOrders, (o) => o.type == ORDER_SELL),
            (o) => o.resourceType,
        );
        for (const resourceType in groupedBuyOrders) {
            // Store buy order with maximum price in cache
            const prices = _.map(
                groupedBuyOrders[resourceType],
                (o) => o.price,
            );
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose) {
                console.log(`${resourceType} BUY: high: ${high}  low: ${low}`);
            }
            // this.memory.cache.buy[resourceType] = minBy(groupedBuyOrders[resourceType], (o:Order) => -1 * o.price);
            this.memory.cache.buy[resourceType] = { high: high, low: low };
        }
        for (const resourceType in groupedSellOrders) {
            // Store sell order with minimum price in cache
            const prices = _.map(
                groupedSellOrders[resourceType],
                (o) => o.price,
            );
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose) {
                console.log(`${resourceType} SELL: high: ${high}  low: ${low}`);
            }
            // this.memory.cache.sell[resourceType] = minBy(groupedSellOrders[resourceType], (o:Order) => o.price);
            this.memory.cache.sell[resourceType] = { high: high, low: low };
        }
        this.memory.cache.tick = Game.time;
        this.memory.cache.enabled = allOrders.length > 0;
    }
    /**
     * Builds a cache for market - this is very expensive; use infrequently
     */
    buildMarketHistoryCache() {
        this.debug('Building market history cache');
        const history = Game.market.getHistory();
        const historyByResource = _.groupBy(
            history,
            (hist) => hist.resourceType,
        );
        // Compute stats for each resource
        for (const resource in historyByResource) {
            const resourceHistory = _.sortBy(
                historyByResource[resource],
                (hist) => hist.date,
            ); // oldest to newest
            const prices = _.map(resourceHistory, (hist) => hist.avgPrice);
            // Get average price and standard deviation for today
            const avg = _.last(resourceHistory).avgPrice;
            const std = _.last(resourceHistory).stddevPrice;
            // Compute average price over last 14 days
            const avg14 =
                _.sum(resourceHistory, (hist) => hist.avgPrice * hist.volume) /
                _.sum(resourceHistory, (hist) => hist.volume); // this could be Infinity
            // Compute average standard deviation over last 14 days using Bessel-corrected variance summation
            const std14 = Math.sqrt(
                _.sum(
                    resourceHistory,
                    (h) =>
                        h.volume * (h.avgPrice - avg14) ** 2 +
                        h.stddevPrice ** 2,
                ) / _.sum(resourceHistory, (h) => h.volume),
            ); // this could be Infinity
            this.memory.cache.history[resource] = {
                avg,
                std,
                avg14,
                std14,
            };
        }
    }
    /**
     * Computes the effective price of energy accounting for transfer costs
     */
    computeEffectiveEnergyPrices() {
        const energyOrders = _(
            Game.market.getAllOrders({ resourceType: RESOURCE_ENERGY }),
        )
            .filter((order) => order.amount >= 5000)
            .groupBy((order) => order.type)
            .value();
        const sellOrders = energyOrders[ORDER_SELL];
        const buyOrders = energyOrders[ORDER_BUY];
        for (const colony of _.sample(getAllColonies(), 5)) {
            const room = colony.room.name;
            const sellDirectPrice = maxBy(
                buyOrders,
                (order) =>
                    order.price - this.marginalTransactionPrice(order, room),
            );
            const buyDirectPrice = minBy(
                sellOrders,
                (order) =>
                    order.price + this.marginalTransactionPrice(order, room),
            );
            const sellOrderPrice = this.computeCompetitivePrice(
                ORDER_SELL,
                RESOURCE_ENERGY,
                room,
            );
            const buyOrderPrice = this.computeCompetitivePrice(
                ORDER_BUY,
                RESOURCE_ENERGY,
                room,
            );
        }
        // TODO: this implicitly requires knonwledge of energy price for this.marginalTransactionPrice() -> problematic?
    }
    invalidateMarketCache() {
        this.memory.cache = getDefaultTraderMemory().cache;
    }
    // /**
    //  * Pretty-prints transaction information in the console
    //  */
    // private logTransaction(order: Order, terminalRoomName: string, amount: number, response: number): void {
    // 	const cost = (order.price * amount).toFixed(0);
    // 	const fee = order.roomName ? Game.market.calcTransactionCost(amount, order.roomName, terminalRoomName) : 0;
    // 	const roomName = printRoomName(terminalRoomName, true);
    // 	let msg: string;
    // 	if (order.type == ORDER_SELL) { // I am buying
    // 		msg = `Direct: ${roomName} ${leftArrow} ${Math.round(amount)} ${order.resourceType} ${leftArrow} ` +
    // 			  `${printRoomName(order.roomName!)} (-${cost}c)`;
    // 		if (response != OK) {
    // 			msg += ` (ERROR: ${response})`;
    // 		}
    // 	} else { // I am selling
    // 		msg = `Direct: ${roomName} ${rightArrow} ${Math.round(amount)} ${order.resourceType} ${rightArrow} ` +
    // 			  `${printRoomName(order.roomName!)} (+${cost}c)`;
    // 		if (response != OK) {
    // 			msg += ` (ERROR: ${response})`;
    // 		}
    // 	}
    // 	// this.notify(msg); // use the transactions from the ledger instead
    // }
    /**
     * Returns a list of orders you have already placed for this type for this resource.
     * If roomName is undefined, count any of your orders; if roomName is specified, only return if order is in room
     */
    getExistingOrders(type, resource, roomName) {
        let orders;
        if (roomName) {
            orders = _.filter(
                Game.market.orders,
                (order) =>
                    order.type == type &&
                    (order.resourceType == resource || resource == 'any') &&
                    order.roomName == roomName,
            );
            if (orders.length > 1 && resource != 'any') {
                log.error(
                    `Multiple orders for ${resource} detected in ${printRoomName(
                        roomName,
                    )}!`,
                );
            }
        } else {
            orders = _.filter(
                Game.market.orders,
                (order) =>
                    order.type == type &&
                    (order.resourceType == resource || resource == 'any'),
            );
        }
        return orders;
    }
    /**
     * Returns whether an order is yours
     */
    isOrderMine(order) {
        return Game.rooms[order.roomName] && Game.rooms[order.roomName].my;
    }
    /**
     * The effective cost in credits of the energy transfer cost per unit to deal to a given order
     */
    marginalTransactionPrice(order, dealerRoomName) {
        if (order.roomName) {
            const transferCost =
                Game.market.calcTransactionCost(
                    10000,
                    order.roomName,
                    dealerRoomName,
                ) / 10000;
            // Average distance between any two rooms is 25 since the map wraps, which has 56% transaction price, so
            // energy is 44% what is is normally. This is a bit pessimistic, so let's bump it to 55%, which currently
            // is what computeCompetitivePrice(sell, energy) is telling me it should be around...
            const energyPriceGuess =
                0.55 * this.memory.cache.history.energy.avg14;
            const energyToCreditMultiplier = Math.min(energyPriceGuess, 0.1);
            return transferCost * energyToCreditMultiplier;
        } else {
            // no order.roomName means subscription token, and I don't trade these so this should never get used
            log.error(`order.roomName is unspecified!`);
            return Infinity;
        }
    }
    /**
     * Computes the **approximate** cost to obtain the base resources needed to synthesize a compound.
     * Could be more optimized to include stuff like energy transfer cost, etc.
     * Returns Infinity if insufficient market data is present.
     */
    getPriceForBaseIngredients(resource /*, colony?: Colony*/) {
        const ingredients = Abathur.enumerateReactionBaseIngredients(resource);
        if (ingredients.length > 0) {
            // a synthesizeable compound
            return _.sum(ingredients, (res) =>
                this.memory.cache.history[res]
                    ? this.memory.cache.history[res].avg14 || Infinity
                    : Infinity,
            );
        } else {
            // not synthesizeable
            if (this.memory.cache.history[resource]) {
                return this.memory.cache.history[resource].avg14;
            } else {
                return Infinity;
            }
        }
    }
    /**
     * Computes a competitive market price to buy or sell resources at or to adjust existing orders to.
     * Returns Infinity if sanity checks are not passed or if there is insufficient data to generate a buy price,
     * in which case the items should not be sold.
     */
    computeCompetitivePrice(type, resource, room) {
        // Find out how much all the ingredients to make this should cost
        const priceForBaseResources = this.getPriceForBaseIngredients(resource);
        if (priceForBaseResources == 0 || priceForBaseResources == Infinity) {
            log.error(`Cannot get base ingredient price for ${resource}!`);
            return Infinity;
        }
        // Get all orders for this resource and group by type
        const allOrdersOfResource = _.groupBy(
            Game.market.getAllOrders({ resourceType: resource }),
            'type',
        );
        const allBuyOrders = allOrdersOfResource[ORDER_BUY];
        const allSellOrders = allOrdersOfResource[ORDER_SELL];
        // Find most competitive orders, ignoring small orders and orders which are mine
        const highestBuyOrder = maxBy(allBuyOrders, (o) =>
            o.amount < 100 || this.isOrderMine(o)
                ? false
                : o.price - this.marginalTransactionPrice(o, room),
        );
        const lowestSellOrder = minBy(allSellOrders, (o) =>
            o.amount < 100 || this.isOrderMine(o)
                ? false
                : o.price + this.marginalTransactionPrice(o, room),
        );
        if (!highestBuyOrder || !lowestSellOrder) {
            log.error(`No buy orders or no sell orders for ${resource}!`);
            return Infinity;
        }
        // Compute an adjustment factor based on how long it's been sitting on the market
        const adjustMagnitude = 0.1;
        let adjustment = 1;
        const existingOrder = _.first(
            this.getExistingOrders(ORDER_SELL, resource, room),
        );
        if (existingOrder) {
            const timeOnMarket = Game.time - existingOrder.created;
            const orderDiscountTimescale = 50000; // order will change by adjustMagnitude percent every this many ticks
            adjustment =
                (adjustment + timeOnMarket / orderDiscountTimescale) / 2;
        }
        // Compute the price, returning Infinity if sanity checks are not passed
        if (type == ORDER_SELL) {
            // if you are trying to sell a resource to buyers, undercut their prices a bit
            const discountFactor = 1 - adjustment * adjustMagnitude;
            const marketRate = Math.max(
                lowestSellOrder.price,
                highestBuyOrder.price,
            );
            const price = marketRate * discountFactor;
            this.debug(
                `Candidate price to ${type} ${resource} in ${printRoomName(
                    room,
                )}: ${price}`,
            );
            // If the sell price is greater than the lowestSell order price, it might mean an opportunity for arbitrage
            if (price > lowestSellOrder.price);
            // It's not sensible to sell at a lower cost than what you paid to make it
            // TODO: batteries were not getting sold, needed to treat them as mineral with 50% discount
            // TODO: make pricing dynamic based on stock pile
            if (
                (!Abathur.isBaseMineral(resource) &&
                    resource != RESOURCE_BATTERY &&
                    price < priceForBaseResources) ||
                // can sell base below market by 50%
                ((resource == RESOURCE_BATTERY ||
                    Abathur.isBaseMineral(resource)) &&
                    price < priceForBaseResources / 2) ||
                price < 0
            ) {
                return Infinity;
            } else {
                return price;
            }
        } else {
            // if you are trying to buy a resource from sellers, offer a little bit more than market rate
            const outbidFactor = 1 + adjustment * adjustMagnitude;
            const marketRate = Math.min(
                highestBuyOrder.price,
                lowestSellOrder.price,
            );
            const price = marketRate * outbidFactor;
            this.debug(
                `Candidate price to ${type} ${resource} in ${printRoomName(
                    room,
                )}: ${price}`,
            );
            // If the buy price is less than the highestBuy order price, it might mean an opportunity for arbitrage
            if (price < highestBuyOrder.price);
            // Don't pay >10x what ingredients cost - about 3.0c for XGHO2 based on March 2020 data
            const maxMarkupWillingToBuyFrom = 3;
            if (price > priceForBaseResources * maxMarkupWillingToBuyFrom) {
                return Infinity;
            } else {
                return price;
            }
        }
    }
    ordersProcessedThisTick() {
        return Game.time % 10 == 5;
    }
    /**
     * Create or maintain an order, extending and repricing as needed
     */
    maintainOrder(terminal, type, resource, amount, opts) {
        this.debug(
            `maintain ${type} order for ${terminal.room.print}: ${amount} ${resource}`,
        );
        // This is all somewhat expensive so only do this occasionally
        if (!this.ordersProcessedThisTick()) {
            return OK; // No action needed on these ticks; we'll pretend this works OK
        }
        // Cap the amount based on the maximum you can make a buy/sell order with
        if (type == ORDER_SELL) {
            amount = Math.min(
                amount,
                TraderJoe_1.settings.market.orders.maxBuyOrderAmount,
            );
        } else {
            amount = Math.min(
                amount,
                TraderJoe_1.settings.market.orders.maxSellOrderAmount,
            );
        }
        // Wait until you accumulate more of the resource to order with bigger transactions
        const minAmount =
            type == ORDER_BUY
                ? TraderJoe_1.settings.market.orders.minBuyOrderAmount
                : TraderJoe_1.settings.market.orders.minSellOrderAmount;
        if (amount < minAmount && !opts.ignoreMinAmounts) {
            this.debug(
                `amount ${amount} less than min amount ${minAmount}; no action taken`,
            );
            return NO_ACTION;
        }
        const existingOrder = _.first(
            this.getExistingOrders(type, resource, terminal.room.name),
        );
        // Maintain an existing order
        if (existingOrder) {
            // Figure out if price should be changed - if the competitive price is now significantly different
            const price = +this.computeCompetitivePrice(
                type,
                resource,
                terminal.room.name,
            ).toFixed(3); // market only allows for 3 decimal places of precision
            if (price == Infinity || price == 0) {
                log.warning(
                    `TradeNetwork: sanity checks not passed to handle existing ${type} order ${resource} ` +
                        `in ${printRoomName(
                            terminal.room.name,
                        )}! - price = ${price} - Not enough market data`,
                );
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            const ratio = existingOrder.price / price;
            const tolerance = 0.03; // might need to tune this, we'll see
            const normalFluctuation =
                1 + tolerance > ratio && ratio > 1 - tolerance;
            // Extend the order if you need to sell more of the resource
            if (amount > existingOrder.remainingAmount && normalFluctuation) {
                const addAmount = amount - existingOrder.remainingAmount;
                const ret = Game.market.extendOrder(
                    existingOrder.id,
                    addAmount,
                );
                this.notify(
                    `${terminal.room.print}: extending ${type} order for ${resource} by ${addAmount}.` +
                        ` Response: ${ret}`,
                );
                return ret;
            }
            // Small chance of changing the price if it's not competitive; don't do too often or you are high risk
            if (!normalFluctuation && Math.random() < 1 / 2000) {
                const ret = Game.market.changeOrderPrice(
                    existingOrder.id,
                    price,
                );
                this.notify(
                    `${terminal.room.print}: changing ${type} order price for ${resource} from ` +
                        `${existingOrder.price} to ${price}. Response: ${ret}`,
                );
                return ret;
            }
            // No action needed
            return OK;
        }
        // Create a new order
        else {
            // Put a cap on the number of orders you can create per tick
            if (
                this.ordersPlacedThisTick >
                TraderJoe_1.settings.market.orders.maxOrdersPlacedPerTick
            ) {
                return NO_ACTION;
            }
            // Only place up to a certain amount of orders
            const existingOrdersForThis = this.getExistingOrders(
                type,
                resource,
            );
            if (
                existingOrdersForThis.length >
                TraderJoe_1.settings.market.orders.maxOrdersForResource
            ) {
                this.notify(
                    `${printRoomName(
                        terminal.room.name,
                        true,
                    )}: could not create ${type} order for ` +
                        `${Math.round(
                            amount,
                        )} ${resource} - too many existing!`,
                );
                return ERR_TOO_MANY_ORDERS_OF_TYPE;
            }
            // Compute the buy or sell price
            const price = +this.computeCompetitivePrice(
                type,
                resource,
                terminal.room.name,
            ).toFixed(3); // market only allows for 3 decimal places of precision
            if (price == Infinity || price == 0) {
                log.warning(
                    `TradeNetwork: sanity checks not passed to create ${type} order ${resource} in ` +
                        `${printRoomName(terminal.room.name)}!`,
                );
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            // adjust the amount to only immediately list what you can afford; it can be extended later
            const brokersFee = price * amount * MARKET_FEE;
            if (Game.market.credits < brokersFee) {
                amount = ((amount * Game.market.credits) / brokersFee) * 0.9;
            }
            // Create the order
            const params = {
                type: type,
                resourceType: resource,
                price: price,
                totalAmount: amount,
                roomName: terminal.room.name,
            };
            //// zGeneral 30/11/2021
            if (resource == RESOURCE_POWER && price > 600) {
                return OK; // No action needed on these ticks; we'll pretend this works OK
                // do not buy power above 50, a hack, fix it later
            }
            const ret = Game.market.createOrder(params);
            let msg = '';
            if (type == ORDER_BUY) {
                msg +=
                    `${printRoomName(
                        terminal.room.name,
                        true,
                    )} creating buy order:  ` +
                    `${Math.round(amount)} ${resource} at price ${price.toFixed(
                        4,
                    )}`;
            } else {
                msg +=
                    `${printRoomName(
                        terminal.room.name,
                        true,
                    )} creating sell order: ` +
                    `${Math.round(amount)} ${resource} at price ${price.toFixed(
                        4,
                    )}`;
            }
            if (ret == OK) {
                this.ordersPlacedThisTick++;
            } else {
                msg += ` ERROR: ${ret}`;
            }
            this.debug(msg);
            this.notify(msg);
            return ret;
        }
    }
    cleanOrders() {
        const ordersToClean = _.filter(Game.market.orders, (order) => {
            // Clean up inactive orders where you've bought/sold everything
            if (order.active == false && order.remainingAmount == 0) {
                return true;
            }
            // These resources are global, i.e they do not associated with colonies, hence do not delete them
            if (
                order.resourceType == CPU_UNLOCK ||
                order.resourceType == PIXEL ||
                order.resourceType == ACCESS_KEY
            ) {
                return false;
            }
            // Clean up very old orders which are almost completed but which have some small amount remaining
            if (
                Game.time - order.created >
                    TraderJoe_1.settings.market.orders.timeout &&
                order.remainingAmount <
                    TraderJoe_1.settings.market.orders.cleanupAmount
            ) {
                return true;
            }
            // Clean up orders placed in colonies which are no longer with us :(
            if (order.roomName && !Overmind.colonies[order.roomName]) {
                return true;
            }
        });
        for (const order of ordersToClean) {
            const ret = Game.market.cancelOrder(order.id);
            if (ret == OK) {
                // Add to canceled orders for tracking
                this.notify(
                    `Cleaning ${order.type} order for ${order.totalAmount} ${order.resourceType}. ` +
                        `Order lifetime: ${Game.time - order.created}`,
                );
                order.lifetime = Game.time - order.created;
                this.memory.canceledOrders.push(order);
                if (this.memory.canceledOrders.length > 300) {
                    this.memory.canceledOrders.shift(); // only keep this many orders in memory
                }
            }
        }
    }
    /**
     * Buy resources directly from a seller using Game.market.deal() rather than making a buy order
     */
    buyDirect(terminal, resource, amount, opts) {
        this.debug(
            `buyDirect for ${terminal.room.print}: ${amount} ${resource}`,
        );
        // If terminal is on cooldown or just did something then skip
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION; // don't return ERR_TIRED here because it doesn't signal an inability to buy
        }
        // Wait until you accumulate more of the resource to buy with bigger transactions
        if (
            amount < TraderJoe_1.settings.market.orders.minBuyDirectAmount &&
            !opts.ignoreMinAmounts &&
            !opts.dryRun
        ) {
            return NO_ACTION;
        }
        // Can only buy what you are allowed to and have space for
        amount = Math.min(
            amount,
            terminal.store.getFreeCapacity(),
            TraderJoe_1.settings.market.orders.maxBuyDirectAmount,
        );
        // If flexibleAmount is allowed, consider buying from orders which don't need the full amount
        const minAmount = opts.flexibleAmount
            ? Math.min(
                  TraderJoe_1.settings.market.orders.minBuyDirectAmount,
                  amount,
              )
            : amount;
        const validOrders = _.filter(
            Game.market.getAllOrders({
                resourceType: resource,
                type: ORDER_SELL,
            }),
            (order) => order.amount >= minAmount,
        );
        // Find the cheapest order, minimizing by (buying price + marginal cost of transaction)
        const order = minBy(
            validOrders,
            (order) =>
                order.price +
                this.marginalTransactionPrice(order, terminal.room.name) -
                order.amount / 1000000000,
        ); // last bit prioritizes biggest orders
        // If no valid order, notify a warning and return an error so it can be handled in .buy()
        if (!order) {
            if (!opts.dryRun) {
                this.notify(
                    `No valid market order to buy from! Buy request: ${amount} ${resource} to ` +
                        `${printRoomName(terminal.room.name)}`,
                );
            }
            return ERR_NO_ORDER_TO_BUY_FROM;
        }
        // Check that the buy price isn't too expensive
        const adjustedPrice =
            order.price +
            this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(
            resource,
        );
        const maxPriceWillingToPay =
            priceForBaseIngredients * (1.5 + Game.market.credits / 2e6);
        this.debug(
            `Price: ${order.price}, Adjusted: ${adjustedPrice}, BaseCost: ${priceForBaseIngredients}, ` +
                `Max: ${maxPriceWillingToPay}`,
        );
        if (
            priceForBaseIngredients == Infinity ||
            (adjustedPrice > maxPriceWillingToPay &&
                !opts.ignorePriceChecksForDirect) ||
            adjustedPrice > 100
        ) {
            // never buy above an absurd threshold, regardless of opts.ignorePriceChecks
            if (!opts.dryRun) {
                this.notify(
                    `Buy direct call is too expenisive! Buy request: ${amount} ${resource} to ` +
                        `${printRoomName(
                            terminal.room.name,
                        )}, adjusted price of best order: ` +
                        `${adjustedPrice.toFixed(4)}`,
                );
            }
            return ERR_BUY_DIRECT_PRICE_TOO_HIGH;
        }
        // Do the deal
        const buyAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(
            buyAmount,
            terminal.room.name,
            order.roomName,
        );
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            // If this is a dry run just check that you have enough credits
            if (opts.dryRun) {
                const haveEnoughCredits =
                    Game.market.credits >= buyAmount * order.price;
                return haveEnoughCredits ? OK : ERR_NOT_ENOUGH_RESOURCES;
            }
            // Otherwise make the deal
            const response = Game.market.deal(
                order.id,
                buyAmount,
                terminal.room.name,
            );
            this.debug(
                `buyDirect executed for ${terminal.room.print}: ${buyAmount} ${resource} (${response})`,
            );
            // this.logTransaction(order, terminal.room.name, amount, response);
            return response;
        } else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    /**
     * Sell resources directly to a buyer using Game.market.deal() rather than making a sell order
     */
    sellDirect(terminal, resource, amount, opts) {
        this.debug(
            `sellDirect for ${terminal.room.print}: ${amount} ${resource}`,
        );
        // If terminal is on cooldown or just did something then skip
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION; // don't return ERR_TIRED here because it doesn't signal an inability to sell
        }
        // Wait until you accumulate more of the resource to sell with bigger transactions
        if (
            amount < TraderJoe_1.settings.market.orders.minSellDirectAmount &&
            !opts.ignoreMinAmounts &&
            !opts.dryRun
        ) {
            return NO_ACTION;
        }
        // Can only sell what you have in store and are allowed to sell
        amount = Math.min(
            amount,
            terminal.store[resource],
            TraderJoe_1.settings.market.orders.maxSellDirectAmount,
        );
        // If flexibleAmount is allowed, consider selling to orders which don't need the full amount
        const minAmount = opts.flexibleAmount
            ? Math.min(
                  amount,
                  TraderJoe_1.settings.market.orders.minSellDirectAmount,
              )
            : amount;
        const validOrders = _.filter(
            Game.market.getAllOrders({
                resourceType: resource,
                type: ORDER_BUY,
            }),
            (order) => order.amount >= minAmount,
        );
        // Find the best order, maximizing by (buying price - marginal loss from transaction)
        const order = maxBy(
            validOrders,
            (order) =>
                order.price -
                this.marginalTransactionPrice(order, terminal.room.name) +
                order.amount / 1000000000,
        ); // last bit prioritizes biggest orders
        // If no order found, notify a warning and return an error so it can be handled in .sell()
        if (!order) {
            if (!opts.dryRun) {
                this.notify(
                    `No valid market order to sell to! Sell request: ${amount} ${resource} from ` +
                        `${printRoomName(terminal.room.name)}`,
                );
            }
            return ERR_NO_ORDER_TO_SELL_TO;
        }
        // Check that the sell price isn't too expensive
        const adjustedPrice =
            order.price -
            this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(
            resource,
        );
        const minPriceWillingToSell = 0.5 * priceForBaseIngredients;
        this.debug(
            `Price: ${order.price}, Adjusted: ${adjustedPrice}, BaseCost: ${priceForBaseIngredients}, ` +
                `Min: ${minPriceWillingToSell}`,
        );
        if (
            priceForBaseIngredients == Infinity ||
            (adjustedPrice < minPriceWillingToSell &&
                !opts.ignorePriceChecksForDirect) ||
            adjustedPrice < 0
        ) {
            // never sell if it will be a net negative, regardless of opts.ignorePriceChecks
            if (!opts.dryRun) {
                this.notify(
                    `Sell direct call is too cheap! Sell request: ${amount} ${resource} from ` +
                        `${printRoomName(
                            terminal.room.name,
                        )}, adjusted price of best order: ` +
                        `${adjustedPrice}`,
                );
            }
            return ERR_SELL_DIRECT_PRICE_TOO_LOW;
        }
        let sellAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(
            sellAmount,
            terminal.room.name,
            order.roomName,
        );
        if (resource == RESOURCE_ENERGY) {
            // if we're selling energy, make sure we have amount + cost
            if (amount + transactionCost > terminal.store[RESOURCE_ENERGY]) {
                sellAmount -= transactionCost;
                if (sellAmount <= 0) {
                    return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
                }
            }
        }
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            // If this is a dry run we should be able to execute the deal by now, so just return OK
            if (opts.dryRun) {
                return OK;
            }
            // Otherwise do the deal
            const response = Game.market.deal(
                order.id,
                sellAmount,
                terminal.room.name,
            );
            this.debug(
                `sellDirect executed for ${terminal.room.print}: ${sellAmount} ${resource} (${response})`,
            );
            // this.logTransaction(order, terminal.room.name, amount, response);
            return response;
        } else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    /**
     * Buy a resource on the market, either through a buy order or directly (usually direct=true will be used)
     */
    buy(terminal, resource, amount, opts = {}) {
        if (Abathur.isBaseMineral(resource)) {
            // base minerals get default treatment
            return ERR_CREDIT_THRESHOLDS; // zGenneral 19/4/2021
        }
        if (!this.memory.cache.enabled) {
            // Markets are disabled in this server
            return ERR_NO_ORDER_TO_BUY_FROM;
        }
        _.defaults(opts, defaultTradeOpts);
        if (
            Game.market.credits <
            TraderJoe_1.settings.market.credits.canBuyAbove
        ) {
            log.error(
                `Credits insufficient to buy resource ${amount} ${resource} to ${terminal.room.print}; ` +
                    `shouldn't be making this TradeNetwork.buy() request!`,
            );
            return ERR_CREDIT_THRESHOLDS;
        }
        if (
            resource == RESOURCE_POWER &&
            (Game.market.credits <
                TraderJoe_1.settings.market.credits.canBuyPowerAbove ||
                Overmind.tradeNetwork.priceOf(RESOURCE_POWER) > 600) // zgeneral 14/04/2023 06/2/2022 price over 60
        ) {
            // zGeneral 1/11/2021
            log.error(
                `Credits insufficient to buy power ${amount} ${resource} to ${terminal.room.print}; ` +
                    `shouldn't be making this TradeNetwork.buy() request!`,
            );
            return ERR_CREDIT_THRESHOLDS;
        }
        if (
            Game.market.credits <
                TraderJoe_1.settings.market.credits.canBuyBoostsAbove &&
            Abathur.isBoost(resource)
        ) {
            log.error(
                `Credits insufficient to buy boost ${amount} ${resource} to ${terminal.room.print}; ` +
                    `shouldn't be making this TradeNetwork.buy() request!`,
            );
            return ERR_CREDIT_THRESHOLDS;
        }
        if (
            Game.market.credits <
                TraderJoe_1.settings.market.credits.canBuyEnergyAbove &&
            resource == RESOURCE_ENERGY
        ) {
            log.error(
                `Credits insufficient to buy ${amount} energy to ${terminal.room.print}; ` +
                    `shouldn't be making this TradeNetwork.buy() request!`,
            );
            return ERR_CREDIT_THRESHOLDS;
        }
        if (
            Abathur.isIntermediateReactant(resource) ||
            resource == RESOURCE_GHODIUM
        ) {
            log.error(
                `Shouldn't request reaction intermediate ${amount} ${resource} to ${terminal.room.print}!`,
            );
            return ERR_DONT_BUY_REACTION_INTERMEDIATES;
        }
        // If you don't have a lot of credits or preferDirect==true, try to sell directly to an existing buy order
        if (
            opts.preferDirect &&
            this.getExistingOrders(ORDER_BUY, resource, terminal.room.name)
                .length == 0
        ) {
            const result = this.buyDirect(terminal, resource, amount, opts);
            if (
                result != ERR_NO_ORDER_TO_BUY_FROM &&
                result != ERR_BUY_DIRECT_PRICE_TOO_HIGH
            ) {
                return result;
            }
            this.notify(
                `Buy direct request: ${amount} ${resource} to ${printRoomName(
                    terminal.room.name,
                )} ` +
                    `was unsuccessful; allowing fallthrough to TradeNetwork.maintainOrder()`,
            );
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        // Fallthrough - if not preferDirect or if existing order or if there's no orders to buy from then make order
        const result = this.maintainOrder(
            terminal,
            ORDER_BUY,
            resource,
            amount,
            opts,
        );
        return result;
    }
    /**
     * Sell a resource on the market, either through a sell order or directly
     */
    sell(terminal, resource, amount, opts = {}) {
        if (!this.memory.cache.enabled) {
            // Markets are disabled in this server
            return ERR_NO_ORDER_TO_SELL_TO;
        }
        _.defaults(opts, defaultTradeOpts);
        // If you don't have a lot of credits or preferDirect==true, try to sell directly to an existing buy order
        if (
            opts.preferDirect ||
            Game.market.credits <
                TraderJoe_1.settings.market.credits.mustSellDirectBelow
        ) {
            if (
                this.getExistingOrders(ORDER_SELL, resource, terminal.room.name)
                    .length == 0
            ) {
                const result = this.sellDirect(
                    terminal,
                    resource,
                    amount,
                    opts,
                );
                if (
                    result != ERR_NO_ORDER_TO_SELL_TO &&
                    result != ERR_SELL_DIRECT_PRICE_TOO_LOW
                ) {
                    return result; // if there's nowhere to sensibly sell, allow creating an order
                }
                this.notify(
                    `Sell direct request: ${amount} ${resource} from ${printRoomName(
                        terminal.room.name,
                    )} ` +
                        `was unsuccessful; allowing fallthrough to TradeNetwork.maintainOrder()`,
                );
            }
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        // If you have enough credits or if there are no buy orders to sell to, create / maintain a sell order
        if (
            Game.market.credits >=
            TraderJoe_1.settings.market.credits.canPlaceSellOrdersAbove
        ) {
            const result = this.maintainOrder(
                terminal,
                ORDER_SELL,
                resource,
                amount,
                opts,
            );
            return result;
        } else {
            return ERR_CREDIT_THRESHOLDS;
        }
    }
    init() {
        if (
            Game.time - (this.memory.cache.tick || 0) >
            TraderJoe_1.settings.cache.timeout
        ) {
            this.buildMarketCache();
            this.buildMarketHistoryCache();
        }
    }
    run() {
        if (!this.memory.cache.enabled) {
            // Markets are disabled in this server
            return;
        }
        if (Game.time % 10 == 0) {
            this.cleanOrders();
        }
        this.notifyLastTickTransactions();
        if (this.notifications.length > 0) {
            this.notifications.sort();
            log.info(
                `Trade network activity: ` +
                    alignedNewline +
                    this.notifications.join(alignedNewline),
            );
        }
        this.recordStats();
    }
    notifyLastTickTransactions() {
        // Outgoing transactions are where I sent the resource
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < Game.time - 1) break; // list is ordered by descending time
            if (transaction.order) {
                // if it was sold on the market
                let msg;
                const cost = (
                    transaction.amount * transaction.order.price
                ).toFixed(2);
                // I am selling to another person's buy order
                if (transaction.order.type == ORDER_BUY) {
                    const coststr = `[+${cost}c]`.padRight(
                        '[-10000.00c]'.length,
                    );
                    msg =
                        coststr +
                        ` sell direct: ${printRoomName(
                            transaction.to,
                            true,
                        )} ${leftArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                        `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        // const sender = transaction.sender.username; // should be me
                        const recipient = transaction.recipient.username;
                        msg += `(sold to: ${recipient})`;
                    } else {
                        msg += `(sold to: ???)`;
                    }
                }
                // Someone else is buying from by sell order
                else {
                    const coststr = `[+${cost}c]`.padRight(
                        '[-10000.00c]'.length,
                    );
                    msg =
                        coststr +
                        ` sell order: ${printRoomName(
                            transaction.from,
                            true,
                        )} ${rightArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                        `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        // const sender = transaction.sender.username; // should be me
                        const recipient = transaction.recipient.username;
                        msg += `(buyer: ${recipient})`;
                    } else {
                        msg += `(buyer: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
        // Incoming transactions are where I received the resource
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < Game.time - 1) break; // list is ordered by descending time
            if (transaction.order) {
                // if it was sold on the market
                let msg;
                const cost = (
                    transaction.amount * transaction.order.price
                ).toFixed(2);
                // I am receiving resources from a direct purchase of someone else's sell order
                if (transaction.order.type == ORDER_SELL) {
                    const coststr = `[-${cost}c]`.padRight(
                        '[-10000.00c]'.length,
                    );
                    msg =
                        coststr +
                        ` buy direct: ${printRoomName(
                            transaction.to,
                            true,
                        )} ${leftArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                        `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        // const recipient = transaction.recipient.username; // should be me
                        msg += `(bought from: ${sender})`;
                    } else {
                        msg += `(bought from: ???)`;
                    }
                }
                // Another person is selling to my buy order
                else {
                    const coststr = `[-${cost}c]`.padRight(
                        '[-10000.00c]'.length,
                    );
                    msg =
                        coststr +
                        ` buy order: ${printRoomName(
                            transaction.from,
                            true,
                        )} ${rightArrow} ` +
                        `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                        `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        // const recipient = transaction.recipient.username; // should be me
                        msg += `(seller: ${sender})`;
                    } else {
                        msg += `(seller: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
    }
    /**
     * Look through transactions happening on the previous tick and record stats
     */
    recordStats() {
        this.stats.credits = Game.market.credits;
        const lastTick = Game.time - 1;
        // Incoming transactions
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick) {
                break; // only look at things from last tick
            } else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.bought[resourceType] = this.stats.bought[
                        resourceType
                    ] || {
                        amount: 0,
                        credits: 0,
                    };
                    this.stats.bought[resourceType].amount += amount;
                    this.stats.bought[resourceType].credits += amount * price;
                }
            }
        }
        // Outgoing transactions
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < lastTick) {
                break; // only look at things from last tick
            } else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.sold[resourceType] = this.stats.sold[
                        resourceType
                    ] || {
                        amount: 0,
                        credits: 0,
                    };
                    this.stats.sold[resourceType].amount += amount;
                    this.stats.sold[resourceType].credits += amount * price;
                }
            }
        }
    }
});
TraderJoe.settings = {
    cache: {
        timeout: 250,
    },
    market: {
        // TODO: add blacklist for rooms to not .deal() with, like Takki
        resources: {
            allowBuyT1T2boosts: false,
        },
        credits: {
            // TODO: the below are personal preferences, need to be moved to memory settings
            mustSellDirectBelow: 50000,
            canPlaceSellOrdersAbove: 2000,
            canBuyAbove: 100000000,
            canBuyPassivelyAbove: 100000000,
            canBuyBoostsAbove: 900000000,
            canBuyEnergyAbove: 900000000,
            canBuyPowerAbove: 100000000, // zGeneral 14/04/2023
        },
        orders: {
            timeout: 500000,
            cleanupAmount: 100,
            maxEnergySellOrders: 5,
            maxBatterySellOrders: 5,
            maxEnergyBuyOrders: 5,
            maxOrdersPlacedPerTick: 7,
            maxOrdersForResource: 20,
            minSellOrderAmount: 1000,
            maxSellOrderAmount: 25000,
            minSellDirectAmount: 250,
            maxSellDirectAmount: 10000,
            minBuyOrderAmount: 1000,
            maxBuyOrderAmount: 25000,
            minBuyDirectAmount: 500,
            maxBuyDirectAmount: 10000,
        },
    },
};
TraderJoe = TraderJoe_1 = __decorate([profile, assimilationLocked], TraderJoe);

var Priority;
(function (Priority) {
    Priority[(Priority['Critical'] = 0)] = 'Critical';
    Priority[(Priority['High'] = 1)] = 'High';
    Priority[(Priority['NormalHigh'] = 2)] = 'NormalHigh';
    Priority[(Priority['Normal'] = 3)] = 'Normal';
    Priority[(Priority['NormalLow'] = 4)] = 'NormalLow';
    Priority[(Priority['Low'] = 5)] = 'Low';
})(Priority || (Priority = {}));
function blankPriorityQueue() {
    const queue = {};
    for (const priority in Priority) {
        queue[priority] = [];
    }
    return queue;
}

// A stripped-down version of the logistics network intended for local deliveries
/**
 * Transport request groups handle close-range prioritized resource requests, in contrast to the logistics network,
 * which handles longer-ranged requests
 */
let TransportRequestGroup = class TransportRequestGroup {
    constructor() {
        this.refresh();
    }
    refresh() {
        this.supply = blankPriorityQueue();
        this.withdraw = blankPriorityQueue();
        this.supplyByID = {};
        this.withdrawByID = {};
    }
    needsSupplying(priorityThreshold) {
        for (const priority in this.supply) {
            if (
                priorityThreshold != undefined &&
                parseInt(priority, 10) > priorityThreshold
            ) {
                continue; // lower numerical priority values are more important; if priority > threshold then ignore it
            }
            if (this.supply[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    needsWithdrawing(priorityThreshold) {
        for (const priority in this.withdraw) {
            if (
                priorityThreshold != undefined &&
                parseInt(priority, 10) > priorityThreshold
            ) {
                continue; // lower numerical priority values are more important; if priority > threshold then ignore it
            }
            if (this.withdraw[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    getPrioritizedClosestRequest(pos, type, filter) {
        const requests = type == 'withdraw' ? this.withdraw : this.supply;
        for (const priority in requests) {
            const targets = _.map(
                requests[priority],
                (request) => request.target,
            );
            const target = pos.findClosestByRangeThenPath(targets);
            if (target) {
                let searchRequests;
                if (filter) {
                    searchRequests = _.filter(requests[priority], (req) =>
                        filter(req),
                    );
                } else {
                    searchRequests = requests[priority];
                }
                return _.find(
                    searchRequests,
                    (request) => request.target.ref == target.ref,
                );
            }
        }
    }
    /**
     * Request for resources to be deposited into this target
     */
    requestInput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };
        if (opts.amount > 0) {
            this.supply[priority].push(req);
            if (!this.supplyByID[target.id]) this.supplyByID[target.id] = [];
            this.supplyByID[target.id].push(req);
        }
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    requestOutput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };

        if (opts.amount > 0) {
            this.withdraw[priority].push(req);
            if (!this.withdrawByID[target.id]) {
                this.withdrawByID[target.id] = [];
            }
            this.withdrawByID[target.id].push(req);
        }
    }
    // /* Makes a provide for every resourceType in a requestor object */
    // requestOutputAll(target: StoreStructure, priority = Priority.Normal, opts = {} as TransportRequestOptions): void {
    // 	for (let resourceType in target.store) {
    // 		let amount = target.store[<ResourceConstant>resourceType] || 0;
    // 		if (amount > 0) {
    // 			opts.resourceType = <ResourceConstant>resourceType;
    // 			this.requestOutput(target, priority, opts);
    // 		}
    // 	}
    // }
    getInputAmount(target, resourceType) {
        // @ts-ignore
        return target.store.getFreeCapacity(resourceType) || 0;
        // Legacy code from before the structure.store refactor
        // if (isStoreStructure(target)) {
        // 	return target.storeCapacity - _.sum(target.store);
        // } else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
        // 	return target.energyCapacity - target.energy;
        // } else {
        // 	if (target instanceof StructureLab) {
        // 		if (resourceType == target.mineralType) {
        // 			return target.mineralCapacity - target.mineralAmount;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	} else if (target instanceof StructureNuker) {
        // 		if (resourceType == RESOURCE_GHODIUM) {
        // 			return target.ghodiumCapacity - target.ghodium;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	} else if (target instanceof StructurePowerSpawn) {
        // 		if (resourceType == RESOURCE_POWER) {
        // 			return target.powerCapacity - target.power;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	}
        // }
        // log.warning('Could not determine requestor amount!');
        // return 0;
    }
    getOutputAmount(target, resourceType) {
        // @ts-ignore
        return target.store.getUsedCapacity(resourceType) || 0;
        // Legacy code from before the structure.store refactor
        // if (isStoreStructure(target)) {
        // 	return target.store[resourceType]!;
        // } else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
        // 	return target.energy;
        // } else {
        // 	if (target instanceof StructureLab) {
        // 		if (resourceType == target.mineralType) {
        // 			return target.mineralAmount;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energy;
        // 		}
        // 	} else if (target instanceof StructureNuker) {
        // 		if (resourceType == RESOURCE_GHODIUM) {
        // 			return target.ghodium;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energy;
        // 		}
        // 	} else if (target instanceof StructurePowerSpawn) {
        // 		if (resourceType == RESOURCE_POWER) {
        // 			return target.power;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energy;
        // 		}
        // 	}
        // }
        // log.warning('Could not determine provider amount!');
        // return 0;
    }
    /**
     * Summarize the state of the transport request group to the console; useful for debugging.
     */
    summarize(ignoreEnergy = false) {
        console.log(`Supply requests ==========================`);
        for (const priority in this.supply) {
            if (this.supply[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.supply[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY) {
                    continue;
                }
                console.log(
                    `    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                        `resourceType: ${request.resourceType}`,
                );
            }
        }
        console.log(`Withdraw requests ========================`);
        for (const priority in this.withdraw) {
            if (this.withdraw[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.withdraw[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY) {
                    continue;
                }
                console.log(
                    `    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                        `resourceType: ${request.resourceType}`,
                );
            }
        }
    }
};
TransportRequestGroup = __decorate([profile], TransportRequestGroup);

/**
 * Energetics manager; makes high-level decisions based on energy amounts
 */
class Energetics {
    static lowPowerMode(colony) {
        if (colony.stage == ColonyStage.Adult) {
            if (
                colony.storageAmount > this.settings.storage.total.cap &&
                colony.terminalAmount > this.settings.terminal.total.cap
            ) {
                return true;
            }
        }
        return false;
    }
}
Energetics.settings = {
    storage: {
        total: {
            cap: STORAGE_CAPACITY - 100000,
            tolerance: 5000,
        },
        energy: {
            destroyTerminalThreshold: 200000,
        },
    },
    terminal: {
        total: {
            cap: TERMINAL_CAPACITY - 50000,
        },
        energy: {
            sendSize: 25000,
            inThreshold: 25000,
            outThreshold: 100000,
            equilibrium: 50000,
            tolerance: 5000,
            tradeAmount: 10000,
        },
    },
};

/**
 * Default ordering for processing spawning requests and prioritizing overlords
 */
let OverlordPriority = {
    emergency: {
        // Colony-wide emergencies such as a catastrohic crash
        bootstrap: 0,
    },
    core: {
        // Functionality related to spawning more creeps
        queen: 100,
        manager: 101,
    },
    powerCreeps: {
        default: 150,
    },
    defense: {
        // Defense of local and remote rooms
        meleeDefense: 200,
        rangedDefense: 201,
    },
    warSpawnCutoff: 299,
    offense: {
        // Offensive operations like raids or sieges
        destroy: 300,
        healPoint: 301,
        siege: 302,
        rangedPair: 303,
        controllerAttack: 399,
        harass: 571,
        roomPoisoner: 399,
    },
    priorityOwnedRoom: {
        // Situationally prioritized in-room operations
        priorityUpgrade: 450,
        priorityTransport: 451,
    },
    ownedRoom: {
        // Operation of an owned room
        firstTransport: 500,
        mine: 501,
        work: 502,
        mineralRCL8: 503,
        transport: 510,
        mineral: 520,
    },
    outpostDefense: {
        outpostDefense: 503,
        guard: 504,
    },
    interShard: {
        scout: 500,
        claim: 504,
        pioneer: 505,
        hauler: 506,
    },
    outpostOffense: {
        harass: 560,
        roomPoisoner: 561,
    },
    upgrading: {
        // Spawning upgraders
        upgrade: 600,
        fastUpgrade: 508,
    },
    throttleThreshold: 699,
    collectionUrgent: {
        // Collecting resources that are time sensitive, like decaying resources on ground
        haul: 700,
    },
    scouting: {
        stationary: 800,
        randomWalker: 801,
    },
    remoteRoom: {
        // Operation of a remote room. Allows colonies to restart one room at a time.
        reserve: 900,
        mine: 901,
        roomIncrement: 5,
        remoteSiege: 950,
    },
    colonization: {
        // Colonizing new rooms
        claim: 902,
        pioneer: 903,
        remoteUpgrading: 410,
    },
    remoteSKRoom: {
        sourceReaper: 1000,
        mineral: 1001,
        mine: 1002,
        roomIncrement: 5,
    },
    powerMine: {
        cool: 1050,
        drill: 1051,
        gather: 604,
        roomIncrement: 5,
    },
    tasks: {
        // Non-urgent tasks, such as collection from a deserted storage
        haul: 1100,
        dismantle: 1101,
    },
    praiseRoom: {
        praiser: 2000,
    },
    default: 99999,
};

const repairTaskName = 'repair';
let TaskRepair = class TaskRepair extends Task {
    constructor(target, options = {}) {
        super(repairTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.timeout = 100;
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits < this.target.hitsMax;
    }
    work() {
        const result = this.creep.repair(this.target);
        if (this.target.structureType == STRUCTURE_ROAD) {
            // prevents workers from idling for a tick before moving to next target
            const newHits =
                this.target.hits +
                this.creep.getActiveBodyparts(WORK) * REPAIR_POWER;
            if (newHits > this.target.hitsMax) {
                this.finish();
            }
        }
        return result;
    }
};
TaskRepair = __decorate([profile], TaskRepair);

const reserveTaskName = 'colony';
let TaskReserve = class TaskReserve extends Task {
    constructor(target, options = {}) {
        super(reserveTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(CLAIM) > 0;
    }
    isValidTarget() {
        const target = this.target;
        return (
            target != null &&
            (!target.reservation || target.reservation.ticksToEnd < 4999)
        );
    }
    work() {
        let ret = this.creep.reserveController(this.target);
        if (ret == ERR_INVALID_TARGET) {
            ret = this.creep.attackController(this.target);
        }
        return ret;
    }
};
TaskReserve = __decorate([profile], TaskReserve);

const signControllerTaskName = 'signController';
let TaskSignController = class TaskSignController extends Task {
    constructor(target, options = {}) {
        super(signControllerTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        return true;
    }
    isValidTarget() {
        const controller = this.target;
        return (
            (!controller.sign ||
                controller.sign.text != Memory.settings.signature) &&
            !controller.signedByScreeps
        );
    }
    work() {
        return this.creep.signController(
            this.target,
            Memory.settings.signature,
        );
    }
};
TaskSignController = __decorate([profile], TaskSignController);

const transferTaskName = 'transfer';
let TaskTransfer = class TaskTransfer extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(transferTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        return (
            // todo fix this
            // @ts-ignore
            this.target.store.getFreeCapacity(this.data.resourceType) >= amount
        );
        // const target = this.target;
        // if (target instanceof Creep) {
        // 	return _.sum(target.carry) <= target.carryCapacity - amount;
        // } else if (isStoreStructure(target)) {
        // 	return _.sum(target.store) <= target.storeCapacity - amount;
        // } else if (isEnergyStructure(target) && this.data.resourceType == RESOURCE_ENERGY) {
        // 	return target.energy <= target.energyCapacity - amount;
        // } else {
        // 	if (target instanceof StructureLab) {
        // 		return (target.mineralType == this.data.resourceType || !target.mineralType) &&
        // 			   target.mineralAmount <= target.mineralCapacity - amount;
        // 	} else if (target instanceof StructureNuker) {
        // 		return this.data.resourceType == RESOURCE_GHODIUM &&
        // 			   target.ghodium <= target.ghodiumCapacity - amount;
        // 	} else if (target instanceof StructurePowerSpawn) {
        // 		return this.data.resourceType == RESOURCE_POWER &&
        // 			   target.power <= target.powerCapacity - amount;
        // 	}
        // }
        // return false;
    }
    work() {
        return this.creep.transfer(
            this.target,
            this.data.resourceType,
            this.data.amount,
        );
    }
};
TaskTransfer = __decorate([profile], TaskTransfer);

const transferAllTaskName = 'transferAll';
let TaskTransferAll = class TaskTransferAll extends Task {
    constructor(target, skipEnergy = false, options = {}) {
        super(transferAllTaskName, target, options);
        this.target = target;
        this.data.skipEnergy = skipEnergy;
    }
    isValidTask() {
        for (const [resourceType, amount] of this.creep.carry.contents) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return true;
            }
        }
        return false;
    }
    isValidTarget() {
        return sumStore(this.target.store) < this.target.storeCapacity;
    }
    work() {
        for (const [resourceType, amount] of this.creep.carry.contents) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return this.creep.transfer(this.target, resourceType);
            }
        }
        return -1;
    }
};
TaskTransferAll = __decorate([profile], TaskTransferAll);

const upgradeTaskName = 'upgrade';
let TaskUpgrade = class TaskUpgrade extends Task {
    constructor(target, options = {}) {
        super(upgradeTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        var _a;
        return (_a = this.target) === null || _a === void 0 ? void 0 : _a.my;
    }
    work() {
        return this.creep.upgradeController(this.target);
    }
};
TaskUpgrade = __decorate([profile], TaskUpgrade);

/* Withdraw a resource from a target */
const withdrawTaskName = 'withdraw';
let TaskWithdraw = class TaskWithdraw extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(withdrawTaskName, target, options);
        this.target = target;
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        return sumStore(this.creep.carry) <= this.creep.carryCapacity - amount;
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        return (
            // todo fix this
            // @ts-ignore
            this.target.store.getUsedCapacity(this.data.resourceType) >= amount
        );
        // const target = this.target;
        // if (isTombstone(target) || isRuin(target) || isStoreStructure(target)) {
        // 	return (target.store[this.data.resourceType] || 0) >= amount;
        // } else if (isEnergyStructure(target) && this.data.resourceType == RESOURCE_ENERGY) {
        // 	return target.energy >= amount;
        // } else {
        // 	if (target instanceof StructureLab) {
        // 		return this.data.resourceType == target.mineralType && target.mineralAmount >= amount;
        // 	} else if (target instanceof StructurePowerSpawn) {
        // 		return this.data.resourceType == RESOURCE_POWER && target.power >= amount;
        // 	}
        // }
        // return false;
    }
    work() {
        return this.creep.withdraw(
            this.target,
            this.data.resourceType,
            this.data.amount,
        );
    }
};
TaskWithdraw = __decorate([profile], TaskWithdraw);

/* Withdraw a resource from a target */
const withdrawAllTaskName = 'withdrawAll';
let TaskWithdrawAll = class TaskWithdrawAll extends Task {
    constructor(target, options = {}) {
        super(withdrawAllTaskName, target, options);
        this.target = target;
    }
    isValidTask() {
        return sumStore(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        return sumStore(this.target.store) > 0;
    }
    work() {
        let resourceTransferType;
        for (const [resourceType, amountInStore] of this.target.store
            .contents) {
            if (amountInStore > 0) {
                resourceTransferType = resourceType;
                // Prioritize non-energy
                if (resourceType != RESOURCE_ENERGY) {
                    break;
                }
            }
        }
        if (!!resourceTransferType) {
            return this.creep.withdraw(this.target, resourceTransferType);
        }
        return -1;
    }
};
TaskWithdrawAll = __decorate([profile], TaskWithdrawAll);

const hibernateTaskName = 'hibernate';
let TaskHibernate = class TaskHibernate extends Task {
    constructor(timer, options = {}) {
        const inGameTime = Game.time + Number(timer);
        const _timer = inGameTime.toString();
        super(hibernateTaskName, {
            ref: _timer,
            pos: new RoomPosition(25, 25, 'W0N0'),
        });
    }
    isValidTask() {
        return (
            this.creep.hits == this.creep.hitsMax && // wake up if hurt
            Game.time < Number(this._target.ref)
        );
    }
    isValidTarget() {
        return Number(this._target.ref) > 0;
    }
    work() {
        return OK;
    }
};
TaskHibernate = __decorate([profile], TaskHibernate);

/**
 * Tasks class provides conveient wrappers for dispensing new Task instances
 */
let Tasks = class Tasks {
    static chain(tasks, setNextPos = true) {
        if (tasks.length == 0) {
            // log.error(`Tasks.chain was passed an empty array of tasks!`);
            return null;
        }
        if (setNextPos) {
            for (let i = 0; i < tasks.length - 1; i++) {
                tasks[i].options.nextPos = tasks[i + 1].targetPos;
            }
        }
        // Make the accumulator task from the end and iteratively fork it
        let task = _.last(tasks); // start with last task
        tasks = _.dropRight(tasks); // remove it from the list
        for (let i = tasks.length - 1; i >= 0; i--) {
            // iterate over the remaining tasks
            task = task.fork(tasks[i]);
        }
        return task;
    }
    static attack(target, options = {}) {
        return new TaskAttack(target, options);
    }
    static build(target, options = {}) {
        return new TaskBuild(target, options);
    }
    static claim(target, options = {}) {
        return new TaskClaim(target, options);
    }
    static dismantle(target, options = {}) {
        return new TaskDismantle(target, options);
    }
    static drop(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskDrop(target, resourceType, amount, options);
    }
    // static flee(target: fleeTargetType, options = {} as TaskOptions) {
    // 	return new TaskFlee(target, options);
    // }
    static fortify(target, hitsMax, options = {}) {
        return new TaskFortify(target, hitsMax, options);
    }
    static getBoosted(target, boostType, amount, options = {}) {
        return new TaskGetBoosted(target, boostType, amount, options);
    }
    static getRenewed(target, options = {}) {
        return new TaskGetRenewed(target, options);
    }
    static goToRoom(target, options = {}) {
        return new TaskGoToRoom(target, options);
    }
    static harvest(target, options = {}) {
        return new TaskHarvest(target, options);
    }
    static heal(target, options = {}) {
        return new TaskHeal(target, options);
    }
    static meleeAttack(target, options = {}) {
        return new TaskMeleeAttack(target, options);
    }
    static pickup(target, options = {}) {
        return new TaskPickup(target, options);
    }
    static rangedAttack(target, options = {}) {
        return new TaskRangedAttack(target, options);
    }
    static recharge(minEnergy = 0, options = {}) {
        return new TaskRecharge(null, minEnergy, options);
    }
    static repair(target, options = {}) {
        return new TaskRepair(target, options);
    }
    static reserve(target, options = {}) {
        return new TaskReserve(target, options);
    }
    static signController(target, options = {}) {
        return new TaskSignController(target, options);
    }
    static transfer(
        target,
        resourceType = RESOURCE_ENERGY,
        amount,
        options = {},
    ) {
        return new TaskTransfer(target, resourceType, amount, options);
    }
    static transferAll(target, skipEnergy = false, options = {}) {
        return new TaskTransferAll(target, skipEnergy, options);
    }
    static upgrade(target, options = {}) {
        return new TaskUpgrade(target, options);
    }
    static withdraw(
        target,
        resourceType = RESOURCE_ENERGY,
        amount,
        options = {},
    ) {
        return new TaskWithdraw(target, resourceType, amount, options);
    }
    static withdrawAll(target, options = {}) {
        return new TaskWithdrawAll(target, options);
    }
    static generateSafeMode(target, options = {}) {
        return new TaskGenerateSafeMode(target, options);
    }
    static hibernate(target, options = {}) {
        return new TaskHibernate(target, options);
    }
};
Tasks = __decorate([profile], Tasks);

var Movement_1;
const ERR_CANNOT_PUSH_CREEP = -30;
const REPORT_CPU_THRESHOLD = 750; // Report when creep uses more than this amount of CPU over lifetime
const REPORT_SWARM_CPU_THRESHOLD = 1500;
const DEFAULT_STUCK_VALUE = 2; // Marked as stuck after this many ticks
const STATE_PREV_X = 0;
const STATE_PREV_Y = 1;
const STATE_STUCK = 2;
const STATE_CPU = 3;
const STATE_DEST_X = 4;
const STATE_DEST_Y = 5;
const STATE_DEST_ROOMNAME = 6;
const STATE_CURRENT_X = 7;
const STATE_CURRENT_Y = 8;
const MovePriorities = {
    [Roles.manager]: 0,
    [Roles.queen]: 2,
    [Roles.bunkerDefender]: 3,
    [Roles.melee]: 3,
    powerCreep: 3, //zGeneral 2/12/2021 was 3
    [Roles.dismantler]: 4,
    [Roles.ranged]: 4,
    [Roles.guardMelee]: 5,
    // [Roles.ranged]: 6,
    [Roles.drill]: 6,
    [Roles.coolant]: 7,
    [Roles.transport]: 8,
    [Roles.worker]: 9,
    default: 10,
};
const getDefaultMoveOptions = () => ({
    pathOpts: {},
});
/**
 * This is the movement library for Overmind. It was originally based on BonzAI's Traveler library, but it has been
 * extensively modified to integrate more tightly with the Overmind framework and add additional functionality.
 */
let Movement = (Movement_1 = class Movement {
    // Core creep movement functions ===================================================================================
    /**
     * Move a creep to a destination
     */
    static goTo(creep, destination, opts = {}) {
        if (creep.blockMovement && !opts.force) {
            return ERR_BUSY;
        }
        if (isStandardZerg(creep)) {
            if (creep.spawning) {
                return NO_ACTION;
            }
            if (creep.fatigue > 0) {
                Movement_1.circle(creep.pos, 'aqua', 0.3);
                return ERR_TIRED;
            }
        }
        if (opts.movingTarget) {
            opts.range = 0;
        }
        // Set default options
        _.defaultsDeep(opts, getDefaultMoveOptions());
        const pathOpts = opts.pathOpts; // modifications to pathOpts show up on opts.pathOpts
        // initialize data object
        if (!creep.memory._go) {
            creep.memory._go = {};
        }
        const moveData = creep.memory._go;
        const deletePath = moveData;
        // set destination according to waypoint specifications; finalDestination is the true destination
        destination = normalizePos(destination);
        // const finalDestination = destination;
        // if (opts.waypoints) {
        // 	destination = this.getDestination(destination, opts.waypoints, moveData);
        // }
        Pathing.updateRoomStatus(creep.room);
        // Fixes bug that causes creeps to idle on the other side of a room
        if (opts.range != undefined && destination.rangeToEdge <= opts.range) {
            opts.range = Math.min(Math.abs(destination.rangeToEdge - 1), 0);
        }
        // Take care of properties which exist on both moveOpts and pathOpts: if they are specified on both moveOpts
        // and moveOpts.pathOpts then the value of range or fleeRange on moveOpts takes precedence.
        // -> This must be done after the last modification to opts.range and opts.fleeRange!
        if (opts.range != undefined) {
            pathOpts.range = opts.range;
        }
        if (opts.fleeRange != undefined) {
            pathOpts.fleeRange = opts.fleeRange;
        }
        // manage case where creep is nearby destination
        const rangeToDestination = creep.pos.getRangeTo(destination);
        if (opts.range != undefined && rangeToDestination <= opts.range) {
            // if (destination.isEqualTo(finalDestination)) {
            if (creep.pos.isEdge) {
                // move the creep off the edge tiles to prevent it bouncing
                return creep.moveOffExit(destination);
            } else {
                delete creep.memory._go;
                return NO_ACTION;
            }
            // } else {
            // 	// debug
            // 	console.log(`Destination ${destination} not equal to final destination ${finalDestination}!`);
            // 	if (!moveData.waypointsVisited) {
            // 		moveData.waypointsVisited = [];
            // 	}
            // 	moveData.waypointsVisited.push(destination.name);
            //
            // 	// call goTo again to path to the final destination
            // 	return this.goTo(creep, finalDestination, opts);
            // }
        } else if (rangeToDestination <= 1) {
            // move onto destination
            if (rangeToDestination == 1 && !opts.range) {
                const direction = creep.pos.getDirectionTo(destination);
                if (destination.isWalkable(opts.ignoreCreepsOnDestination)) {
                    return creep.move(direction, !!opts.force);
                }
            } else {
                // at destination
                if (!moveData.fleeWait) {
                    delete creep.memory._go;
                }
                return NO_ACTION;
            }
        }
        // // traverse through a portal waypoint or check that has just been traversed
        // if (opts.waypoints && !destination.isEqualTo(finalDestination) && (moveData.portaling == true
        // 																   || creep.pos.getRangeTo(destination) < 2)) {
        // 	const portalTraversed = this.traversePortalWaypoint(creep, destination);
        // 	if (portalTraversed) {
        // 		return this.goTo(creep, finalDestination, opts);
        // 	} else {
        // 		return CROSSING_PORTAL;
        // 	}
        // }
        // handle delay
        if (moveData.delay != undefined) {
            if (moveData.delay <= 0) {
                delete moveData.delay;
            } else {
                moveData.delay--;
                return OK;
            }
        }
        const state = this.deserializeState(moveData, destination);
        // // verify creep is in the location it thinks it should be in
        // if (state.currentXY) {
        // 	let {x, y} = state.currentXY;
        // 	if (!(creep.pos.x == x && creep.pos.y == y)) { // creep thought it would move last tick but didn't
        // 		log.debug(`${creep.print} has gotten off track; deleting path!`);
        // 		delete moveData.path;
        // 	}
        // }
        // uncomment to visualize destination
        // this.circle(destination, "orange");
        // check if creep is stuck
        if (this.isStuck(creep, state)) {
            state.stuckCount++;
            this.circle(creep.pos, 'magenta', state.stuckCount * 0.3);
            // pushedCreep = this.pushCreep(creep);
        } else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (!opts.stuckValue) {
            opts.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= opts.stuckValue && Math.random() > 0.5) {
            pathOpts.blockCreeps = true;
            delete deletePath.path;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            if (opts.movingTarget && state.destination.isNearTo(destination)) {
                moveData.path += state.destination.getDirectionTo(destination);
                state.destination = destination;
            } else {
                delete deletePath.path;
            }
        }
        // randomly repath with specified probability
        if (opts.repathChance && Math.random() < opts.repathChance) {
            delete deletePath.path;
        }
        // TODO: repath if you are not on expected next position
        // pathfinding
        let newPath = false;
        if (!moveData.path || moveData.path.length == 0) {
            newPath = true;
            if (isStandardZerg(creep) && creep.spawning) {
                return ERR_BUSY;
            }
            state.destination = destination;
            // Compute terrain costs
            if (isPowerZerg(creep)) {
                if (pathOpts.terrainCosts) {
                    log.error(
                        `${creep.print}: MoveOptions.terrainCosts not supported by PowerZerg`,
                    );
                }
                pathOpts.terrainCosts = { plainCost: 1, swampCost: 1 };
            } else if (isStandardZerg(creep)) {
                if (!pathOpts.terrainCosts) {
                    pathOpts.terrainCosts = getTerrainCosts(creep.creep);
                }
            } else {
                log.error(`${creep.print} is not Zerg or PowerZerg!`);
            }
            const cpu = Game.cpu.getUsed();
            // creep.debug(`Pathfinding from ${creep.pos} to ${destination} with opts ${JSON.stringify(pathOpts)}`);
            // Pathfinding call ------------------------------------------
            const ret = Pathing.findPath(creep.pos, destination, pathOpts);
            // -----------------------------------------------------------
            // creep.debug(`Pathfinding return: ${print(ret)}`);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_CPU_THRESHOLD) {
                log.alert(
                    `Movement: heavy cpu use: ${creep.name}, cpu: ${state.cpu}. ` +
                        `(${creep.pos.print} ${rightArrow} ${destination.print})`,
                );
            }
            let color = 'orange';
            if (ret.incomplete) {
                // uncommenting this is a great way to diagnose creep behavior issues
                log.debug(
                    `Movement: incomplete path for ${creep.print}! ` +
                        `(${creep.pos.print} ${rightArrow} ${destination.print})`,
                );
                color = 'red';
            }
            this.circle(creep.pos, color);
            moveData.path = Pathing.serializePath(creep.pos, ret.path, color);
            const roomsVisited = _.unique(
                _.map(ret.path, (pos) => pos.roomName),
            );
            if (!moveData.roomVisibility) {
                moveData.roomVisibility = {};
            }
            for (const roomName of roomsVisited) {
                moveData.roomVisibility[roomName] = !!Game.rooms[roomName];
            }
            state.stuckCount = 0;
        }
        if (!moveData.path || moveData.path.length == 0) {
            this.serializeState(creep, destination, state, moveData);
            return ERR_NO_PATH;
        }
        // push creeps out of the way if needed
        if (!opts.noPush) {
            const obstructingCreep = this.findBlockingCreep(creep);
            if (obstructingCreep && this.shouldPush(creep, obstructingCreep)) {
                const pushedCreep = this.pushCreep(creep, obstructingCreep);
                if (!pushedCreep) {
                    this.serializeState(creep, destination, state, moveData);
                    return ERR_CANNOT_PUSH_CREEP;
                }
            }
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        // predict next coordinate (for verification)
        const nextPos = creep.pos.getPositionAtDirection(nextDirection);
        this.serializeState(creep, destination, state, moveData, {
            x: nextPos.x,
            y: nextPos.y,
        });
        return creep.move(nextDirection, !!opts.force);
    }
    // /**
    //  * Gets the effective destination based on the waypoints to travel over and the creep.memory._go object.
    //  * Finds the next waypoint which has not been marked as visited in moveData.
    //  */
    // private static getDestination(destination: RoomPosition, waypoints: RoomPosition[],
    // 							  moveData: MoveData): RoomPosition {
    //
    // 	const waypointsVisited = _.compact(_.map(moveData.waypointsVisited || [],
    // 											 posName => getPosFromString(posName))) as RoomPosition[];
    // 	const nextWaypoint = _.find(waypoints, waypoint => !_.any(waypointsVisited,
    // 															  visited => waypoint.isEqualTo(visited)));
    //
    // 	if (nextWaypoint) {
    // 		return nextWaypoint;
    // 	} else {
    // 		return destination;
    // 	}
    //
    // }
    // /**
    //  * Navigate a creep through a portal
    //  */
    // private static traversePortalWaypoint(creep: AnyZerg, portalPos: RoomPosition): boolean {
    // 	if (creep.pos.roomName == portalPos.roomName && creep.pos.getRangeTo(portalPos) > 1) {
    // 		log.error(`Movement.travelPortalWaypoint() should only be called in range 1 of portal!`);
    // 	}
    //
    // 	const moveData = creep.memory._go || {} as MoveData;
    //
    // 	if (portalPos.room && !portalPos.lookForStructure(STRUCTURE_PORTAL)) {
    // 		log.error(`Portal not found at ${portalPos.print}!`);
    // 		return false;
    // 	}
    //
    // 	moveData.portaling = true;
    // 	const crossed = this.crossPortal(creep, portalPos);
    //
    // 	if (crossed) {
    // 		moveData.portaling = false;
    // 		if (!moveData.waypointsVisited) {
    // 			moveData.waypointsVisited = [];
    // 		}
    // 		moveData.waypointsVisited.push(portalPos.name);
    //
    // 		return true; // done crossing portal
    // 	} else {
    // 		return false; // still trying to cross portal
    // 	}
    //
    // }
    // /**
    //  * Cross a portal that is within range 1 and then step off of the exit portal. Returns true when creep is on the
    //  * other side of the portal and no longer standing on a portal.
    //  */
    // private static crossPortal(creep: AnyZerg, portalPos: RoomPosition): boolean {
    // 	if (Game.map.getRoomLinearDistance(creep.pos.roomName, portalPos.roomName) > 5) {
    // 		// if you're on the other side of the portal
    // 		const creepOnPortal = !!creep.pos.lookForStructure(STRUCTURE_PORTAL);
    // 		if (!creepOnPortal) {
    // 			return true;
    // 		} else {
    // 			creep.moveOffCurrentPos();
    // 			return false;
    // 		}
    // 		// console.log(agent.name + " waiting on other side");
    // 	} else {
    // 		if (creep.pos.getRangeTo(portalPos) > 1) {
    // 			log.error(`Movement.crossPortal() should only be called in range 1 of portal!`);
    // 		} else {
    // 			const dir = creep.pos.getDirectionTo(portalPos);
    // 			creep.move(dir);
    // 		}
    // 		// console.log(agent.name + " traveling to waypoint");
    // 		return false;
    // 	}
    // }
    static getPushPriority(creep) {
        if (!creep.memory) return MovePriorities.default;
        if (creep.memory._go && creep.memory._go.priority) {
            return creep.memory._go.priority;
        } else {
            if (isPowerZerg(creep)) {
                return MovePriorities.powerCreep;
            } else {
                return creep.memory.role in MovePriorities
                    ? MovePriorities[creep.memory.role]
                    : MovePriorities.default;
            }
        }
    }
    static shouldPush(pusher, pushee) {
        if (this.getPushPriority(pusher) < this.getPushPriority(pushee)) {
            // pushee less important than pusher
            return true;
        } else if (this.getPushPriority(pushee) == 0) {
            return false;
        } else {
            pushee = normalizeAnyZerg(pushee);
            if (isAnyZerg(pushee)) {
                if (isStandardZerg(pushee)) {
                    // pushee is equal or more important than pusher
                    if (pushee.task && pushee.task.isWorking) {
                        // If creep is doing a task, only push out of way if it can go somewhere else in range
                        const targetPos = pushee.task.targetPos;
                        const targetRange = pushee.task.settings.targetRange;
                        return (
                            _.filter(
                                pushee.pos
                                    .availableNeighbors()
                                    .concat(pusher.pos),
                                (pos) =>
                                    pos.getRangeTo(targetPos) <= targetRange,
                            ).length > 0
                        );
                    } else if (!pushee.isMoving) {
                        // push creeps out of the way if they're idling
                        return true;
                    }
                } else if (isPowerZerg(pushee)) {
                    if (!pushee.isMoving) {
                        // push creeps out of the way if they're idling
                        return true;
                    }
                }
            } else {
                return pushee.my;
            }
        }
        return false;
    }
    static getPushDirection(pusher, pushee) {
        const possiblePositions = pushee.pos.availableNeighbors();
        pushee = normalizeAnyZerg(pushee);
        if (isStandardZerg(pushee)) {
            let preferredPositions = [];
            if (pushee.task && pushee.task.isWorking) {
                // push creeps out of the way when they're doing task
                const targetPos = pushee.task.targetPos;
                const targetRange = pushee.task.settings.targetRange;
                preferredPositions = _.filter(
                    possiblePositions,
                    (pos) => pos.getRangeTo(targetPos) <= targetRange,
                );
            }
            if (preferredPositions[0]) {
                return pushee.pos.getDirectionTo(preferredPositions[0]);
            }
        } else {
            log.debug(`${pushee.name}@${pushee.pos.print} is not Zerg! (Why?)`);
        }
        return pushee.pos.getDirectionTo(pusher);
    }
    static findBlockingCreep(creep) {
        const nextDir = Pathing.nextDirectionInPath(creep);
        if (nextDir == undefined) return;
        const nextPos = Pathing.positionAtDirection(creep.pos, nextDir);
        if (!nextPos) return;
        return nextPos.room ? nextPos.lookFor(LOOK_CREEPS)[0] : undefined; // 9/2032 bug fix zgeneral
    }
    /* Push a blocking creep out of the way */
    static pushCreep(creep, otherCreep) {
        if (!otherCreep.memory) return false;
        otherCreep = normalizeAnyZerg(otherCreep);
        const pushDirection = this.getPushDirection(creep, otherCreep);
        const otherData = otherCreep.memory._go;
        // Push the creep and update the state
        const outcome = otherCreep.move(pushDirection);
        const otherNextPos = otherCreep.pos.getPositionAtDirection(
            pushDirection,
        );
        if (isStandardZerg(otherCreep)) {
            if (outcome == OK) {
                if (otherData && otherData.path && !otherCreep.blockMovement) {
                    // don't add to path unless you moved
                    otherData.path =
                        Pathing.oppositeDirection(pushDirection) +
                        otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                otherCreep.blockMovement = true; // TODO: <-- movement bug? what if cmds are procesed in wrong order?
                return true;
            } else {
                return false;
            }
        } else {
            // Shouldn't reach here ideally
            log.warning(
                `${otherCreep.name}@${otherCreep.pos.print} is not Zerg! (Why?)`,
            );
            if (outcome == OK) {
                if (otherData && otherData.path) {
                    otherData.path =
                        Pathing.oppositeDirection(pushDirection) +
                        otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                return true;
            } else {
                return false;
            }
        }
    }
    // TODO: this is bugged somewhere
    /**
     * Recursively moves creeps out of the way of a position to make room for something, such as a spawning creep.
     * If suicide is specified and there is no series of move commands that can move a block of creeps out of the way,
     * the lead blocking creep will suicide. Returns whether the position has been vacated.
     */
    static vacatePos(pos, suicide = false) {
        // prevent creeps from moving onto pos
        const nearbyCreeps = _.compact(
            _.map(
                pos.findInRange(FIND_MY_CREEPS, 2),
                (creep) => Overmind.zerg[creep.name],
            ),
        );
        _.forEach(nearbyCreeps, (creep) => (creep.blockMovement = true));
        // recurively move creeps off of the position
        const creep = pos.lookFor(LOOK_CREEPS)[0];
        if (!creep) return true;
        const blockingCreep = Overmind.zerg[creep.name];
        if (!blockingCreep) return true;
        const moved = !!this.recursivePush(blockingCreep);
        if (moved) {
            log.debug(
                `Moved creep ${blockingCreep.name} off of ${blockingCreep.pos.print}.`,
            );
            return true;
        } else {
            if (suicide) {
                log.debug(
                    `Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}! ` +
                        `Suiciding creep! (RIP)`,
                );
                blockingCreep.suicide();
                return true;
            } else {
                log.debug(
                    `Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}!`,
                );
                return false;
            }
        }
    }
    /**
     * Recursively pushes creeps out of the way of a root position.
     */
    static recursivePush(creep, excludePos = []) {
        const creepPos = creep.pos;
        let movePos = _.find(
            creepPos.availableNeighbors(),
            (neighbor) => !_.any(excludePos, (pos) => pos.isEqualTo(neighbor)),
        );
        if (movePos) {
            log.debug(`Moving ${creep.name} to ${JSON.stringify(movePos)}`);
            this.goTo(creep, movePos, { force: true });
            creep.blockMovement = true;
            return creepPos;
        } else {
            // Every position is occupied by a creep
            const availablePositions = _.filter(
                creepPos.availableNeighbors(true),
                (neighbor) =>
                    !_.any(excludePos, (pos) => pos.isEqualTo(neighbor)),
            );
            for (const otherPos of availablePositions) {
                const otherCreep = otherPos.lookFor(LOOK_CREEPS)[0];
                if (!otherCreep) continue;
                const otherZerg = Overmind.zerg[otherCreep.name];
                if (!otherZerg) continue;
                movePos = this.recursivePush(
                    otherZerg,
                    excludePos.concat(creepPos),
                );
                if (movePos) {
                    this.goTo(creep, movePos, { range: 0, force: true });
                    creep.blockMovement = true;
                    return creepPos;
                }
            }
        }
    }
    /**
     * Travel to a room
     */
    static goToRoom(creep, roomName, options = {}) {
        options.range = 20;
        return this.goTo(creep, new RoomPosition(25, 25, roomName), options);
    }
    /**
     * Travel to a room
     */
    static goToRoom_swarm(swarm, roomName, options = {}) {
        options.range = 24 - Math.max(swarm.width, swarm.height);
        return this.swarmMove(
            swarm,
            new RoomPosition(25, 25, roomName),
            options,
        );
    }
    /**
     * Park a creep off-roads
     */
    static park(creep, pos = creep.pos, maintainDistance = false) {
        return OK; // zGeneral 2/2024
        const road = creep.pos.lookForStructure(STRUCTURE_ROAD);
        if (!road) return OK;
        // Move out of the bunker if you're in it
        if (
            !maintainDistance &&
            creep.colony &&
            creep.colony.bunker &&
            insideBunkerBounds(creep.pos, creep.colony)
        ) {
            return this.goTo(creep, creep.colony.controller.pos);
        }
        let positions = _.sortBy(creep.pos.availableNeighbors(), (p) =>
            p.getRangeTo(pos),
        );
        if (maintainDistance) {
            const currentRange = creep.pos.getRangeTo(pos);
            positions = _.filter(
                positions,
                (p) => p.getRangeTo(pos) <= currentRange,
            );
        }
        let swampPosition;
        for (const position of positions) {
            if (position.lookForStructure(STRUCTURE_ROAD)) continue;
            const terrain = position.lookFor(LOOK_TERRAIN)[0];
            if (terrain === 'swamp') {
                swampPosition = position;
            } else {
                return creep.move(creep.pos.getDirectionTo(position));
            }
        }
        if (swampPosition) {
            return creep.move(creep.pos.getDirectionTo(swampPosition));
        }
        return this.goTo(creep, pos);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    static moveOffCurrentPos(creep) {
        const destinationPos = _.first(creep.pos.availableNeighbors());
        if (destinationPos) {
            const direction = creep.pos.getDirectionTo(destinationPos);
            return creep.move(direction);
        } else {
            log.debug(`${creep.print} can't move off current pos!`);
        }
    }
    /**
     * Moves onto an exit tile
     */
    static moveOnExit(creep) {
        if (creep.pos.rangeToEdge > 0) {
            if (isStandardZerg(creep) && creep.fatigue > 0) {
                return;
            }
            const directions = [1, 3, 5, 7, 2, 4, 6, 8];
            for (const direction of directions) {
                const position = creep.pos.getPositionAtDirection(direction);
                const terrain = position.lookFor(LOOK_TERRAIN)[0];
                if (terrain != 'wall' && position.rangeToEdge == 0) {
                    const outcome = creep.move(direction);
                    return outcome;
                }
            }
            log.warning(
                `moveOnExit() assumes nearby exit tile, position: ${creep.pos}`,
            );
            return ERR_NO_PATH;
        }
    }
    /**
     * Moves off of an exit tile
     */
    static moveOffExit(creep, towardPos, avoidSwamp = true) {
        if (!creep.pos.isEdge) {
            return NO_ACTION;
        }
        const terrain = creep.room.getTerrain();
        const pos = minBy(creep.pos.neighbors, (pos) => {
            if (pos.isEdge || !pos.isWalkable()) {
                return false;
            }
            let penalty = 0;
            if (avoidSwamp && terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP) {
                penalty += 10;
            }
            if (towardPos) {
                penalty += pos.getRangeTo(towardPos);
            }
            return penalty;
        });
        if (pos) {
            const direction = creep.pos.getDirectionTo(pos);
            creep.debug(
                `moving off exit toward ${pos.print}, direction ${direction}`,
            );
            return creep.move(direction);
        } else {
            log.warning(`${creep.print}: cannot move off exit!`);
            return ERR_NO_PATH;
        }
    }
    /**
     * Moves a pair of creeps; the follower will always attempt to be in the last position of the leader
     */
    static pairwiseMove(leader, follower, target, opts = {}, allowedRange = 1) {
        let outcome;
        if (leader.room != follower.room) {
            if (leader.pos.rangeToEdge == 0) {
                // Leader should move off of exit tiles while waiting for follower
                outcome = leader.goTo(target, opts);
            }
            follower.goTo(leader);
            return outcome;
        }
        const range = leader.pos.getRangeTo(follower);
        if (range > allowedRange) {
            // If leader is farther than max allowed range, allow follower to catch up
            if (follower.pos.isEdge && follower.room == leader.room) {
                const goToPos = _.find(
                    follower.pos.availableNeighbors(),
                    (pos) => pos.isNearTo(leader),
                );
                if (goToPos) {
                    follower.goTo(goToPos);
                } else {
                    follower.goTo(leader, { pathOpts: { blockCreeps: true } });
                }
            } else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        } else if (isStandardZerg(follower) && follower.fatigue == 0) {
            // Leader should move if follower can also move this tick
            outcome = leader.goTo(target, opts);
            if (range == 1) {
                follower.move(follower.pos.getDirectionTo(leader));
            } else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        return outcome;
    }
    /**
     * Moves a swarm to a destination, accounting for group pathfinding
     */
    static swarmMove(swarm, destination, opts = {}) {
        if (swarm.fatigue > 0) {
            Movement_1.circle(swarm.anchor, 'aqua', 0.3);
            console.log('tired');
            return ERR_TIRED;
        }
        // Set default options
        _.defaults(opts, {
            range: 1,
            blockCreeps: false,
            exitCost: 10,
        });
        // if (options.range! < Math.max(swarm.width, swarm.height)) {
        // 	log.warning(`Range specified is ${options.range}; not allowable for ${swarm.width}x${swarm.height} swarm!`);
        // }
        destination = normalizePos(destination);
        // initialize data object
        if (!swarm.memory._go) {
            swarm.memory._go = {};
        }
        const moveData = swarm.memory._go;
        const deletePath = moveData;
        // manage case where creep is nearby destination
        if (
            opts.range != undefined &&
            swarm.minRangeTo(destination) <= opts.range &&
            swarm.maxRangeTo(destination) <=
                opts.range + Math.max(swarm.width, swarm.height)
        ) {
            delete swarm.memory._go;
            console.log('no action');
            return NO_ACTION;
        }
        const state = this.deserializeState(moveData, destination);
        // check if swarm is stuck
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(swarm.anchor, state.lastCoord)) {
                // didn't move
                stuck = true;
            } else if (isExit(swarm.anchor) && isExit(state.lastCoord)) {
                // moved against exit
                stuck = true;
            }
        }
        if (stuck) {
            state.stuckCount++;
            this.circle(swarm.anchor, 'magenta', state.stuckCount * 0.3);
        } else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (!opts.stuckValue) {
            opts.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= opts.stuckValue && Math.random() > 0.5) {
            opts.blockCreeps = true;
            delete deletePath.path;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            delete deletePath.path;
        }
        if (opts.repathChance && Math.random() < opts.repathChance) {
            // randomly repath with some probability
            delete deletePath.path;
        }
        // pathfinding
        let newPath = false;
        if (!moveData.path) {
            newPath = true;
            state.destination = destination;
            const cpu = Game.cpu.getUsed();
            // (!) Pathfinding is done here
            const ret = Pathing.findSwarmPath(
                swarm.anchor,
                destination,
                swarm.width,
                swarm.height,
                opts,
            );
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_SWARM_CPU_THRESHOLD) {
                log.alert(
                    `Movement: heavy cpu use for swarm with ${
                        _.first(swarm.creeps).print
                    }, cpu: ${state.cpu}. ` +
                        `(${swarm.anchor.print} ${rightArrow} ${destination.print})`,
                );
            }
            let color = 'orange';
            if (ret.incomplete) {
                log.debug(
                    `Movement: incomplete path for swarm with ${
                        _.first(swarm.creeps).print
                    }! ` +
                        `(${swarm.anchor.print} ${rightArrow} ${destination.print})`,
                );
                color = 'red';
            }
            this.circle(swarm.anchor, color);
            moveData.path = Pathing.serializePath(
                swarm.anchor,
                ret.path,
                color,
            );
            state.stuckCount = 0;
        }
        // uncomment to visualize destination
        this.circle(destination, 'orange');
        // Serialize state for swarm
        moveData.state = [
            swarm.anchor.x,
            swarm.anchor.y,
            state.stuckCount,
            state.cpu,
            destination.x,
            destination.y,
            destination.roomName,
        ];
        if (!moveData.path || moveData.path.length == 0) {
            console.log(
                `No path from ${swarm.anchor.print} to ${destination.print}!`,
            );
            return ERR_NO_PATH;
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        return swarm.move(nextDirection);
    }
    static combatMoveCallbackModifier(room, matrix, approach, avoid, options) {
        // This is only applied once creep is in the target room
        if (!options.allowExit) {
            MatrixLib.blockExits(room.name, matrix);
        }
        // Add penalties for things you want to avoid
        _.forEach(avoid, (avoidThis) => {
            let cost;
            let x, y;
            for (let dx = -avoidThis.range; dx <= avoidThis.range; dx++) {
                for (let dy = -avoidThis.range; dy <= avoidThis.range; dy++) {
                    x = avoidThis.pos.x + dx;
                    y = avoidThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        cost = Math.min(cost + options.avoidPenalty, 0xfe);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        // Add bonuses for things you want to approach
        _.forEach(approach, (approachThis) => {
            let cost;
            let x, y;
            for (let dx = -approachThis.range; dx <= approachThis.range; dx++) {
                for (
                    let dy = -approachThis.range;
                    dy <= approachThis.range;
                    dy++
                ) {
                    x = approachThis.pos.x + dx;
                    y = approachThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        // is walkable
                        cost = Math.max(cost - options.approachBonus, 1);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        // Prefer to path into open ramparts
        if (options.preferRamparts) {
            MatrixLib.setWalkableRampartCostToOne(matrix, room);
        }
        return matrix;
    }
    static swarmCombatMove(swarm, approach, avoid, options = {}) {
        _.defaults(options, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            blockMyCreeps: true,
        });
        const callback = (roomName) => {
            const room = swarm.roomsByName[roomName];
            const matrixOpts = {
                explicitTerrainCosts: true,
                swarmWidth: swarm.width,
                swarmHeight: swarm.height,
                blockExits: !options.allowExit,
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts).clone();
            if (room) {
                matrix = matrix.clone();
                if (options.blockMyCreeps) {
                    const otherCreeps = _.filter(
                        room.creeps,
                        (creep) =>
                            !_.any(swarm.creeps, (c) => c.name == creep.name),
                    );
                    MatrixLib.blockAfterMaxPooling(
                        matrix,
                        otherCreeps,
                        swarm.width,
                        swarm.height,
                    );
                }
                // Pathing.blockHostileCreeps(matrix, creep.room);
                Movement_1.combatMoveCallbackModifier(
                    room,
                    matrix,
                    approach,
                    avoid,
                    options,
                );
                // TODO: ^ needs to take swarm size into account
            }
            if (options.displayCostMatrix) {
                Visualizer.displayCostMatrix(matrix, roomName);
            }
            return matrix;
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            const size = Math.max(swarm.width, swarm.height);
            if (_.any(avoid, (goal) => swarm.minRangeTo(goal) <= goal.range)) {
                const allAvoid = _.flatten(
                    _.map(avoid, (goal) =>
                        _.map(
                            Pathing.getPosWindow(
                                goal.pos,
                                -swarm.width,
                                -swarm.height,
                            ),
                            (pos) => ({
                                pos: pos,
                                range: goal.range,
                            }),
                        ),
                    ),
                );
                if (options.displayAvoid) {
                    const room = swarm.rooms[0];
                    for (const avoid of allAvoid) {
                        const { x, y } = avoid.pos;
                        room.visual.text(avoid.range.toString(), x, y, {
                            color: 'ff0099',
                        });
                    }
                }
                const avoidRet = PathFinder.search(swarm.anchor, allAvoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: options.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    outcome = swarm.move(
                        swarm.anchor.getDirectionTo(avoidRet.path[0]),
                    );
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (
                !_.any(approach, (goal) => swarm.minRangeTo(goal) <= goal.range)
            ) {
                const allApproach = _.flatten(
                    _.map(approach, (goal) =>
                        _.map(
                            Pathing.getPosWindow(
                                goal.pos,
                                -swarm.width,
                                -swarm.height,
                            ),
                            (pos) => ({
                                pos: pos,
                                range: goal.range,
                            }),
                        ),
                    ),
                );
                const approachRet = PathFinder.search(
                    swarm.anchor,
                    allApproach,
                    {
                        roomCallback: callback,
                        maxRooms: 1,
                        plainCost: 2,
                        swampCost: 10,
                    },
                );
                if (approachRet.path.length > 0) {
                    outcome = swarm.move(
                        swarm.anchor.getDirectionTo(approachRet.path[0]),
                    );
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static combatMove(creep, approach, avoid, opts = {}) {
        _.defaults(opts, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            requireRamparts: false,
            blockMyCreeps: true,
            blockHostileCreeps: false,
            blockAlliedCreeps: false,
        });
        const callback = (roomName) => {
            const matrixOpts = {
                blockExits: !opts.allowExit,
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts);
            if (roomName == creep.room.name) {
                matrix = matrix.clone();
                if (opts.blockMyCreeps) {
                    MatrixLib.blockMyCreeps(matrix, creep.room);
                } // TODO: is this necessary?
                if (opts.blockHostileCreeps) {
                    MatrixLib.blockHostileCreeps(matrix, creep.room);
                }
                if (opts.blockAlliedCreeps) {
                    MatrixLib.blockAlliedCreeps(matrix, creep.room);
                }
                if (opts.preferRamparts) {
                    MatrixLib.setWalkableRampartCostToOne(matrix, creep.room);
                }
                if (opts.requireRamparts) {
                    MatrixLib.blockNonRamparts(matrix, creep.room);
                }
                Movement_1.combatMoveCallbackModifier(
                    creep.room,
                    matrix,
                    approach,
                    avoid,
                    opts,
                );
                if (opts.displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            } else {
                if (Pathing.shouldAvoid(roomName)) return false;
                return matrix;
            }
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            if (
                _.any(avoid, (goal) =>
                    creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range),
                ) &&
                !creep.inRampart
            ) {
                const avoidRet = PathFinder.search(creep.pos, avoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: opts.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    outcome = creep.move(
                        creep.pos.getDirectionTo(avoidRet.path[0]),
                    );
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (
                !_.any(approach, (goal) =>
                    creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range),
                )
            ) {
                const approachRet = PathFinder.search(creep.pos, approach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    outcome = creep.move(
                        creep.pos.getDirectionTo(approachRet.path[0]),
                    );
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Try to maneuver under ramparts if possible
        if (
            (opts.preferRamparts || opts.requireRamparts) &&
            !creep.inRampart &&
            approach.length > 0
        ) {
            const openRamparts = _.filter(
                creep.room.walkableRamparts,
                (rampart) =>
                    _.any(approach, (g) =>
                        rampart.pos.inRangeToXY(g.pos.x, g.pos.y, g.range),
                    ) && rampart.pos.isWalkable(),
            );
            if (openRamparts.length > 0) {
                const ret = PathFinder.search(
                    creep.pos,
                    _.map(openRamparts, (r) => ({ pos: r.pos, range: 0 })),
                    {
                        roomCallback: callback,
                        maxRooms: 1,
                        plainCost: 2,
                        swampCost: 10,
                    },
                );
                if (ret.path.length > 0) {
                    outcome = creep.move(creep.pos.getDirectionTo(ret.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static invasionMoveCallbackModifier(room, matrix) {
        // This is only applied once creep is in the target room
        MatrixLib.blockExits(room.name, matrix);
        for (const hostile of room.invaders) {
            if (hostile.getActiveBodyparts(RANGED_ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 3, 1, true);
            } else if (hostile.getActiveBodyparts(ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 1, 1, true);
            }
        }
        for (const keeper of room.sourceKeepers) {
            MatrixLib.setInRange(matrix, keeper, 3, 10, true);
        }
        for (const lair of room.keeperLairs) {
            if ((lair.ticksToSpawn || Infinity) < 25) {
                MatrixLib.setInRange(matrix, lair, 5, 5, true);
            }
        }
        return matrix;
    }
    /**
     * Moving routine for guards or sourceReapers in a room with NPC invaders
     */
    static invasionMove(creep, destination, opts = {}) {
        _.defaults(opts, getDefaultMoveOptions());
        const dest = normalizePos(destination);
        if (creep.pos.getRangeTo(dest) > 8) {
            opts.repathChance = 0.1;
            opts.movingTarget = true;
        }
        if (creep.room.name == dest.roomName) {
            _.defaults(opts.pathOpts, {
                maxRooms: 1,
                modifyRoomCallback: Movement_1.invasionMoveCallbackModifier,
            });
        }
        return creep.goTo(dest, opts);
        
    }
    /**
     * Kite around enemies in a single room, repathing every tick. More expensive than flee().
     */
    static kite(creep, avoidGoals, options = {}) {
        _.defaults(options, {
            fleeRange: 5,
            terrainCosts: isPowerZerg(creep)
                ? { plainCost: 1, swampCost: 1 }
                : getTerrainCosts(creep.creep),
        });
        const nextPos = _.first(
            Pathing.findKitingPath(
                creep.pos,
                avoidGoals,
                options.pathOpts || {},
            ).path,
        );
        if (nextPos) {
            return creep.move(creep.pos.getDirectionTo(nextPos));
        }
    }
    /**
     * Flee from avoid goals in the room while not re-pathing every tick like kite() does.
     */
    static flee(creep, avoidGoals, dropEnergy = false, opts = {}) {
        if (avoidGoals.length == 0) {
            return; // nothing to flee from
        }
        const terrainCosts = isPowerZerg(creep)
            ? { plainCost: 1, swampCost: 1 }
            : getTerrainCosts(creep.creep);
        const fleeDefaultOpts = {
            pathOpts: { terrainCosts: terrainCosts },
        };
        _.defaults(opts, fleeDefaultOpts);
        const fleeRange =
            opts.fleeRange || (terrainCosts.plainCost > 1 ? 8 : 16);
        if (opts.fleeRange == undefined) {
            opts.fleeRange = fleeRange;
            opts.pathOpts.fleeRange = fleeRange;
        }
        const closest = creep.pos.findClosestByRange(avoidGoals);
        const rangeToClosest = closest ? creep.pos.getRangeTo(closest) : 50;
        if (rangeToClosest > opts.fleeRange) {
            // Out of range of baddies
            if (!creep.memory._go) {
                return;
            }
            if (creep.pos.isEdge) {
                return creep.moveOffExit();
            }
            // wait until safe
            const moveData = creep.memory._go;
            if (moveData.fleeWait != undefined) {
                if (moveData.fleeWait <= 0) {
                    // you're safe now
                    delete creep.memory._go;
                    return;
                } else {
                    moveData.fleeWait--;
                    return NO_ACTION;
                }
            } else {
                // you're safe
                return;
            }
        } else {
            // Still need to run away
            // initialize data object
            if (!creep.memory._go) {
                creep.memory._go = {};
            }
            const moveData = creep.memory._go;
            const deletePath = moveData;
            moveData.fleeWait = 2;
            // Invalidate path if needed
            if (moveData.path) {
                if (moveData.path.length > 0) {
                    const nextDirection = parseInt(moveData.path[0], 10);
                    const pos = creep.pos.getPositionAtDirection(nextDirection);
                    if (!pos.isEdge) {
                        const newClosest = pos.findClosestByRange(avoidGoals);
                        if (
                            newClosest &&
                            normalizePos(newClosest).getRangeTo(pos) <
                                rangeToClosest
                        ) {
                            delete deletePath.path;
                        }
                    }
                } else {
                    delete deletePath.path;
                }
            }
            // Re-calculate path if needed
            if (!moveData.path || !moveData.destination) {
                const ret = Pathing.findFleePath(
                    creep.pos,
                    avoidGoals,
                    opts.pathOpts || {},
                );
                if (ret.path.length == 0) {
                    return NO_ACTION;
                }
                moveData.destination = _.last(ret.path);
                moveData.path = Pathing.serializePath(
                    creep.pos,
                    ret.path,
                    'purple',
                );
            }
            // Call goTo to the final position in path
            return Movement_1.goTo(
                creep,
                derefRoomPosition(moveData.destination),
                opts,
            );
        }
    }
    static deserializeState(moveData, destination) {
        const state = {};
        if (moveData.state) {
            state.lastCoord = {
                x: moveData.state[STATE_PREV_X],
                y: moveData.state[STATE_PREV_Y],
            };
            state.cpu = moveData.state[STATE_CPU];
            state.stuckCount = moveData.state[STATE_STUCK];
            state.destination = new RoomPosition(
                moveData.state[STATE_DEST_X],
                moveData.state[STATE_DEST_Y],
                moveData.state[STATE_DEST_ROOMNAME],
            );
            if (
                moveData.state[STATE_CURRENT_X] &&
                moveData.state[STATE_CURRENT_Y]
            ) {
                state.currentXY = {
                    x: moveData.state[STATE_CURRENT_X],
                    y: moveData.state[STATE_CURRENT_Y],
                };
            }
        } else {
            state.cpu = 0;
            state.destination = destination;
        }
        return state;
    }
    static serializeState(creep, destination, state, moveData, nextCoord) {
        if (nextCoord) {
            moveData.state = [
                creep.pos.x,
                creep.pos.y,
                state.stuckCount,
                state.cpu,
                destination.x,
                destination.y,
                destination.roomName,
                nextCoord.x,
                nextCoord.y,
            ];
        } else {
            moveData.state = [
                creep.pos.x,
                creep.pos.y,
                state.stuckCount,
                state.cpu,
                destination.x,
                destination.y,
                destination.roomName,
            ];
        }
    }
    /**
     * Update the currentXY property for a move state
     */
    static updateStateNextCoord(moveData, nextCoord) {
        if (moveData.state) {
            if (
                moveData.state[STATE_CURRENT_X] != undefined &&
                moveData.state[STATE_CURRENT_Y] != undefined
            ) {
                moveData.state[STATE_CURRENT_X] = nextCoord.x;
                moveData.state[STATE_CURRENT_Y] = nextCoord.y;
            } else if (moveData.state.length == STATE_CURRENT_X) {
                moveData.state.push(nextCoord.x);
                moveData.state.push(nextCoord.y);
            } else {
                // Shouldn't ever reach here
                log.warning(`Invalid moveData.state length!`);
            }
        }
    }
    static isStuck(creep, state) {
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(creep.pos, state.lastCoord)) {
                // didn't move
                stuck = true;
            } else if (isExit(creep.pos) && isExit(state.lastCoord)) {
                // moved against exit
                stuck = true;
            }
        }
        return stuck;
    }
    /**
     * Draw a circle
     */
    static circle(pos, color, opacity) {
        return new RoomVisual(pos.roomName).circle(pos, {
            radius: 0.45,
            fill: 'transparent',
            stroke: color,
            strokeWidth: 0.15,
            opacity: opacity,
        });
    }
});
Movement = Movement_1 = __decorate([profile], Movement);
// Creep.prototype.goTo = function (destination: RoomPosition | HasPos, options?: MoveOptions) {
// 	return Movement.goTo(this, destination, options);
// };

function getOverlord(creep) {
    if (creep.memory['O' /* OVERLORD */]) {
        return Overmind.overlords[creep.memory['O' /* OVERLORD */]] || null;
    } else {
        return null;
    }
}
function setOverlord(creep, newOverlord) {
    // Remove cache references to old assignments
    const roleName = creep.memory.role;
    const ref = creep.memory['O' /* OVERLORD */];
    const oldOverlord = ref ? Overmind.overlords[ref] : null;
    if (
        ref &&
        Overmind.cache.overlords[ref] &&
        Overmind.cache.overlords[ref][roleName]
    ) {
        _.remove(
            Overmind.cache.overlords[ref][roleName],
            (name) => name == creep.name,
        );
    }
    if (newOverlord) {
        // Change to the new overlord's colony
        creep.memory['C' /* COLONY */] = newOverlord.colony.name;
        // Change assignments in memory
        creep.memory['O' /* OVERLORD */] = newOverlord.ref;
        // Update the cache references
        if (!Overmind.cache.overlords[newOverlord.ref]) {
            Overmind.cache.overlords[newOverlord.ref] = {};
        }
        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
            Overmind.cache.overlords[newOverlord.ref][roleName] = [];
        }
        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);
    } else {
        creep.memory['O' /* OVERLORD */] = null;
    }
    if (oldOverlord) oldOverlord.recalculateCreeps();
    if (newOverlord) newOverlord.recalculateCreeps();
}
function normalizeAnyZerg(creep) {
    return Overmind.zerg[creep.name] || Overmind.powerZerg[creep.name] || creep;
}
const RANGES = {
    BUILD: 3,
    REPAIR: 3,
    TRANSFER: 1,
    WITHDRAW: 1,
    HARVEST: 1,
    DROP: 0,
};
/**
 * The AnyZerg abstract class contains all of the base methods that are present on both the Zerg and PowerZerg classes.
 * Most of these methods have been moved from the Zerg class.
 */
let AnyZerg = class AnyZerg {
    // private _task: Task | null; 		// Cached Task object that is instantiated once per tick and on change
    constructor(creep, notifyWhenAttacked = true) {
        this.isAnyZerg = true;
        // Copy over creep references
        this.creep = creep;
        // this.body = creep.body;
        this.carry = creep.carry;
        this.store = creep.store;
        this.carryCapacity = creep.carryCapacity;
        // this.fatigue = creep.fatigue;
        this.effects = creep.effects;
        this.hits = creep.hits;
        this.hitsMax = creep.hitsMax;
        this.id = creep.id;
        this.memory = creep.memory;
        this.name = creep.name;
        this.pos = creep.pos;
        this.nextPos = creep.pos;
        this.ref = creep.ref;
        // this.roleName = creep.memory.role;
        this.room = creep.room; // only wrap actively spawned PowerCreeps
        this.saying = creep.saying;
        // this.spawning = creep.spawning;
        this.ticksToLive = creep.ticksToLive;
        // Extra properties
        if (isPowerCreep(creep)) {
            this.lifetime = POWER_CREEP_LIFE_TIME;
        } else {
            this.lifetime =
                _.filter(creep.body, (part) => part.type == CLAIM).length > 0
                    ? CREEP_CLAIM_LIFE_TIME
                    : CREEP_LIFE_TIME;
        }
        this.actionLog = {};
        this.blockMovement = false;
        // Register global references
        // Overmind.zerg[this.name] = this;
        global[this.name] = this;
        // Handle attack notification when at lifetime - 1
        if (
            !notifyWhenAttacked &&
            (this.ticksToLive || 0) >=
                this.lifetime - (NEW_OVERMIND_INTERVAL + 1)
        ) {
            // creep.notifyWhenAttacked only uses the 0.2CPU intent cost if it changes the intent value
            this.notifyWhenAttacked(notifyWhenAttacked);
        }
    }
    /**
     * Refresh all changeable properties of the creep or delete from Overmind and global when dead
     */
    refresh() {
        const creep = Game.creeps[this.name];
        if (creep) {
            this.creep = creep;
            this.pos = creep.pos;
            this.nextPos = creep.pos;
            // this.body = creep.body;
            this.carry = creep.carry;
            this.store = creep.store;
            this.carryCapacity = creep.carryCapacity;
            // this.fatigue = creep.fatigue;
            this.hits = creep.hits;
            this.memory = creep.memory;
            // this.roleName = creep.memory.role;
            this.room = creep.room;
            this.saying = creep.saying;
            // this.spawning = creep.spawning;
            this.ticksToLive = creep.ticksToLive;
            this.actionLog = {};
            this.blockMovement = false;
            // this._task = null;
            if (this.hits < creep.hitsMax * 0.1) {
                console.log(
                    creep.name +
                        ' creep under attack in ' +
                        creep.room.name +
                        ' task = ' +
                        this._task,
                ); // zGeneral 8/2023 debug
            }
        } else {
            log.debug(`Deleting ${this.print} from global`);
            // delete Overmind.zerg[this.name];
            delete global[this.name];
        }
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.pos.roomName +
            '">[' +
            this.name +
            ']</a>'
        );
    }
    // Wrapped creep methods ===========================================================================================
    cancelOrder(methodName) {
        const result = this.creep.cancelOrder(methodName);
        if (result == OK) this.actionLog[methodName] = false;
        return result;
    }
    drop(resourceType, amount) {
        const result = this.creep.drop(resourceType, amount);
        if (result == OK && !this.actionLog.drop) {
            this.actionLog.drop = true;
            Stats.logIntent('drop');
        }
        return result;
    }
    goDrop(pos, resourceType, amount) {
        if (this.pos.inRangeToPos(pos, RANGES.DROP)) {
            return this.drop(resourceType, amount);
        } else {
            return this.goTo(pos);
        }
    }
    move(direction, force = false) {
        if (!this.blockMovement || force) {
            // bug fix
            const result = this.creep.move(direction);
            if (result == OK) {
                if (!this.actionLog.move) {
                    this.actionLog.move = true;
                    Stats.logIntent('move');
                }
                this.nextPos = this.pos.getPositionAtDirection(direction);
            }
            return result;
        } else {
            return ERR_BUSY;
        }
    }
    notifyWhenAttacked(enabled) {
        return this.creep.notifyWhenAttacked(enabled);
    }
    pickup(resource) {
        const result = this.creep.pickup(resource);
        if (result == OK && !this.actionLog.pickup) {
            Stats.logIntent('pickup');
            this.actionLog.pickup = true;
        }
        return result;
    }
    /* Say a message; maximum message length is 10 characters */
    say(message, pub) {
        return this.creep.say(message, pub);
    }
    suicide() {
        const result = this.creep.suicide();
        if (result == OK) {
            Stats.logIntent('suicide');
        }
        return result;
    }
    transfer(target, resourceType = RESOURCE_ENERGY, amount) {
        let result;
        if (isAnyZerg(target)) {
            result = this.creep.transfer(target.creep, resourceType, amount);
        } else {
            result = this.creep.transfer(target, resourceType, amount);
        }
        if (result == OK && !this.actionLog.transfer) {
            Stats.logIntent('transfer');
            this.actionLog.transfer = true;
        }
        return result;
    }
    transferAll(target, amount) {
        for (const [resourceType, amount] of this.creep.store.contents) {
            if (amount > 0) {
                return this.transfer(target, resourceType);
            }
        }
    }
    goTransfer(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.transfer(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    withdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        const result = this.creep.withdraw(target, resourceType, amount);
        if (result == OK && !this.actionLog.withdraw) {
            Stats.logIntent('withdraw');
            this.actionLog.withdraw = true;
        }
        return result;
    }
    goWithdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.withdraw(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    // Custom creep methods ============================================================================================
    // Carry methods
    get hasMineralsInCarry() {
        for (const [resourceType, amount] of this.carry.contents) {
            if (resourceType != RESOURCE_ENERGY && amount > 0) {
                return true;
            }
        }
        return false;
    }
    // Overlord logic --------------------------------------------------------------------------------------------------
    get overlord() {
        return getOverlord(this);
    }
    set overlord(newOverlord) {
        setOverlord(this, newOverlord);
    }
    // Colony association ----------------------------------------------------------------------------------------------
    /**
     * Colony that the creep belongs to.
     */
    get colony() {
        if (this.memory['C' /* COLONY */] != null) {
            return Overmind.colonies[this.memory['C' /* COLONY */]];
        } else {
            return null;
        }
    }
    set colony(newColony) {
        if (newColony != null) {
            this.memory['C' /* COLONY */] = newColony.name;
        } else {
            this.memory['C' /* COLONY */] = null;
        }
    }
    /**
     * If the creep is in a colony room or outpost
     */
    get inColonyRoom() {
        return (
            Overmind.colonyMap[this.room.name] == this.memory['C' /* COLONY */]
        );
    }
    // Movement and location -------------------------------------------------------------------------------------------
    goTo(destination, options = {}) {
        return Movement.goTo(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        return Movement.goToRoom(this, roomName, options);
    }
    inSameRoomAs(target) {
        return this.pos.roomName == target.pos.roomName;
    }
    safelyInRoom(roomName) {
        return this.room.name == roomName && !this.pos.isEdge;
    }
    get inRampart() {
        return this.creep.inRampart;
    }
    get isMoving() {
        const moveData = this.memory._go;
        return (
            (!!moveData && !!moveData.path && moveData.path.length > 1) ||
            this.actionLog[MOVE]
        );
    }
    /**
     * Kite around hostiles in the room
     */
    kite(avoidGoals = this.room.hostiles, options = {}) {
        _.defaults(options, {
            fleeRange: 5,
        });
        return Movement.kite(this, avoidGoals, options);
    }
    defaultFleeGoals() {
        let fleeGoals = [];
        fleeGoals = fleeGoals
            .concat(this.room.hostiles)
            .concat(
                _.filter(
                    this.room.keeperLairs,
                    (lair) => (lair.ticksToSpawn || Infinity) < 10,
                ),
            );
        return fleeGoals;
    }
    /**
     * Flee from hostiles in the room, while not repathing every tick // TODO: take a look at this
     */
    flee(
        avoidGoals = this.room.fleeDefaults,
        fleeOptions = {},
        moveOptions = {},
    ) {
        if (
            avoidGoals.length == 0 ||
            this.room.dangerousHostiles.find(
                (creep) => creep.pos.getRangeToXY(this.pos.x, this.pos.y) < 6,
            ) == undefined
        ) {
            return false;
        } else if (
            this.room.controller &&
            this.room.controller.my &&
            this.room.controller.safeMode
        ) {
            return false;
        } else {
            const fleeing =
                Movement.flee(
                    this,
                    avoidGoals,
                    fleeOptions.dropEnergy,
                    moveOptions,
                ) != undefined;
            if (fleeing) {
                // Drop energy if needed
                if (fleeOptions.dropEnergy && this.carry.energy > 0) {
                    const nearbyContainers = this.pos.findInRange(
                        this.room.storageUnits,
                        1,
                    );
                    if (nearbyContainers.length > 0) {
                        this.transfer(
                            _.first(nearbyContainers),
                            RESOURCE_ENERGY,
                        );
                    } else {
                        this.drop(RESOURCE_ENERGY);
                    }
                }
            }
            return fleeing;
        }
    }
    /**
     * Callback that is checked for many civilian roles. Returns true if the civilian zerg is in a dangerous situation
     * and handles the zerg retreating to a fallback room. Acts as a replacement to the current default Zerg.flee()
     * danger avoidance logic
     */
    avoidDanger(opts = {}) {
        // If you're almost expired or you're spawning do nothing - if you get killed you're cheap and faster to replace
        if ((this.ticksToLive || 0) < 50) {
            return false; // I just wanna die!!
        }
        _.defaults(opts, { timer: 10, dropEnergy: true });
        // If you previously determined you are in danger, wait for timer to expire
        if (this.memory.avoidDanger) {
            if (this.memory.avoidDanger.timer > 0) {
                this.goToRoom(this.memory.avoidDanger.fallback);
                if (opts.dropEnergy && this.carry.energy > 0) {
                    this.drop(RESOURCE_ENERGY); // transfer energy to container check is only run on first danger tick
                }
                this.memory.avoidDanger.timer--;
                return true;
            } else {
                delete this.memory.avoidDanger;
            }
        }
        if (!this.room.isSafe || this.hits < this.hitsMax) {
            if (
                Cartographer.roomType(this.room.name) == ROOMTYPE_SOURCEKEEPER
            ) {
                // If you're in an SK room, you can skip the danger avoidance as long as you have max hp, there are no
                // player hostiles, no invaders, and you're not in range to any of the sourceKeepers or spawning lairs
                if (
                    this.hits >= this.hitsMax * 0.9 && //zGeneral 31/12/2021
                    this.room.dangerousPlayerHostiles.length == 0 &&
                    this.room.invaders.length == 0 &&
                    !_.any(this.room.fleeDefaults, (fleeThing) =>
                        this.pos.inRangeTo(fleeThing, 5),
                    )
                ) {
                    // Not actually in danger
                    return false;
                }
            }
            let fallback;
            const maxLinearRange = 6;
            // Like 99.999% of the time this will be the case
            if (
                this.colony &&
                Game.map.getRoomLinearDistance(
                    this.room.name,
                    this.colony.name,
                ) <= maxLinearRange
            ) {
                fallback = this.colony.name;
            }
            // But this could happen if the creep was working remotely through a portal
            else {
                const nearbyColonies = _.filter(
                    getAllColonies(),
                    (colony) =>
                        Game.map.getRoomLinearDistance(
                            this.room.name,
                            colony.name,
                        ) <= maxLinearRange,
                );
                const closestColony = minBy(nearbyColonies, (colony) => {
                    const route = Pathing.findRoute(
                        this.room.name,
                        colony.room.name,
                    );
                    if (route == ERR_NO_PATH) {
                        return false;
                    } else {
                        return route.length;
                    }
                });
                if (!closestColony) {
                    log.error(
                        `${this.print} is all alone in a dangerous place and can't find their way home!`,
                    );
                    return false;
                }
                fallback = closestColony.name;
            }
            this.memory.avoidDanger = {
                start: Game.time,
                timer: opts.timer,
                fallback: fallback,
            };
            if (opts.dropEnergy && this.carry.energy > 0) {
                const containersInRange = this.pos.findInRange(
                    this.room.containers,
                    1,
                );
                const adjacentContainer = _.first(containersInRange);
                if (adjacentContainer) {
                    this.transfer(adjacentContainer, RESOURCE_ENERGY);
                }
            }
            this.goToRoom(fallback);
            return true;
        }
        return false;
    }
    /**
     * Park the creep off-roads
     */
    park(pos = this.pos, maintainDistance = false) {
        return Movement.park(this, pos, maintainDistance);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    moveOffCurrentPos() {
        return Movement.moveOffCurrentPos(this);
    }
    /**
     * Moves onto an exit tile
     */
    moveOnExit() {
        return Movement.moveOnExit(this);
    }
    /**
     * Moves off of an exit tile
     */
    moveOffExit(towardPos, avoidSwamp = true) {
        return Movement.moveOffExit(this, towardPos, avoidSwamp);
    }
    // Miscellaneous fun stuff -----------------------------------------------------------------------------------------
    sayLoop(messageList, pub) {
        return this.say(messageList[Game.time % messageList.length], pub);
    }
    sayRandom(phrases, pub) {
        return this.say(
            phrases[Math.floor(Math.random() * phrases.length)],
            pub,
        );
    }
    // others
    isFull() {
        return sumStore(this.store) >= this.carryCapacity;
    }
    isEmpty() {
        return sumStore(this.store) == 0;
    }
    hasState() {
        return this.memory.state !== undefined;
    }
    getState() {
        return this.memory.state;
    }
    setState(state) {
        this.memory.state = state;
    }
};
AnyZerg = __decorate([profile], AnyZerg);

function toCreep(creep) {
    return isStandardZerg(creep) ? creep.creep : creep;
}
// Last pipeline is more complex because it depends on the energy a creep has; sidelining this for now
const ACTION_PIPELINES = [
    [
        'harvest',
        'attack',
        'build',
        'repair',
        'dismantle',
        'attackController',
        'rangedHeal',
        'heal',
    ],
    ['rangedAttack', 'rangedMassAttack', 'build', 'repair', 'rangedHeal'],
];
/**
 * The Zerg class is a wrapper for owned creeps and contains all wrapped creep methods and many additional methods for
 * direct control of a creep. As of April 2020, this class now extends the AnyZerg class to accommodate the introduction
 * of power creeps into the game.
 */
let Zerg = class Zerg extends AnyZerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isStandardZerg = true;
        // Copy over creep references
        // this.creep = creep;
        this.body = creep.body;
        // this.carry = creep.carry;
        // this.store = creep.store;
        // this.carryCapacity = creep.carryCapacity;
        this.fatigue = creep.fatigue;
        // this.hits = creep.hits;
        // this.hitsMax = creep.hitsMax;
        // this.id = creep.id;
        // this.memory = creep.memory;
        // this.name = creep.name;
        // this.pos = creep.pos;
        // this.nextPos = creep.pos;
        // this.ref = creep.ref;
        this.roleName = creep.memory.role;
        // this.room = creep.room;
        // this.saying = creep.saying;
        this.spawning = creep.spawning;
        // this.ticksToLive = creep.ticksToLive;
        // Extra properties
        // this.lifetime = this.getBodyparts(CLAIM) > 0 ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        // this.actionLog = {};
        // this.blockMovement = false;
        // Register global references
        Overmind.zerg[this.name] = this;
        // global[this.name] = this;
        // Handle attack notification when at lifetime - 1
        // if (!notifyWhenAttacked && (this.ticksToLive || 0) >= this.lifetime - (NEW_OVERMIND_INTERVAL + 1)) {
        // 	// creep.notifyWhenAttacked only uses the 0.2CPU intent cost if it changes the intent value
        // 	this.notifyWhenAttacked(notifyWhenAttacked);
        // }
    }
    /**
     * Refresh all changeable properties of the creep or delete from Overmind and global when dead
     */
    refresh() {
        super.refresh();
        const creep = Game.creeps[this.name];
        if (creep) {
            // this.creep = creep;
            // this.pos = creep.pos;
            // this.nextPos = creep.pos;
            this.body = creep.body;
            // this.carry = creep.carry;
            // this.store = creep.store;
            // this.carryCapacity = creep.carryCapacity;
            this.fatigue = creep.fatigue;
            // this.hits = creep.hits;
            // this.memory = creep.memory;
            this.roleName = creep.memory.role;
            // this.room = creep.room;
            // this.saying = creep.saying;
            this.spawning = creep.spawning;
            // this.ticksToLive = creep.ticksToLive;
            // this.actionLog = {};
            // this.blockMovement = false;
            this._task = null; // todo
            this._neededBoosts = undefined;
        } else {
            // log.debug(`Deleting from global`);
            delete Overmind.zerg[this.name];
            // delete global[this.name];
        }
    }
    get ticksUntilSpawned() {
        if (this.spawning) {
            const spawner = this.pos.lookForStructure(STRUCTURE_SPAWN);
            if (spawner && spawner.spawning) {
                return spawner.spawning.remainingTime;
            } else {
                // Shouldn't ever get here
                console.log(
                    `Error determining ticks to spawn for ${this.name} @ ${this.pos.print}!`,
                );
            }
        }
    }
    // Wrapped creep methods ===========================================================================================
    attack(target) {
        const result = this.creep.attack(target);
        if (result == OK) {
            if (!this.actionLog.attack) {
                Stats.logIntent('attack');
                this.actionLog.attack = true;
            }
            if (isCreep(target) || isPowerCreep(target)) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(
                    this.creep,
                    target,
                    'attack',
                );
            }
            if (isCreep(target)) {
                // account for hitback effects
                if (this.creep.hitsPredicted == undefined) {
                    this.creep.hitsPredicted = this.creep.hits;
                }
                this.creep.hitsPredicted -= CombatIntel.predictedDamageAmount(
                    target,
                    this.creep,
                    'attack',
                );
            }
            if (this.memory.talkative) this.say(`💥`);
        }
        return result;
    }
    attackController(controller) {
        const result = this.creep.attackController(controller);
        if (result == OK && !this.actionLog.attackController) {
            Stats.logIntent('attackController');
            this.actionLog.attackController = true;
        }
        return result;
    }
    build(target) {
        const result = this.creep.build(target);
        if (result == OK && !this.actionLog.build) {
            Stats.logIntent('build');
            this.actionLog.build = true;
        }
        return result;
    }
    goBuild(target) {
        if (this.build(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    // cancelOrder(methodName: string): OK | ERR_NOT_OWNER | ERR_BUSY | ERR_NOT_FOUND {
    // 	const result = this.creep.cancelOrder(methodName);
    // 	if (result == OK) this.actionLog[methodName] = false;
    // 	return result;
    // }
    claimController(controller) {
        const result = this.creep.claimController(controller);
        if (result == OK) {
            Stats.logIntent('claimController');
        }
        if (result == OK && !this.actionLog.claimController) {
            this.actionLog.claimController = result == OK;
            Stats.logIntent('claimController');
        }
        if (result == OK) {
            // rebuild the overmind object on the next tick to account for new room
            Overmind.shouldBuild = true;
        }
        return result;
    }
    dismantle(target) {
        const result = this.creep.dismantle(target);
        if (result == OK && !this.actionLog.dismantle) {
            Stats.logIntent('dismantle');
            this.actionLog.dismantle = true;
        }
        return result;
    }
    goDismantle(target) {
        if (this.dismantle(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target, {
                // make sure miners stay in the room
                pathOpts: { maxRooms: 1 },
            });
        }
    }
    // drop(resourceType: ResourceConstant, amount?: number) {
    // 	const result = this.creep.drop(resourceType, amount);
    // 	if (!this.actionLog.drop) this.actionLog.drop = (result == OK);
    // 	return result;
    // }
    // goDrop(pos: RoomPosition, resourceType: ResourceConstant, amount?: number) {
    // 	if (this.pos.inRangeToPos(pos, RANGES.DROP)) {
    // 		return this.drop(resourceType, amount);
    // 	} else {
    // 		return this.goTo(pos);
    // 	}
    // }
    generateSafeMode(target) {
        const result = this.creep.generateSafeMode(target);
        if (result == OK) {
            Stats.logIntent('generateSafeMode');
        }
        return result;
    }
    harvest(source) {
        if(Game.cpu.getUsed() >= 295 || Game.cpu.bucket < 9000) {
            // console.log('skip harvest, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), source.room.name); // zGeneral 3/2024
            return OK
        }
        const result = this.creep.harvest(source);
        if (result == OK && !this.actionLog.harvest) {
            Stats.logIntent('harvest');
            this.actionLog.harvest = true;
        }
        return result;
    }
    goHarvest(source) {
        if (this.harvest(source) == ERR_NOT_IN_RANGE) {
            this.goTo(source);
        }
    }
    // move(direction: DirectionConstant, force = false) {
    // 	if (!this.blockMovement && !force) {
    // 		const result = this.creep.move(direction);
    // 		if (result == OK) {
    // 			if (!this.actionLog.move) this.actionLog.move = true;
    // 			this.nextPos = this.pos.getPositionAtDirection(direction);
    // 		}
    // 		return result;
    // 	} else {
    // 		return ERR_BUSY;
    // 	}
    // }
    // notifyWhenAttacked(enabled: boolean) {
    // 	return this.creep.notifyWhenAttacked(enabled);
    // }
    // pickup(resource: Resource) {
    // 	const result = this.creep.pickup(resource);
    // 	if (!this.actionLog.pickup) this.actionLog.pickup = (result == OK);
    // 	return result;
    // }
    rangedAttack(target) {
        const result = this.creep.rangedAttack(target);
        if (result == OK) {
            if (!this.actionLog.rangedAttack) {
                Stats.logIntent('rangedAttack');
                this.actionLog.rangedAttack = true;
            }
            if (isCreep(target)) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(
                    this,
                    target,
                    'rangedAttack',
                );
            }
            if (this.memory.talkative) this.say(`🔫`);
        }
        return result;
    }
    rangedMassAttack() {
        const result = this.creep.rangedMassAttack();
        if (result == OK) {
            if (!this.actionLog.rangedMassAttack) {
                Stats.logIntent('rangedMassAttack');
                this.actionLog.rangedMassAttack = true;
            }
            for (const target of this.pos.findInRange(this.room.hostiles, 3)) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                target.hitsPredicted -= CombatIntel.getMassAttackDamageTo(
                    this,
                    target,
                );
            }
            if (this.memory.talkative) this.say(`💣`);
        }
        return result;
    }
    repair(target) {
        const result = this.creep.repair(target);
        if (result == OK && !this.actionLog.repair) {
            Stats.logIntent('repair');
            this.actionLog.repair = true;
        }
        return result;
    }
    goRepair(target) {
        if (this.repair(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    reserveController(controller) {
        if(Game.cpu.getUsed() >= 280 || Game.cpu.bucket < 9000) {
            // console.log('skip reserveController, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), controller.room.name); // zGeneral 3/2024
            return OK
        }
        const result = this.creep.reserveController(controller);
        if (result == OK && !this.actionLog.reserveController) {
            Stats.logIntent('reserveController');
            this.actionLog.reserveController = true;
        }
        return result;
    }
    // /* Say a message; maximum message length is 10 characters */
    // say(message: string, pub?: boolean) {
    // 	return this.creep.say(message, pub);
    // }
    signController(target, text) {
        const result = this.creep.signController(target, text);
        if (result == OK && !this.actionLog.signController) {
            Stats.logIntent('signController');
            this.actionLog.signController = true;
        }
        return result;
    }
    // suicide() {
    // 	return this.creep.suicide();
    // }
    upgradeController(controller) {
        if(Game.cpu.getUsed() >= 280 || Game.cpu.bucket < 9000) {
            // console.log('skip upgradeController, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), controller.room.name); // zGeneral 3/2024
            return OK
        }
        const result = this.creep.upgradeController(controller);
        if (result == OK && !this.actionLog.upgradeController) {
            Stats.logIntent('upgradeController');
            this.actionLog.upgradeController = true;
        }
        // Determine amount of upgrade power
        // let weightedUpgraderParts = _.map(this.boostCounts, )
        // let upgradeAmount = this.getActiveBodyparts(WORK) * UPGRADE_CONTROLLER_POWER;
        // let upgrade
        // Stats.accumulate(`colonies.${this.colony.name}.rcl.progressTotal`, upgradeAmount);
        return result;
    }
    heal(target, rangedHealInstead = false) {
        if (rangedHealInstead && !this.pos.isNearTo(target)) {
            return this.rangedHeal(target);
        }
        const creep = toCreep(target);
        const result = this.creep.heal(creep);
        if (result == OK) {
            if (!this.actionLog.heal) {
                Stats.logIntent('heal');
                this.actionLog.heal = true;
            }
            if (creep.hitsPredicted == undefined) {
                creep.hitsPredicted = creep.hits;
            }
            creep.hitsPredicted += CombatIntel.getHealAmount(this);
            if (this.memory.talkative) this.say('🚑');
        }
        return result;
    }
    rangedHeal(target) {
        const creep = toCreep(target);
        const result = this.creep.rangedHeal(creep);
        if (result == OK) {
            if (!this.actionLog.rangedHeal) {
                Stats.logIntent('rangedHeal');
                this.actionLog.rangedHeal = true;
            }
            if (creep.hitsPredicted == undefined) {
                creep.hitsPredicted = creep.hits;
            }
            creep.hitsPredicted += CombatIntel.getRangedHealAmount(this);
            if (this.memory.talkative) this.say(`💉`);
        }
        return result;
    }
    // transfer(target: Creep | Zerg | Structure, resourceType: ResourceConstant = RESOURCE_ENERGY, amount?: number) {
    // 	let result: ScreepsReturnCode;
    // 	if (target instanceof Zerg) {
    // 		result = this.creep.transfer(target.creep, resourceType, amount);
    // 	} else {
    // 		result = this.creep.transfer(target, resourceType, amount);
    // 	}
    // 	if (!this.actionLog.transfer) this.actionLog.transfer = (result == OK);
    // 	return result;
    // }
    // goTransfer(target: Creep | Zerg | Structure, resourceType: ResourceConstant = RESOURCE_ENERGY, amount?: number) {
    // 	if (this.pos.inRangeToPos(target.pos, RANGES.TRANSFER)) {
    // 		return this.transfer(target, resourceType, amount);
    // 	} else {
    // 		return this.goTo(target);
    // 	}
    // }
    // withdraw(target: Structure | Tombstone | Ruin,
    // resourceType: ResourceConstant = RESOURCE_ENERGY, amount?: number) {
    // 	const result = this.creep.withdraw(target, resourceType, amount);
    // 	if (!this.actionLog.withdraw) this.actionLog.withdraw = (result == OK);
    // 	return result;
    // }
    // goWithdraw(target: Structure | Tombstone, resourceType: ResourceConstant = RESOURCE_ENERGY, amount?: number) {
    // 	if (this.pos.inRangeToPos(target.pos, RANGES.WITHDRAW)) {
    // 		return this.withdraw(target, resourceType, amount);
    // 	} else {
    // 		return this.goTo(target);
    // 	}
    // }
    // Simultaneous creep actions --------------------------------------------------------------------------------------
    /**
     * Determine whether the given action will conflict with an action the creep has already taken.
     * See http://docs.screeps.com/simultaneous-actions.html for more details.
     */
    canExecute(actionName) {
        // Only one action can be executed from within a single pipeline
        let conflictingActions = [actionName];
        for (const pipeline of ACTION_PIPELINES) {
            if (pipeline.includes(actionName)) {
                conflictingActions = conflictingActions.concat(pipeline);
            }
        }
        for (const action of conflictingActions) {
            if (this.actionLog[action]) {
                return false;
            }
        }
        return true;
    }
    // Body configuration and related data -----------------------------------------------------------------------------
    getActiveBodyparts(type) {
        return this.creep.getActiveBodyparts(type);
    }
    /**
     * The same as creep.getActiveBodyparts, but just counts bodyparts regardless of condition.
     */
    getBodyparts(partType) {
        return _.filter(this.body, (part) => part.type == partType).length;
    }
    // Custom creep methods ============================================================================================
    // Carry methods
    // get hasMineralsInCarry(): boolean {
    // 	for (const [resourceType, amount] of this.carry.contents) {
    // 		if (resourceType != RESOURCE_ENERGY && amount > 0) {
    // 			return true;
    // 		}
    // 	}
    // 	return false;
    // }
    // Boosting logic --------------------------------------------------------------------------------------------------
    get boostCounts() {
        return _.countBy(this.body, (bodyPart) => bodyPart.boost);
    }
    get bodypartCounts() {
        return this.creep.bodypartCounts;
    }
    get needsBoosts() {
        if (!this.overlord) {
            return false;
        }
        if (
            (this.ticksToLive || this.lifetime) <
            MIN_LIFETIME_FOR_BOOST * this.lifetime
        ) {
            return false;
        }
        return !_.isEmpty(this.getNeededBoosts());
    }
    /**
     * Gets an object describing the amount of boosts (in minerals, not bodyparts) this Zerg needs. If the zerg is
     * fully boosted for a given resource type, the entry is removed from memory.needBoosts.
     */
    getNeededBoosts() {
        if (!this._neededBoosts) {
            // this is cleared each tick
            if (this.memory.needBoosts && this.memory.needBoosts.length > 0) {
                const neededBoosts = {};
                const boostCounts = this.boostCounts;
                const bodyCounts = this.bodypartCounts;
                for (const boost of _.cloneDeep(this.memory.needBoosts)) {
                    const bodypartType = BOOST_PARTS[boost];
                    if (!bodypartType) {
                        log.error(`${boost} is not a valid boost!`);
                    }
                    const numParts = bodyCounts[bodypartType] || 0;
                    const numBoostedParts = boostCounts[boost] || 0;
                    if (numBoostedParts < numParts) {
                        neededBoosts[boost] =
                            LAB_BOOST_MINERAL * (numParts - numBoostedParts);
                    } else {
                        _.pull(this.memory.needBoosts, boost);
                    }
                }
                this._neededBoosts = neededBoosts;
            } else {
                this._neededBoosts = {};
            }
        }
        return this._neededBoosts;
    }
    // Overlord logic --------------------------------------------------------------------------------------------------
    // get overlord(): Overlord | null {
    // 	return getOverlord(this);
    // }
    // set overlord(newOverlord: Overlord | null) {
    // 	setOverlord(this, newOverlord);
    // }
    // TODO add retire/reassignment logic
    // Eg. creep get repurposed, it gets recycled, etc
    /**
     * When a zerg has no more use for it's current overlord, it will be retired.
     * For now, that means RIP
     */
    retire() {
        this.say('💀 RIP 💀', true);
        return this.suicide();
    }
    /**
     * Reassigns the creep to work under a new overlord and as a new role.
     */
    reassign(newOverlord, newRole, invalidateTask = true) {
        this.overlord = newOverlord;
        if (
            newOverlord &&
            newOverlord.colony &&
            this.colony != newOverlord.colony
        ) {
            this.colony = newOverlord.colony;
        }
        if (newRole) {
            this.roleName = newRole;
            this.memory.role = newRole;
        }
        if (invalidateTask) {
            this.task = null;
        }
    }
    // Task logic ------------------------------------------------------------------------------------------------------
    /**
     * Wrapper for _task
     */
    get task() {
        if (!this._task) {
            this._task = this.memory.task
                ? initializeTask(this.memory.task)
                : null;
        }
        return this._task;
    }
    /**
     * Assign the creep a task with the setter, replacing creep.assign(Task)
     */
    set task(task) {
        // Unregister target from old task if applicable
        const oldProtoTask = this.memory.task;
        if (oldProtoTask) {
            const oldRef = oldProtoTask._target.ref;
            if (Overmind.cache.targets[oldRef]) {
                _.remove(
                    Overmind.cache.targets[oldRef],
                    (name) => name == this.name,
                );
            }
        }
        // Set the new task
        this.memory.task = task ? task.proto : null;
        if (task) {
            if (task.target) {
                // Register task target in cache if it is actively targeting something (excludes goTo and similar)
                if (!Overmind.cache.targets[task.target.ref]) {
                    Overmind.cache.targets[task.target.ref] = [];
                }
                Overmind.cache.targets[task.target.ref].push(this.name);
            }
            // Register references to creep
            task.creep = this;
        }
        // Clear cache
        this._task = null;
    }
    /**
     * Does the creep have a valid task at the moment?
     */
    get hasValidTask() {
        return !!this.task && this.task.isValid();
    }
    /**
     * Creeps are idle if they don't have a task.
     */
    get isIdle() {
        return !this.task || !this.task.isValid();
    }
    /**
     * Execute the task you currently have.
     */
    run() {
        if (this.task) {
            return this.task.run();
        }
    }
};
Zerg = __decorate([profile], Zerg);

// Combat Intel - provides information related to making combat-related decisions
var CombatIntel_1;
const getDefaultCombatIntelMemory = () => ({
    cache: {
        tick: Game.time,
    },
});
let CombatIntel = (CombatIntel_1 = class CombatIntel {
    constructor(directive) {
        this.directive = directive;
    }
    get memory() {
        return Mem.wrap(
            this.directive.memory,
            'combatIntel',
            getDefaultCombatIntelMemory,
        );
    }
    get room() {
        return this.directive.room;
    }
    get colony() {
        return this.directive.colony;
    }
    // Tower damage ====================================================================================================
    /**
     * Get the tower damage at a given range
     */
    static singleTowerDamage(range) {
        if (range <= TOWER_OPTIMAL_RANGE) {
            return TOWER_POWER_ATTACK;
        }
        range = Math.min(range, TOWER_FALLOFF_RANGE);
        const falloff =
            (range - TOWER_OPTIMAL_RANGE) /
            (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        return TOWER_POWER_ATTACK * (1 - TOWER_FALLOFF * falloff);
    }
    /**
     * Total tower damage from all towers in room at a given position
     * TODO needs to address stronghold
     */
    static towerDamageAtPos(pos, ignoreEnergy = false) {
        if (pos.room) {
            let expectedDamage = 0;
            for (const tower of pos.room.towers) {
                if (tower.energy > 0 || ignoreEnergy) {
                    // zGeneral 8/2023 removed tower.isActive() && from the condition
                    expectedDamage += this.singleTowerDamage(
                        pos.getRangeTo(tower),
                    );
                }
            }
            return expectedDamage;
        } else {
            log.warning(
                `CombatIntel.towerDamageAtPos: room visibility at ${pos.print}!`,
            );
            return 0;
        }
    }
    // Cost matrix calculations
    computeCostMatrix() {
        if (this.room) {
            const matrix = new PathFinder.CostMatrix();
            const barriers = this.room.barriers;
            if (barriers.length > 0) {
                const highestHits = _.last(
                    _.sortBy(barriers, (barrier) => barrier.hits),
                ).hits;
                for (const barrier of barriers) {
                    matrix.set(
                        barrier.pos.x,
                        barrier.pos.y,
                        Math.ceil((barrier.hits * 10) / highestHits) * 10,
                    );
                }
            }
            return matrix;
        }
    }
    /**
     * Calculates the total potential damage per tile in a region
     */
    static computeCreepDamagePotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            // const otherMatrix = new Array(50);
            // otherMatrix.forEach((loc, index) => otherMatrix[index] = new Array(50));
            creeps.forEach((creep) => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(
                    creep,
                );
                // const heal = CombatIntel.getHealPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach((pos) =>
                        matrix.set(
                            pos.x,
                            pos.y,
                            matrix.get(pos.x, pos.y) +
                                (meleeAttack * ATTACK_POWER) / 100,
                        ),
                    );
                }
                if (rangedAttack > 0) {
                    creep.pos
                        .getPositionsInRange(3)
                        .forEach((pos) =>
                            matrix.set(
                                pos.x,
                                pos.y,
                                matrix.get(pos.x, pos.y) +
                                    (rangedAttack * RANGED_ATTACK_POWER) / 100,
                            ),
                        );
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(
                `Cost matrix cpu used in ${room.print} = ${
                    Game.cpu.getUsed() - cpuUsed
                }`,
            );
            return matrix;
        }
    }
    /**
     * Calculates potential damage and heal per location in a region
     */
    static computeTotalCreepPotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            // const otherMatrix = new Array(50);
            // otherMatrix.forEach((loc, index) => otherMatrix[index] = new Array(50));
            creeps.forEach((creep) => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(
                    creep,
                );
                // const heal = CombatIntel.getHealPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach((pos) =>
                        matrix.set(
                            pos.x,
                            pos.y,
                            matrix.get(pos.x, pos.y) +
                                (meleeAttack * ATTACK_POWER) / 100,
                        ),
                    );
                }
                if (rangedAttack > 0) {
                    creep.pos
                        .getPositionsInRange(3)
                        .forEach((pos) =>
                            matrix.set(
                                pos.x,
                                pos.y,
                                matrix.get(pos.x, pos.y) +
                                    (rangedAttack * RANGED_ATTACK_POWER) / 100,
                            ),
                        );
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(
                `Cost matrix cpu used in ${room.print} = ${
                    Game.cpu.getUsed() - cpuUsed
                }`,
            );
            return matrix;
        }
    }
    // Fallback and exit calculations ==================================================================================
    findBestExit(matrix, towers, spawns) {
        if (!this.room) {
            return;
        }
        let bestExit;
        const destination = this.room.spawns[0] || this.room.storage; // enemy structure you are trying to get to
        if (!destination) {
            return;
        }
        const ret = Pathing.findPath(this.colony.pos, destination.pos, {
            range: 1,
        });
        if (!ret.incomplete) {
            bestExit = _.find(ret.path, (p) => p.roomName == this.room.name);
        }
        // Figure out possible exits to go from enemy room back to colony in a reasonable amount of time
        const maxRoomDistance = 8;
        const allowedExits = {};
        if (!bestExit) {
            const exitData = Game.map.describeExits(this.room.name);
            for (const direction in exitData) {
                const roomName = exitData[direction];
                const allowedRooms = Pathing.findRoute(
                    this.colony.name,
                    roomName,
                );
                if (
                    allowedRooms &&
                    Object.keys(allowedRooms).length <= maxRoomDistance
                ) {
                    allowedExits[direction] = true;
                }
            }
            if (_.keys(allowedExits).length == 0) {
                return;
            }
        }
        const exitPositions = [];
        const terrain = Game.map.getRoomTerrain(this.room.name);
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (x !== 0 && y !== 0 && x !== 49 && y !== 49) {
                    continue;
                }
                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, 0xff);
                if (bestExit) {
                    continue;
                }
                if (allowedExits['1'] && y === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                } else if (allowedExits['3'] && x === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                } else if (allowedExits['5'] && y === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                } else if (allowedExits['7'] && x === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
            }
        }
        if (!bestExit) {
            bestExit = _(exitPositions)
                .sortBy((p) => -_.sum(towers, (t) => p.getRangeTo(t)))
                .head();
        }
        matrix.set(bestExit.x, bestExit.y, 1);
        return bestExit;
    }
    // static findBestSiegeExit(roomName: string, matrix?: CostMatrix): RoomPosition | undefined  {
    // 	let edgeCoords: [number, number][] = [];
    // 	for (let x = 0; x < 50; x += 49) {
    // 		for (let y = 0; y < 50; y++) {
    // 			edgeCoords.push([x,y])
    // 		}
    // 	}
    // 	for (let x = 0; x < 50; x++) {
    // 		for (let y = 0; y < 50; y += 49) {
    // 			edgeCoords.push([x,y])
    // 		}
    // 	}
    //
    // 	const room = Game.rooms[roomName];
    // 	let siegeTarget = CombatTargeting.findBestStructureTarget()
    // }
    /**
     * Simple routine to find an assembly point outside of the target room
     */
    findSimpleSiegeFallback() {
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, {
            range: 23,
        });
        if (ret.incomplete) {
            log.warning(
                `Incomplete path while finding fallback! Destination: ${this.directive.pos.print}`,
            );
        }
        const firstPosInRoom = _.find(
            ret.path,
            (pos) => pos.roomName == this.directive.pos.roomName,
        );
        if (firstPosInRoom) {
            return CombatIntel_1.getFallbackFrom(firstPosInRoom);
        } else {
            return CombatIntel_1.getFallbackFrom(this.directive.pos);
        }
    }
    /**
     * Finds a location for a swarm to assemble outside of the target room
     */
    findSwarmAssemblyPoint(clearance, swarmIndex = 0) {
        const simpleFallback = this.findSimpleSiegeFallback();
        const startPos = Pathing.findPathablePosition(
            simpleFallback.roomName,
            clearance,
        );
        let ret = Pathing.findSwarmPath(
            startPos,
            this.directive.pos,
            clearance.width,
            clearance.height,
        );
        if (ret.incomplete) {
            log.debug(
                `Incomplete swarm path to find assembly point. Retrying with startpos = fallback.`,
            );
            ret = Pathing.findSwarmPath(
                simpleFallback,
                this.directive.pos,
                clearance.width,
                clearance.height,
            );
            if (ret.incomplete) {
                log.warning(`No pathable assembly point!`);
            }
        }
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(
            path,
            (pos) =>
                pos.roomName == simpleFallback.roomName && pos.rangeToEdge > 1,
        );
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return (
            acceptablePositions[posIndex] ||
            acceptablePositions[0] ||
            simpleFallback
        );
    }
    /**
     * Finds a location for a swarm to assemble within an owned room
     */
    findSwarmAssemblyPointInColony(clearance, swarmIndex = 0) {
        // let ret = Pathing.findSwarmPath(this.colony.pos, this.directive.pos, clearance.width, clearance.height,
        // 								{ignoreCreeps: true});
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos);
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(
            path,
            (pos) => pos.roomName == this.colony.name && pos.rangeToEdge > 1,
        );
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0];
    }
    /**
     * Fallback is a location on the other side of the nearest exit the directive is placed at
     */
    static getFallbackFrom(pos, fallbackDistance = 2) {
        let { x, y, roomName } = pos;
        const rangesToExit = [
            [x, 'left'],
            [49 - x, 'right'],
            [y, 'top'],
            [49 - y, 'bottom'],
        ];
        const [range, direction] = _.first(
            _.sortBy(rangesToExit, (pair) => pair[0]),
        );
        switch (direction) {
            case 'left':
                x = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, -1, 0);
                break;
            case 'right':
                x = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 1, 0);
                break;
            case 'top':
                y = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, -1);
                break;
            case 'bottom':
                y = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, 1);
                break;
            default:
                log.error('Error getting fallback position!');
                break;
        }
        return new RoomPosition(x, y, roomName);
    }
    // Creep potentials ================================================================================================
    /**
     * Cache the result of a computation for a tick
     */
    static cache(creep, key, callback) {
        if (!creep.intel) creep.intel = {};
        if (creep.intel[key] == undefined) {
            creep.intel[key] = callback();
        }
        return creep.intel[key];
    }
    static uniqueBoosts(creep) {
        return _.compact(
            _.unique(_.map(creep.body, (bodyPart) => bodyPart.boost)),
        );
    }
    /**
     * Check if the creep has any attack or rangedAttack parts.
     * Useful to ensure we don't create defense for harmless creeps.
     * @param creep the creeps to check
     */
    static isDangerous(creep) {
        return (
            this.cache(
                creep,
                'isDangerous',
                () =>
                    this.getRangedAttackDamage(creep) +
                    this.getAttackDamage(creep),
            ) > 0
        );
    }
    /**
     * Heal potential of a single creep in units of effective number of parts
     */
    static getHealPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'healPotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == HEAL) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.heal.T1 ||
                                    boost == BOOST_TIERS.heal.T2 ||
                                    boost == BOOST_TIERS.heal.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.heal.T1) {
                        return BOOSTS.heal.LO.heal;
                    } else if (boost == BOOST_TIERS.heal.T2) {
                        return BOOSTS.heal.LHO2.heal;
                    } else if (boost == BOOST_TIERS.heal.T3) {
                        return BOOSTS.heal.XLHO2.heal;
                    }
                }
                return 0;
            }),
        );
    }
    static getHealAmount(creep) {
        return HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    static getRangedHealAmount(creep) {
        return RANGED_HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    /**
     * If a creep appears to primarily be a healer
     */
    static isHealer(zerg) {
        const creep = toCreep(zerg);
        const healParts = _.filter(zerg.body, (part) => part.type == HEAL)
            .length;
        const attackParts = _.filter(zerg.body, (part) => part.type == ATTACK)
            .length;
        const rangedAttackParts = _.filter(
            zerg.body,
            (part) => part.type == RANGED_ATTACK,
        ).length;
        return healParts > attackParts + rangedAttackParts;
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getAttackPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'attackPotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == ATTACK) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.attack.T1 ||
                                    boost == BOOST_TIERS.attack.T2 ||
                                    boost == BOOST_TIERS.attack.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.attack.T1) {
                        return BOOSTS.attack.UH.attack;
                    } else if (boost == BOOST_TIERS.attack.T2) {
                        return BOOSTS.attack.UH2O.attack;
                    } else if (boost == BOOST_TIERS.attack.T3) {
                        return BOOSTS.attack.XUH2O.attack;
                    }
                }
                return 0;
            }),
        );
    }
    static getAttackDamage(creep) {
        return ATTACK_POWER * this.getAttackPotential(toCreep(creep));
    }
    /**
     * Ranged attack potential of a single creep in units of effective number of parts
     */
    static getRangedAttackPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'rangedAttackPotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == RANGED_ATTACK) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.ranged.T1 ||
                                    boost == BOOST_TIERS.ranged.T2 ||
                                    boost == BOOST_TIERS.ranged.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.ranged.T1) {
                        return BOOSTS.ranged_attack.KO.rangedAttack;
                    } else if (boost == BOOST_TIERS.ranged.T2) {
                        return BOOSTS.ranged_attack.KHO2.rangedAttack;
                    } else if (boost == BOOST_TIERS.ranged.T3) {
                        return BOOSTS.ranged_attack.XKHO2.rangedAttack;
                    }
                }
                return 0;
            }),
        );
    }
    static getRangedAttackDamage(creep) {
        return (
            RANGED_ATTACK_POWER * this.getRangedAttackPotential(toCreep(creep))
        );
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getDismantlePotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'dismantlePotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == WORK) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.dismantle.T1 ||
                                    boost == BOOST_TIERS.dismantle.T2 ||
                                    boost == BOOST_TIERS.dismantle.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.dismantle.T1) {
                        return BOOSTS.work.ZH.dismantle;
                    } else if (boost == BOOST_TIERS.dismantle.T2) {
                        return BOOSTS.work.ZH2O.dismantle;
                    } else if (boost == BOOST_TIERS.dismantle.T3) {
                        return BOOSTS.work.XZH2O.dismantle;
                    }
                }
                return 0;
            }),
        );
    }
    static getDismantleDamage(creep) {
        return DISMANTLE_POWER * this.getDismantlePotential(toCreep(creep));
    }
    static getRepairPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'repairPotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == WORK) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.construct.T1 ||
                                    boost == BOOST_TIERS.construct.T2 ||
                                    boost == BOOST_TIERS.construct.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.construct.T1) {
                        return BOOSTS.work.LH.repair;
                    } else if (boost == BOOST_TIERS.construct.T2) {
                        return BOOSTS.work.LH2O.repair;
                    } else if (boost == BOOST_TIERS.construct.T3) {
                        return BOOSTS.work.XLH2O.repair;
                    }
                }
                return 0;
            }),
        );
    }
    static getRepairPower(creep) {
        return REPAIR_POWER * this.getRepairPotential(toCreep(creep));
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getCarryPotential(creep, countIntendedBoosts = false) {
        return this.cache(creep, 'carryPotential', () =>
            _.sum(creep.body, function (part) {
                if (part.hits == 0) {
                    return 0;
                }
                if (part.type == CARRY) {
                    let boost = part.boost;
                    if (!boost && countIntendedBoosts && creep.my) {
                        if (creep.memory.needBoosts) {
                            boost = _.find(
                                creep.memory.needBoosts,
                                (boost) =>
                                    boost == BOOST_TIERS.carry.T1 ||
                                    boost == BOOST_TIERS.carry.T2 ||
                                    boost == BOOST_TIERS.carry.T3,
                            );
                        }
                    }
                    if (!boost) {
                        return 1;
                    } else if (boost == BOOST_TIERS.carry.T1) {
                        return BOOSTS.carry.KH.capacity;
                    } else if (boost == BOOST_TIERS.carry.T2) {
                        return BOOSTS.carry.KH2O.capacity;
                    } else if (boost == BOOST_TIERS.carry.T3) {
                        return BOOSTS.carry.XKH2O.capacity;
                    }
                }
                return 0;
            }),
        );
    }
    /**
     * Minimum damage multiplier a creep has
     */
    static minimumDamageTakenMultiplier(creep) {
        return this.cache(creep, 'minDamageMultiplier', () =>
            _.min(
                _.map(creep.body, function (part) {
                    if (part.type == TOUGH && part.hits > 0) {
                        if (part.boost == BOOST_TIERS.tough.T1) {
                            return BOOSTS.tough.GO.damage;
                        } else if (part.boost == BOOST_TIERS.tough.T2) {
                            return BOOSTS.tough.GHO2.damage;
                        } else if (part.boost == BOOST_TIERS.tough.T3) {
                            return BOOSTS.tough.XGHO2.damage;
                        }
                    }
                    return 1;
                }),
            ),
        );
    }
    static minimumDamageMultiplierForGroup(creeps) {
        return _.min(
            _.map(creeps, (creep) => this.minimumDamageTakenMultiplier(creep)),
        );
    }
    static getMassAttackDamageTo(attacker, target) {
        if (isStructure(target) && (!isOwnedStructure(target) || target.my)) {
            return 0;
        }
        const range = attacker.pos.getRangeTo(target.pos);
        let rangedMassAttackPower = 0;
        if (range <= 1) {
            rangedMassAttackPower = 10;
        } else if (range == 2) {
            rangedMassAttackPower = 4;
        } else if (range == 3) {
            rangedMassAttackPower = 1;
        }
        return (
            rangedMassAttackPower *
            this.getRangedAttackPotential(
                isStandardZerg(attacker) ? attacker.creep : attacker,
            )
        );
    }
    /**
     * Total damage to enemy creeps done by attacker.rangedMassAttack()
     */
    static getMassAttackDamage(
        attacker,
        targets = attacker.room.hostiles,
        checkRampart = true,
    ) {
        const hostiles = attacker.pos.findInRange(targets, 3);
        return _.sum(hostiles, function (hostile) {
            if (
                checkRampart &&
                hostile.pos.lookForStructure(STRUCTURE_RAMPART)
            ) {
                return 0; // Creep inside rampart
            } else {
                return CombatIntel_1.getMassAttackDamageTo(attacker, hostile);
            }
        });
    }
    /**
     * A heuristic for scoring the effectiveness of creeps
     */
    static rating(creep) {
        const c = toCreep(creep);
        return this.cache(c, 'rating', () => {
            let rating =
                this.getRangedAttackPotential(c) +
                this.getAttackPotential(c) / 2;
            const healMultiplier = 1 / this.minimumDamageTakenMultiplier(c);
            rating += healMultiplier * this.getHealPotential(c);
            return rating;
        });
    }
    // Group creep calculations ========================================================================================
    /**
     * Maximum damage that a group of creeps can dish out (doesn't count for simultaneity restrictions)
     */
    static maxDamageByCreeps(creeps) {
        return _.sum(
            creeps,
            (creep) =>
                ATTACK_POWER * this.getAttackPotential(creep) +
                RANGED_ATTACK_POWER * this.getRangedAttackPotential(creep),
        );
    }
    /**
     * Maximum healing that a group of creeps can provide (doesn't count for simultaneity restrictions)
     */
    static maxHealingByCreeps(creeps) {
        return _.sum(creeps, (creep) => this.getHealAmount(creep));
    }
    /**
     * Total attack/rangedAttack/heal potentials for a group of creeps
     */
    static getCombatPotentials(creeps) {
        const attack = _.sum(creeps, (creep) => this.getAttackPotential(creep));
        const rangedAttack = _.sum(creeps, (creep) =>
            this.getRangedAttackPotential(creep),
        );
        const heal = _.sum(creeps, (creep) => this.getHealPotential(creep));
        const dismantle = _.sum(creeps, (creep) =>
            this.getDismantlePotential(creep),
        );
        return { attack, ranged: rangedAttack, heal, dismantle };
    }
    /**
     * Total attack/rangedAttack/heal potentials for a group of creeps
     */
    static getMyCombatPotentials(zergs, countIntendedBoosts = true) {
        const attack = _.sum(zergs, (zerg) =>
            this.getAttackPotential(zerg.creep, countIntendedBoosts),
        );
        const rangedAttack = _.sum(zergs, (zerg) =>
            this.getRangedAttackPotential(zerg.creep, countIntendedBoosts),
        );
        const heal = _.sum(zergs, (zerg) =>
            this.getHealPotential(zerg.creep, countIntendedBoosts),
        );
        const dismantle = _.sum(zergs, (zerg) =>
            this.getDismantlePotential(zerg.creep, countIntendedBoosts),
        );
        return { attack, ranged: rangedAttack, heal, dismantle };
    }
    /**
     * Maximum damage that is dealable at a given position by enemy forces
     */
    static maxDamageAtPos(pos) {
        if (!pos.room) {
            return 0;
        }
        const hostilesInMeleeRange = _.filter(
            pos.room.dangerousHostiles,
            (creep) => pos.getRangeTo(creep) <= 1,
        );
        const meleeDamage = _.sum(hostilesInMeleeRange, (hostile) =>
            this.getAttackDamage(hostile),
        );
        const hostilesInRange = _.filter(
            pos.room.dangerousHostiles,
            (creep) => pos.getRangeTo(creep) <= 3,
        );
        const rangedDamage = _.sum(hostilesInRange, (hostile) =>
            this.getRangedAttackDamage(hostile),
        );
        let totalDamage = meleeDamage + rangedDamage;
        if (!pos.room.my) {
            totalDamage += this.towerDamageAtPos(pos) || 0;
        }
        return totalDamage;
    }
    /**
     * Maximum damage that is dealable at a given position by my forces
     */
    static maxAllyDamageAtPos(pos) {
        if (!pos.room) {
            return 0;
        }
        const myCreepsInMeleeRange = _.filter(
            pos.room.creeps,
            (creep) => pos.getRangeTo(creep) <= 1,
        );
        const meleeDamage = _.sum(myCreepsInMeleeRange, (hostile) =>
            this.getAttackDamage(hostile),
        );
        const myCreepsInRange = _.filter(
            pos.room.creeps,
            (creep) => pos.getRangeTo(creep) <= 3,
        );
        const rangedDamage = _.sum(myCreepsInRange, (hostile) =>
            this.getRangedAttackDamage(hostile),
        );
        let totalDamage = meleeDamage + rangedDamage;
        if (pos.room.my) {
            totalDamage += this.towerDamageAtPos(pos) || 0;
        }
        return totalDamage;
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxHostileHealingTo(creep) {
        return this.cache(creep, 'maxHostileHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.hostiles, (hostile) =>
                hostile.pos.isNearTo(creep),
            );
            const neighborHealing = _.sum(neighbors, (neighbor) =>
                this.getHealAmount(neighbor),
            );
            const rangedHealers = _.filter(
                creep.room.hostiles,
                (hostile) =>
                    hostile.pos.getRangeTo(creep) <= 3 &&
                    !neighbors.includes(hostile),
            );
            const rangedHealing = _.sum(rangedHealers, (healer) =>
                this.getRangedHealAmount(healer),
            );
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static avgHostileHealingTo(creeps) {
        return (
            _.max(
                _.map(creeps, (creep) =>
                    CombatIntel_1.maxHostileHealingTo(creep),
                ),
            ) / creeps.length
        );
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxFriendlyHealingTo(friendly) {
        const creep = toCreep(friendly);
        return this.cache(creep, 'maxFriendlyHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.creeps, (hostile) =>
                hostile.pos.isNearTo(creep),
            );
            const neighborHealing = _.sum(neighbors, (neighbor) =>
                this.getHealAmount(neighbor),
            );
            const rangedHealers = _.filter(
                creep.room.creeps,
                (hostile) =>
                    hostile.pos.getRangeTo(creep) <= 3 &&
                    !neighbors.includes(hostile),
            );
            const rangedHealing = _.sum(rangedHealers, (healer) =>
                this.getHealAmount(healer),
            );
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Determine the predicted damage amount of a certain type of attack. Can specify if you should use predicted or
     * current hits amount and whether to include predicted healing. Does not update predicted hits.
     */
    static predictedDamageAmount(
        attacker,
        target,
        attackType,
        useHitsPredicted = true,
    ) {
        // Compute initial (gross) damage amount
        let grossDamage;
        if (attackType == 'attack') {
            grossDamage = this.getAttackDamage(attacker);
        } else if (attackType == 'rangedAttack') {
            grossDamage = this.getRangedAttackDamage(attacker);
        } else {
            // rangedMassAttack; not currently used
            grossDamage = this.getMassAttackDamageTo(attacker, target);
        }
        // Adjust for remaining tough parts
        let toughHits;
        let damageMultiplier;
        if (isCreep(target)) {
            if (useHitsPredicted) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                const nonToughHits = _.sum(target.body, (part) =>
                    part.type == TOUGH ? 0 : part.hits,
                );
                toughHits = Math.min(target.hitsPredicted - nonToughHits, 0); // predicted amount of TOUGH
            } else {
                toughHits = 100 * target.getActiveBodyparts(TOUGH);
            }
            damageMultiplier = this.minimumDamageTakenMultiplier(target); // assumes only 1 tier of boosts
        } else {
            toughHits = 0;
            damageMultiplier = 1;
        }
        if (grossDamage * damageMultiplier < toughHits) {
            // if you can't eat through armor
            return grossDamage * damageMultiplier;
        } else {
            // if you break tough shield
            grossDamage -= toughHits / damageMultiplier;
            return toughHits + grossDamage;
        }
    }
    // Creep position calculations =====================================================================================
    // // Distance from a given creep to the nearest rampart or wall; Infinity if no barriers in room
    // static distanceToBarrier(creep: Creep): number {
    //
    // }
    static isApproaching(approacher, toPos) {
        const previousPos = RoomIntel.getPreviousPos(approacher);
        const previousRange = toPos.getRangeTo(previousPos);
        const currentRange = toPos.getRangeTo(approacher.pos);
        return currentRange < previousRange;
    }
    static isRetreating(retreater, fromPos) {
        const previousPos = RoomIntel.getPreviousPos(retreater);
        const previousRange = fromPos.getRangeTo(previousPos);
        const currentRange = fromPos.getRangeTo(retreater.pos);
        return currentRange > previousRange;
    }
    /**
     * This method is probably expensive; use sparingly
     */
    static isEdgeDancing(creep, reentryThreshold = 3) {
        return false;
        // TODO: rewrite this
        // if (!creep.room.my) {
        // 	log.warning(`isEdgeDancing should only be called in owned rooms!`);
        // }
        // const creepOccupancies = creep.room.memory[RMEM.CREEPS_IN_ROOM];
        // if (creepOccupancies) {
        // 	// Look to see if the creep has exited and re-entered the room a given number of times
        // 	const creepInRoomTicks = [];
        // 	for (const tick in creepOccupancies) {
        // 		if (creepOccupancies[tick].includes(creep.name)) {
        // 			creepInRoomTicks.push(parseInt(tick, 10));
        // 		}
        // 	}
        // 	let reentries = 1;
        // 	if (creepInRoomTicks.length > 0) {
        // 		for (const i of _.range(creepInRoomTicks.length - 1)) {
        // 			if (creepInRoomTicks[i + 1] != creepInRoomTicks[i] + 1) {
        // 				// There was a gap between the creep's presence in the room so it must have reentered
        // 				reentries++;
        // 			}
        // 		}
        // 	}
        // 	return reentries >= reentryThreshold;
        // } else {
        // 	return false;
        // }
    }
    static getPositionsNearEnemies(hostiles, range = 0) {
        return _.unique(
            _.flatten(
                _.map(hostiles, (hostile) =>
                    hostile.pos.getPositionsInRange(range, false, true),
                ),
            ),
        );
    }
});
CombatIntel = CombatIntel_1 = __decorate([profile], CombatIntel);
// For debugging
global.CombatIntel = CombatIntel;

/**
 * Prioritized list of what order structures should be built in
 */
const BuildPriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_TERMINAL,
    STRUCTURE_STORAGE,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_CONTAINER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_FACTORY,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_ROAD,
];
/**
 * Prioritized list of what order structures should be fortified in case of nuclear strike
 */
const FortifyPriorities = [
    STRUCTURE_TERMINAL,
    STRUCTURE_STORAGE,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_FACTORY,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
];
/**
 * Prioritized list of what order enemy structures should be attacked in
 */
const AttackStructurePriorities = [
    STRUCTURE_RAMPART,
    STRUCTURE_EXTENSION, // zGeneral 8/2023
    STRUCTURE_TOWER,

    STRUCTURE_SPAWN,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_FACTORY,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
    STRUCTURE_POWER_BANK,
];
const AttackStructurePrioritiesW13N48 = [
    //STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    //STRUCTURE_STORAGE,
    //STRUCTURE_TERMINAL,
    STRUCTURE_FACTORY,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
const DismantleStructurePriorities = [
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
];
const AttackStructureScores = _.zipObject(
    _.map(AttackStructurePriorities, (type) => [
        type,
        AttackStructurePriorities.length -
            _.indexOf(AttackStructurePriorities, type),
    ]),
);
/**
 * Prioritized list of what order owned structures should be demolished (and then moved) in
 */
const DemolishStructurePriorities = [
    { structureType: STRUCTURE_EXTENSION, maxRemoved: 15 },
    { structureType: STRUCTURE_SPAWN, maxRemoved: 1 },
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_TOWER, maxRemoved: 1 },
    { structureType: STRUCTURE_LINK },
    { structureType: STRUCTURE_LAB },
    { structureType: STRUCTURE_NUKER },
    { structureType: STRUCTURE_OBSERVER },
    // {structureType: STRUCTURE_EXTRACTOR, maxRemoved: 1}, // skip extractor; doesn't need to be relocated
    { structureType: STRUCTURE_POWER_SPAWN },
    // {structureType: STRUCTURE_ROAD}, // just let roads decay
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_STORAGE, maxRemoved: 1 },
    { structureType: STRUCTURE_TERMINAL, maxRemoved: 1 },
    { structureType: STRUCTURE_WALL },
    { structureType: STRUCTURE_RAMPART },
];

let CombatTargeting = class CombatTargeting {
    static findBestCreepTargetInRange2(zerg, range, targets = zerg.room.hostiles) {
        // Filter out enemy creeps that are beyond the specified range.
        const enemiesInRange = _.filter(targets, enemy => zerg.pos.getRangeTo(enemy) <= range);
    
        // Filter out enemy creeps that are positioned at the room's edge.
        const enemiesAwayFromEdge = _.filter(enemiesInRange, enemy => enemy.pos.rangeToEdge > 0);
    
        // Filter out enemy creeps that are protected inside ramparts.
        const unprotectedEnemies = _.filter(enemiesAwayFromEdge, enemy => !enemy.inRampart);
    
        // Sort unprotected enemy creeps based on priority and strategy.
        unprotectedEnemies.sort((enemyA, enemyB) => {
            // Priority 1: Active MOVE part at [0]
            const hasActiveMoveAtStartA = enemyA.body[0].type === MOVE && enemyA.body[0].hits > 0;
            const hasActiveMoveAtStartB = enemyB.body[0].type === MOVE && enemyB.body[0].hits > 0;
            if (hasActiveMoveAtStartA && !hasActiveMoveAtStartB) return -1;
            if (!hasActiveMoveAtStartA && hasActiveMoveAtStartB) return 1;
    
            // Priority 2: No active MOVE parts at all to be last
            const hasAnyActiveMoveA = enemyA.body.some(part => part.type === MOVE && part.hits > 0);
            const hasAnyActiveMoveB = enemyB.body.some(part => part.type === MOVE && part.hits > 0);
            if (!hasAnyActiveMoveA && hasAnyActiveMoveB) return -1;
            if (hasAnyActiveMoveA && !hasAnyActiveMoveB) return 1;


    
            // Subsequent priorities
            const healDifference = enemyB.getActiveBodyparts(HEAL) - enemyA.getActiveBodyparts(HEAL);
            if (healDifference !== 0) return healDifference;
    
            const rangedAttackDifference = enemyB.getActiveBodyparts(RANGED_ATTACK) - enemyA.getActiveBodyparts(RANGED_ATTACK);
            if (rangedAttackDifference !== 0) return rangedAttackDifference;
    
            const attackDifference = enemyB.getActiveBodyparts(ATTACK) - enemyA.getActiveBodyparts(ATTACK);
            if (attackDifference !== 0) return attackDifference;
    
            const proximityDifference = enemyA.pos.getRangeTo(zerg) - enemyB.pos.getRangeTo(zerg);
            if (proximityDifference !== 0) return proximityDifference;
    
            const healthPercentageA = enemyA.hits / enemyA.hitsMax;
            const healthPercentageB = enemyB.hits / enemyB.hitsMax;
            return healthPercentageA - healthPercentageB;
        });
    
        // Return the highest-priority enemy from the sorted list.
        return unprotectedEnemies[0];
    }


    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetInRange(
        zerg,
        range,
        targets = zerg.room.hostiles,
    ) {
        const nearbyHostiles = _.filter(targets, (c) =>
            zerg.pos.inRangeToXY(c.pos.x, c.pos.y, range),
        );
        return maxBy(nearbyHostiles, function (hostile) {
            if (hostile.hitsPredicted == undefined) {
                hostile.hitsPredicted = hostile.hits;
            }
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) return false;
            return (
                hostile.hitsMax -
                hostile.hitsPredicted +
                CombatIntel.getHealPotential(hostile)
            ); // compute score
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestStructureTargetInRange(zerg, range, allowUnowned = true) {
        let nearbyStructures = _.filter(zerg.room.hostileStructures, (s) =>
            zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range),
        );
        // If no owned structures to attack and not in colony room or outpost, target unowned structures
        if (
            allowUnowned &&
            nearbyStructures.length == 0 &&
            !Overmind.colonyMap[zerg.room.name]
        ) {
            nearbyStructures = _.filter(zerg.room.structures, (s) =>
                zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range),
            );
        }
        return maxBy(nearbyStructures, function (structure) {
            let score = 10 * AttackStructureScores[structure.structureType];
            if (structure.pos.lookForStructure(STRUCTURE_RAMPART)) score *= 0.1;
            return score;
        });
    }
    /**
     * Standard target-finding logic
     */
    static findTarget(zerg, targets = zerg.room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined) {
                hostile.hitsPredicted = hostile.hits;
            }
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) return false;
            return (
                hostile.hitsMax -
                hostile.hitsPredicted +
                CombatIntel.getHealPotential(hostile) -
                10 * zerg.pos.getMultiRoomRangeTo(hostile.pos)
            ); // compute score
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetForTowers(room, targets = room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined) {
                hostile.hitsPredicted = hostile.hits;
            }
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) return false;
            return (
                hostile.hitsMax -
                hostile.hitsPredicted +
                CombatIntel.getHealPotential(hostile) +
                (CombatIntel.towerDamageAtPos(hostile.pos) || 0)
            );
        });
    }
    static findClosestHostile2(zerg, opts) {
    // Set default options.
    _.defaults(opts, {
        checkReachable: false,
        ignoreCreepsAtEdge: true,
        playerOnly: false,
        onlyUnramparted: false,
        ignoreDefenseless: false
    });

    // Early exit if no hostiles are present.
    if (!zerg.room.hostiles.length) return;

    // Determine potential targets based on options.
    const potentialTargets = opts.playerOnly ? zerg.room.playerHostiles : zerg.room.hostiles;
    
    // Filter out hostiles at the edge if the option is set.
    let targets = opts.ignoreCreepsAtEdge
        ? _.filter(potentialTargets, hostile => hostile.pos.rangeToEdge > 0)
        : potentialTargets;

    // Filter out hostiles inside ramparts if the option is set.
    if (opts.onlyUnramparted) {
        targets = _.filter(targets, hostile => !hostile.inRampart);
    }

    // For enemies <= 3 range away:
    const closeTargets = _.filter(targets, target => zerg.pos.getRangeTo(target) <= 3);
    
    // Filter out enemies with only MOVE parts if ignoreDefenseless is true.
    /*
    const filteredCloseTargets = _.filter(closeTargets, target => {
        if (opts.ignoreDefenseless) {
            const totalParts = _.sum(target.getActiveBodyparts());
            const moveParts = target.getActiveBodyparts(MOVE);
            return totalParts !== moveParts;  // Ensure there are other parts besides MOVE.
        }
        return true;
    });
    */
    // Filter out enemies based on the provided options.
    const filteredCloseTargets = _.filter(closeTargets, target => {
        const moveParts = target.getActiveBodyparts(MOVE);
        const healParts = target.getActiveBodyparts(HEAL);
        const totalParts = _.sum(target.getActiveBodyparts());
    
        if (opts.ignoreDefenseless) {
            // Option 1: Ignore creeps that only have MOVE parts.
            if (moveParts === totalParts) {
                return false;
            }
    
            // Option 2: No MOVE or HEAL parts and isolated from friendly creeps.
            if (!moveParts && !healParts) {
                const friendlyCreepsNearby = target.pos.findInRange(FIND_MY_CREEPS, 3);
                if (!friendlyCreepsNearby.length) {
                    return false;  // Ignore this target.
                }
            }
        }
    
        return true;
    });

    /*

    // Sort close targets based on priority: HEAL > RANGED_ATTACK > MELEE.
    filteredCloseTargets.sort((a, b) => {
        if (a.getActiveBodyparts(HEAL) > 0) return -1;
        if (b.getActiveBodyparts(HEAL) > 0) return 1;
        if (a.getActiveBodyparts(RANGED_ATTACK) > 0) return -1;
        if (b.getActiveBodyparts(RANGED_ATTACK) > 0) return 1;
        if (a.getActiveBodyparts(ATTACK) > 0) return -1;
        if (b.getActiveBodyparts(ATTACK) > 0) return 1;
        return 0;
    });
    
    */
    filteredCloseTargets.sort((a, b) => {
        // Prioritize by number of HEAL parts
        const healDiff = b.getActiveBodyparts(HEAL) - a.getActiveBodyparts(HEAL);
        if (healDiff !== 0) return healDiff;
    
        // Prioritize by number of RANGED_ATTACK parts
        const rangedAttackDiff = b.getActiveBodyparts(RANGED_ATTACK) - a.getActiveBodyparts(RANGED_ATTACK);
        if (rangedAttackDiff !== 0) return rangedAttackDiff;
    
        // Prioritize by number of ATTACK parts
        const attackDiff = b.getActiveBodyparts(ATTACK) - a.getActiveBodyparts(ATTACK);
        if (attackDiff !== 0) return attackDiff;
    
        // Prioritize by proximity to the zerg
        const rangeDiff = a.pos.getRangeTo(zerg) - b.pos.getRangeTo(zerg);
        if (rangeDiff !== 0) return rangeDiff;
    
        // Prioritize by health percentage (lower health first)
        const healthPercentageA = a.hits / a.hitsMax;
        const healthPercentageB = b.hits / b.hitsMax;
        return healthPercentageA - healthPercentageB;
    });

    
    
    

    // For enemies > 3 range away, find primary distant targets.
    const distantTargets = _.difference(targets, closeTargets);
    
    const primaryDistantTarget = _.find(distantTargets, target => {
    const totalParts = _.sum(target.getActiveBodyparts());
    const moveParts = target.getActiveBodyparts(MOVE);
    return totalParts !== moveParts;  // Ensure the target has more than just the MOVE part active.
});

    // Return the top target from the combined list of close and distant targets.
    return filteredCloseTargets[0] || primaryDistantTarget;
}


    static findClosestHostile(zerg, opts) {
        _.defaults(opts, {
            checkReachable: false,
            ignoreCreepsAtEdge: true,
            playerOnly: false,
            onlyUnramparted: false,
        });
        if (zerg.room.hostiles.length > 0) {
            let targets;
            const potentialTargets = opts.playerOnly
                ? zerg.room.playerHostiles
                : zerg.room.hostiles;
            if (opts.ignoreCreepsAtEdge) {
                targets = _.filter(
                    potentialTargets,
                    (hostile) => hostile.pos.rangeToEdge > 0,
                );
            } else {
                targets = potentialTargets;
            }
            if (opts.onlyUnramparted) {
                targets = _.filter(targets, (hostile) => !hostile.inRampart);
            }
            if (opts.checkReachable) {
                const targetsByRange = _.sortBy(targets, (target) =>
                    zerg.pos.getRangeTo(target),
                );
                return _.find(targetsByRange, (target) =>
                    Pathing.isReachable(
                        zerg.pos,
                        target.pos,
                        zerg.room.barriers.filter(
                            (barrier) =>
                                barrier.structureType == STRUCTURE_WALL ||
                                (barrier.structureType == STRUCTURE_RAMPART &&
                                    (barrier.owner.username == MY_USERNAME ||
                                        !barrier.isPublic)),
                        ),
                    ),
                );
            } else {
                return zerg.pos.findClosestByRange(targets);
            }
        }
    }
    // This method is expensive
    static findClosestReachable(pos, targets) {
        const targetsByRange = _.sortBy(targets, (target) =>
            pos.getRangeTo(target),
        );
        return _.find(targetsByRange, (target) =>
            Pathing.isReachable(pos, target.pos, target.room.barriers),
        );
    }
    static findClosestHurtFriendly(healer) {
        // do not consider 'drill' role as it is always hurt
        return healer.pos.findClosestByRange(
            _.filter(
                healer.room.creeps,
                (creep) =>
                    creep.hits < creep.hitsMax &&
                    !(creep.memory && creep.memory.role == 'drill'),
            ),
        );
    }
    /**
     * Finds the best (friendly) target in range that a zerg can currently heal
     */
    static findBestHealingTargetInRange(
        healer,
        range = 3,
        friendlies = healer.room.creeps,
    ) {
        const tempHitsPredicted = {};
        return maxBy(
            _.filter(friendlies, (f) => healer.pos.getRangeTo(f) <= range),
            (friend) => {
                if (friend.hitsPredicted == undefined) {
                    friend.hitsPredicted = friend.hits;
                }
                const attackProbability = 0.5;
                tempHitsPredicted[friend.id] = friend.hitsPredicted;
                for (const hostile of friend.pos.findInRange(
                    friend.room.hostiles,
                    3,
                )) {
                    if (!friend.inRampart) {
                        if (hostile.pos.isNearTo(friend)) {
                            tempHitsPredicted[friend.id] -=
                                attackProbability *
                                CombatIntel.getAttackDamage(hostile);
                        } else {
                            tempHitsPredicted[friend.id] -=
                                attackProbability *
                                CombatIntel.getRangedAttackDamage(hostile);
                        }
                    }
                }
                const missingHits =
                    friend.hitsMax - tempHitsPredicted[friend.id];
                if (healer.pos.getRangeTo(friend) > 1) {
                    return Math.min(
                        missingHits,
                        CombatIntel.getRangedHealAmount(healer.creep),
                    );
                } else {
                    return Math.min(
                        missingHits,
                        CombatIntel.getHealAmount(healer.creep),
                    );
                }
            },
        );
    }
    static findClosestPrioritizedStructure(zerg, checkReachable = false) {
        if (zerg.room.name == 'W13N48') {
            for (const structureType of AttackStructurePrioritiesW13N48) {
                const structures = _.filter(
                    zerg.room.hostileStructures,
                    (s) => s.structureType == structureType,
                );
                if (structures.length == 0) continue;
                if (checkReachable) {
                    const closestReachable = this.findClosestReachable(
                        zerg.pos,
                        structures,
                    );
                    if (closestReachable) return closestReachable;
                } else {
                    return zerg.pos.findClosestByRange(structures);
                }
            }
        } else {
            for (const structureType of AttackStructurePriorities) {
                const structures = _.filter(
                    zerg.room.hostileStructures,
                    (s) => s.structureType == structureType,
                );
                if (structures.length == 0) continue;
                if (checkReachable) {
                    const closestReachable = this.findClosestReachable(
                        zerg.pos,
                        structures,
                    );
                    if (closestReachable) return closestReachable;
                } else {
                    return zerg.pos.findClosestByRange(structures);
                }
            }
        }

        const core = _.filter(
            zerg.room.hostileStructures,
            (s) => s.structureType.toString() == 'invaderCore',
        );
        if (core.length != 0) {
            return core[0];
        }
    }
    static findClosestPrioritizedDismantleStructure(
        zerg,
        checkReachable = false,
    ) {
        for (const structureType of DismantleStructurePriorities) {
            const structures = _.filter(
                zerg.room.hostileStructures,
                (s) => s.structureType == structureType,
            );
            if (checkReachable) {
                const closestReachable = this.findClosestReachable(
                    zerg.pos,
                    structures,
                );
                if (closestReachable) return closestReachable;
            } else {
                return zerg.pos.findClosestByRange(structures);
            }
        }
    }
    static findBestStructureTarget(pos) {
        const room = Game.rooms[pos.roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        // Look for any unprotected structures
        const unprotectedRepairables = _.filter(room.repairables, (s) => {
            const rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
            return !rampart || rampart.hits < 10000;
        });
        let approach = _.map(unprotectedRepairables, (structure) => {
            return { pos: structure.pos, range: 0 };
        });
        if (room.barriers.length == 0 && unprotectedRepairables.length == 0) {
            return;
        } // if there's nothing in the room
        // Try to find a reachable unprotected structure
        if (approach.length > 0) {
            const ret = PathFinder.search(pos, approach, {
                maxRooms: 1,
                maxOps: 2000,
                roomCallback: (roomName) => {
                    if (roomName != room.name) return false;
                    const matrix = new PathFinder.CostMatrix();
                    for (const barrier of room.barriers) {
                        matrix.set(barrier.pos.x, barrier.pos.y, 0xff);
                    }
                    return matrix;
                },
            });
            const targetPos = _.last(ret.path);
            if (!ret.incomplete && targetPos) {
                const targetStructure = _.first(
                    _.filter(targetPos.lookFor(LOOK_STRUCTURES), (s) => {
                        return (
                            s.structureType != STRUCTURE_ROAD &&
                            s.structureType != STRUCTURE_CONTAINER
                        );
                    }),
                );
                if (targetStructure) {
                    log.debug(
                        `Found unprotected structure target @ ${targetPos.print}`,
                    );
                    return targetStructure;
                }
            }
        }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0) targets = room.repairables;
        if (targets.length == 0) targets = room.barriers;
        if (targets.length == 0) targets = room.structures;
        if (targets.length == 0) return;
        // Recalculate approach targets
        approach = _.map(targets, (s) => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, (b) => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(pos, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: (roomName) => {
                if (roomName != pos.roomName) return false;
                const matrix = new PathFinder.CostMatrix();
                for (const barrier of room.barriers) {
                    const cost =
                        100 + Math.round((barrier.hits / maxWallHits) * 100);
                    matrix.set(barrier.pos.x, barrier.pos.y, cost);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path
        for (const pos of ret.path) {
            const targetStructure = _.first(
                _.filter(pos.lookFor(LOOK_STRUCTURES), (s) => {
                    return (
                        s.structureType != STRUCTURE_ROAD &&
                        s.structureType != STRUCTURE_CONTAINER
                    );
                }),
            );
            if (targetStructure) {
                log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                return targetStructure;
            }
        }
    }
    static findBestSwarmStructureTarget(
        swarm,
        roomName,
        randomness = 0,
        displayCostMatrix = false,
    ) {
        const room = Game.rooms[roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        if (swarm.anchor.roomName != roomName) {
            log.warning(`Swarm is not in target room!`);
            return;
        }
        // // Look for any unprotected structures
        // let unprotectedRepairables = _.filter(room.repairables, s => {
        // 	let rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
        // 	return !rampart || rampart.hits < 10000;
        // });
        // let approach = _.map(unprotectedRepairables, structure => {
        // 	return {pos: structure.pos, range: 0};
        // }) as PathFinderGoal[];
        // if (room.barriers.length == 0 && unprotectedRepairables.length == 0) return; // if there's nothing in the room
        //
        // // Try to find a reachable unprotected structure
        // if (approach.length > 0) {
        // 	let ret = PathFinder.search(swarm.anchor, approach, {
        // 		maxRooms    : 1,
        // 		maxOps      : 2000,
        // 		roomCallback: roomName => {
        // 			if (roomName != room.name) return false;
        // 			let matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();
        // 			for (let barrier of room.barriers) {
        // 				let setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);
        // 				for (let pos of setPositions) {
        // 					matrix.set(pos.x, pos.y, 0xff);
        // 				}
        // 			}
        // 			return matrix;
        // 		},
        // 	});
        // 	let targetPos = _.last(ret.path);
        // 	if (!ret.incomplete && targetPos) {
        // 		let targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {
        // 			return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
        // 		}));
        // 		if (targetStructure) {
        // 			log.debug(`Found unprotected structure target @ ${targetPos.print}`);
        // 			return targetStructure;
        // 		}
        // 	}
        // }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0) targets = room.towers;
        if (targets.length == 0) targets = room.repairables;
        if (targets.length == 0) targets = room.barriers;
        if (targets.length == 0) targets = room.structures;
        if (targets.length == 0) return;
        // Recalculate approach targets
        const approach = _.map(targets, (s) => {
            // TODO: might need to Pathing.getPosWindow() this
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, (b) => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(swarm.anchor, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: (rn) => {
                if (rn != roomName) return false;
                const matrix = MatrixLib.getSwarmTerrainMatrix(
                    roomName,
                    { plainCost: 1, swampCost: 5 },
                    swarm.width,
                    swarm.height,
                );
                for (const barrier of room.barriers) {
                    const randomFactor = Math.min(
                        Math.round(randomness * Math.random()),
                        100,
                    );
                    const cost =
                        100 +
                        Math.round((barrier.hits / maxWallHits) * 100) +
                        randomFactor;
                    MatrixLib.setToMaxCostAfterMaxPooling(
                        matrix,
                        [barrier],
                        swarm.width,
                        swarm.height,
                        cost,
                    );
                }
                if (displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path or neighboring positions
        for (const pos of ret.path) {
            log.debug(`Searching path ${pos.print}...`);
            const searchPositions = Pathing.getPosWindow(
                pos,
                swarm.width,
                swarm.height,
            ); // not -1*width
            for (const searchPos of searchPositions) {
                const targetStructure = _.first(
                    _.filter(searchPos.lookFor(LOOK_STRUCTURES), (s) => {
                        return (
                            s.structureType != STRUCTURE_ROAD &&
                            s.structureType != STRUCTURE_CONTAINER
                        );
                    }),
                );
                if (targetStructure) {
                    log.debug(
                        `Targeting structure @ ${targetStructure.pos.print}`,
                    );
                    return targetStructure;
                }
            }
        }
    }
};
CombatTargeting = __decorate([profile], CombatTargeting);

const getDefaultSwarmMemory = () => ({
    creeps: [],
    orientation: TOP,
    numRetreats: 0,
});
const ERR_NOT_ALL_OK = -7;
const DEBUG = true;
/**
 * Swarms represent a coordinated group of creeps moving as a single unit and use special-purpose pathing and movement
 * functions to ensure they don't get separated
 */
let Swarm = class Swarm {
    constructor(overlord, ref, creeps, width = 2, height = 2) {
        this.overlord = overlord;
        this.ref = ref;
        this.memory = Mem.wrap(
            overlord.memory,
            `swarm:${ref}`,
            getDefaultSwarmMemory,
        );
        // Build the static formation by putting attackers at the front and healers at the rear
        const paddedCreeps = _.clone(creeps);
        for (let i = paddedCreeps.length; i < width * height; i++) {
            paddedCreeps.push(undefined); // fill in remaining positions with undefined
        }
        const creepScores = this.getCreepScores(paddedCreeps);
        const sortedCreeps = _.sortBy(
            paddedCreeps,
            (creep) =>
                creepScores[creep != undefined ? creep.name : 'undefined'],
        );
        this.uniformCreepType =
            _.unique(_.filter(_.values(creepScores), (score) => score != 0))
                .length <= 1;
        this.staticFormation = _.chunk(sortedCreeps, width);
        this.width = width;
        this.height = height;
        const firstCreepIndex = _.findIndex(sortedCreeps);
        let leadPos; // upper left corner of formation when in TOP orientation
        if (firstCreepIndex != -1) {
            const firstCreepPos = sortedCreeps[firstCreepIndex].pos;
            const dx = firstCreepIndex % width;
            const dy = Math.floor(firstCreepIndex / width);
            leadPos = firstCreepPos.getOffsetPos(-dx, -dy);
        } else {
            leadPos = this.overlord.pos;
        }
        switch (this.orientation) {
            case TOP:
                this.anchor = leadPos;
                break;
            case RIGHT:
                this.anchor = leadPos.getOffsetPos(-1 * (height - 1), 0);
                break;
            case BOTTOM:
                this.anchor = leadPos.getOffsetPos(
                    -1 * (width - 1),
                    -1 * (height - 1),
                );
                break;
            case LEFT:
                this.anchor = leadPos.getOffsetPos(0, -1 * (width - 1));
                break;
        }
        this.formation = rotatedMatrix(
            this.staticFormation,
            this.rotationsFromOrientation(this.orientation),
        );
        this.creeps = creeps;
        this.rooms = _.unique(
            _.map(this.creeps, (creep) => creep.room),
            (room) => room.name,
        );
        this.roomsByName = _.zipObject(
            _.map(this.rooms, (room) => [room.name, room]),
        );
        this.fatigue = _.max(_.map(this.creeps, (creep) => creep.fatigue));
        this.debug(
            `\n${this.print} tick ${Game.time} ========================================`,
        );
        // this.debug(`Orientation: ${this.orientation}, anchor: ${this.anchor.print}, leadPos: ${leadPos.print}`);
        // this.debug(`Formation: ${this.printFormation(this.formation)}`);
        // this.debug(`StaticFormation: ${this.printFormation(this.staticFormation)}`);
    }
    getCreepScores(creeps) {
        const keys = _.map(creeps, (c) =>
            c != undefined ? c.name : 'undefined',
        );
        const values = _.map(creeps, (z) => {
            if (z == undefined) {
                return 0;
            } else {
                const score =
                    CombatIntel.getAttackPotential(z.creep) +
                    CombatIntel.getRangedAttackPotential(z.creep) +
                    CombatIntel.getDismantlePotential(z.creep) -
                    CombatIntel.getHealPotential(z.creep);
                return -1 * score || 1;
            }
        });
        return _.zipObject(keys, values);
    }
    printFormation(formation) {
        const names = _.map(formation, (creeps) =>
            _.map(creeps, (creep) => (creep ? creep.name : 'NONE')),
        );
        const SPACE = '    ';
        let msg = '';
        for (const row of names) {
            msg += '\n' + SPACE;
            for (const name of row) {
                if (name != 'NONE') {
                    const role = name.split('_')[0];
                    const num = name.split('_')[1];
                    const shortName = role.slice(0, 4 - num.length) + num;
                    msg += shortName;
                } else {
                    msg += name;
                }
                msg += ' ';
            }
        }
        return msg;
    }
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            (this.anchor || this.rooms[0]).roomName +
            '">[' +
            `Swarm ` +
            this.ref +
            ']</a>'
        );
    }
    debug(...args) {
        {
            console.log(args);
        }
    }
    // This should occasionally be executed at run() phase
    static cleanMemory(overlord) {
        for (const ref in overlord.swarms) {
            // TODO
        }
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        // If nothing found
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(100) };
        } else {
            delete this.memory.target;
        }
    }
    get orientation() {
        return this.memory.orientation;
    }
    set orientation(direction) {
        this.memory.orientation = direction;
        this.formation = rotatedMatrix(
            this.staticFormation,
            this.rotationsFromOrientation(direction),
        );
    }
    /**
     * Pivots the swarm formation clockwise or counterclockwise
     */
    pivot(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Rotating ${direction}`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(
            `c1...c4: ${this.printFormation([
                [c1, c2],
                [c3, c4],
            ])}`,
        );
        let r1,
            r2,
            r3,
            r4 = OK;
        if (direction == 'clockwise') {
            if (c1) r1 = c1.move(RIGHT);
            if (c2) r2 = c2.move(BOTTOM);
            if (c3) r3 = c3.move(TOP);
            if (c4) r4 = c4.move(LEFT);
        } else {
            if (c1) r1 = c1.move(BOTTOM);
            if (c2) r2 = c2.move(LEFT);
            if (c3) r3 = c3.move(RIGHT);
            if (c4) r4 = c4.move(TOP);
        }
        const allMoved = _.all([r1, r2, r3, r4], (r) => r == OK);
        if (allMoved) {
            return OK;
        } else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return (
                -1 * (_.findIndex([r1, r2, r3, r4], (r) => r != OK) || 899) -
                100
            );
        }
    }
    /**
     * Reverses the orientation of the swarm formation in an X pattern to preserve the reflective parity of the
     * original formation
     */
    swap(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Swapping ${direction}ly`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(
            `c1...c4: ${this.printFormation([
                [c1, c2],
                [c3, c4],
            ])}`,
        );
        let r1,
            r2,
            r3,
            r4 = OK;
        // This operation is actually the same for both horizontal and vertical swaps
        if (c1) r1 = c1.move(BOTTOM_RIGHT);
        if (c2) r2 = c2.move(BOTTOM_LEFT);
        if (c3) r3 = c3.move(TOP_RIGHT);
        if (c4) r4 = c4.move(TOP_LEFT);
        const allMoved = _.all([r1, r2, r3, r4], (r) => r == OK);
        if (allMoved) {
            return OK;
        } else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return (
                -1 * (_.findIndex([r1, r2, r3, r4], (r) => r != OK) || 899) -
                100
            );
        }
    }
    rotate(direction) {
        if (direction == this.orientation) {
            // do nothing
            return NO_ACTION;
        }
        if (!(this.width == 2 && this.height == 2)) {
            console.log('NOT IMPLEMENTED FOR LARGER SWARMS YET');
            return -100;
        }
        let ret = -777;
        if (this.fatigue > 0) {
            ret = ERR_TIRED;
        } else {
            const prevDirection = this.orientation;
            const prevFormation = this.formation;
            const prevAngle = this.rotationsFromOrientation(prevDirection);
            const newAngle = this.rotationsFromOrientation(direction);
            const rotateAngle = newAngle - prevAngle;
            if (rotateAngle == 3 || rotateAngle == -1) {
                ret = this.pivot('counterclockwise');
            } else if (rotateAngle == 1 || rotateAngle == -3) {
                ret = this.pivot('clockwise');
            } else if (rotateAngle == 2 || rotateAngle == -2) {
                if (newAngle % 2 == 0) {
                    ret = this.swap('vertical');
                } else {
                    ret = this.swap('horizontal');
                }
            }
            if (ret == OK) {
                this.orientation = direction;
            }
        }
        this.debug(`Rotating to ${direction}, result: ${ret}`);
        return ret;
    }
    /**
     * Number of clockwise 90 degree turns corresponding to an orientation
     */
    rotationsFromOrientation(direction) {
        switch (direction) {
            case TOP:
                return 0;
            case RIGHT:
                return 1;
            case BOTTOM:
                return 2;
            case LEFT:
                return 3;
        }
    }
    // Swarm assignment ================================================================================================
    // Range finding methods ===========================================================================================
    minRangeTo(obj) {
        if (hasPos(obj)) {
            return _.min(
                _.map(this.creeps, (creep) =>
                    creep.pos.roomName === obj.pos.roomName
                        ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y)
                        : Infinity,
                ),
            );
        } else {
            return _.min(
                _.map(this.creeps, (creep) =>
                    creep.pos.roomName === obj.roomName
                        ? creep.pos.getRangeToXY(obj.x, obj.y)
                        : Infinity,
                ),
            );
        }
    }
    maxRangeTo(obj) {
        if (hasPos(obj)) {
            return _.max(
                _.map(this.creeps, (creep) =>
                    creep.pos.roomName === obj.pos.roomName
                        ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y)
                        : Infinity,
                ),
            );
        } else {
            return _.max(
                _.map(this.creeps, (creep) =>
                    creep.pos.roomName === obj.roomName
                        ? creep.pos.getRangeToXY(obj.x, obj.y)
                        : Infinity,
                ),
            );
        }
    }
    findInMinRange(targets, range) {
        const initialRange = range + Math.max(this.width, this.height) - 1;
        const targetsInRange = _.filter(targets, (t) =>
            this.anchor.inRangeToXY(t.pos.x, t.pos.y, initialRange),
        );
        return _.filter(targetsInRange, (t) => this.minRangeTo(t) <= range);
    }
    /**
     * Compute the "average" direction to a target
     */
    getDirectionTo(obj) {
        const pos = normalizePos(obj);
        const directions = _.map(this.creeps, (creep) =>
            creep.pos.getDirectionTo(obj),
        );
        // TODO
        log.warning(`NOT IMPLEMENTED`);
        return TOP;
    }
    // Formation methods ===============================================================================================
    /**
     * Generates a table of formation positions for each creep
     */
    getFormationPositionsFromAnchor(anchor) {
        const formationPositions = {};
        for (let dy = 0; dy < this.formation.length; dy++) {
            for (let dx = 0; dx < this.formation[dy].length; dx++) {
                if (this.formation[dy][dx]) {
                    formationPositions[
                        this.formation[dy][dx].name
                    ] = anchor.getOffsetPos(dx, dy);
                }
            }
        }
        // this.debug(`Formation positions: `, JSON.stringify(formationPositions));
        return formationPositions;
    }
    /**
     * Returtn whether every creep in the swarm is in the position dictated by formation
     */
    isInFormation(anchor = this.anchor) {
        const formationPositions = this.getFormationPositionsFromAnchor(anchor);
        return _.all(this.creeps, (creep) =>
            creep.pos.isEqualTo(formationPositions[creep.name]),
        );
    }
    get hasMaxCreeps() {
        return this.creeps.length == this.width * this.height;
    }
    /**
     * Returns true if the swarm has lost a creep and the oldest living creep is too old to partner with a new one
     */
    get isExpired() {
        if (!this.hasMaxCreeps) {
            const minTicksToLive =
                _.min(
                    _.map(this.creeps, (creep) => creep.ticksToLive || 9999),
                ) || 0;
            const spawnBuffer = 150 + 25;
            const newCreepTicksToLive = CREEP_LIFE_TIME + spawnBuffer; // TTL of a creep spawned right now
            return (
                newCreepTicksToLive - minTicksToLive >=
                DEFAULT_SWARM_TICK_DIFFERENCE
            );
        } else {
            return false;
        }
    }
    get inMultipleRooms() {
        return _.keys(this.roomsByName).length > 1;
    }
    /**
     * Assemble the swarm at the target location
     */
    assemble(assemblyPoint, allowIdleCombat = true) {
        if (this.isInFormation(assemblyPoint) && this.hasMaxCreeps) {
            this.memory.initialAssembly = true;
            return true;
        } else {
            // Creeps travel to their relative formation positions
            const formationPositions = this.getFormationPositionsFromAnchor(
                assemblyPoint,
            );
            console.log(JSON.stringify(formationPositions));
            for (const creep of this.creeps) {
                if (creep.hasValidTask) {
                    // Ignore creeps which have tasks (usually getting boosted)
                    continue;
                }
                if (
                    allowIdleCombat &&
                    creep.room.dangerousPlayerHostiles.length > 0 &&
                    !this.hasMaxCreeps
                ) {
                    creep.autoSkirmish(creep.room.name);
                } else {
                    const destination = formationPositions[creep.name];
                    const ret = creep.goTo(destination, {
                        noPush: creep.pos.inRangeToPos(destination, 5),
                        ignoreCreepsOnDestination: true,
                    });
                    console.log(
                        `${creep.print} moves to ${destination.print}, response: ${ret}`,
                    );
                }
            }
            return false;
        }
    }
    findRegroupPosition() {
        let x, y;
        const MAX_RADIUS = 10;
        for (let radius = 0; radius < MAX_RADIUS; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = this.anchor.x + dx;
                    y = this.anchor.y + dy;
                    if (x < 0 || x > 49 || y < 0 || y > 49) {
                        continue;
                    }
                    let allPathable = true;
                    const pos = new RoomPosition(x, y, this.anchor.roomName);
                    for (let i = 0; i < this.formation.length; i++) {
                        for (let j = 0; j < this.formation[i].length; j++) {
                            if (!pos.getOffsetPos(i, j).isWalkable(true)) {
                                allPathable = false;
                            }
                        }
                    }
                    if (allPathable) {
                        return pos;
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, 'cannotFindLocationPosition');
    }
    /**
     * Try to re-assemble the swarm at the nearest possible location in case it broke formation
     */
    regroup() {
        if (this.isInFormation(this.anchor)) {
            return true;
        } else {
            const regroupPosition = this.findRegroupPosition();
            this.debug(`Reassembling at ${regroupPosition.print}`);
            return this.assemble(regroupPosition, false);
        }
    }
    // Movement methods ================================================================================================
    move(direction) {
        let allMoved = true;
        for (const creep of this.creeps) {
            const result = creep.move(direction);
            this.debug(`${creep.print} move ${direction}, result: ${result}`);
            if (result != OK) {
                allMoved = false;
            }
        }
        if (!allMoved) {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
        }
        return allMoved ? OK : ERR_NOT_ALL_OK;
    }
    goTo(destination, options = {}) {
        // if (DEBUG) {
        // 	options.displayCostMatrix = true;
        // }
        return Movement.swarmMove(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        // if (DEBUG) {
        // 	options.displayCostMatrix = true;
        // }
        return Movement.goToRoom_swarm(this, roomName, options);
    }
    combatMove(approach, avoid, options = {}) {
        // if (DEBUG) {
        // 	options.displayAvoid = true;
        // }
        const ret = Movement.swarmCombatMove(this, approach, avoid, options);
        this.debug(`Moving... Result: ${ret}`);
        return ret;
    }
    safelyInRoom(roomName) {
        return _.all(this.creeps, (creep) => creep.safelyInRoom(roomName));
    }
    // private getBestSiegeOrientation(room: Room): TOP | RIGHT | BOTTOM | LEFT {
    // 	let targets: HasPos[] = [];
    // 	let structureTargets = this.findInMinRange(room.hostileStructures, 1);
    // 	for (let structure of structureTargets) {
    // 		targets.push(structure);
    // 	}
    // 	this.debug(`Targets: `, _.map(targets, t => t.pos.print));
    // 	if (targets.length == 0) {
    // 		return this.orientation;
    // 	}
    // 	let dxList = _.flatten(_.map(this.creeps,
    // 								 creep => _.map(targets,
    // 												target => target.pos.x - creep.pos.x))) as number[];
    // 	let dyList = _.flatten(_.map(this.creeps,
    // 								 creep => _.map(targets,
    // 												target => target.pos.y - creep.pos.y))) as number[];
    // 	let dx = _.sum(dxList) / dxList.length || 0;
    // 	let dy = _.sum(dyList) / dyList.length || 0;
    // 	this.debug(`dx: ${dx}, dy: ${dy}`);
    // 	if (Math.abs(dx) > Math.abs(dy)) {
    // 		return dx > 0 ? RIGHT : LEFT;
    // 	} else {
    // 		return dy > 0 ? BOTTOM : TOP;
    // 	}
    // }
    reorient(includeStructures = true, includeCreeps = false) {
        if (this.uniformCreepType) {
            return NO_ACTION;
        }
        const targetRoom = _.find(this.rooms, (room) => room.owner && !room.my);
        if (targetRoom) {
            const orientation = this.getBestOrientation(
                targetRoom,
                includeStructures,
                includeCreeps,
            );
            if (orientation != this.orientation && this.fatigue == 0) {
                this.debug(`Reorienting to ${orientation}!`);
                return this.rotate(orientation);
            }
        }
        return NO_ACTION;
    }
    getBestOrientation(room, includeStructures = true, includeCreeps = false) {
        const targets = [];
        if (includeStructures) {
            const structureTargets = this.findInMinRange(
                room.hostileStructures,
                1,
            );
            for (const structure of structureTargets) {
                targets.push(structure);
            }
        }
        if (includeCreeps) {
            const creepTargets = this.findInMinRange(room.dangerousHostiles, 2);
            for (const creep of creepTargets) {
                targets.push(creep);
            }
        }
        this.debug(
            `Targets: `,
            _.map(targets, (t) => t.pos.print),
        );
        if (targets.length == 0) {
            return this.orientation;
        }
        const dxList = _.flatten(
            _.map(this.creeps, (creep) =>
                _.map(targets, (target) => target.pos.x - creep.pos.x),
            ),
        );
        const dyList = _.flatten(
            _.map(this.creeps, (creep) =>
                _.map(targets, (target) => target.pos.y - creep.pos.y),
            ),
        );
        const dx = _.sum(dxList) / dxList.length || 0;
        const dy = _.sum(dyList) / dyList.length || 0;
        this.debug(`dx: ${dx}, dy: ${dy}`);
        if (Math.abs(dx) > Math.abs(dy)) {
            return dx > 0 ? RIGHT : LEFT;
        } else {
            return dy > 0 ? BOTTOM : TOP;
        }
    }
    // Auto-combat methods =============================================================================================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(ATTACK) > 0) {
                creep.autoMelee();
            }
        }
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
                creep.autoRanged();
            }
        }
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true) {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(HEAL) > 0) {
                creep.autoHeal(allowRangedHeal);
            }
        }
    }
    /**
     * Standard sequence of actions for sieging a room. Assumes the swarm has already initially assembled.
     */
    autoSiege(roomName, waypoint) {
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, (creep) => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            if (waypoint) {
                return this.goTo(waypoint);
            } else {
                return this.goToRoom(roomName);
            }
        }
        // Find a target if needed
        if (!this.target) {
            const displayCostMatrix = DEBUG;
            this.target = CombatTargeting.findBestSwarmStructureTarget(
                this,
                roomName,
                10 * this.memory.numRetreats,
                displayCostMatrix,
            );
            this.debug(this.target);
        }
        // Approach the siege target
        if (this.target) {
            // let approach = _.map(Pathing.getPosWindow(this.target.pos, -this.width, -this.height),
            // 					 pos => ({pos: pos, range: 1}));
            const result = this.combatMove(
                [{ pos: this.target.pos, range: 1 }],
                [],
            );
            if (result != NO_ACTION) {
                this.debug(`Moving to target ${this.target}: ${result}`);
                return result;
            }
        } else {
            log.warning(`No target for swarm ${this.ref}!`);
        }
        // Orient yourself to face structure targets
        this.reorient(true, false);
    }
    /**
     * Standard sequence of actions for fighting within a room. Assumes the swarm has already initially assembled.
     */
    autoCombat(roomName, waypoint) {
        this.debug(`Running autocombat!`);
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, (creep) => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            // if (this.rooms[0].dangerousHostiles.length > 0) {
            //
            // } else {
            //
            // }
            if (waypoint) {
                return this.goTo(waypoint);
            } else {
                return this.goToRoom(roomName);
            }
        }
        // Maneuver around the room
        const goals = GoalFinder.swarmCombatGoals(this, true);
        this.debug(`Goals: ${JSON.stringify(goals)}`);
        if (_.any(goals.avoid, (goal) => this.minRangeTo(goal) <= goal.range)) {
            // If creeps nearby, try to flee first, then reorient
            let result = this.combatMove(goals.approach, goals.avoid);
            if (result != OK) {
                result = this.reorient(true, true);
            }
            return result;
        } else {
            // Otherwise try to reorient first then move
            let result = this.reorient(true, true);
            if (result != OK) {
                result = this.combatMove(goals.approach, goals.avoid);
            }
            return result;
        }
    }
    needsToRecover(recoverThreshold = 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = _.any(
                this.creeps,
                (creep) => creep.hits < creep.hitsMax * reengageThreshold,
            );
        } else {
            recovering = _.any(
                this.creeps,
                (creep) => creep.hits < creep.hitsMax * recoverThreshold,
            );
        }
        if (recovering && recovering != this.memory.recovering) {
            this.memory.numRetreats++;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    recover() {
        const allHostiles = _.flatten(
            _.map(this.rooms, (room) => room.hostiles),
        );
        const allTowers = _.flatten(
            _.map(this.rooms, (room) =>
                room.owner && !room.my ? room.towers : [],
            ),
        );
        if (
            _.filter(allHostiles, (h) => this.minRangeTo(h)).length > 0 ||
            allTowers.length > 0
        ) {
            this.memory.lastInDanger = Game.time;
        }
        const allAvoidGoals = _.flatten(
            _.map(
                this.rooms,
                (room) => GoalFinder.retreatGoalsForRoom(room).avoid,
            ),
        );
        const result = Movement.swarmCombatMove(this, [], allAvoidGoals);
        if (result == NO_ACTION) {
            const safeRoom = _.first(
                _.filter(this.rooms, (room) => !room.owner || room.my),
            );
            if (safeRoom && !this.safelyInRoom(safeRoom.name)) {
                if (Game.time < (this.memory.lastInDanger || 0) + 3) {
                    return this.goToRoom(safeRoom.name);
                }
            }
        }
        return result;
    }
    // Simulated swarms ================================================================================================
    /**
     * Groups enemies into proto-swarms based on proximity to each other
     */
    static findEnemySwarms(room, anchor, maxClumpSize = 3) {
        const enemySwarms = [];
        const origin = anchor ||
            _.first(room.spawns) ||
            room.controller || { pos: new RoomPosition(25, 25, room.name) };
        let attackers = _.sortBy(room.dangerousHostiles, (creep) =>
            origin.pos.getRangeTo(creep),
        );
        while (attackers.length > 0) {
            const clump = _.first(attackers).pos.findInRange(
                attackers,
                maxClumpSize,
            );
            attackers = _.difference(attackers, clump);
            enemySwarms.push({ creeps: clump });
        }
        return enemySwarms;
    }
};
Swarm = __decorate([profile], Swarm);

let GoalFinder = class GoalFinder {
    // Standard set of goals for fighting small groups of hostiles (not optimal for larger fights)
    static skirmishGoals(zerg) {
        const approach = [];
        const avoid = [];
        const room = zerg.room;
        const analysis = {};
        const myAttack = CombatIntel.getAttackDamage(zerg);
        const myRangedAttack = CombatIntel.getRangedAttackDamage(zerg);
        const myHealing = CombatIntel.getHealAmount(zerg);
        // If you're purely a healer, ignore combat goals
        if (myHealing > 0 && myAttack == 0 && myRangedAttack == 0) {
            return this.healingGoals(zerg);
        }
        const preferCloseCombat = myAttack > 0;
        const myRating = CombatIntel.rating(zerg);
        const nearbyRating = _.sum(zerg.pos.findInRange(room.creeps, 6), (c) =>
            CombatIntel.rating(c),
        );
        const braveMode =
            zerg.hits * (nearbyRating / myRating) * 0.5 > zerg.hitsMax;
        const hostileHealers = [];
        // Analyze capabilities of hostile creeps in the room
        for (const hostile of room.hostiles) {
            if (hostile.owner.username == 'Source Keeper') continue;
            const attack = CombatIntel.getAttackDamage(hostile);
            const rangedAttack = CombatIntel.getRangedAttackDamage(hostile);
            const healing = CombatIntel.getHealAmount(hostile);
            if (healing > 0 && attack == 0 && rangedAttack == 0) {
                hostileHealers.push(hostile);
            }
            analysis[hostile.id] = {
                attack: attack,
                rangedAttack: rangedAttack,
                heal: healing,
                advantage:
                    healing == 0 ||
                    attack + rangedAttack == 0 ||
                    myAttack +
                        myRangedAttack +
                        myHealing /
                            CombatIntel.minimumDamageTakenMultiplier(
                                zerg.creep,
                            ) >
                        attack +
                            rangedAttack +
                            healing /
                                CombatIntel.minimumDamageTakenMultiplier(
                                    hostile,
                                ),
                isRetreating: CombatIntel.isRetreating(
                    hostile,
                    RoomIntel.getPreviousPos(zerg.creep),
                ),
                isApproaching: CombatIntel.isApproaching(
                    hostile,
                    RoomIntel.getPreviousPos(zerg.creep),
                ),
            };
        }
        // Generate list of targets to approach and respective ranges to keep them at
        const approachTargets =
            hostileHealers.length > 0 ? hostileHealers : room.hostiles;
        for (const target of approachTargets) {
            const data = analysis[target.id];
            if (data && (data.advantage || braveMode)) {
                let range = 1;
                if (
                    !preferCloseCombat &&
                    (data.attack > 0 || data.rangedAttack > myRangedAttack)
                ) {
                    range =
                        zerg.pos.getRangeTo(target) == 3 && data.isRetreating
                            ? 2
                            : 3;
                    avoid.push({ pos: target.pos, range: range });
                }
                approach.push({ pos: target.pos, range: range });
            }
        }
        // If there's nothing left to approach, group up with other creeps
        if (approach.length == 0) {
            for (const friendly of room.creeps) {
                approach.push({ pos: friendly.pos, range: 0 });
            }
        }
        // Avoid hostiles that are significantly better than you
        for (const target of room.hostiles) {
            const data = analysis[target.id];
            if (data && !data.advantage && !braveMode) {
                let range = data.isApproaching ? 3 : 2;
                if (data.rangedAttack > 0) {
                    range = 8;
                }
                avoid.push({ pos: target.pos, range: range });
            }
        }
        return { approach, avoid };
    }
    static swarmCombatGoals(swarm, includeStructures = true) {
        const approach = [];
        const avoid = [];
        if (swarm.rooms.length > 1) {
            log.warning(`Swarm in more than 1 room!`);
        }
        // If in more than 1 room, pick the room with more hostile stuff in it
        const room = maxBy(
            swarm.rooms,
            (room) => room.hostiles.length + room.hostileStructures.length,
        );
        const myAttack = _.sum(swarm.creeps, (creep) =>
            CombatIntel.getAttackDamage(creep),
        );
        const myRangedAttack = _.sum(swarm.creeps, (creep) =>
            CombatIntel.getRangedAttackDamage(creep),
        );
        const myHealing = _.sum(swarm.creeps, (creep) =>
            CombatIntel.getHealAmount(creep),
        );
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(
            _.map(swarm.creeps, (c) => c.creep),
        );
        const preferCloseCombat = myAttack > myRangedAttack;
        const myRating = _.sum(swarm.creeps, (creep) =>
            CombatIntel.rating(creep),
        );
        const hostileSwarms = Swarm.findEnemySwarms(room, {
            pos: swarm.anchor,
        });
        // Analyze capabilities of hostile creeps in the room
        for (const i in hostileSwarms) {
            const hostiles = hostileSwarms[i].creeps;
            const attack = _.sum(hostiles, (creep) =>
                CombatIntel.getAttackDamage(creep),
            );
            const rangedAttack = _.sum(hostiles, (creep) =>
                CombatIntel.getRangedAttackDamage(creep),
            );
            const healing = _.sum(hostiles, (creep) =>
                CombatIntel.getHealAmount(creep),
            );
            const damageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(
                hostiles,
            );
            const canPopShield =
                (attack +
                    rangedAttack +
                    CombatIntel.towerDamageAtPos(swarm.anchor)) *
                    myDamageMultiplier >
                _.min(
                    _.map(
                        swarm.creeps,
                        (creep) => 100 * creep.getActiveBodyparts(TOUGH),
                    ),
                );
            const isRetreating =
                _.sum(
                    hostiles,
                    (creep) => +CombatIntel.isRetreating(creep, swarm.anchor),
                ) /
                    hostiles.length >=
                0.5;
            const isApproaching =
                _.sum(
                    hostiles,
                    (creep) => +CombatIntel.isApproaching(creep, swarm.anchor),
                ) /
                    hostiles.length >=
                0.5;
            const advantage =
                healing == 0 ||
                attack + rangedAttack == 0 ||
                myAttack + myRangedAttack + myHealing / myDamageMultiplier >
                    attack + rangedAttack + healing / damageMultiplier;
            for (const hostile of hostiles) {
                if (
                    canPopShield &&
                    hostile.pos.lookForStructure(STRUCTURE_RAMPART)
                ) {
                    let range =
                        (rangedAttack > attack || !preferCloseCombat ? 3 : 1) +
                        1;
                    if (CombatIntel.isApproaching(hostile, swarm.anchor)) {
                        range += 1;
                    }
                    avoid.push({ pos: hostile.pos, range: range });
                } else {
                    if (advantage) {
                        let range = preferCloseCombat ? 1 : 2;
                        if (
                            !preferCloseCombat &&
                            (attack > 0 || rangedAttack > myAttack)
                        ) {
                            range =
                                swarm.minRangeTo(hostile) == 3 && isRetreating
                                    ? 2
                                    : 3;
                            avoid.push({ pos: hostile.pos, range: range });
                        }
                        approach.push({ pos: hostile.pos, range: range });
                    } else {
                        let range = isApproaching ? 3 : 2;
                        if (rangedAttack > attack) {
                            range = 5;
                        }
                        avoid.push({ pos: hostile.pos, range: range });
                    }
                }
            }
        }
        if (includeStructures) {
            const approachStructures = [];
            for (const structure of room.hostileStructures) {
                approachStructures.push(structure);
            }
            for (const wall of room.walls) {
                approachStructures.push(wall);
            }
            for (const approachStructure of approachStructures) {
                approach.push({ pos: approachStructure.pos, range: 1 });
            }
        }
        return { approach, avoid };
    }
    static retreatGoals(creep) {
        const approach = [];
        const avoid = [];
        const isHealer = CombatIntel.isHealer(creep);
        for (const friendly of creep.room.creeps) {
            if (
                CombatIntel.getHealPotential(friendly) > 0 ||
                (isHealer && isCombatZerg(creep))
            ) {
                approach.push({ pos: friendly.pos, range: 1 });
            }
        }
        for (const hostile of creep.room.hostiles) {
            if (
                CombatIntel.getAttackPotential(hostile) > 0 ||
                CombatIntel.getRangedAttackPotential(hostile) > 0
            ) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (creep.room.owner && !creep.room.my) {
            for (const tower of creep.room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach, avoid };
    }
    static retreatGoalsForRoom(room) {
        const avoid = [];
        for (const hostile of room.hostiles) {
            if (
                CombatIntel.getAttackPotential(hostile) > 0 ||
                CombatIntel.getRangedAttackPotential(hostile) > 0
            ) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (room.owner && !room.my) {
            for (const tower of room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach: [], avoid: avoid };
    }
    static healingGoals(healer) {
        const approach = [];
        const avoid = [];
        const healAmount = CombatIntel.getHealAmount(healer);
        let target = minBy(
            _.filter(healer.room.creeps, (c) => c.hits < c.hitsMax),
            (c) => c.hits + healer.pos.getRangeTo(c),
        );
        if (!target) {
            target = minBy(healer.room.creeps, (creep) => {
                const range = healer.pos.getRangeTo(creep);
                return range > 0
                    ? CombatIntel.maxFriendlyHealingTo(creep) / healAmount +
                          range
                    : false;
            });
        }
        if (target) {
            approach.push({ pos: target.pos, range: 0 });
        }
        for (const hostile of healer.room.hostiles) {
            const meleeDamage = CombatIntel.getAttackDamage(hostile);
            const rangedDamage = CombatIntel.getRangedAttackDamage(hostile);
            if (meleeDamage + rangedDamage > 0) {
                const range = rangedDamage > healAmount ? 4 : 3;
                avoid.push({ pos: hostile.pos, range: range });
            }
        }
        return { approach, avoid };
    }
    static structureGoals(creep) {
        const approach = [];
        // // TODO: finish this
        // let range = CombatIntel.getAttackDamage(creep) > 0 || CombatIntel.getDismantleDamage(creep) > 0 ? 1 : 3;
        // let structureTarget = CombatTargeting.findBestStructureTarget(creep);
        // if (structureTarget) {
        // 	approach.push({pos: structureTarget.pos, range: range});
        // }
        log.error(`NOT IMPLEMENTED`);
        return { approach: approach, avoid: [] };
    }
};
GoalFinder = __decorate([profile], GoalFinder);
global.GoalFinder = GoalFinder;

const DEFAULT_PARTNER_TICK_DIFFERENCE = 650;
const DEFAULT_SWARM_TICK_DIFFERENCE = 500;
/**
 * CombatZerg is an extension of the Zerg class which contains additional combat-related methods
 */
let CombatZerg = class CombatZerg extends Zerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isCombatZerg = true;
        _.defaults(this.memory, {
            recovering: false,
            lastInDanger: 0,
            targets: {},
        });
    }
    findPartner(partners, tickDifference = DEFAULT_PARTNER_TICK_DIFFERENCE) {
        if (this.memory.partner) {
            const partner = _.find(
                partners,
                (partner) => partner.name == this.memory.partner,
            );
            if (partner) {
                return partner;
            } else {
                delete this.memory.partner;
                this.findPartner(partners, tickDifference);
            }
        } else {
            let partner = _.find(
                partners,
                (partner) => partner.memory.partner == this.name,
            );
            if (!partner) {
                partner = _(partners)
                    .filter(
                        (partner) =>
                            !partner.memory.partner &&
                            Math.abs(
                                (this.ticksToLive || CREEP_LIFE_TIME) -
                                    (partner.ticksToLive || CREEP_LIFE_TIME),
                            ) <= tickDifference,
                    )
                    .min((partner) =>
                        Math.abs(
                            (this.ticksToLive || CREEP_LIFE_TIME) -
                                (partner.ticksToLive || CREEP_LIFE_TIME),
                        ),
                    );
            }
            if (_.isObject(partner)) {
                this.memory.partner = partner.name;
                partner.memory.partner = this.name;
                return partner;
            }
        }
    }
    findSwarm(
        partners,
        maxByRole,
        tickDifference = DEFAULT_SWARM_TICK_DIFFERENCE,
    ) {
        if (this.memory.swarm) {
            return this.memory.swarm;
        } else {
            // Find a swarm that isn't too old and that has space for the creep's role
            const partnersBySwarm = _.groupBy(
                partners,
                (partner) => partner.memory.swarm,
            );
            for (const swarmRef in partnersBySwarm) {
                if (swarmRef == undefined || swarmRef == 'undefined') continue;
                if (
                    _.all(
                        partnersBySwarm[swarmRef],
                        (c) =>
                            Math.abs(
                                (this.ticksToLive || CREEP_LIFE_TIME) -
                                    (c.ticksToLive || CREEP_LIFE_TIME),
                            ) <= tickDifference,
                    )
                ) {
                    const swarmCreepsByRole = _.groupBy(
                        partnersBySwarm[swarmRef],
                        (c) => c.memory.role,
                    );
                    if (
                        (swarmCreepsByRole[this.memory.role] || []).length +
                            1 <=
                        maxByRole[this.memory.role]
                    ) {
                        this.memory.swarm = swarmRef;
                        return swarmRef;
                    }
                }
            }
            // Otherwise just make a new swarm ref
            const newSwarmRef = randomHex(6);
            this.memory.swarm = newSwarmRef;
            return newSwarmRef;
        }
    }
    /**
     * Returns true if there is a target for medic actions, otherwise false
     */
    doMedicActions(roomName) {
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
            return true; // en route
        }
        // Heal friendlies
        const target = CombatTargeting.findClosestHurtFriendly(this);
        if (target) {
            // Approach the target
            const range = this.pos.getRangeTo(target);
            if (range > 1) {
                this.goTo(target, { movingTarget: true });
            }
            // Heal or ranged-heal the target
            if (range <= 1) {
                this.heal(target);
            } else if (range <= 3) {
                this.rangedHeal(target);
            }
        } else {
            this.park();
        }
        return !!target;
    }
    healSelfIfPossible() {
        // Heal yourself if it won't interfere with attacking
        if (
            this.canExecute('heal') &&
            (this.hits < this.hitsMax ||
                this.pos.findInRange(this.room.hostiles, 3).length > 0)
        ) {
            return this.heal(this);
        }
    }
    /**
     * Attack and chase the specified target
     */
    attackAndChase(target) {
        let ret;
        // Attack the target if you can, else move to get in range
        if (this.pos.isNearTo(target)) {
            ret = this.attack(target);
            // Move in the direction of the creep to prevent it from running away
            this.move(this.pos.getDirectionTo(target));
            return ret;
        } else {
            if (
                this.pos.getRangeTo(target.pos) > 10 &&
                target instanceof Creep
            ) {
                if (target.pos.roomName == this.pos.roomName) {
                    // avoid edge dancing, stay in room
                    this.goTo(target, {
                        movingTarget: true,
                        pathOpts: { maxRooms: 1 },
                    });
                } else {
                    this.goTo(target, { movingTarget: true });
                }
            } else {
                if (target.pos.roomName == this.pos.roomName) {
                    this.goTo(target, { pathOpts: { maxRooms: 1 } }); // avoid edge dancing, stay in room
                } else {
                    this.goTo(target);
                }
            }
            return ERR_NOT_IN_RANGE;
        }
    }
    // Standard action sequences for engaging small numbers of enemies in a neutral room ===============================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee(possibleTargets = this.room.hostiles) {
        const target =
            CombatTargeting.findBestCreepTargetInRange(
                this,
                1,
                possibleTargets,
            ) || CombatTargeting.findBestStructureTargetInRange(this, 1);
        this.debug(`Melee target: ${target}`);
        if (target) {
            return this.attack(target);
        }
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged(possibleTargets = this.room.hostiles, allowMassAttack = true) {
        const target =
            CombatTargeting.findBestCreepTargetInRange2(
                this,
                3,
                possibleTargets,
            ) || CombatTargeting.findBestStructureTargetInRange(this, 3, false);
        // disabled allowUnowned structure attack in order not to destroy poison walls
        this.debug(`Ranged target: ${target}`);
        if (target) {
            if (
                allowMassAttack &&
                CombatIntel.getMassAttackDamage(this, possibleTargets) >
                    CombatIntel.getRangedAttackDamage(this)
            ) {
                return this.rangedMassAttack();
            } else {
                return this.rangedAttack(target);
            }
        }
    }
    kiteIfNecessary() {
        // Should filter by melee at some point
        const nearbyHostiles = _.filter(this.room.dangerousHostiles, (c) =>
            this.pos.inRangeToXY(c.pos.x, c.pos.y, 2),
        );
        if (nearbyHostiles.length && !this.inRampart) {
            this.say('run!');
            this.rangedMassAttack();
            const possibleDamage = _.sum(
                nearbyHostiles.map(
                    (creep) =>
                        CombatIntel.getAttackDamage(creep) +
                        CombatIntel.getRangedAttackDamage(creep),
                ),
            );
            if (possibleDamage > 0) {
                return this.kite(nearbyHostiles, {
                    fleeRange: possibleDamage > 20 ? 4 : 5,
                });
            }
        }
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true, friendlies = this.room.creeps) {
        const target = CombatTargeting.findBestHealingTargetInRange(
            this,
            allowRangedHeal ? 3 : 1,
            friendlies,
        );
        this.debug(`Heal target: ${target}`);
        if (
            target &&
            (target.hits < target.hitsMax ||
                this.room.dangerousPlayerHostiles.length)
        ) {
            if (this.pos.getRangeTo(target) <= 1) {
                return this.heal(target);
            } else if (allowRangedHeal && this.pos.getRangeTo(target) <= 3) {
                return this.rangedHeal(target);
            }
        }
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoSkirmish(roomName, verbose = false) {
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        // Skirmish within the room
        const goals = GoalFinder.skirmishGoals(this);
        this.debug(JSON.stringify(goals));
        return Movement.combatMove(this, goals.approach, goals.avoid);
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoCombat(roomName, verbose = false, preferredRange, options) {
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        // Fight within the room
        const target = CombatTargeting.findTarget(this);
        const preferRanged =
            this.getActiveBodyparts(RANGED_ATTACK) >
            this.getActiveBodyparts(ATTACK);
        let targetRange = preferredRange || preferRanged ? 2 : 1;
        this.debug(`${target}, ${targetRange}`);
        if (target) {
            const avoid = [];
            // Avoid melee hostiles if you are a ranged creep
            if (preferRanged) {
                const meleeHostiles = _.filter(
                    this.room.hostiles,
                    (h) => CombatIntel.getAttackDamage(h) > 0,
                );
                for (const hostile of meleeHostiles) {
                    avoid.push({ pos: hostile.pos, range: targetRange - 1 });
                }
                const rangedHostiles = _.filter(
                    this.room.hostiles,
                    (h) => CombatIntel.getRangedAttackDamage(h) > 0,
                );
                for (const hostile of rangedHostiles) {
                    avoid.push({ pos: hostile.pos, range: targetRange - 2 });
                }
                if (this.kiteIfNecessary()) {
                    return;
                }
                if (
                    CombatIntel.getRangedAttackDamage(target) +
                        CombatIntel.getAttackDamage(target) <=
                    20
                ) {
                    targetRange = 1;
                }
            }
            return Movement.combatMove(
                this,
                [{ pos: target.pos, range: targetRange }],
                avoid,
                options,
            );
        }
    }
    autoBunkerCombat(roomName, verbose = false) {
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        // TODO check if right colony, also yes colony check is in there to stop red squigglies
        // const siegingCreeps = this.room.hostiles.filter(creep =>
        // 	_.any(creep.pos.neighbors, pos => this.colony && insideBunkerBounds(pos, this.colony)));
        const target = CombatTargeting.findTarget(
            this,
            this.colony
                ? this.room.playerHostiles.filter(
                      (creep) => creep.pos.getRangeTo(this.colony.pos) <= 9,
                  )
                : this.room.dangerousHostiles,
        );
        if (target) {
            return Movement.combatMove(
                this,
                [{ pos: target.pos, range: 1 }],
                [],
                {
                    preferRamparts: true,
                    requireRamparts: true,
                },
            );
        }
    }
    needsToRecover(
        recoverThreshold = CombatIntel.minimumDamageTakenMultiplier(
            this.creep,
        ) < 1
            ? 0.85
            : 0.75,
        reengageThreshold = 1.0,
    ) {
        let recovering;
        if (this.memory.recovering) {
            recovering = this.hits < this.hitsMax * reengageThreshold;
        } else {
            recovering = this.hits < this.hitsMax * recoverThreshold;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    /**
     * Retreat and get healed
     */
    recover() {
        if (
            this.pos.findInRange(this.room.hostiles, 5).length > 0 ||
            this.room.towers.length > 0
        ) {
            this.memory.lastInDanger = Game.time;
        }
        const goals = GoalFinder.retreatGoals(this);
        const result = Movement.combatMove(this, goals.approach, goals.avoid, {
            allowExit: true,
        });
        if (result == NO_ACTION && this.pos.isEdge) {
            if (Game.time < this.memory.lastInDanger + 3) {
                return this.moveOffExit();
            }
        }
        return result;
    }
};
CombatZerg = __decorate([profile], CombatZerg);

function hasColony(initializer) {
    return initializer.colony != undefined;
}
const DEFAULT_PRESPAWN = 40;
const MAX_SPAWN_REQUESTS = 100; // this stops division by zero or related errors from sending infinite requests
const getDefaultOverlordMemory = () => ({});
/**
 * An Overlord is roughly analogous to a process in an OS: it is a generalization of a set of related things that need
 * to be done in a colony, like mining from a site, bootstrapping a new colony, guarding against invaders, or building
 * construction sites. Overlords handle spawning or obtaining suitable creeps to do these things and contain the actual
 * implementation of doing them.
 */
let Overlord = class Overlord {
    constructor(
        initializer,
        name,
        priority,
        memDefaults = getDefaultOverlordMemory,
    ) {
        this.initializer = initializer;
        this.memory = Mem.wrap(initializer.memory, name, memDefaults);
        this.room = initializer.room;
        this.priority = priority;
        this.name = name;
        this.ref = initializer.ref + '>' + name;
        this.pos = initializer.pos;
        this.colony = hasColony(initializer) ? initializer.colony : initializer;
        this.spawnGroup = undefined;
        // Calculate the creeps associated with this overlord and group by roles
        this._creeps = {};
        this._zerg = {};
        this._combatZerg = {};
        this.recalculateCreeps();
        this.creepUsageReport = _.mapValues(this._creeps, (creep) => undefined);
        // Register the overlord on the colony overseer and on the overmind
        Overmind.overlords[this.ref] = this;
        Overmind.overseer.registerOverlord(this);
    }
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.pos.roomName +
            '">[' +
            this.ref +
            ']</a>'
        );
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    /**
     * Refreshes overlord, recalculating creeps and refreshing existing Zerg. New creeps are automatically added,
     * and the corresponding role groups (e.g. 'queens') are automatically updated. Child methods do not need to
     * refresh their zerg properties or their memories, only other room objects stored on the Overlord.
     */
    refresh() {
        // Refresh memory
        this.memory = Mem.wrap(this.initializer.memory, this.name);
        // Refresh room
        this.room = Game.rooms[this.pos.roomName];
        // Refresh zerg
        this.recalculateCreeps();
        for (const role in this._creeps) {
            for (const creep of this._creeps[role]) {
                if (Overmind.zerg[creep.name]) {
                    // log.debug(`Refreshing creep ${creep.name}`)
                    Overmind.zerg[creep.name].refresh();
                } else {
                    log.warning(
                        `${this.print}: could not find and refresh zerg with name ${creep.name}! Incorrect role?  role ${role} & ${creep.memory.role}`,
                    );
                }
            }
        }
        // Refresh pos
        this.pos = this.initializer.pos;
    }
    recalculateCreeps() {
        // Recalculate the sets of creeps for each role in this overlord
        this._creeps = _.mapValues(
            Overmind.cache.overlords[this.ref],
            (creepsOfRole) =>
                _.map(creepsOfRole, (creepName) => Game.creeps[creepName]),
        );
        // Update zerg and combatZerg records
        for (const role in this._zerg) {
            this.synchronizeZerg(role);
        }
        for (const role in this._combatZerg) {
            this.synchronizeCombatZerg(role);
        }
    }
    /**
     * Returns whether the overlord is currently suspended
     */
    get isSuspended() {
        if (this.memory.suspend) {
            if (this.memory.suspend.endTick) {
                if (Game.time < this.memory.suspend.endTick) {
                    return true;
                } else {
                    delete this.memory.suspend;
                    return false;
                }
            }
            if (this.memory.suspend.condition) {
                log.error('NOT IMPLEMENTED'); // TODO
                const { fn, freq } = this.memory.suspend.condition;
                if (Game.time % freq == 0);
            }
        }
        return false;
    }
    suspendFor(ticks) {
        this.memory.suspend = {
            endTick: Game.time + ticks,
        };
    }
    suspendUntil(endTick) {
        this.memory.suspend = {
            endTick: endTick,
        };
    }
    /**
     * Check if profiling is active, also shuts it down if it is past end tick
     */
    get profilingActive() {
        if (this.memory['S' /* STATS */]) {
            if (this.memory['S' /* STATS */].end) {
                if (Game.time > this.memory['S' /* STATS */].end) {
                    this.finishProfiling();
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Starts profiling on this overlord and initializes memory to defaults
     */
    startProfiling(ticks) {
        if (!this.memory['S' /* STATS */]) {
            this.memory['S' /* STATS */] = {
                start: Game.time,
                cpu: 0,
                spawnCost: 0,
                deaths: 0,
            };
            if (ticks) {
                this.memory['S' /* STATS */].end = Game.time + ticks;
            }
        } else {
            log.alert(`Overlord ${this.print} is already being profiled!`);
        }
    }
    /**
     * Finishes profiling this overlord and deletes the memory objects
     */
    finishProfiling(verbose = true) {
        if (!this.memory['S' /* STATS */]) {
            log.error(
                `Overlord ${this.print} is not being profiled, finishProfiling() invalid!`,
            );
            return;
        }
        if (verbose) {
            log.alert(
                `Profiling finished for overlord ${this.print}. Results:\n` +
                    JSON.stringify(this.memory['S' /* STATS */]),
            );
        }
        delete this.memory['S' /* STATS */];
    }
    /**
     * Wraps all creeps of a given role to Zerg objects and updates the contents in future ticks to avoid having to
     * explicitly refresh groups of Zerg
     */
    zerg(role, opts = {}) {
        if (!this._zerg[role]) {
            this._zerg[role] = [];
            this.synchronizeZerg(role, opts.notifyWhenAttacked);
        }
        return this._zerg[role];
    }
    synchronizeZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of Zerg
        const zergNames = _.zipObject(
            _.map(this._zerg[role] || [], (zerg) => [zerg.name, true]),
        );
        const creepNames = _.zipObject(
            _.map(this._creeps[role] || [], (creep) => [creep.name, true]),
        );
        // Add new creeps which aren't in the _zerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                this._zerg[role].push(
                    Overmind.zerg[creep.name] ||
                        new Zerg(creep, notifyWhenAttacked),
                );
            }
        }
        // Remove dead/reassigned creeps from the _zerg record
        const removeZergNames = [];
        for (const zerg of this._zerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._zerg[role], (deadZerg) =>
            removeZergNames.includes(deadZerg.name),
        );
    }
    getAllZerg() {
        const allZerg = [];
        for (const role in this._creeps) {
            for (const zerg of this.zerg(role)) {
                allZerg.push(zerg);
            }
        }
        return allZerg;
    }
    /**
     * Wraps all creeps of a given role to CombatZerg objects and updates the contents in future ticks
     */
    combatZerg(role, opts = {}) {
        if (!this._combatZerg[role]) {
            this._combatZerg[role] = [];
            this.synchronizeCombatZerg(role, opts.notifyWhenAttacked);
        }
        return this._combatZerg[role];
    }
    synchronizeCombatZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of CombatZerg
        const zergNames = _.zipObject(
            _.map(this._combatZerg[role] || [], (zerg) => [zerg.name, true]),
        );
        const creepNames = _.zipObject(
            _.map(this._creeps[role] || [], (creep) => [creep.name, true]),
        );
        // Add new creeps which aren't in the _combatZerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                if (
                    Overmind.zerg[creep.name] &&
                    Overmind.zerg[creep.name].isCombatZerg
                ) {
                    this._combatZerg[role].push(Overmind.zerg[creep.name]);
                } else {
                    this._combatZerg[role].push(
                        new CombatZerg(creep, notifyWhenAttacked),
                    );
                }
            }
        }
        // Remove dead/reassigned creeps from the _combatZerg record
        const removeZergNames = [];
        for (const zerg of this._combatZerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._combatZerg[role], (deadZerg) =>
            removeZergNames.includes(deadZerg.name),
        );
    }
    getAllCombatZerg() {
        const allCombatZerg = [];
        for (const role in this._creeps) {
            for (const combatZerg of this.combatZerg(role)) {
                allCombatZerg.push(combatZerg);
            }
        }
        return allCombatZerg;
    }
    /**
     * Gets the "ID" of the outpost this overlord is operating in. 0 for owned rooms, >= 1 for outposts, -1 for other
     */
    get outpostIndex() {
        return _.findIndex(
            this.colony.roomNames,
            (roomName) => roomName == this.pos.roomName,
        );
    }
    // TODO: make this potentially colony independent
    reassignIdleCreeps(role, maxPerTick = 1) {
        // Find all creeps without an overlord
        const idleCreeps = _.filter(
            this.colony.getCreepsByRole(role),
            (creep) => !getOverlord(creep),
        );
        // Reassign them all to this flag
        let reassigned = 0;
        for (const creep of idleCreeps) {
            // TODO: check range of creep from overlord
            setOverlord(creep, this);
            reassigned++;
            if (reassigned >= maxPerTick) {
                break;
            }
        }
        return reassigned > 0;
    }
    creepReport(role, currentAmt, neededAmt) {
        this.creepUsageReport[role] = [currentAmt, neededAmt];
    }
    /**
     * Requests a group of (2-3) creeps from a hatchery to be spawned at the same time. Using this with low-priority
     * operations can result in a long time
     */
    requestSquad(setups, opts = {}) {
        log.warning(`Overlord.requestSquad() is not finished yet!`); // TODO: finish
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
        });
        const spawner =
            this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            if (setups.length > 3) {
                log.warning(`Requesting squads of >3 is not advisable`);
            }
            const request = {
                setup: _.head(setups),
                overlord: this,
                priority: opts.priority,
                partners: _.tail(setups),
            };
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        } else {
            if (Game.time % 100 == 0) {
                log.warning(
                    `Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`,
                );
            }
        }
    }
    /**
     * Create a creep setup and enqueue it to the Hatchery; does not include automatic reporting
     */
    requestCreep(setup, opts = {}) {
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
        });
        const spawner =
            this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            const request = {
                setup: setup,
                overlord: this,
                priority: opts.priority,
            };
            if (opts.partners) {
                request.partners = opts.partners;
            }
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        } else {
            if (Game.time % 100 == 0) {
                log.warning(
                    `Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`,
                );
            }
        }
    }
    // TODO: include creep move speed
    lifetimeFilter(creeps, prespawn = DEFAULT_PRESPAWN, spawnDistance) {
        if (!spawnDistance) {
            spawnDistance = 0;
            if (this.spawnGroup) {
                const distances = _.take(
                    _.sortBy(this.spawnGroup.memory.distances),
                    2,
                );
                spawnDistance = _.sum(distances) / distances.length || 0;
            } else if (this.colony.hatchery) {
                // Use distance or 0 (in case distance returns something undefined due to incomplete pathfinding)
                spawnDistance =
                    Pathing.distance(this.pos, this.colony.hatchery.pos) || 0;
            }
            if (this.colony.state.isIncubating && this.colony.spawnGroup) {
                spawnDistance += this.colony.spawnGroup.stats.avgDistance;
            }
        }
        /* The last condition fixes a bug only present on private servers that took me a fucking week to isolate.
         * At the tick of birth, creep.spawning = false and creep.ticksTolive = undefined
         * See: https://screeps.com/forum/topic/443/creep-spawning-is-not-updated-correctly-after-spawn-process */
        return _.filter(
            creeps,
            (creep) =>
                creep.ticksToLive >
                    CREEP_SPAWN_TIME * creep.body.length +
                        spawnDistance +
                        prespawn ||
                creep.spawning ||
                (!creep.spawning && !creep.ticksToLive),
        );
    }
    /**
     * Wishlist of creeps to simplify spawning logic; includes automatic reporting
     */
    wishlist(quantity, setup, opts = {}) {
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
            reassignIdle: false,
        });
        // TODO Don't spawn if spawning is halted
        if (this.shouldSpawnAt && this.shouldSpawnAt > Game.time) {
            log.info(
                `Disabled spawning for ${this.print} for another ${
                    this.shouldSpawnAt - Game.time
                } ticks`,
            );
            return;
        }
        let creepQuantity;
        if (opts.noLifetimeFilter) {
            creepQuantity = (this._creeps[setup.role] || []).length;
        } else if (_.has(this.initializer, 'waypoints')) {
            // TODO: replace hardcoded distance with distance computed through portals
            creepQuantity = this.lifetimeFilter(
                this._creeps[setup.role] || [],
                opts.prespawn,
                500,
            ).length;
        } else {
            creepQuantity = this.lifetimeFilter(
                this._creeps[setup.role] || [],
                opts.prespawn,
            ).length;
        }
        let spawnQuantity = quantity - creepQuantity;
        if (opts.reassignIdle && spawnQuantity > 0) {
            const idleCreeps = _.filter(
                this.colony.getCreepsByRole(setup.role),
                (creep) => !getOverlord(creep),
            );
            for (
                let i = 0;
                i < Math.min(idleCreeps.length, spawnQuantity);
                i++
            ) {
                setOverlord(idleCreeps[i], this);
                spawnQuantity--;
            }
        }
        // A bug in outpostDefenseOverlord caused infinite requests and cost me two botarena rounds before I found it...
        if (spawnQuantity > MAX_SPAWN_REQUESTS) {
            log.error(
                `Too many requests for ${setup.role}s submitted by ${this.print}! (Check for errors.)`,
            );
        } else {
            for (let i = 0; i < spawnQuantity; i++) {
                if (i >= 1 && opts.spawnOneAtATime) break;
                this.requestCreep(setup, opts);
            }
        }
        this.creepReport(setup.role, creepQuantity, quantity);
    }
    /**
     * Requests that should be handled for all overlords prior to the init() phase
     */
    preInit() {
        // Handle requesting boosts from the evolution chamber
        const allZerg = _.flatten([
            ..._.values(this._zerg),
            ..._.values(this._combatZerg),
        ]);
        for (const zerg of allZerg) {
            if (zerg.needsBoosts) {
                const colony = Overmind.colonies[zerg.room.name];
                const evolutionChamber = colony
                    ? colony.evolutionChamber
                    : undefined;
                if (evolutionChamber) {
                    evolutionChamber.requestBoosts(zerg.getNeededBoosts());
                }
            }
        }
    }
    /**
     * Contains logic for shutting down the overlord
     */
    finish(successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
        // TODO: CombatOverlord
    }
    /**
     * Handle boosting of a creep; should be called during run()
     */
    handleBoosting(zerg) {
        const colony = Overmind.colonies[zerg.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (evolutionChamber) {
            if (!zerg.needsBoosts) {
                log.error(
                    `Overlord.handleBoosting() called for ${zerg.print}, but no boosts needed!`,
                );
            }
            const neededBoosts = zerg.getNeededBoosts();
            const neededBoostResources = _.keys(neededBoosts);
            const [
                moveBoosts,
                nonMoveBoosts,
            ] = _.partition(neededBoostResources, (resource) =>
                Abathur.isMoveBoost(resource),
            );
            // bug fix: https://github.com/bencbartlett/Overmind/pull/171
            for (const boost of [...moveBoosts, ...nonMoveBoosts]) {
                // try to get move boosts first if they're available
                const boostLab = _.find(
                    evolutionChamber.boostingLabs,
                    (lab) => lab.mineralType == boost,
                );
                if (boostLab) {
                    zerg.task = Tasks.getBoosted(boostLab, boost);
                    return;
                }
            }
        }
    }
    getZerg() {
        return this._zerg;
    }
    getCombatZerg() {
        return this._combatZerg;
    }
    /**
     * Standard sequence of actions for running task-based creeps
     */
    autoRun(roleCreeps, taskHandler, fleeCallback) {
        for (const creep of roleCreeps) {
            if (creep.spawning) {
                return;
            }
            if (!!fleeCallback) {
                if (fleeCallback(creep)) continue;
            }
            if (creep.isIdle) {
                if (creep.needsBoosts) {
                    this.handleBoosting(creep);
                } else {
                    taskHandler(creep);
                }
            }
            creep.run();
        }
    }
    visuals() {}
};
Overlord = __decorate([profile], Overlord);

/**
 * Generates a random integer between [low, high] inclusive
 */
function randint(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
/**
 * Flips a coin with probability p
 */
function p(probability) {
    return Math.random() < probability;
}

var NotifierPriority;
(function (NotifierPriority) {
    NotifierPriority[(NotifierPriority['Critical'] = 0)] = 'Critical';
    NotifierPriority[(NotifierPriority['High'] = 1)] = 'High';
    NotifierPriority[(NotifierPriority['Normal'] = 2)] = 'Normal';
    NotifierPriority[(NotifierPriority['Low'] = 3)] = 'Low';
})(NotifierPriority || (NotifierPriority = {}));
/**
 * Records one-time and persistent notifications from various in-game events
 */
class Notifier {
    constructor() {
        this.alerts = [];
        this.notifications = [];
    }
    clear() {
        this.alerts = [];
    }
    alert(message, roomName, priority = NotifierPriority.Normal) {
        // Register an alert to be displayed this in the notifications visual box
        const alert = { message, roomName, priority };
        this.alerts.push(alert);
    }
    // TODO: finish
    email(message, roomName, duration = 100, email = false) {
        log.alert(printRoomName(roomName) + ': ' + message);
    }
    // init() {
    //
    // }
    //
    // run() {
    //
    // }
    generateNotificationsList(links = false) {
        const sortedAlerts = _.sortBy(this.alerts, (alert) => alert.priority);
        return _.map(sortedAlerts, (alert) => {
            if (alert.roomName) {
                return (
                    (links ? printRoomName(alert.roomName) : alert.roomName) +
                    ': ' +
                    alert.message
                );
            } else {
                return alert.message;
            }
        });
    }
    visuals() {
        const notificationMessages = this.generateNotificationsList();
        Visualizer.drawNotifications(notificationMessages);
    }
}

const DEFAULT_MAX_PATH_LENGTH = 800;
const DEFAULT_MAX_LINEAR_RANGE = 15;
const DIRECTIVE_PATH_TIMEOUT = 30000;
/**
 * Directives are contextual wrappers for flags and serve as attachment points for Overlords, acting as a sort of
 * "process table" for the bot, with individual processes (Overlords) run by the scheulder (Overseer)
 */
let Directive = class Directive {
    // waypoints?: RoomPosition[];					// List of portals to travel through to reach destination
    constructor(flag, colonyFilter) {
        this.memory = flag.memory;
        this.name = flag.name;
        this.ref = flag.ref;
        // Register creation tick
        if (!this.memory['T' /* TICK */]) {
            this.memory['T' /* TICK */] = Game.time;
        }
        // if (this.memory.waypoints) {
        // 	this.waypoints = _.map(this.memory.waypoints, posName => getPosFromString(posName)!);
        // }
        // Relocate flag if needed; this must be called before the colony calculations
        if (this.memory.setPos) {
            const setPosition = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(setPosition)) {
                this.flag.setPosition(setPosition);
            } else {
                delete this.memory.setPos;
            }
            this.pos = setPosition;
            this.room = Game.rooms[setPosition.roomName];
        } else {
            this.pos = flag.pos;
            this.room = flag.room;
        }
        // Delete the directive if expired
        if (
            this.memory['X' /* EXPIRATION */] &&
            !this.memory.persistent &&
            Game.time > this.memory['X' /* EXPIRATION */]
        ) {
            log.alert(`Removing expired directive ${this.print}!`);
            flag.remove();
            return;
        }
        // Handle colony assigning
        const forceRecalc =
            !!this.memory.recalcColonyOnTick &&
            Game.time >= this.memory.recalcColonyOnTick;
        const colony = this.getColony(colonyFilter, forceRecalc);
        // Delete the directive if the colony is dead
        if (!colony) {
            if (Overmind.exceptions.length == 0) {
                if (Object.keys(Overmind.colonies).length === 0) {
                    log.info('InterShard travel detected, flag will stay');
                    this.overlords = {};
                    if (this.age == 0) {
                        this.onCreation();
                    }
                    // Register directive on Overmind
                    global[this.name] = this;
                    Overmind.overseer.registerDirective(this);
                    Overmind.directives[this.name] = this;
                    return;
                }
                log.alert(
                    `Could not get colony for directive ${this.print}; removing flag!`,
                );
                flag.remove();
            } else {
                log.alert(
                    `Could not get colony for directive ${this.print}; ` +
                        `exceptions present this tick, so won't remove`,
                );
            }
            return;
        }
        // Register colony and add flags to colony.flags
        this.colony = colony;
        this.colony.flags.push(flag);
        this.overlords = {};
        // Run creation actions if needed
        if (this.age == 0) {
            this.onCreation();
        }
        // Register directive on Overmind
        global[this.name] = this;
        Overmind.overseer.registerDirective(this);
        Overmind.directives[this.name] = this;
    }
    get colony() {
        return this._colony;
    }
    set colony(value) {
        this._colony = value;
    }
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.pos.roomName +
            '">[' +
            this.name +
            ']</a>'
        );
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    get age() {
        return Game.time - this.memory['T' /* TICK */];
    }
    info() {
        let msg = `Info for ${this.print}: —————————————————————————————————————————————————————————————————————————`;
        const info1 = {
            'Type:': this.directiveName,
            'Name:': this.name,
            'Pos:': this.pos.print,
            'Colony:': this.colony.print,
        };
        msg += toColumns(info1).join('\n');
        msg += `Overlords: \n`;
        const tab = `  `;
        for (const overlordName in this.overlords) {
            msg += tab + `${overlordName}:\n`;
            const olInfo = {};
            const overlord = this.overlords[overlordName];
            olInfo[tab + tab + 'Creep usage:'] = JSON.stringify(
                overlord.creepUsageReport,
            );
            olInfo[tab + tab + 'Zerg:'] = _.mapValues(
                overlord._zerg,
                (zergOfRole) => _.map(zergOfRole, (zerg) => zerg.print),
            );
            olInfo[
                tab + tab + 'CombatZerg:'
            ] = _.mapValues(overlord._combatZerg, (zergOfRole) =>
                _.map(zergOfRole, (zerg) => zerg.print),
            );
            msg += toColumns(olInfo).join('\n');
        }
        msg += 'Memory:\n' + print(this.memory);
        return msg;
    }
    /**
     * Gets an effective room position for a directive; allows you to reference this.pos in constructor super() without
     * throwing an error
     */
    static getPos(flag) {
        if (flag.memory && flag.memory.setPos) {
            const pos = derefRoomPosition(flag.memory.setPos);
            return pos;
        }
        return flag.pos;
    }
    // Flag must be a getter to avoid caching issues
    get flag() {
        return Game.flags[this.name];
    }
    // This allows you to access static DirectiveClass.directiveName from an instance of DirectiveClass
    get directiveName() {
        return this.constructor.directiveName;
    }
    refresh() {
        const flag = this.flag;
        if (!flag) {
            log.warning(
                `Missing flag for directive ${this.print}! Removing directive.`,
            );
            this.remove();
            return;
        }
        this.memory = flag.memory;
        this.pos = flag.pos;
        this.room = flag.room;
    }
    alert(message, priority = NotifierPriority.Normal) {
        Overmind.overseer.notifier.alert(message, this.pos.roomName, priority);
    }
    /**
     * Returns values for weighted and unweighted path length from colony and recomputes if necessary.
     */
    get distanceFromColony() {
        if (
            !this.memory['D' /* DISTANCE */] ||
            Game.time >= this.memory['D' /* DISTANCE */]['X' /* EXPIRATION */]
        ) {
            const ret = Pathing.findPath(this.colony.pos, this.pos, {
                maxOps: DIRECTIVE_PATH_TIMEOUT,
            });
            const terrainCache = {};
            const terrainWeighted = _.sum(ret.path, (pos) => {
                let terrain;
                if (!terrainCache[pos.roomName]) {
                    terrainCache[pos.roomName] = Game.map.getRoomTerrain(
                        pos.roomName,
                    );
                }
                terrain = terrainCache[pos.roomName];
                return terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP ? 5 : 1;
            });
            this.memory['D' /* DISTANCE */] = {
                ['u' /* UNWEIGHTED */]: ret.path.length,
                ['w' /* WEIGHTED */]: terrainWeighted,
                ['X' /* EXPIRATION */]: Game.time + 10000 + randint(0, 100),
            };
            if (ret.incomplete) {
                this.memory['D' /* DISTANCE */].incomplete = true;
            }
        }
        const memDistance = this.memory['D' /* DISTANCE */];
        if (memDistance.incomplete) {
            log.warning(`${this.print}: distanceFromColony() info incomplete!`);
        }
        return {
            unweighted: memDistance['u' /* UNWEIGHTED */],
            terrainWeighted: memDistance['w' /* WEIGHTED */],
        };
    }
    handleRelocation() {
        if (this.memory.setPos) {
            const pos = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(pos)) {
                const result = this.flag.setPosition(pos);
                if (result == OK) {
                    log.debug(
                        `Moving ${this.name} from ${this.flag.pos.print} to ${pos.print}.`,
                    );
                } else {
                    log.warning(
                        `Could not set room position to ${JSON.stringify(
                            this.memory.setPos,
                        )}!`,
                    );
                }
            } else {
                delete this.memory.setPos;
            }
            this.pos = pos;
            this.room = Game.rooms[pos.roomName];
            return true;
        }
        return false;
    }
    /**
     * Computes the parent colony for the directive to be handled by
     */
    getColony(colonyFilter, forceRecalc = false) {
        // If something is written to flag.colony, use that as the colony
        if (this.memory['C' /* COLONY */] && !forceRecalc) {
            return Overmind.colonies[this.memory['C' /* COLONY */]];
        } else {
            // If flag contains a colony name as a substring, assign to that colony, regardless of RCL
            const colonyNames = _.keys(Overmind.colonies);
            for (const name of colonyNames) {
                if (this.name.includes(name)) {
                    if (this.name.split(name)[1] != '') continue; // in case of other substring, e.g. E11S12 and E11S1
                    this.memory['C' /* COLONY */] = name;
                    return Overmind.colonies[name];
                }
            }
            // If flag is in a room belonging to a colony and the colony has sufficient RCL, assign to there
            const colony =
                Overmind.colonies[Overmind.colonyMap[this.pos.roomName]];
            if (colony) {
                if (!colonyFilter || colonyFilter(colony)) {
                    this.memory['C' /* COLONY */] = colony.name;
                    return colony;
                }
            }
            // Otherwise assign to closest colony
            const maxPathLength =
                this.memory.maxPathLength || DEFAULT_MAX_PATH_LENGTH;
            const maxLinearRange =
                this.memory.maxLinearRange || DEFAULT_MAX_LINEAR_RANGE;
            this.debug(
                `Recalculating colony association for ${this.name} in ${this.pos.roomName}`,
            );
            let nearestColony;
            let minDistance = Infinity;
            for (const colony of getAllColonies()) {
                if (
                    Game.map.getRoomLinearDistance(
                        this.pos.roomName,
                        colony.name,
                    ) > maxLinearRange &&
                    !this.memory.allowPortals
                ) {
                    continue;
                }
                if (!colonyFilter || colonyFilter(colony)) {
                    const ret = Pathing.findPath(
                        (colony.hatchery || colony).pos,
                        this.pos,
                        { maxOps: DIRECTIVE_PATH_TIMEOUT },
                    );
                    // TODO handle directives that can't find a path at great range
                    if (!ret.incomplete) {
                        if (
                            ret.path.length < maxPathLength &&
                            ret.path.length < minDistance
                        ) {
                            nearestColony = colony;
                            minDistance = ret.path.length;
                        }
                        if (ret.portalUsed && ret.portalUsed.expiration) {
                            this.memory.recalcColonyOnTick =
                                ret.portalUsed.expiration + 1;
                        }
                        this.debug(
                            `Path length to ${colony.room.print}: ${ret.path.length}`,
                        );
                    } else {
                        this.debug(`Incomplete path from ${colony.room.print}`);
                    }
                }
            }
            if (nearestColony) {
                log.info(
                    `Colony ${nearestColony.room.print} assigned to ${this.name}.`,
                );
                this.memory['C' /* COLONY */] = nearestColony.room.name;
                return nearestColony;
            } else {
                log.error(
                    `Could not find colony match for ${this.name} in ${this.pos.roomName}! ` +
                        `Try setting memory.maxPathLength and memory.maxLinearRange.`,
                );
            }
        }
    }
    // Wrapped flag methods ============================================================================================
    remove(force = false) {
        if (!this.memory.persistent || force) {
            delete Overmind.directives[this.name];
            delete global[this.name];
            Overmind.overseer.removeDirective(this);
            if (this.colony) {
                _.remove(this.colony.flags, (flag) => flag.name == this.name);
            }
            if (this.flag) {
                // check in case flag was removed manually in last build cycle
                return this.flag.remove();
            }
        }
    }
    setColor(color, secondaryColor) {
        if (secondaryColor) {
            return this.flag.setColor(color, secondaryColor);
        } else {
            return this.flag.setColor(color);
        }
    }
    setPosition(pos) {
        // Ignore the (x,y) setPosition option since I never use it
        return this.flag.setPosition(pos);
    }
    // Custom directive methods ========================================================================================
    /* Create an appropriate flag to instantiate this directive in the next tick */
    static create(pos, opts = {}) {
        let flagName = opts.name || undefined;
        if (!flagName) {
            flagName = this.directiveName + ':' + randomHex(6);
            if (Game.flags[flagName]) {
                return ERR_NAME_EXISTS;
            }
        }
        if (!opts.quiet) {
            log.alert(
                `Creating ${this.directiveName} directive at ${pos.print}!`,
            );
        }
        const result = pos.createFlag(
            flagName,
            this.color,
            this.secondaryColor,
        );
        if (result == flagName && opts.memory) {
            Memory.flags[flagName] = opts.memory;
        }
        log.debug(
            `Result: ${result}, memory: ${JSON.stringify(
                Memory.flags[result],
            )}`,
        );
        return result;
    }
    /**
     * Returns whether a directive of this type is present either at this position or within the room of this name
     */
    static isPresent(posOrRoomName) {
        if (PHASE != 'run' && PHASE != 'init') {
            log.error(
                `Directive.isPresent() will only give correct results in init() and run() phases!`,
            );
            return true; // usually we want to do something if directive isn't present; so this minimizes bad results
        }
        if (typeof posOrRoomName === 'string') {
            const roomName = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(
                roomName,
            );
            return (
                _.filter(directivesInRoom, (directive) =>
                    this.filter(directive.flag),
                ).length > 0
            );
        } else {
            const pos = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(
                pos.roomName,
            );
            return (
                _.filter(
                    directivesInRoom,
                    (directive) =>
                        this.filter(directive.flag) &&
                        equalXYR(pos, directive.pos),
                ).length > 0
            );
        }
    }
    /**
     * Create a directive if one of the same type is not already present (in room | at position).
     * Calling this method on positions in invisible rooms can be expensive and should be used sparingly.
     */
    static createIfNotPresent(pos, scope, opts = {}) {
        if (PHASE != 'run') {
            log.error(
                `Directive.createIfNotPresent() can only be called during the run phase!`,
            );
            return;
        }
        // Do nothing if flag is already here
        if (scope == 'pos') {
            if (this.isPresent(pos)) return;
        } else {
            if (this.isPresent(pos.roomName)) return;
        }
        const room = Game.rooms[pos.roomName];
        if (!room) {
            if (!opts.memory) {
                opts.memory = {};
            }
            opts.memory.setPos = pos;
        }
        switch (scope) {
            case 'room':
                if (room) {
                    return this.create(pos, opts);
                } else {
                    log.info(
                        `Creating directive at ${pos.print}... ` +
                            `No visibility in room; directive will be relocated on next tick.`,
                    );
                    let createAtPos;
                    if (opts.memory && opts.memory['C' /* COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(
                            opts.memory['C' /* COLONY */],
                        );
                    } else {
                        createAtPos = Pathing.findPathablePosition(
                            _.first(getAllColonies()).room.name,
                        );
                    }
                    return this.create(createAtPos, opts);
                }
            case 'pos':
                if (room) {
                    return this.create(pos, opts);
                } else {
                    log.info(
                        `Creating directive at ${pos.print}... ` +
                            `No visibility in room; directive will be relocated on next tick.`,
                    );
                    let createAtPos;
                    if (opts.memory && opts.memory['C' /* COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(
                            opts.memory['C' /* COLONY */],
                        );
                    } else {
                        createAtPos = Pathing.findPathablePosition(
                            _.first(getAllColonies()).room.name,
                        );
                    }
                    return this.create(createAtPos, opts);
                }
        }
    }
    /**
     * Filter for _.filter() that checks if a flag is of the matching type
     */
    static filter(flag) {
        return (
            flag.color == this.color &&
            flag.secondaryColor == this.secondaryColor
        );
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static find(flags) {
        flags = _.filter(flags, (flag) => this.filter(flag));
        return _.compact(
            _.map(flags, (flag) => Overmind.directives[flag.name]),
        );
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static findInRoom(roomName) {
        const directivesInRoom = Overmind.overseer.getDirectivesInRoom(
            roomName,
        );
        return _.filter(directivesInRoom, (directive) =>
            this.filter(directive.flag),
        );
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static findInColony(colony) {
        const directivesInColony = Overmind.overseer.getDirectivesForColony(
            colony,
        );
        return _.filter(directivesInColony, (directive) =>
            this.filter(directive.flag),
        );
    }
    // /**
    //  * Directive.creation() should contain any necessary logic for creating the directive (if the directive is
    //  * automatically placeable); this gets called for every type of directive every tick.
    //  */
    // static creation(): void {
    //
    // }
    /**
     * Actions that are performed only once on the tick of the directive creation
     */
    onCreation() {}
    // /**
    //  * Directive.removal() should contain any necessary logic for removing the directive.
    //  */
    // removal(): void {
    //
    // }
    /**
     * Override Directive.visuals() to display any relevant information via room visuals
     */
    visuals() {}
};
Directive = __decorate([profile], Directive);

var DirectiveNukeResponse_1;
/**
 * Nuke response: automatically over-fortify ramparts to withstand an incoming nuclear strike
 */
let DirectiveNukeResponse = (DirectiveNukeResponse_1 = class DirectiveNukeResponse extends (
    Directive
) {
    constructor(flag) {
        super(
            flag,
            (colony) =>
                colony.name == Directive.getPos(flag).roomName &&
                colony.level >= DirectiveNukeResponse_1.requiredRCL,
        );
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.nukes = this.room.find(FIND_NUKES);
        if (this.nukes.length > 0) {
            this.colony.state.isBeingNuked = true;
        }
    }
    spawnMoarOverlords() {}
    init() {
        for (const nuke of this.nukes) {
            this.alert(
                `Nuclear impact in ${nuke.timeToLand}`,
                NotifierPriority.Critical,
            );
        }
    }
    /**
     * Returns whether a position should be reinforced or not
     */
    static shouldReinforceLocation(pos) {
        const dontReinforce = [
            STRUCTURE_ROAD,
            STRUCTURE_RAMPART,
            STRUCTURE_WALL,
        ];
        const colony = Overmind.colonies[pos.roomName];
        if (colony && colony.assets.energy < 200000) {
            dontReinforce.push(STRUCTURE_EXTENSION);
        }
        return (
            _.filter(
                pos.lookFor(LOOK_STRUCTURES),
                (s) => !_.contains(dontReinforce, s.structureType),
            ).length > 0
        );
    }
    run() {
        // Build ramparts at all positions affected by nukes with structures on them
        if (Game.time % 50 == 0) {
            if (this.nukes.length > 0) {
                for (const nuke of this.nukes) {
                    const rampartPositions = _.filter(
                        nuke.pos.getPositionsInRange(2),
                        (pos) =>
                            DirectiveNukeResponse_1.shouldReinforceLocation(
                                pos,
                            ),
                    );
                    for (const pos of rampartPositions) {
                        // Build a rampart if there isn't one already
                        if (!pos.lookForStructure(STRUCTURE_RAMPART)) {
                            pos.createConstructionSite(STRUCTURE_RAMPART);
                        }
                    }
                    log.alert(
                        `Incoming nuke at ${nuke.pos.print}! Time until impact: ${nuke.timeToLand}`,
                    );
                }
            } else {
                // Remove once nuke is gone
                this.remove();
            }
        }
    }
});
DirectiveNukeResponse.directiveName = 'nukeResponse';
DirectiveNukeResponse.color = COLOR_ORANGE;
DirectiveNukeResponse.secondaryColor = COLOR_BLUE;
DirectiveNukeResponse.requiredRCL = 6;
DirectiveNukeResponse = DirectiveNukeResponse_1 = __decorate(
    [profile],
    DirectiveNukeResponse,
);

var WorkerOverlord_1;
/**
 * Spawns general-purpose workers, which maintain a colony, performing actions such as building, repairing, fortifying,
 * paving, and upgrading, when needed
 */
let WorkerOverlord = (WorkerOverlord_1 = class WorkerOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.work) {
        super(colony, 'worker', priority);
        // Compute barriers needing fortification or critical attention
        this.fortifyBarriers = $.structures(
            this,
            'fortifyBarriers',
            () =>
                _.sortBy(
                    _.filter(
                        this.room.barriers,
                        (s) =>
                            s.hits <
                                WorkerOverlord_1.settings.barrierHits[
                                    this.colony.level
                                ] &&
                            this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(
                                s.pos,
                            ),
                    ),
                    (s) => s.hits,
                ),
            25,
        );
        this.criticalBarriers = $.structures(
            this,
            'criticalBarriers',
            () =>
                _.filter(
                    this.fortifyBarriers,
                    (barrier) =>
                        barrier.hits <
                        WorkerOverlord_1.settings.barrierHits.critical,
                ),
            10,
        );
        // Generate a list of structures needing repairing (different from fortifying except in critical case)
        this.repairStructures = $.structures(this, 'repairStructures', () =>
            _.filter(this.colony.repairables, (structure) => {
                if (structure.structureType == STRUCTURE_CONTAINER) {
                    // only repair containers in owned room
                    if (structure.pos.roomName == this.colony.name) {
                        return structure.hits < 0.5 * structure.hitsMax;
                    } else {
                        return false;
                    }
                } else {
                    return structure.hits < structure.hitsMax;
                }
            }),
        );
        this.dismantleStructures = [];
        const homeRoomName = this.colony.room.name;
        const defcon = this.colony.defcon;
        // Filter constructionSites to only build valid ones
        const room = this.colony.room;
        const level = this.colony.controller.level;
        this.constructionSites = _.filter(
            this.colony.constructionSites,
            function (site) {
                // If site will be more than max amount of a structure at current level, ignore (happens after downgrade)
                const structureAmount = room[site.structureType + 's']
                    ? room[site.structureType + 's'].length
                    : room[site.structureType]
                    ? 1
                    : 0;
                if (
                    structureAmount >=
                    CONTROLLER_STRUCTURES[site.structureType][level]
                ) {
                    return false;
                }
                if (defcon > DEFCON.safe) {
                    // Only build non-road, non-container sites in the home room if defcon is unsafe
                    return (
                        site.pos.roomName == homeRoomName &&
                        site.structureType != STRUCTURE_CONTAINER &&
                        site.structureType != STRUCTURE_ROAD
                    );
                } else {
                    // Build all non-container sites in outpost and all sites in room if defcon is safe
                    if (
                        site.pos.roomName != homeRoomName &&
                        Cartographer.roomType(site.pos.roomName) ==
                            ROOMTYPE_CONTROLLER
                    ) {
                        return (
                            site.structureType != STRUCTURE_CONTAINER &&
                            !(
                                site.room &&
                                site.room.dangerousHostiles.length > 0
                            )
                        );
                    } else {
                        return true;
                    }
                }
            },
        );
        // Nuke defense ramparts needing fortification
        this.nukeDefenseRamparts = [];
        this.nukeDefenseHitsRemaining = {};
        if (this.room.find(FIND_NUKES).length > 0) {
            for (const rampart of this.colony.room.ramparts) {
                const neededHits = this.neededRampartHits(rampart);
                if (
                    rampart.hits < neededHits &&
                    rampart.pos.findInRange(FIND_NUKES, 2).length > 0 &&
                    DirectiveNukeResponse.shouldReinforceLocation(rampart.pos)
                ) {
                    this.nukeDefenseRamparts.push(rampart);
                    Visualizer.marker(rampart.pos, { color: 'gold' });
                    this.nukeDefenseHitsRemaining[rampart.id] = Math.min(
                        neededHits - rampart.hits,
                        0,
                    );
                }
            }
        }
        // Spawn boosted workers if there is significant fortifying which needs to be done
        const totalNukeDefenseHitsRemaining = _.sum(
            _.values(this.nukeDefenseHitsRemaining),
        );
        // bug fix https://github.com/bencbartlett/Overmind/pull/167
        const totalFortifyHitsRemaining = _.sum(
            this.fortifyBarriers,
            (barrier) =>
                Math.max(
                    WorkerOverlord_1.settings.barrierHits[this.colony.level] -
                        barrier.hits,
                    0,
                ),
        );
        const approxRepairAmountPerLifetime =
            ((REPAIR_POWER * 50) / 3) * CREEP_LIFE_TIME;
        if (
            totalNukeDefenseHitsRemaining > 3 * approxRepairAmountPerLifetime ||
            totalFortifyHitsRemaining > 5 * approxRepairAmountPerLifetime
        ) {
            this.useBoostedRepair = true;
        }
        // Register workers
        this.workers = this.zerg(Roles.worker);
    }
    neededRampartHits(rampart) {
        let neededHits =
            WorkerOverlord_1.settings.barrierHits[this.colony.level];
        for (const nuke of rampart.pos.lookFor(LOOK_NUKES)) {
            neededHits += 10e6;
        }
        for (const nuke of rampart.pos.findInRange(FIND_NUKES, 2)) {
            if (nuke.pos != rampart.pos) {
                neededHits += 5e6;
            }
        }
        return neededHits;
    }
    refresh() {
        super.refresh();
        $.refresh(
            this,
            'repairStructures',
            'dismantleStructures',
            'fortifyBarriers',
            'criticalBarriers',
            'constructionSites',
            'nukeDefenseRamparts',
        );
    }
    init() {
        let setup =
            this.colony.level == 1
                ? Setups.workers.early
                : Setups.workers.default;
        const workPartsPerWorker = setup.getBodyPotential(WORK, this.colony);
        let numWorkers;
        if (this.colony.stage == ColonyStage.Larva) {
            numWorkers = $.number(this, 'numWorkers', () => {
                // At lower levels, try to saturate the energy throughput of the colony
                let MAX_WORKERS = this.colony.upgradeSite.battery ? 10 : 15; // Maximum number of workers to spawn
                if (this.colony.level >= 3) {
                    MAX_WORKERS = 8;
                    const constructionSites = this.constructionSites.length;
                    if (constructionSites < 5) {
                        MAX_WORKERS = 6;
                        if (constructionSites < 2) {
                            MAX_WORKERS = 5;
                            if (constructionSites === 0) {
                                MAX_WORKERS = 4;
                            }
                        }
                    }
                }
                const energyMinedPerTick = _.sum(
                    _.map(this.colony.miningSites, function (site) {
                        const overlord = site.overlords.mine;
                        if (
                            overlord.isSuspended ||
                            overlord.miners.length === 0
                        ) {
                            return 0;
                        }
                        const miningPowerAssigned = _.sum(
                            overlord.miners,
                            (miner) => miner.getActiveBodyparts(WORK),
                        );
                        const saturation = Math.min(
                            miningPowerAssigned / overlord.miningPowerNeeded,
                            1,
                        );
                        return overlord.energyPerTick * saturation;
                    }),
                );
                const energyPerTickPerWorker = 1.1 * workPartsPerWorker; // Average energy per tick when working
                const workerUptime = 0.8;
                const numWorkers = Math.ceil(
                    energyMinedPerTick /
                        (energyPerTickPerWorker * workerUptime),
                );
                return Math.min(numWorkers, MAX_WORKERS);
            });
        } else {
            if (this.colony.roomPlanner.memory.relocating) {
                // If relocating, maintain a maximum of workers
                numWorkers = Math.min(
                    5,
                    Math.floor(this.colony.assets.energy / 25000) + 1,
                );
            } else {
                numWorkers = $.number(this, 'numWorkers', () => {
                    // At higher levels, spawn workers based on construction and repair that needs to be done
                    // Maximum number of workers to spawn
                    const MAX_WORKERS = Math.min(
                        2,
                        Math.floor(this.colony.assets.energy / 25000) + 1,
                    ); // zgeneral 29/3/2022 reduce workers from 5 to 3
                    if (this.nukeDefenseRamparts.length > 0) {
                        return MAX_WORKERS;
                    }
                    const buildTicks =
                        _.sum(this.constructionSites, (site) =>
                            Math.max(site.progressTotal - site.progress, 0),
                        ) / BUILD_POWER;
                    const repairTicks =
                        _.sum(
                            this.repairStructures,
                            (structure) => structure.hitsMax - structure.hits,
                        ) / REPAIR_POWER;
                    const activeRooms = _.filter(
                        this.colony.roomNames,
                        (roomName) => this.colony.isRoomActive(roomName),
                    );
                    const paveTicks = 1; // zgeneral 2/2024 //_.sum(activeRooms, (roomName) =>
                        //this.colony.roadLogistics.energyToRepave(roomName),
                    //);
                    let fortifyTicks = 0;
                    if (
                        this.colony.assets.energy >
                        WorkerOverlord_1.settings.fortifyDutyThreshold
                    ) {
                        fortifyTicks =
                            (0.25 *
                                _.sum(this.fortifyBarriers, (barrier) =>
                                    Math.max(
                                        0,
                                        WorkerOverlord_1.settings.barrierHits[
                                            this.colony.level
                                        ] - barrier.hits,
                                    ),
                                )) /
                            REPAIR_POWER;
                    }
                    // max constructionTicks for private server manually setting progress
                    let numWorkers = Math.ceil(
                        (2 *
                            (5 * buildTicks +
                                repairTicks +
                                paveTicks +
                                fortifyTicks)) /
                            (workPartsPerWorker * CREEP_LIFE_TIME),
                    );
                    numWorkers = Math.min(numWorkers, MAX_WORKERS);
                    if (
                        this.colony.controller.ticksToDowngrade <=
                        (this.colony.level >= 4 ? 10000 : 2000)
                    ) {
                        numWorkers = Math.max(numWorkers, 1);
                    }
                    // only do the bare minimum in case of energy shortage
                    if (this.colony.assets.energy < 5000) {
                        numWorkers = 1;
                        setup = Setups.workers.emergency;
                    }
                    return numWorkers;
                });
            }
        }
        if (this.useBoostedRepair) {
            setup = CreepSetup.boosted(setup, ['construct']);
        }
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //numWorkers = this.colony.assets.energy > 300000 ? 4 : numWorkers // zGeneral 2/09/2022 force workers to be 6
        /*
        const anchor = this.colony.bunker.anchor;
        const ramp = _.find(anchor.lookFor(LOOK_STRUCTURES), (s) => s.structureType == STRUCTURE_RAMPART);
        if (ramp && ramp.hits < 299e6) {
            numWorkers = 4;
        } else {
            
            // Game.time % 100 == 0 && console.log(this.colony.room.name, 'reached 299 level - congrats')
        }
        */

        numWorkers = 1; // zgeneral OVERRIDE< I DO NOT NEED MORE THAN ONE!
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        this.wishlist(numWorkers, setup);
    }
    repairActions(worker) {
        const target = worker.pos.findClosestByMultiRoomRange(
            this.repairStructures,
        );
        if (target) {
            worker.task = Tasks.repair(target);
            return true;
        } else {
            return false;
        }
    }
    buildActions(worker) {
        const groupedSites = _.groupBy(
            this.constructionSites,
            (site) => site.structureType,
        );
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = worker.pos.findClosestByMultiRoomRange(
                    groupedSites[structureType],
                );
                if (target) {
                    worker.task = Tasks.build(target);
                    return true;
                }
            }
        }
        return false;
    }
    dismantleActions(worker) {
        const targets = _.filter(
            this.dismantleStructures,
            (s) => (s.targetedBy || []).length < 3,
        );
        const target = worker.pos.findClosestByMultiRoomRange(targets);
        if (target) {
            _.remove(this.dismantleStructures, (s) => s == target);
            worker.task = Tasks.dismantle(target);
            return true;
        } else {
            return false;
        }
    }
    // Find a suitable repair ordering of roads with a depth first search
    pavingActions(worker) {
        const roomToRepave = this.colony.roadLogistics.workerShouldRepave(
            worker,
        );
        this.colony.roadLogistics.registerWorkerAssignment(
            worker,
            roomToRepave,
        );
        // Build a paving manifest
        const pavingManifest = this.colony.roadLogistics.buildPavingManifest(
            worker,
            roomToRepave,
        );
        if (pavingManifest) {
            worker.task = pavingManifest;
            return true;
        } else {
            return false;
        }
    }
    fortifyActions(worker, fortifyStructures = this.fortifyBarriers) {
        let lowBarriers;
        const highestBarrierHits = _.max(
            _.map(fortifyStructures, (structure) => structure.hits),
        );
        if (highestBarrierHits > WorkerOverlord_1.settings.hitTolerance) {
            // At high barrier HP, fortify only structures that are within a threshold of the lowest
            const lowestBarrierHits = _.min(
                _.map(fortifyStructures, (structure) => structure.hits),
            );
            lowBarriers = _.filter(
                fortifyStructures,
                (structure) =>
                    structure.hits <=
                    lowestBarrierHits + WorkerOverlord_1.settings.hitTolerance,
            );
        } else {
            // Otherwise fortify the lowest N structures
            const numBarriersToConsider = 5; // Choose the closest barrier of the N barriers with lowest hits
            lowBarriers = _.take(fortifyStructures, numBarriersToConsider);
        }
        const target = worker.pos.findClosestByMultiRoomRange(lowBarriers);
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        } else {
            return false;
        }
    }
    nukeFortifyActions(worker, fortifyStructures = this.nukeDefenseRamparts) {
        const target = minBy(fortifyStructures, (rampart) => {
            const structuresUnderRampart = rampart.pos.lookFor(LOOK_STRUCTURES);
            return _.min(
                _.map(structuresUnderRampart, (structure) => {
                    const priority = _.findIndex(
                        FortifyPriorities,
                        (sType) => sType == structure.structureType,
                    );
                    if (priority >= 0) {
                        // if found
                        return priority;
                    } else {
                        // not found
                        return 999;
                    }
                }),
            );
        });
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        } else {
            return false;
        }
    }
    upgradeActions(worker) {
        // Sign controller if needed
        if (
            !this.colony.controller.signedByMe &&
            !this.colony.controller.signedByScreeps
        ) {
            worker.task = Tasks.signController(this.colony.controller);
            return true;
        }
        worker.task = Tasks.upgrade(this.room.controller);
        return true;
    }
    handleWorker(worker) {
        if (worker.carry.energy > 0) {
            // TODO Add high priority to block controller with ramparts/walls in case of downgrade attack
            // FIXME workers get stalled at controller in case of downgrade attack
            // Upgrade controller if close to downgrade or if getting controller attacked/was downgraded
            const downgradeLevel =
                CONTROLLER_DOWNGRADE[this.colony.controller.level] *
                (this.colony.controller.level < 4 ? 0.3 : 0.7);
            if (
                this.colony.controller.level < 8 &&
                (!this.colony.controller.upgradeBlocked ||
                    this.colony.controller.upgradeBlocked < 30) &&
                (this.colony.controller.ticksToDowngrade <= downgradeLevel ||
                    this.colony.controller.progress >
                        this.colony.controller.progressTotal)
            ) {
                if (this.upgradeActions(worker)) return;
            }
            // Repair damaged non-road non-barrier structures
            if (
                this.repairStructures.length > 0 &&
                this.colony.defcon == DEFCON.safe
            ) {
                if (this.repairActions(worker)) return;
            }
            // Fortify critical barriers
            if (this.criticalBarriers.length > 0) {
                if (this.fortifyActions(worker, this.criticalBarriers)) return;
            }
            // Build new structures
            if (this.constructionSites.length > 0) {
                if (this.buildActions(worker)) return;
            }
            // Build ramparts to block incoming nuke
            if (
                this.nukeDefenseRamparts.length > 0 &&
                !this.colony.state.isRebuilding
            ) {
                if (this.nukeFortifyActions(worker, this.nukeDefenseRamparts)) {
                    return;
                }
            }
            // Build and maintain roads
            if (
                this.colony.roadLogistics.workerShouldRepave(worker) &&
                this.colony.defcon == DEFCON.safe
            ) {
                if (this.pavingActions(worker)) return;
            }
            // Dismantle marked structures
            if (
                this.dismantleStructures.length > 0 &&
                this.colony.defcon == DEFCON.safe
            ) {
                if (this.dismantleActions(worker)) return;
            }
            // Fortify walls and ramparts
            if (this.fortifyBarriers.length > 0) {
                if (this.fortifyActions(worker, this.fortifyBarriers)) return;
            }
            // Upgrade controller if less than RCL8 or no upgraders
            if (
                this.colony.level < 8 &&
                this.colony.upgradeSite.overlord.upgraders.length == 0 &&
                this.colony.defcon == DEFCON.safe
            ) {
                if (this.upgradeActions(worker)) return;
            }
        } else {
            // Acquire more energy
            let workerWithdrawLimit = 100;
            if (this.colony.stage == ColonyStage.Larva) {
                if (this.colony.upgradeSite.battery) {
                    workerWithdrawLimit = 800;
                    if (this.constructionSites.length > 1) {
                        workerWithdrawLimit = 300;
                    }
                } else {
                    workerWithdrawLimit = 200;
                }
            }
            worker.task = Tasks.recharge(workerWithdrawLimit);
        }
    }
    run() {
        this.autoRun(
            this.workers,
            (worker) => this.handleWorker(worker),
            (worker) =>
                worker.flee(worker.room.fleeDefaults, { invalidateTask: true }),
        );
    }
});
WorkerOverlord.settings = {
    barrierHits: {
        // What HP to fortify barriers to at each RCL
        critical: 2500, //2500
        1: 3e3,
        2: 3e3,
        3: 1e4,
        4: 5e4,
        5: 1e5,
        6: 5e5,
        7: 2e6,
        8: 100e6,
    },
    hitTolerance: 100000,
    fortifyDutyThreshold: 150000,
};
WorkerOverlord = WorkerOverlord_1 = __decorate([profile], WorkerOverlord);

const TERMINAL_THRESHOLDS = {
    energy: {
        target: 50000,
        tolerance: 5000,
    },
    power: {
        target: 1000,
        tolerance: 500,
    },
    ops: {
        target: 1000,
        tolerance: 500,
    },
    baseMinerals: {
        target: 6500,
        tolerance: 500,
    },
    intermediateReactants: {
        target: 3500,
        tolerance: 500,
    },
    boosts: {
        target: 3500,
        tolerance: 500,
    },
    battery: {
        target: 3500,
        tolerance: 500,
    },
    default: {
        target: 1000,
        tolerance: 500,
    },
};
function getTerminalThresholds(resource) {
    let thresholds;
    if (resource == RESOURCE_ENERGY) {
        thresholds = TERMINAL_THRESHOLDS.energy;
    } else if (resource == RESOURCE_POWER) {
        thresholds = TERMINAL_THRESHOLDS.power;
    } else if (resource == RESOURCE_OPS) {
        thresholds = TERMINAL_THRESHOLDS.ops;
    } else if (Abathur.isBaseMineral(resource)) {
        thresholds = TERMINAL_THRESHOLDS.baseMinerals;
    } else if (
        Abathur.isIntermediateReactant(resource) ||
        resource == RESOURCE_GHODIUM
    ) {
        thresholds = TERMINAL_THRESHOLDS.intermediateReactants;
    } else if (Abathur.isBoost(resource)) {
        thresholds = TERMINAL_THRESHOLDS.boosts;
    } else if (resource == RESOURCE_BATTERY) {
        thresholds = TERMINAL_THRESHOLDS.battery;
    } else {
        thresholds = TERMINAL_THRESHOLDS.default;
    }
    return thresholds;
}
// Needs to be after class declaration because fuck lack of class hoisting
const TERMINAL_THRESHOLDS_ALL = _.zipObject(
    RESOURCES_ALL,
    _.map(RESOURCES_ALL, (resource) => getTerminalThresholds(resource)),
);
/**
 * Command center overlord: spawn and run a dediated commandCenter attendant
 */
let CommandCenterOverlord = class CommandCenterOverlord extends Overlord {
    constructor(commandCenter, priority = OverlordPriority.core.manager) {
        super(commandCenter, 'manager', priority);
        this.commandCenter = commandCenter;
        this.mode = this.colony.layout;
        this.managers = this.zerg(Roles.manager);
        // if (this.commandCenter.terminal && _.sum(this.commandCenter.terminal.store) < TERMINAL_CAPACITY - 5000) {
        // 	this.depositTarget = this.commandCenter.terminal;
        // } else {
        // 	this.depositTarget = this.commandCenter.storage;
        // }
        if (this.colony.bunker) {
            const anchor = this.colony.bunker.anchor;
            $.set(this, 'managerRepairTarget', () =>
                minBy(
                    _.filter(
                        anchor.findInRange(anchor.room.barriers, 3),
                        (b) =>
                            b.hits <
                            WorkerOverlord.settings.barrierHits[
                                this.colony.level
                            ],
                    ),
                    (b) => b.hits,
                ),
            );
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'managerRepairTarget');
    }
    init() {
        let setup = Setups.managers.default;
        let spawnRequestOptions = {};
        if (this.colony.layout == 'twoPart') {
            setup = Setups.managers.twoPart;
        }
        if (
            this.colony.bunker &&
            this.colony.bunker.coreSpawn &&
            this.colony.level == 8
        ) {
            if (!this.colony.roomPlanner.memory.relocating) {
                setup = Setups.managers.stationary;
            }
            // // Spawn a worker manager to repair central tiles
            // if (this.managerRepairTarget &&
            // 	this.managerRepairTarget.hits < WorkerOverlord.settings.barrierHits[this.colony.level] - 1e5 &&
            // 	this.colony.assets.energy > WorkerOverlord.settings.fortifyDutyThreshold) {
            // 	setup = Setups.managers.stationary_work; // use working manager body if you have something to repair
            // }
            spawnRequestOptions = {
                spawn: this.colony.bunker.coreSpawn,
                directions: [
                    // getDirectionTo always gives a valid direction,
                    // so it's relocating safe.
                    this.colony.bunker.coreSpawn.pos.getDirectionTo(
                        this.colony.bunker.anchor,
                    ),
                ],
            };
        }
        this.wishlist(1, setup, { options: spawnRequestOptions });
    }
    /**
     * Dump anything you are currently holding into terminal or storage
     */
    unloadCarry(manager) {
        // Nothing to do if creep is empty
        if (manager.store.getUsedCapacity() == 0) {
            return false;
        } else {
            manager.debug(`Unloading carry: ${JSON.stringify(manager.carry)}`);
            if (!this.commandCenter.storage.isFull) {
                manager.task = Tasks.transferAll(this.commandCenter.storage); // placeholder solution
                return true;
            } else {
                // TODO: Not sure if this is a good idea, the manager might pick them back up
                // TODO: but at least we have a warning message for now.
                manager.task = Tasks.drop(manager.pos);
                log.warning(
                    `Manager ${manager.print} is dropping resource in ${manager.room.print} - storage is full`,
                );
                return true;
            }
        }
    }
    /**
     * Handle any supply requests from your transport request group
     */
    supplyActions(manager) {
        manager.debug('supplyActions');
        const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(
            manager.pos,
            'supply',
        );
        if (request) {
            const amount = Math.min(request.amount, manager.carryCapacity);
            const resource = request.resourceType;
            // If we have enough to fulfill the request, we're done
            if (manager.store[request.resourceType] >= amount) {
                manager.task = Tasks.transfer(request.target, resource, amount);
                return true;
            }
            // Otherwise, if we have any currently in manager's carry, transfer it to the requestor
            else if (manager.store[request.resourceType] > 0) {
                manager.task = Tasks.transfer(
                    request.target,
                    resource,
                    manager.store[request.resourceType],
                );
                return true;
            }
            // Otherwise, we don't have any of the resource in the carry
            else {
                if (this.unloadCarry(manager)) {
                    // if we have other crap, we should unload it
                    return true;
                }
                // Otherwise, we have an empty carry; withdraw the right amount of resource and transfer it
                const storage = this.commandCenter.storage;
                const terminal = this.commandCenter.terminal;
                let withdrawFrom;
                let withdrawAmount = amount;
                if (
                    request.target.id != storage.id &&
                    storage.store[resource] > 0
                ) {
                    withdrawFrom = storage;
                    withdrawAmount = Math.min(amount, storage.store[resource]);
                } else if (
                    terminal &&
                    request.target.id != terminal.id &&
                    terminal.store[resource] > 0
                ) {
                    withdrawFrom = terminal;
                    withdrawAmount = Math.min(amount, terminal.store[resource]);
                }
                if (withdrawFrom) {
                    manager.task = Tasks.chain([
                        Tasks.withdraw(withdrawFrom, resource, withdrawAmount),
                        Tasks.transfer(
                            request.target,
                            resource,
                            withdrawAmount,
                        ),
                    ]);
                    return true;
                } else {
                    log.warning(
                        `${manager.print}: could not fulfill supply request for ${resource}!`,
                    );
                    return false;
                }
            }
        } else {
            return false;
        }
    }
    /**
     * Handle any withdrawal requests from your transport request group
     */
    withdrawActions(manager) {
        manager.debug('withdrawActions');
        const freeCapacity = manager.store.getFreeCapacity();
        if (freeCapacity > 0) {
            const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(
                manager.pos,
                'withdraw',
            );
            if (request) {
                const amount = Math.min(request.amount, freeCapacity);
                manager.task = Tasks.withdraw(
                    request.target,
                    request.resourceType,
                    amount,
                );
                return true;
            }
        } else {
            // Currently the only withdraw requests are energy from links so we can dump in to terminal by default
            manager.task = Tasks.transferAll(
                this.commandCenter.terminal || this.commandCenter.storage,
            );
            return true;
        }
        return false;
    }
    /**
     * Move energy into terminal if storage is too full and into storage if storage is too empty
     */
    balanceStorageAndTerminal(manager) {
        let factoryResources = [
            {
                // in only
                [RESOURCE_HYDROGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_OXYGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_UTRIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_KEANIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_LEMERGIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_ZYNTHIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_CATALYST]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_GHODIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_SILICON]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_METAL]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_BIOMASS]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_MIST]: { min: 200, max: 400, prod: 0 },

                // shared in/out:
                [RESOURCE_UTRIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_LEMERGIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_ZYNTHIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_KEANIUM_BAR]: { min: 120, max: 500, prod: 1000 },

                // out only
                [RESOURCE_GHODIUM_MELT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_OXIDANT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_REDUCTANT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_PURIFIER]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_WIRE]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_CELL]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_ALLOY]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_CONDENSATE]: { min: 0, max: 0, prod: 40 },
            },
            {
                // in only
                [RESOURCE_HYDROGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_OXYGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_UTRIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_KEANIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_LEMERGIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_ZYNTHIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_CATALYST]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_GHODIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_SILICON]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_METAL]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_BIOMASS]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_MIST]: { min: 200, max: 400, prod: 0 },

                // shared in/out:
                [RESOURCE_UTRIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_LEMERGIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_ZYNTHIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_KEANIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_OXIDANT]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_PURIFIER]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_WIRE]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_CELL]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_ALLOY]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_CONDENSATE]: { min: 40, max: 60, prod: 80 },

                // out only
                [RESOURCE_GHODIUM_MELT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_REDUCTANT]: { min: 0, max: 0, prod: 1000 },

                //level 1 output
                [RESOURCE_COMPOSITE]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_SWITCH]: { min: 0, max: 0, prod: 10 },
                [RESOURCE_PHLEGM]: { min: 0, max: 0, prod: 4 },
                [RESOURCE_TUBE]: { min: 0, max: 0, prod: 4 },
                [RESOURCE_CONCENTRATE]: { min: 0, max: 0, prod: 6 },
            },
        ];
        manager.debug('balanceStorageAndTerminal');
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal) return false;
        const factory = this.commandCenter.factory;
        // BOGDEN: Load er up
        if (factory) {
            if (
                factory.store.getUsedCapacity(RESOURCE_ENERGY) > 5000 &&
                storage.store.getFreeCapacity(RESOURCE_ENERGY) > 50000
            ) {
                manager.task = Tasks.chain([
                    Tasks.withdraw(factory, RESOURCE_ENERGY),
                    Tasks.transfer(storage, RESOURCE_ENERGY),
                ]);
                return true;
            } else if (
                factory.store.getUsedCapacity(RESOURCE_BATTERY) <= 1000 &&
                storage.store.getUsedCapacity(RESOURCE_BATTERY) >= 500
            ) {
                manager.task = Tasks.chain([
                    Tasks.withdraw(storage, RESOURCE_BATTERY),
                    Tasks.transfer(factory, RESOURCE_BATTERY),
                ]);
                return true;
            } else if (
                factory.store.getUsedCapacity(RESOURCE_BATTERY) >= 20000 &&
                storage.store.getFreeCapacity() > 10000
            ) {
                manager.task = Tasks.chain([
                    Tasks.withdraw(factory, RESOURCE_BATTERY),
                    Tasks.transfer(storage, RESOURCE_BATTERY),
                ]);
                return true;
            } else if (
                factory.store.getFreeCapacity(RESOURCE_ENERGY) > 1000 &&
                factory.store.getUsedCapacity(RESOURCE_ENERGY) < 1000 &&
                storage.store.getUsedCapacity(RESOURCE_ENERGY) > 150000
            ) {
                manager.task = Tasks.chain([
                    Tasks.withdraw(storage, RESOURCE_ENERGY),
                    Tasks.transfer(factory, RESOURCE_ENERGY),
                ]);
                return true;
            }
        }
        //const roomSellOrders = Overmind.tradeNetwork.getExistingOrders(ORDER_SELL, 'any', this.colony.name); //zGeneral 9/2023
        for (const resourceType in this.colony.assets) {
            const resource = resourceType; // to make the fucking TS compiler happy
            // Skip it if you don't have it
            if (this.colony.assets[resource] <= 0) continue;
            // Get target and tolerance for the resource and skip if you don't care about it
            const thresholds = TERMINAL_THRESHOLDS_ALL[resource];
            if (!thresholds) continue;
            let { target, tolerance } = thresholds;
            // If you're selling this resource from this room, keep a bunch of it in the terminal
             //zGeneral 9/2023
             /*
            if (roomSellOrders.length > 0) {
                const sellOrderForResource = _.find(roomSellOrders, (order) => order.resourceType == resourceType);
                if (sellOrderForResource) {
                    target = Math.max(target, sellOrderForResource.remainingAmount);
                }
            }
            */
            // Move stuff from terminal into storage
            if (
                terminal.store[resource] > target + tolerance &&
                storage.store.getFreeCapacity(resource) > 0
            ) {
                manager.debug(`Moving ${resource} from terminal into storage`);
                if (this.unloadCarry(manager)) {
                    return true;
                }
                const transferAmount = Math.min(
                    terminal.store[resource] - target,
                    storage.store.getFreeCapacity(resource),
                    manager.carryCapacity,
                );
                manager.task = Tasks.chain([
                    Tasks.withdraw(terminal, resource, transferAmount),
                    Tasks.transfer(storage, resource, transferAmount),
                ]);
                // manager.debug(`Assigned task ${print(manager.task)}`)
                return true;
            }
            // Move stuff into terminal from storage
            if (
                terminal.store[resource] < target - tolerance &&
                storage.store[resource] > 0
            ) {
                manager.debug(`Moving ${resource} from storage into terminal`);
                if (this.unloadCarry(manager)) {
                    return true;
                }
                const transferAmount = Math.min(
                    target - terminal.store[resource],
                    storage.store[resource],
                    manager.carryCapacity,
                );
                manager.task = Tasks.chain([
                    Tasks.withdraw(storage, resource, transferAmount),
                    Tasks.transfer(terminal, resource, transferAmount),
                ]);
                // manager.debug(`Assigned task ${print(manager.task)}`)
                return true;
            }

            if (
                Game.time % 101 == 0 &&
                terminal &&
                terminal.cooldown == 0 &&
                resourceType == RESOURCE_BATTERY &&
                (this.colony.assets[resource] | 0) > 15000 &&
                (terminal.store[resourceType] | 0) > 250 &&
                (terminal.store[RESOURCE_ENERGY] | 0) > 30000
            ) {
                //zgeneral - reverse back later
                //console.log(terminal.pos.roomName);
                let targetRoom = minBy(
                    Overmind.colonies,
                    (colony) =>
                        colony.storage &&
                        colony.terminal &&
                        colony.assets[resource] | 0,
                ).name;
                if (
                    Game.rooms[targetRoom].controller.level == 8 &&
                    _.sum(Game.rooms[targetRoom].storage.store) < 950000 &&
                    (Overmind.colonies[targetRoom].assets[resourceType] | 0) <
                        10000
                ) {
                    terminal.send(resourceType, 250, targetRoom);
                    console.log(
                        'distribute battery ',
                        resourceType,
                        250,
                        terminal.room.name,
                        terminal.store[resourceType],
                        '=>',
                        targetRoom,
                        Game.rooms[targetRoom].storage.store[RESOURCE_BATTERY] |
                            0,
                    );
                    return true;
                }
            }
            if (
                (Game.time + 11) % 101 == 0 &&
                terminal &&
                terminal.cooldown == 0 &&
                resourceType == RESOURCE_BATTERY &&
                (this.colony.assets[resource] | 0) > 150000 &&
                (terminal.store[resourceType] | 0) > 100000 &&
                (terminal.store[RESOURCE_ENERGY] | 0) > 30000
            ) {
                //zgeneral - reverse back later
                //console.log(terminal.pos.roomName);
                let targetRoom = minBy(
                    Overmind.colonies,
                    (colony) =>
                        colony.storage &&
                        colony.terminal &&
                        colony.assets[resource] | 0,
                ).name;
                if (
                    Game.rooms[targetRoom].controller.level == 8 &&
                    _.sum(Game.rooms[targetRoom].storage.store) < 950000 &&
                    _.sum(Game.rooms[targetRoom].terminal.store) < 200000 &&
                    (Overmind.colonies[targetRoom].assets[resourceType] | 0) <
                        50000
                ) {
                    terminal.send(resourceType, 2500, targetRoom);
                    console.log(
                        'MEGA distribute battery ',
                        resourceType,
                        2500,
                        terminal.room.name,
                        terminal.store[resourceType],
                        '=>',
                        targetRoom,
                        Game.rooms[targetRoom].storage.store[RESOURCE_BATTERY] |
                            0,
                    );
                    return true;
                }
            }
            if (
                (Game.time + 21) % 101 == 0 &&
                terminal &&
                terminal.cooldown == 0 &&
                resourceType == RESOURCE_POWER &&
                (this.colony.assets[resourceType] | 0) > 10000 &&
                (terminal.store[resourceType] | 0) > 250 &&
                (terminal.store[RESOURCE_ENERGY] | 0) > 30000
            ) {
                //zgeneral - reverse back later
                //console.log(terminal.pos.roomName);
                let targetRoom = minBy(
                    Overmind.colonies,
                    (colony) =>
                        colony.storage &&
                        colony.terminal &&
                        colony.assets[resource] | 0,
                ).name;
                if (
                    Game.rooms[targetRoom].controller.level == 8 &&
                    Game.rooms[targetRoom].storage.store.getUsedCapacity() <
                        950000 &&
                    (Overmind.colonies[targetRoom].assets[resourceType] | 0) <
                        5000
                ) {
                    terminal.send(resourceType, 250, targetRoom);
                    /*
                    console.log(
                        'distribute power ',
                        resourceType,
                        250, 
                        terminal.room.name,
                        terminal.store[resourceType],
                        '=>',
                        targetRoom,
                        Game.rooms[targetRoom].storage.store[RESOURCE_POWER] |
                            0,
                    );
                    */
                    return true;
                }
            }
            if (
                false &&
                terminal &&
                terminal.cooldown == 0 &&
                resourceType == 'XLHO2' &&
                (this.colony.assets[resourceType] | 0) > 25000 &&
                (terminal.store[resourceType] | 0) > 250 &&
                (terminal.store[RESOURCE_ENERGY] | 0) > 30000
            ) {
                //zgeneral - reverse back later
                //console.log(terminal.pos.roomName);
                let targetRoom = minBy(
                    Overmind.colonies,
                    (colony) =>
                        colony.storage &&
                        colony.terminal &&
                        colony.assets[resource] | 0,
                ).name;
                if (
                    Game.rooms[targetRoom].controller.level == 8 &&
                    _.sum(Game.rooms[targetRoom].storage.store) < 950000 &&
                    (Overmind.colonies[targetRoom].assets[resourceType] | 0) <
                        15000
                ) {
                    terminal.send(resourceType, 250, targetRoom);
                    console.log(
                        'distribute XLHO2 ',
                        resourceType,
                        250,
                        terminal.room.name,
                        terminal.store[resourceType],
                        '=>',
                        targetRoom,
                        Game.rooms[targetRoom].storage.store['XLHO2'] | 0,
                    );
                    return true;
                }
            }
            /*
            if ( // zGeneral 14/04/2023
                terminal &&
                terminal.cooldown == 0 &&
                resourceType == RESOURCE_POWER &&
                (this.colony.assets[resourceType] | 0) < 250 &&
                (terminal.store[RESOURCE_ENERGY] | 0) > 5000
            ) {
                const defaultTradeOpts = {
                        preferDirect: true,
                        flexibleAmount: true,
                        ignoreMinAmounts: true,
                        ignorePriceChecksForDirect: true,
                        dryRun: false,
                    };

                Overmind.tradeNetwork.buy(terminal, RESOURCE_POWER, 1000, defaultTradeOpts);
                return true;
                
            }
            */
        }
        let factoryResourcesByLevel = factoryResources[factory.level || 0];

        for (const resource in factoryResourcesByLevel) {
            const config = factoryResourcesByLevel[resource];
            const factoryResourceAmount =
                factory.store.getUsedCapacity(resource) || 0;
            const terminalResourceAmount =
                terminal.store.getUsedCapacity(resource) || 0;
            const factoryFreeSpace = factory.store.getFreeCapacity();
            const terminalFreeSpace = terminal.store.getFreeCapacity();

            if (
                factoryResourceAmount < config.min &&
                factoryFreeSpace > config.min &&
                terminalResourceAmount >= config.min
            ) {
                let transferAmount = _.min(config.min, manager.carryCapacity);
                manager.task = Tasks.chain([
                    Tasks.withdraw(terminal, resource, transferAmount),
                    Tasks.transfer(factory, resource),
                ]);

                return true;
            } else if (
                config.min == 0 &&
                factoryResourceAmount > 0 &&
                terminalFreeSpace > factoryResourceAmount
            ) {
                manager.task = Tasks.chain([
                    Tasks.withdraw(factory, resource),
                    Tasks.transfer(terminal, resource),
                ]);
                console.log(2);
                return true;
            } else if (
                factoryResourceAmount > config.max &&
                terminalFreeSpace > factoryResourceAmount
            ) {
                let transferAmount = _.min(
                    factoryResourceAmount - config.max,
                    manager.carryCapacity,
                );
                manager.task = Tasks.chain([
                    Tasks.withdraw(factory, resource, transferAmount),
                    Tasks.transfer(terminal, resource),
                ]);
                console.log(3, transferAmount);
                return true;
            }
        }
        // Nothing has happened
        return false;
    }
    // /**
    //  * Move energy into terminal if storage is too full and into storage if storage is too empty
    //  */
    // private equalizeStorageAndTerminal_old(manager: Zerg): boolean {
    // 	manager.debug('equalizeStorageAndTerminal');
    // 	const storage = this.commandCenter.storage;
    // 	const terminal = this.commandCenter.terminal;
    // 	if (!storage || !terminal) return false;
    //
    // 	const equilibrium = Energetics.settings.terminal.energy.equilibrium;
    // 	const tolerance = Energetics.settings.terminal.energy.tolerance;
    // 	const storageTolerance = Energetics.settings.storage.total.tolerance;
    // 	const storageEnergyCap = Energetics.settings.storage.total.cap;
    // 	// const terminalState = this.colony.terminalState;
    // 	// // Adjust max energy allowable in storage if there's an exception state happening
    // 	// if (terminalState && terminalState.type == 'out') {
    // 	// 	storageEnergyCap = terminalState.amounts[RESOURCE_ENERGY] || 0;
    // 	// }
    //
    // 	// Move energy from storage to terminal if there is not enough in terminal or if there's terminal evacuation
    // 	if ((terminal.energy < equilibrium - tolerance || storage.energy > storageEnergyCap + storageTolerance)
    // 		&& storage.energy > 0) {
    // 		if (this.unloadCarry(manager)) return true;
    // 		manager.task = Tasks.withdraw(storage);
    // 		manager.task.parent = Tasks.transfer(terminal);
    // 		return true;
    // 	}
    //
    // 	// Move energy from terminal to storage if there is too much in terminal and there is space in storage
    // 	if (terminal.energy > equilibrium + tolerance && storage.energy < storageEnergyCap) {
    // 		if (this.unloadCarry(manager)) return true;
    // 		manager.task = Tasks.withdraw(terminal);
    // 		manager.task.parent = Tasks.transfer(storage);
    // 		return true;
    // 	}
    //
    // 	// Nothing has happened
    // 	return false;
    // }
    /**
     * Move enough energy from a terminal which needs to be moved into storage to allow you to rebuild the terminal
     */
    moveEnergyFromRebuildingTerminal(manager) {
        manager.debug('moveEnergyFromRebuildingTerminal');
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal) {
            return false;
        }
        if (
            storage.energy <
            Energetics.settings.storage.energy.destroyTerminalThreshold
        ) {
            if (this.unloadCarry(manager)) {
                return true;
            }
            manager.task = Tasks.chain([
                Tasks.withdraw(terminal),
                Tasks.transfer(storage),
            ]);
            return true;
        }
        return false;
    }
    // private moveMineralsToTerminal(manager: Zerg): boolean {
    // 	const storage = this.commandCenter.storage;
    // 	const terminal = this.commandCenter.terminal;
    // 	if (!storage || !terminal) {
    // 		return false;
    // 	}
    // 	// Don't do this if terminal is critically full
    // 	if (terminal.store.getFreeCapacity() < (1 - CommandCenterOverlord.MAX_TERMINAL_FILLED_PERCENTAGE)
    // 		* terminal.store.getCapacity()) {
    // 		return false;
    // 	}
    // 	// Move all non-energy resources from storage to terminal
    // 	for (const [resourceType, amount] of storage.store.contents) {
    // 		if (resourceType != RESOURCE_ENERGY && resourceType != RESOURCE_OPS && amount > 0
    // 			&& terminal.store[resourceType] < 5000) {
    // 			if (this.unloadCarry(manager)) return true;
    // 			manager.task = Tasks.withdraw(storage, resourceType);
    // 			manager.task.parent = Tasks.transfer(terminal, resourceType);
    // 			return true;
    // 		}
    // 	}
    // 	return false;
    // }
    /**
     * Pickup resources dropped on manager position or in tombstones from last manager
     */
    pickupActions(manager, tombstonesOnly = true) {
        manager.debug('pickupActions');
        // Look for tombstones at position
        const tombstones = manager.pos.lookFor(LOOK_TOMBSTONES);
        const tombstone = _.first(tombstones);
        if (tombstone && sumStore(tombstone.store) > 0) {
            manager.task = Tasks.chain([
                Tasks.withdrawAll(tombstone),
                Tasks.transferAll(this.commandCenter.storage),
            ]);
            return true;
        }
        if (tombstonesOnly) {
            return false; // skip next bit if only looking at tombstones
        }
        // Pickup any resources that happen to be dropped where you are
        const resources = manager.pos.lookFor(LOOK_RESOURCES);
        const resource = _.first(resources);
        if (resource) {
            manager.task = Tasks.chain([
                Tasks.pickup(resource),
                Tasks.transferAll(this.commandCenter.storage),
            ]);
            return true;
        }
        return false;
    }
    /**
     * When storage + terminal are critically full, start dumping the least useful stuff on the ground.
     * This should rarely be run; added in Feb 2020 to fix a critical issue where I hadn't added factory code and all
     * my terminals and storage filled up with crap.
     */
    // private emergencyDumpingActions(manager: Zerg): boolean {
    // 	manager.debug('emergencyDumpingActions');
    // 	const storage = this.commandCenter.storage;
    // 	const terminal = this.commandCenter.terminal;
    // 	if (!storage && !terminal) {
    // 		return false;
    // 	}
    // 	const storageCapacity = storage ? storage.store.getFreeCapacity() : 0;
    // 	const terminalCapacity = terminal ? terminal.store.getFreeCapacity() : 0;
    // 	const storageEnergy = storage ? storage.store.energy : 0;
    // 	const terminalEnergy = terminal ? terminal.store.energy : 0;
    // 	// const freeCapacity = (storage ? storage.store.getFreeCapacity() : 0) +
    // 	// 					 (terminal ? terminal.store.getFreeCapacity() : 0);
    // 	// const energy = (storage ? storage.store.energy : 0) +
    // 	// 			   (terminal ? terminal.store.energy : 0);
    // 	// if (energy >= 5000) {
    // 	// 	return false;
    // 	// }
    // 	const DUMP_THRESHOLD = 5000;
    // 	if (terminal && terminalCapacity < DUMP_THRESHOLD && terminalEnergy < DUMP_THRESHOLD) {
    // 		return this.dumpFrom(manager, terminal);
    // 	}
    // 	if (storage && storageCapacity < DUMP_THRESHOLD && storageEnergy < DUMP_THRESHOLD) {
    // 		return this.dumpFrom(manager, storage);
    // 	}
    // 	return false;
    // }
    /**
     * Dump resources on ground from a target that is critically full
     */
    // private dumpFrom(manager: Zerg, target: StructureTerminal | StructureStorage): boolean {
    // 	manager.say('Dump!');
    // 	// Start dumping least valuable shit on the ground
    // 	const toDump = _.sortBy(BASE_RESOURCES, resource => (target.store[resource] || 0) * -1);
    // 	const toDumpInCarry = _.first(_.filter(toDump, res => manager.carry[res] > 0));
    // 	// Drop anything you have in carry that is dumpable
    // 	if (toDumpInCarry) {
    // 		manager.drop(toDumpInCarry);
    // 		return true;
    // 	}
    // 	// Take out stuff to dump
    // 	for (const resource of toDump) {
    // 		if (target.store[resource] > 0) {
    // 			manager.task = Tasks.drop(manager.pos, resource).fork(Tasks.withdraw(target, resource));
    // 			return true;
    // 		}
    // 	}
    // 	log.warning('No shit to drop! Shouldn\'t reach here!');
    // 	return false;
    // }
    /**
     * Suicide once you get old and make sure you don't drop and waste any resources
     */
    deathActions(manager) {
        manager.debug('deathActions');
        const nearbyManagers = _.filter(
            this.managers,
            (manager) =>
                manager.pos.inRangeTo(this.commandCenter.pos, 3) &&
                (manager.ticksUntilSpawned || 0) <= 10,
        );
        if (nearbyManagers.length > 1) {
            // > 1 including self
            if (manager.store.getUsedCapacity() > 0) {
                this.unloadCarry(manager);
            } else {
                const nearbySpawn = _.first(
                    manager.pos.findInRange(manager.room.spawns, 1),
                );
                if (nearbySpawn) {
                    nearbySpawn.recycleCreep(manager.creep);
                } else {
                    manager.suicide();
                }
            }
            return true;
        }
        return false;
    }
    // private preventTerminalFlooding(manager: Zerg): boolean {
    // 	// Prevent terminal flooding
    // 	if (this.room && this.room.terminal && this.room.storage && _.sum(this.room.terminal.store)
    // 		> this.room.terminal.store.getCapacity() * CommandCenterOverlord.MAX_TERMINAL_FILLED_PERCENTAGE) {
    // 		let max = 0;
    // 		let resType: ResourceConstant = RESOURCE_ENERGY;
    // 		for (const res in this.room.terminal.store) {
    // 			const amount = this.room.terminal.store[<ResourceConstant>res];
    // 			if (amount && amount > max && res !== RESOURCE_ENERGY) {
    // 				max = amount;
    // 				resType = <ResourceConstant>res;
    // 			}
    // 		}
    //
    // 		manager.task = Tasks.transferAll(this.room.storage).fork(Tasks.withdraw(this.room.terminal, resType));
    // 		return true;
    // 	}
    // 	return false;
    // }
    handleManager(manager) {
        // Handle switching to next manager
        if (manager.ticksToLive < 150) {
            if (this.deathActions(manager)) return;
        }
        // if (this.preventTerminalFlooding(manager)) return;
        // Emergency dumping actions for critically clogged terminals and storages
        // if (this.emergencyDumpingActions(manager)) return;
        // Pick up any dropped resources on ground
        if (this.pickupActions(manager)) return;
        // // Move minerals from storage to terminal if needed
        // if (hasMinerals(this.commandCenter.storage.store)) {
        // 	if (this.moveMineralsToTerminal(manager)) return;
        // }
        // Fill up storage before you destroy terminal if rebuilding room
        if (this.colony.state.isRebuilding) {
            if (this.moveEnergyFromRebuildingTerminal(manager)) return;
        }
        // Moving energy to terminal gets priority above withdraw/supply if evacuating room
        if (this.colony.state.isEvacuating) {
            if (this.balanceStorageAndTerminal(manager)) return;
        }
        // Fulfill withdraw requests normal priority and above
        if (
            this.commandCenter.transportRequests.needsWithdrawing(
                Priority.Normal,
            )
        ) {
            if (this.withdrawActions(manager)) return;
        }
        // Fulfill supply requests normal priority and above
        if (
            this.commandCenter.transportRequests.needsSupplying(Priority.Normal)
        ) {
            if (this.supplyActions(manager)) return;
        }
        // Move resources between storage and terminal at this point if room isn't being evacuated
        if (!this.colony.state.isEvacuating) {
            if (this.balanceStorageAndTerminal(manager)) return;
        }
        // Fulfill remaining low-priority withdraw requests
        if (this.commandCenter.transportRequests.needsWithdrawing()) {
            if (this.withdrawActions(manager)) return;
        }
        // Fulfill remaining low-priority supply requests
        if (this.commandCenter.transportRequests.needsSupplying()) {
            if (this.supplyActions(manager)) return;
        }
    }
    /**
     * Handle idle actions if the manager has nothing to do
     */
    idleActions(manager) {
        manager.debug('idleActions');
        if (
            this.mode == 'bunker' &&
            this.managerRepairTarget &&
            manager.getActiveBodyparts(WORK) > 0
        ) {
            // Repair ramparts when idle
            if (manager.carry.energy > 0) {
                manager.repair(this.managerRepairTarget);
            } else {
                const storage = this.commandCenter.storage;
                const terminal = this.commandCenter.terminal;
                const energyTarget =
                    storage.store[RESOURCE_ENERGY] > 0 ? storage : terminal;
                if (energyTarget) {
                    manager.withdraw(energyTarget);
                }
            }
        }
        if (!manager.pos.isEqualTo(this.commandCenter.idlePos)) {
            manager.goTo(this.commandCenter.idlePos);
        }
    }
    run() {
        for (const manager of this.managers) {
            // Get a task if needed
            if (manager.isIdle) {
                this.handleManager(manager);
            }
            // manager.debug(print(manager.task))
            // If you have a valid task, run it; else go to idle pos
            if (manager.hasValidTask) {
                manager.run();
            } else {
                // this.idleActions(manager); // zgeneral 9/2023 do nothing
            }
        }
    }
};
CommandCenterOverlord.MAX_TERMINAL_FILLED_PERCENTAGE = 0.98;
CommandCenterOverlord = __decorate([profile], CommandCenterOverlord);

/**
 * Abstract class for a hive cluster. Hive clusters group structures with related functionalities together in a
 * single cohesive object
 */
let HiveCluster = class HiveCluster {
    constructor(colony, instantiationObject, name) {
        this.colony = colony;
        this.room = instantiationObject.room;
        this.pos = instantiationObject.pos;
        this.ref = name + '@' + this.colony.name;
        this.colony.hiveClusters.push(this);
    }
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.pos.roomName +
            '">[' +
            this.ref +
            ']</a>'
        );
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
};
HiveCluster = __decorate([profile], HiveCluster);

var CommandCenter_1;
const MAX_OBSERVE_DISTANCE = 4;
const OBSERVATIONS_PER_TICK = 7;
/**
 * The command center groups the high-level structures at the core of the bunker together, including storage, terminal,
 * link, power spawn, observer, and nuker.
 */
let CommandCenter = (CommandCenter_1 = class CommandCenter extends HiveCluster {
    constructor(colony, storage) {
        super(colony, storage, 'commandCenter');
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        // Register physical components
        this.storage = storage;
        this.terminal = colony.terminal;
        this.factory = colony.factory;
        this.powerSpawn = colony.powerSpawn;
        this.nuker = colony.nuker;
        this.observer = colony.observer;
        if (this.colony.bunker) {
            this.link = this.colony.bunker.anchor.findClosestByLimitedRange(
                colony.availableLinks,
                1,
            );
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.colony.bunker.anchor.findInRange(
                colony.towers,
                1,
            );
        } else {
            this.link = this.pos.findClosestByLimitedRange(
                colony.availableLinks,
                2,
            );
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.pos.findInRange(colony.towers, 3);
        }
        this.transportRequests = new TransportRequestGroup(); // commandCenter always gets its own request group
        this.observeRoom = undefined;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        $.refreshRoom(this);
        $.refresh(
            this,
            'storage',
            'terminal',
            'powerSpawn',
            'nuker',
            'observer',
            'link',
            'towers',
            'factory',
        );
        this.transportRequests.refresh();
        this.observeRoom = undefined;
    }
    spawnMoarOverlords() {
        if (this.link || this.terminal) {
            this.overlord = new CommandCenterOverlord(this);
        }
    }
    // Idle position
    get idlePos() {
        if (this.colony.bunker) {
            return this.colony.bunker.anchor;
        }
        if (!this.memory.idlePos || Game.time % 25 == 0) {
            this.memory.idlePos = this.findIdlePos();
        }
        return derefRoomPosition(this.memory.idlePos);
    }
    /* Find the best idle position */
    findIdlePos() {
        // Try to match as many other structures as possible
        const proximateStructures = _.compact([
            this.link,
            this.terminal,
            this.powerSpawn,
            this.nuker,
            ...this.towers,
        ]);
        const numNearbyStructures = (pos) =>
            _.filter(
                proximateStructures,
                (s) => s.pos.isNearTo(pos) && !s.pos.isEqualTo(pos),
            ).length;
        return _.last(
            _.sortBy(this.storage.pos.neighbors, (pos) =>
                numNearbyStructures(pos),
            ),
        );
    }
    /* Register a link transfer store if the link is sufficiently full */
    registerLinkTransferRequests() {
        if (this.link) {
            if (this.link.energy > CommandCenter_1.settings.linksTransmitAt) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    registerRequests() {
        // TODO: relocate factory requests properly from manager to here
        // Refill core spawn (only applicable to bunker layouts)
        if (this.colony.bunker && this.colony.bunker.coreSpawn) {
            if (
                this.colony.bunker.coreSpawn.energy <
                this.colony.bunker.coreSpawn.energyCapacity
            ) {
                this.transportRequests.requestInput(
                    this.colony.bunker.coreSpawn,
                    Priority.Normal,
                );
            }
        }
        // If the link has energy and nothing needs it, empty it
        if (this.link && this.link.energy > 0) {
            if (
                this.colony.linkNetwork.receive.length == 0 ||
                this.link.cooldown > 3
            ) {
                this.transportRequests.requestOutput(this.link, Priority.High);
            }
        }
        // Nothing else should request if you're trying to start a room back up again
        if (this.colony.state.bootstrapping) {
            return;
        }
        // Supply requests:
        // If the link is empty and can send energy and something needs energy, fill it up
        if (
            this.link &&
            this.link.energy < 0.9 * this.link.energyCapacity &&
            this.link.cooldown <= 1
        ) {
            if (this.colony.linkNetwork.receive.length > 0) {
                // If something wants energy
                this.transportRequests.requestInput(
                    this.link,
                    Priority.Critical,
                );
            }
        }
        // Refill towers as needed with variable priority
        const refillTowers = _.filter(
            this.towers,
            (tower) =>
                tower.energy < CommandCenter_1.settings.refillTowersBelow,
        );
        _.forEach(refillTowers, (tower) =>
            this.transportRequests.requestInput(tower, Priority.High),
        );
        // Refill power spawn
        if (this.powerSpawn) {
            if (this.powerSpawn.energy < this.powerSpawn.energyCapacity * 0.5) {
                this.transportRequests.requestInput(
                    this.powerSpawn,
                    Priority.High,
                );
            } else if (
                this.powerSpawn.power < this.powerSpawn.powerCapacity * 0.5 &&
                this.terminal &&
                this.terminal.store.power &&
                this.terminal.store.power >= 100
            ) {
                this.transportRequests.requestInput(
                    this.powerSpawn,
                    Priority.High,
                    {
                        resourceType: RESOURCE_POWER,
                    },
                );
            }
            // TODO: this is a personal preferance: 10K
            // TODO: const {target, surplus, tolerance} =
            //  could use Overmind.terminalnetwork.thresholds(this.colont,RESOURCE_POWER) ...
            /*
            const powerThreshold = 8000;
            if (this.colony.terminal.cooldown == 0 &&
                this.colony.assets[RESOURCE_POWER] < powerThreshold && // 14/04/2023 11/06/2021 zGeneral trying to reduce excessive requests // zgeneral - stop buying power 1/11/2021
                Game.market.credits >
                    TraderJoe.settings.market.credits.canBuyPowerAbove) {
                
                let orderSize = powerThreshold - this.colony.assets[RESOURCE_POWER]
                let m = Game.market.getAllOrders({resourceType: RESOURCE_POWER, type: ORDER_SELL,});

                let filteredOrders = _.filter(m, o => o.roomName != 'E2S25' && o.price < 600);
                let bestOrder = minBy(filteredOrders, o => o.price);
                    
                
                if (!!bestOrder) {
                    let ret = Game.market.deal(bestOrder.id, bestOrder.amount, this.colony.room.name);
                }

                log.info(`${this.colony.print} is requesting power`);
            }
            */
        }
        // Refill nuker with low priority
        if (this.nuker) {
            if (
                this.nuker.energy < this.nuker.energyCapacity &&
                ((this.storage.energy > 200000 &&
                    this.nuker.cooldown <= 1000) ||
                    this.storage.energy > 800000)
            ) {
                this.transportRequests.requestInput(this.nuker, Priority.Low);
            }
            if (
                this.nuker.ghodium < this.nuker.ghodiumCapacity &&
                this.colony.assets[RESOURCE_GHODIUM] >= LAB_MINERAL_CAPACITY
            ) {
                this.transportRequests.requestInput(this.nuker, Priority.Low, {
                    resourceType: RESOURCE_GHODIUM,
                });
            }
        }
    }
    requestRoomObservation(roomName) {
        this.observeRoom = roomName;
    }
    runObserver() {
        if (this.observer) {
            if (this.observeRoom) {
                this.observer.observeRoom(this.observeRoom);
            } else if (CommandCenter_1.settings.enableIdleObservation) {
                const axisLength = MAX_OBSERVE_DISTANCE * 2 + 1;
                const observationArea = axisLength ** 2; // number of rooms under observation per colony
                // time required to cover observation area for all colonies divided by observations per tick
                const observationTimeWindow =
                    (getAllColonies().length * observationArea) /
                    OBSERVATIONS_PER_TICK;
                if (
                    (Game.time + observationArea * this.colony.id) %
                        observationTimeWindow <
                    observationArea
                ) {
                    const dx = (Game.time % axisLength) - MAX_OBSERVE_DISTANCE;
                    const dy =
                        Math.floor((Game.time % observationArea) / axisLength) -
                        MAX_OBSERVE_DISTANCE;
                    const roomToObserve = Cartographer.findRelativeRoomName(
                        this.pos.roomName,
                        dx,
                        dy,
                    );
                    if (
                        !Game.rooms[roomToObserve] &&
                        Game.time - RoomIntel.lastVisible(roomToObserve) > 50
                        /*&& Cartographer.roomType(roomToObserve) == ROOMTYPE_ALLEY*/
                    ) {
                        // zGeneral 20/12/2020
                        this.observer.observeRoom(roomToObserve);
                        Game.map.visual.circle(
                            new RoomPosition(25, 25, roomToObserve),
                            {
                                fill: '#ff0000',
                                radius: 25,
                                stroke: '#ff0000',
                            },
                        );
                    }
                    // debug
                    // const progress = ((Game.time + observationArea * this.colony.id) %
                    // 						observationTimeWindow)*100/observationArea;
                    // console.log(`id: ${this.colony.id} colony: ${this.colony.name
                    //     } observing: ${roomToObserve} progress: ${Math.round(progress)}%`);
                }
            }
        }
        // if (this.observer) {
        // 	if (this.observeRoom) {
        // 		this.observer.observeRoom(this.observeRoom);
        // 	} else if (CommandCenter.settings.enableIdleObservation && Game.time % 1000 < 100) {
        // 		const axisLength = MAX_OBSERVE_DISTANCE * 2 + 1;
        // 		const dx = Game.time % axisLength - MAX_OBSERVE_DISTANCE;
        // 		const dy = Math.floor((Game.time % axisLength ** 2) / axisLength) - MAX_OBSERVE_DISTANCE;
        // 		if (dx == 0 && dy == 0) {
        // 			return;
        // 		}
        // 		const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
        // 		this.observer.observeRoom(roomToObserve);
        // 		// // TODO OBSERVER FIX ONLY LOOK AT southwest corner
        // 		// const dx = Game.time % MAX_OBSERVE_DISTANCE;
        // 		// const dy = Game.time % (MAX_OBSERVE_DISTANCE ** 2);
        // 		// const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
        // 		this.observer.observeRoom(roomToObserve);
        // 	}
        // }
    }
    
    
    // runPowerSpawn() {
    //     if (
    //         this.powerSpawn &&
    //         this.storage &&
    //         this.powerSpawn.store.energy > 50 &&
    //         this.powerSpawn.store.power > 0 &&
    //         this.colony.assets.energy > 100000
    //     ) {
    //         // don't process under 100k and process scaling up to 500k

    //         /*
    //         if ( this.colony.assets.energy > 100000 // zgeneral 28/07/2022
    //             && (this.storage.energy -
    //             Memory.settings.powerProcessing.minEnergy) > 
    //             Math.random() * Memory.settings.powerProcessing.fullThrottle
    //             && (this.colony.assets.battery > 90000 || this.colony.assets.power > 100000)) { // zgeneral 20/may/2022
    //                 this.powerSpawn.processPower(); // zgeneral 26/april/2022
    //         }
    //         */

    //         if (
    //             (this.colony.assets.energy > 100000 /*&& // zgeneral 28/07/2022
    //                 this.storage.energy -
    //                     Memory.settings.powerProcessing.minEnergy >
    //                     Math.random() *
    //                         Memory.settings.powerProcessing.fullThrottle)*/ ||
    //             (this.colony.storage.store.getFreeCapacity() < 100000 &&
    //                 this.colony.assets.energy > 100000)
    //         ) {
    //             // zgeneral 20/may/2022
    //             /*
    //             let price = Overmind.tradeNetwork.priceOf(RESOURCE_BATTERY);
    //             let newPrice = Overmind.tradeNetwork.priceOf(RESOURCE_ENERGY)*5*0.8;
    //             if(price < newPrice) {
    //                 price = newPrice;
    //             }
    //             newPrice = Overmind.tradeNetwork.computeCompetitivePrice(ORDER_SELL, RESOURCE_BATTERY, 'W44N37').toFixed(3);
    //             if(price < newPrice) {
    //                 price = newPrice;
    //             }*/
                
    //             if (Overmind.tradeNetwork.computeCompetitivePrice(ORDER_SELL, RESOURCE_BATTERY, this.colony.room.name)*3 < Overmind.tradeNetwork.computeCompetitivePrice(ORDER_BUY, RESOURCE_POWER, this.colony.room.name) || this.colony.assets[RESOURCE_BATTERY] > 60000 || this.colony.storage.store.getFreeCapacity() < 100000 )
    //             if(Game.cpu.getUsed() >= 280 || Game.cpu.bucket < 9000) {
    //                 // console.log('skip processPower, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.colony.room.name); // zGeneral 3/2024
    //             } else {
    //                 this.powerSpawn.processPower(); // zgeneral 26/april/2022
    //             }
    //         }
    //     }
    // }
    runPowerSpawn() {
        const debugRoomName = 'W52N48'; // Replace with the desired room name for debugging
        const debug = this.colony.room.name === debugRoomName;
        if (
            !this.powerSpawn ||
            !this.storage ||
            this.powerSpawn.store.energy <= 50 ||
            this.powerSpawn.store.power <= 0 ||
            this.colony.assets.energy <= 100000
        ) {
            if (debug) {
                if (!this.powerSpawn) console.log(`[${this.colony.room.name}] Debug: Power spawn not found`);
                if (!this.storage) console.log(`[${this.colony.room.name}] Debug: Storage not found`);
                if (this.powerSpawn && this.powerSpawn.store.energy <= 50) console.log(`[${this.colony.room.name}] Debug: Power spawn energy too low`);
                if (this.powerSpawn && this.powerSpawn.store.power <= 0) console.log(`[${this.colony.room.name}] Debug: Power spawn power too low`);
                if (this.colony.assets.energy <= 100000) console.log(`[${this.colony.room.name}] Debug: Colony energy assets too low`);
            }
            return;
        }
        
        const shouldProcess = (
            this.colony.assets.energy > 100000 ||
            (this.colony.storage.store.getFreeCapacity() < 100000 && this.colony.assets.energy > 100000)
        );
        
        //const competitiveSellPrice = Overmind.tradeNetwork.computeCompetitivePrice(ORDER_SELL, RESOURCE_BATTERY, this.colony.room.name) * 3;
        //const competitiveBuyPrice = Overmind.tradeNetwork.computeCompetitivePrice(ORDER_BUY, RESOURCE_POWER, this.colony.room.name);
        
        const shouldProcessBasedOnPrice = /*competitiveSellPrice < competitiveBuyPrice ||*/ this.colony.assets[RESOURCE_BATTERY] > 10000 || this.colony.storage.store.getFreeCapacity() < 100000;
        
        if (shouldProcess && shouldProcessBasedOnPrice && (Game.cpu.getUsed() < 280 && Game.cpu.bucket >= 9000 || Game.cpu.bucket >= 9600)) {
            this.powerSpawn.processPower();
        } else {
            if (debug) {
                if (!shouldProcess) console.log(`[${this.colony.room.name}] Debug: Processing conditions not met`);
                if (!shouldProcessBasedOnPrice) console.log(`[${this.colony.room.name}] Debug: Price conditions not met`);
                if (Game.cpu.getUsed() >= 280) console.log(`[${this.colony.room.name}] Debug: CPU usage too high`);
                if (Game.cpu.bucket < 9000) console.log(`[${this.colony.room.name}] Debug: CPU bucket too low`);
            }
        }
    }

    runFactory() {
        const BASE_RESOURCES = [
            RESOURCE_ENERGY,
            RESOURCE_HYDROGEN,
            RESOURCE_OXYGEN,
            RESOURCE_UTRIUM,
            RESOURCE_KEANIUM,
            RESOURCE_LEMERGIUM,
            RESOURCE_ZYNTHIUM,
            RESOURCE_CATALYST,
            RESOURCE_GHODIUM,
            RESOURCE_SILICON,
            RESOURCE_METAL,
            RESOURCE_BIOMASS,
            RESOURCE_MIST,
        ];
        let factoryResources = [
            {
                // in only
                [RESOURCE_HYDROGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_OXYGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_UTRIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_KEANIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_LEMERGIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_ZYNTHIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_CATALYST]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_GHODIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_SILICON]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_METAL]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_BIOMASS]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_MIST]: { min: 200, max: 400, prod: 0 },

                // shared in/out:
                [RESOURCE_UTRIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_LEMERGIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_ZYNTHIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_KEANIUM_BAR]: { min: 120, max: 500, prod: 1000 },

                // out only
                [RESOURCE_GHODIUM_MELT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_OXIDANT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_REDUCTANT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_PURIFIER]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_WIRE]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_CELL]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_ALLOY]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_CONDENSATE]: { min: 0, max: 0, prod: 40 },
            },
            {
                // in only
                [RESOURCE_HYDROGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_OXYGEN]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_UTRIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_KEANIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_LEMERGIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_ZYNTHIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_CATALYST]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_GHODIUM]: { min: 500, max: 1000, prod: 0 },
                [RESOURCE_SILICON]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_METAL]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_BIOMASS]: { min: 200, max: 400, prod: 0 },
                [RESOURCE_MIST]: { min: 200, max: 400, prod: 0 },

                // shared in/out:
                [RESOURCE_UTRIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_LEMERGIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_ZYNTHIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_KEANIUM_BAR]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_OXIDANT]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_PURIFIER]: { min: 120, max: 500, prod: 1000 },
                [RESOURCE_WIRE]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_CELL]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_ALLOY]: { min: 40, max: 60, prod: 80 },
                [RESOURCE_CONDENSATE]: { min: 40, max: 60, prod: 80 },

                // out only
                [RESOURCE_GHODIUM_MELT]: { min: 0, max: 0, prod: 1000 },
                [RESOURCE_REDUCTANT]: { min: 0, max: 0, prod: 1000 },

                //level 1 output
                [RESOURCE_COMPOSITE]: { min: 0, max: 0, prod: 40 },
                [RESOURCE_SWITCH]: { min: 0, max: 0, prod: 10 },
                [RESOURCE_PHLEGM]: { min: 0, max: 0, prod: 4 },
                [RESOURCE_TUBE]: { min: 0, max: 0, prod: 4 },
                [RESOURCE_CONCENTRATE]: { min: 0, max: 0, prod: 6 },
            },
        ];
        function canProduceCommodity(commodity, room) {
            if (BASE_RESOURCES.includes(commodity)) return false;
            const requiredResources = COMMODITIES[commodity].components;
            return _.every(
                requiredResources,
                (amount, resourceName) =>
                    room.factory.store[resourceName] >= amount,
            );
        }
        if (!this.factory || this.factory.cooldown > 0) {
            return;
        }

        let factoryResourcesByLevel = factoryResources[this.factory.level || 0];
        // Create an array of resource keys and shuffle them using lodash
        const shuffledResources = _.shuffle(
            _.keys(factoryResourcesByLevel),
        ).reduce((acc, key) => {
            acc[key] = factoryResourcesByLevel[key];
            return acc;
        }, {});

        for (const resource in shuffledResources) {
            const config = factoryResourcesByLevel[resource];
            const factoryResourceAmount =
                this.factory.store.getUsedCapacity(resource) || 0;
            const terminalResourceAmount =
                this.terminal.store.getUsedCapacity(resource) || 0;
            const factoryFreeSpace = this.factory.store.getFreeCapacity();
            const terminalFreeSpace = this.terminal.store.getFreeCapacity();

            // to produce > 0, needed in terminal,
            // this.room.name == 'W32N47' && console.log(resource)
            //this.room.name == 'W36N47' && console.log(resource,config.prod > 0, factoryResourceAmount <= config.min , terminalResourceAmount < config.prod , canProduceCommodity(resource,this.room))
            if (
                config.prod > 0 &&
                terminalResourceAmount + factoryResourceAmount / 2 <
                    config.prod &&
                canProduceCommodity(resource, this.room)
            ) {
                if(Game.cpu.getUsed() >= 280 || Game.cpu.bucket < 9000) {
                    // console.log('skip factory.produce, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.room.name); // zGeneral 3/2024
                    return;
                } else {
                    this.factory.produce(resource);
                    return;
                }
            }
        }
        if (
            this.colony.storage.store.getFreeCapacity() < 50000 &&
            (this.factory.store[RESOURCE_ENERGY] | 0) > 35000 &&
            this.factory.store.getFreeCapacity() >= 100
        ) {
            if(Game.cpu.getUsed() >= 300) {
                // console.log('skip factory.produce, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.room.name); // zGeneral 3/2024
                return;
            } else {
                this.factory.produce(RESOURCE_BATTERY);
                return;
            }
        } else if (
            this.colony.assets.energy < 400000 &&
            this.factory.store.getUsedCapacity(RESOURCE_BATTERY) >= 50
        ) {
            if(Game.cpu.getUsed() >= 300) {
                // console.log('skip factory.produce, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.room.name); // zGeneral 3/2024
                return;
            } else {
                this.factory.produce(RESOURCE_ENERGY);
                return;
            }
        } else if (
            (this.colony.assets.energy > 450000 ||
                (this.factory.store[RESOURCE_ENERGY] | 0) > 35000) &&
            this.factory.store.getFreeCapacity() >= 100
        ) {
            if(Game.cpu.getUsed() >= 300) {
                // console.log('skip factory.produce, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.room.name); // zGeneral 3/2024
                return;
            } else {
                this.factory.produce(RESOURCE_BATTERY);
                return;
            }
        }
    }
    // Initialization and operation ====================================================================================
    init() {
        this.registerLinkTransferRequests();
        this.registerRequests();
    }
    run() {
        if(Game.cpu.getUsed() >= 290 || Game.cpu.bucket < 9000) {
            // console.log('skip Observe,PowerSpawn, Factory, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.room.name); // zGeneral 3/2024
            
        } else {
            this.runObserver();
            this.runPowerSpawn();
            this.runFactory();
        }
    }
    visuals(coord) {
        let { x, y } = coord;
        const height = this.storage && this.terminal ? 2 : 1;
        const titleCoords = Visualizer.section(
            `${this.colony.name} Command Center`,
            { x, y, roomName: this.room.name },
            9.5,
            height + 0.1,
        );
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        if (this.storage) {
            Visualizer.text('Storage', {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(
                this.colony.storageAmount / this.storage.storeCapacity,
                { x: boxX + 4, y: y, roomName: this.room.name },
                5,
            );
            y += 1;
        }
        if (this.terminal) {
            Visualizer.text('Terminal', {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(
                this.colony.terminalAmount / this.terminal.storeCapacity,
                { x: boxX + 4, y: y, roomName: this.room.name },
                5,
            );
            y += 1;
        }
        return { x: x, y: y + 0.25 };
    }
});
CommandCenter.settings = {
    enableIdleObservation: true,
    linksTransmitAt: LINK_CAPACITY - 100,
    refillTowersBelow: 750,
};
CommandCenter = CommandCenter_1 = __decorate([profile], CommandCenter);

var EvolutionChamber_1;
const LabStatus = {
    Idle: 0,
    AcquiringMinerals: 1,
    LoadingLabs: 2,
    Synthesizing: 3,
    UnloadingLabs: 4,
};
const LabStageTimeouts = {
    Idle: Infinity,
    AcquiringMinerals: 50,
    LoadingLabs: 50,
    Synthesizing: 10000,
    UnloadingLabs: 50,
};
const LAB_USAGE_WINDOW = 100;
const getDefaultEvolutionChamberMemory = () => ({
    status: LabStatus.Idle,
    statusTick: 0,
    activeReaction: undefined,
    stats: {
        totalProduction: {},
        avgUsage: 1,
    },
});
function neighboringLabs(pos) {
    return _.compact(
        _.map(pos.neighbors, (neighbor) =>
            neighbor.lookForStructure(STRUCTURE_LAB),
        ),
    );
}
/**
 * The evolution chamber handles mineral production and boosting logic, handling resource supply for labs
 */
let EvolutionChamber = (EvolutionChamber_1 = class EvolutionChamber extends (
    HiveCluster
) {
    constructor(colony, terminal) {
        super(colony, terminal, 'evolutionChamber');
        this.memory = Mem.wrap(
            this.colony.memory,
            'evolutionChamber',
            getDefaultEvolutionChamberMemory,
        );
        // Register physical components
        this.terminal = terminal;
        this.terminalNetwork = Overmind.terminalNetwork;
        this.labs = colony.labs;
        // Reserve some easily-accessible labs which are restricted not to be reagent labs
        const restrictedLabs = this.colony.bunker
            ? _.filter(
                  this.labs,
                  (lab) =>
                      lab.pos.findInRange(this.colony.spawns, 1).length > 0,
              )
            : _.take(
                  _.sortBy(this.labs, (lab) =>
                      Pathing.distance(this.terminal.pos, lab.pos),
                  ),
                  1,
              );
        const getReagentLabs = () => {
            if (this.colony.bunker) {
                const reagentLabPositions = _.map(reagentLabSpots, (coord) =>
                    getPosFromBunkerCoord(coord, this.colony),
                );
                const preferredReagentLabs = _.compact(
                    _.map(reagentLabPositions, (pos) =>
                        pos.lookForStructure(STRUCTURE_LAB),
                    ),
                );
                if (preferredReagentLabs.length == 2) {
                    return preferredReagentLabs;
                }
            }
            // Reagent labs are range=2 from all other labs and are not a boosting lab
            const range2Labs = _.filter(this.labs, (lab) =>
                _.all(this.labs, (otherLab) => lab.pos.inRangeTo(otherLab, 2)),
            );
            const reagentLabCandidates = _.filter(
                range2Labs,
                (lab) => !_.any(restrictedLabs, (l) => l.id == lab.id),
            );
            return _.take(
                _.sortBy(
                    reagentLabCandidates,
                    (lab) => -1 * neighboringLabs(lab.pos).length,
                ),
                2,
            );
        };
        this.reagentLabs = getReagentLabs();
        // Product labs are everything that isn't a reagent lab. (boostingLab can also be a productLab)
        this.productLabs = _.difference(this.labs, this.reagentLabs);
        // Boosting labs are product labs sorted by distance to terminal
        const unrestrictedBoostingLabs = _.sortBy(
            _.difference(this.productLabs, restrictedLabs),
            (lab) => Pathing.distance(this.terminal.pos, lab.pos),
        );
        this.boostingLabs = [...restrictedLabs, ...unrestrictedBoostingLabs];
        // This keeps track of reservations for boosting
        this.labReservations = {};
        // this.boostQueue = {};
        this.neededBoosts = {};
        if (this.colony.commandCenter && this.colony.layout == 'twoPart') {
            // TODO: deprecate soon
            // in two-part layout, evolution chamber shares a common request group with command center
            this.transportRequests = this.colony.commandCenter.transportRequests;
        } else {
            // otherwise (in bunker layout), it uses colony/hatchery transport requests
            this.transportRequests = this.colony.transportRequests;
        }
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'evolutionChamber',
            getDefaultEvolutionChamberMemory,
        );
        $.refreshRoom(this);
        $.refresh(
            this,
            'terminal',
            'labs',
            'boostingLabs',
            'reagentLabs',
            'productLabs',
        );
        this.labReservations = {};
        this.neededBoosts = {};
    }
    spawnMoarOverlords() {
        // Evolution chamber is attended to by queens; overlord spawned at Hatchery
    }
    initLabStatus() {
        if (
            !this.memory.activeReaction &&
            this.memory.status != LabStatus.Idle
        ) {
            log.warning(
                `Unexpected lack of active reaction at ${this.print}! Reverting to idle state.`,
            );
            this.memory.status = LabStatus.Idle;
        }
        const reagents = this.memory.activeReaction
            ? REAGENTS[this.memory.activeReaction.mineralType]
            : [];
        const amount = this.memory.activeReaction
            ? this.memory.activeReaction.amount
            : Infinity;
        switch (this.memory.status) {
            case LabStatus.Idle:
                if (this.memory.activeReaction) {
                    log.info(
                        `${this.colony.print}: starting synthesis of ${reagents[0]} + ${reagents[1]} ` +
                            `${rightArrow} ${this.memory.activeReaction.mineralType}`,
                    );
                    this.memory.status = LabStatus.AcquiringMinerals;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.AcquiringMinerals: // "We acquire more mineralzzz"
                if (
                    _.all(
                        reagents,
                        (reagent) => this.colony.assets[reagent] >= amount,
                    )
                ) {
                    this.memory.status = LabStatus.LoadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.LoadingLabs:
                if (
                    _.all(
                        this.reagentLabs,
                        (lab) =>
                            lab.mineralAmount >= amount &&
                            _.includes(reagents, lab.mineralType),
                    )
                ) {
                    this.memory.status = LabStatus.Synthesizing;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.Synthesizing:
                if (
                    _.any(
                        this.reagentLabs,
                        (lab) => lab.mineralAmount < LAB_REACTION_AMOUNT,
                    )
                ) {
                    this.memory.status = LabStatus.UnloadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.UnloadingLabs:
                const unloadLabs = _.filter(
                    this.labs,
                    (lab) => !this.labReservations[lab.id],
                );
                if (_.all(unloadLabs, (lab) => lab.mineralAmount == 0)) {
                    this.memory.status = LabStatus.Idle;
                    this.memory.statusTick = Game.time;
                }
                break;
            default:
                log.error(
                    `Bad lab state at ${this.print}! State: ${this.memory.status}`,
                );
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        this.statusTimeoutCheck();
    }
    statusTimeoutCheck() {
        const ticksInStatus = Game.time - this.memory.statusTick;
        let timeout = false;
        switch (this.memory.status) {
            case LabStatus.Idle:
                timeout = ticksInStatus > LabStageTimeouts.Idle;
                break;
            case LabStatus.AcquiringMinerals:
                timeout = ticksInStatus > LabStageTimeouts.AcquiringMinerals;
                break;
            case LabStatus.LoadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.LoadingLabs;
                break;
            case LabStatus.Synthesizing:
                timeout = ticksInStatus > LabStageTimeouts.Synthesizing;
                break;
            case LabStatus.UnloadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.UnloadingLabs;
                break;
            default:
                log.error(`Bad lab state at ${this.print}!`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        if (timeout) {
            //log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, ` +
            //    `rebuilding reaction queue and reverting to idle state!`);
            this.memory.status = LabStatus.Idle;
            this.memory.statusTick = Game.time;
            this.memory.activeReaction = undefined;
            // this.memory.reactionQueue = [];
        }
    }
    registerReagentLabRequests(reagentLabs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            const [ing1, ing2] = REAGENTS[mineralType];
            const [lab1, lab2] = reagentLabs;
            if (!lab1 || !lab2) return;
            // Empty out any incorrect minerals and request the correct reagents
            if (
                this.memory.status == LabStatus.UnloadingLabs ||
                (lab1.mineralType != ing1 && lab1.mineralAmount > 0)
            ) {
                this.transportRequests.requestOutput(lab1, Priority.Normal, {
                    resourceType: lab1.mineralType,
                });
            } else if (
                this.memory.status == LabStatus.LoadingLabs &&
                lab1.mineralAmount < amount
            ) {
                this.transportRequests.requestInput(lab1, Priority.Normal, {
                    resourceType: ing1,
                    amount: amount - lab1.mineralAmount,
                });
            }
            if (
                this.memory.status == LabStatus.UnloadingLabs ||
                (lab2.mineralType != ing2 && lab2.mineralAmount > 0)
            ) {
                this.transportRequests.requestOutput(lab2, Priority.Normal, {
                    resourceType: lab2.mineralType,
                });
            } else if (
                this.memory.status == LabStatus.LoadingLabs &&
                lab2.mineralAmount < amount
            ) {
                this.transportRequests.requestInput(lab2, Priority.Normal, {
                    resourceType: ing2,
                    amount: amount - lab2.mineralAmount,
                });
            }
        } else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of reagentLabs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.Normal, {
                        resourceType: lab.mineralType,
                    });
                }
            }
        }
    }
    registerProductLabRequests(labs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            for (const lab of labs) {
                const labHasWrongMineral =
                    lab.mineralType != mineralType && lab.mineralAmount > 0;
                const labIsFull = lab.mineralAmount == lab.mineralCapacity;
                // Empty out incorrect minerals or if it's time to unload or if lab is full
                if (
                    (this.memory.status == LabStatus.UnloadingLabs &&
                        lab.mineralAmount > 0) ||
                    labHasWrongMineral ||
                    labIsFull
                ) {
                    this.transportRequests.requestOutput(
                        lab,
                        Priority.NormalLow,
                        {
                            resourceType: lab.mineralType,
                        },
                    );
                }
            }
        } else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of labs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(
                        lab,
                        Priority.NormalLow,
                        {
                            resourceType: lab.mineralType,
                        },
                    );
                }
            }
        }
    }
    registerBoosterLabRequests(labs) {
        for (const lab of labs) {
            const { mineralType, amount } = this.labReservations[lab.id];
            // Empty out incorrect minerals
            if (lab.mineralType != mineralType && lab.mineralAmount > 0) {
                this.transportRequests.requestOutput(lab, Priority.High, {
                    resourceType: lab.mineralType,
                });
            } else {
                this.transportRequests.requestInput(lab, Priority.High, {
                    resourceType: mineralType,
                    amount: amount - lab.mineralAmount,
                });
            }
        }
    }
    registerRequests() {
        // Don't care about labs if you can't spawn any creeps!
        if (this.colony.state.bootstrapping) {
            return;
        }
        // Separate product labs into actively boosting or ready for reaction
        const [boostingProductLabs, reactionProductLabs] = _.partition(
            this.productLabs,
            (lab) => this.labReservations[lab.id],
        );
        // Handle energy requests for labs with different priorities
        const boostingRefillLabs = _.filter(
            boostingProductLabs,
            (lab) => lab.energy < lab.energyCapacity,
        );
        _.forEach(boostingRefillLabs, (lab) =>
            this.transportRequests.requestInput(lab, Priority.High),
        );
        const reactionRefillLabs = _.filter(
            reactionProductLabs,
            (lab) => lab.energy < lab.energyCapacity,
        );
        _.forEach(reactionRefillLabs, (lab) =>
            this.transportRequests.requestInput(lab, Priority.NormalLow),
        );
        const reagentRefillLabs = _.filter(
            this.reagentLabs,
            (lab) => lab.energy < lab.energyCapacity,
        );
        _.forEach(reagentRefillLabs, (lab) =>
            this.transportRequests.requestInput(lab, Priority.NormalLow),
        );
        // Request resources delivered to / withdrawn from each type of lab
        this.registerReagentLabRequests(this.reagentLabs);
        this.registerProductLabRequests(reactionProductLabs);
        this.registerBoosterLabRequests(boostingProductLabs);
    }
    // Lab mineral reservations ========================================================================================
    /* Reserves a product lab for boosting with a compound unrelated to production */
    reserveLab(lab, resourceType, amount) {
        // _.remove(this.productLabs, productLab => productLab.id == lab.id); // This gets excluded in registerRequests
        this.labReservations[lab.id] = {
            mineralType: resourceType,
            amount: Math.min(amount, LAB_MINERAL_CAPACITY),
        };
    }
    /* Return the amount of a given resource necessary to fully boost a creep body */
    static requiredBoostAmount(body, boostType) {
        const existingBoostCounts = _.countBy(body, (part) => part.boost);
        const numPartsToBeBoosted = _.filter(
            body,
            (part) => part.type == BOOST_PARTS[boostType],
        ).length;
        return (
            LAB_BOOST_MINERAL *
            (numPartsToBeBoosted - (existingBoostCounts[boostType] || 0))
        );
    }
    /**
     * Returns the best boost of a given type (e.g. "tough") that the room can acquire a specified amount of
     */
    bestBoostAvailable(boostType, amount) {
        if (PHASE != 'run') {
            log.error(
                `EvolutionChamber.bestBoostAvailable() must be called in the run() phase!`,
            );
        }
        // let boostFilter: (resource: ResourceConstant) => boolean;
        // switch (boostType) {
        // 	case 'attack':
        // 		boostFilter = Abathur.isAttackBoost;
        // 		break;
        // 	case 'carry':
        // 		boostFilter = Abathur.isCarryBoost;
        // 		break;
        // 	case 'ranged':
        // 		boostFilter = Abathur.isRangedBoost;
        // 		break;
        // 	case 'heal':
        // 		boostFilter = Abathur.isHealBoost;
        // 		break;
        // 	case 'move':
        // 		boostFilter = Abathur.isMoveBoost;
        // 		break;
        // 	case 'tough':
        // 		boostFilter = Abathur.isToughBoost;
        // 		break;
        // 	case 'harvest':
        // 		boostFilter = Abathur.isHarvestBoost;
        // 		break;
        // 	case 'construct':
        // 		boostFilter = Abathur.isConstructBoost;
        // 		break;
        // 	case 'dismantle':
        // 		boostFilter = Abathur.isDismantleBoost;
        // 		break;
        // 	case 'upgrade':
        // 		boostFilter = Abathur.isUpgradeBoost;
        // 		break;
        // 	default:
        // 		log.error(`${this.print}: ${boostType} is not a valid boostType!`);
        // 		return;
        // }
        const boosts = BOOST_TIERS[boostType];
        for (const boost of [boosts.T3, boosts.T2, boosts.T1]) {
            if (this.colony.assets[boost] >= amount) {
                return boost;
            } else if (
                this.terminalNetwork.canObtainResource(
                    this.colony,
                    boost,
                    amount,
                )
            ) {
                return boost;
            }
        }
        // If we get to here there's no available boosts of this type
        return undefined;
    }
    /* Request boosts sufficient to fully boost a given creep to be added to the boosting queue */
    requestBoosts(boosts) {
        // Add the required amount to the neededBoosts
        this.debug(`${JSON.stringify(boosts)} boosts requested!`);
        for (const boostResource in boosts) {
            const boostAmount = boosts[boostResource];
            // Here this.neededBoosts is describing what we want, not what we are going to load into labs, so it's okay
            // (and in fact better) to allow this to exceed LAB_MINERAL_CAPACITY so that terminalNetwork knows we
            // want a lot of this
            this.neededBoosts[boostResource] =
                (this.neededBoosts[boostResource] || 0) + boostAmount;
        }
    }
    lockLabFromTerminalNetwork(lab) {
        if (lab.mineralType && lab.store[lab.mineralType]) {
            this.terminalNetwork.lockResource(
                this.colony,
                lab.mineralType,
                lab.store[lab.mineralType],
            );
        }
    }
    // Initialization and operation ====================================================================================
    init() {
        
        // This gets called after every Overlord.init() so you should have all your boost requests in already
        // Set boosting lab reservations and compute needed resources; needs to be done BEFORE initLabStatus()!
        for (const boost in this.neededBoosts) {
            if (this.neededBoosts[boost] == 0) continue;
            let boostLab;
            for (const id in this.labReservations) {
                // find a lab already reserved for this mineral type
                if (
                    this.labReservations[id] &&
                    this.labReservations[id].mineralType == boost
                ) {
                    boostLab = deref(id);
                }
            }
            if (!boostLab) {
                // otherwise choose the first unreserved product lab
                boostLab = _.find(
                    this.boostingLabs,
                    (lab) => !this.labReservations[lab.id],
                );
            }
            if (boostLab) {
                this.reserveLab(boostLab, boost, this.neededBoosts[boost]);
            }
        }
        // Update the evo chamber status
        this.initLabStatus();
        // Register local transport requests
        this.registerRequests();
        // Request resources for boosting and lock them once you have them
        for (const boost in this.neededBoosts) {
            const product = this.memory.activeReaction
                ? this.memory.activeReaction.mineralType
                : undefined;
            const reagents = this.memory.activeReaction
                ? REAGENTS[this.memory.activeReaction.mineralType]
                : [undefined, undefined];
            let amountUnavailable = 0;
            if (boost == product) {
                _.forEach(this.productLabs, (lab) => {
                    if (
                        lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)
                    ) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            } else if (boost == reagents[0]) {
                _.forEach(this.reagentLabs, (lab) => {
                    if (
                        lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)
                    ) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            } else if (boost == reagents[1]) {
                _.forEach(this.reagentLabs, (lab) => {
                    if (
                        lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)
                    ) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            const amountNeeded = this.neededBoosts[boost] + amountUnavailable;
            if (amountNeeded > this.colony.assets[boost]) {
                this.debug(
                    `Requesting boost from terminal network: ${this.neededBoosts[boost]} ${boost}`,
                );
                this.terminalNetwork.requestResource(
                    this.colony,
                    boost,
                    amountNeeded,
                );
            } else {
                this.debug(
                    `Locking boost from terminal network: ${this.neededBoosts[boost]} ${boost}`,
                );
                this.terminalNetwork.lockResource(
                    this.colony,
                    boost,
                    amountNeeded,
                );
            }
        }
        // Request or lock resources from the terminal network
        if (this.memory.activeReaction) {
            const amount = this.memory.activeReaction.amount;
            const product = this.memory.activeReaction.mineralType;
            const reagents = REAGENTS[this.memory.activeReaction.mineralType];
            // Lock resources that are currently being used or produced
            switch (this.memory.status) {
                case LabStatus.Idle:
                    break;
                case LabStatus.AcquiringMinerals:
                    _.forEach(reagents, (reagent) => {
                        if (this.colony.assets[reagent] < amount) {
                            this.terminalNetwork.requestResource(
                                this.colony,
                                reagent,
                                amount,
                            );
                        } else {
                            this.terminalNetwork.lockResource(
                                this.colony,
                                reagent,
                                amount,
                            );
                        }
                    });
                    break;
                case LabStatus.LoadingLabs:
                    _.forEach(reagents, (reagent) =>
                        this.terminalNetwork.lockResource(
                            this.colony,
                            reagent,
                            amount,
                        ),
                    );
                    break;
                case LabStatus.Synthesizing:
                    _.forEach(this.reagentLabs, (lab) => {
                        if (
                            lab.mineralType == reagents[0] ||
                            lab.mineralType == reagents[1]
                        ) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    _.forEach(this.productLabs, (lab) => {
                        if (lab.mineralType == product) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
                case LabStatus.UnloadingLabs:
                    _.forEach(this.labs, (lab) => {
                        if (
                            lab.mineralType == product ||
                            lab.mineralType == reagents[0] ||
                            lab.mineralType == reagents[1]
                        ) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
            }
        }
        
    }
    run() {
        if (
            this.memory.suspendReactionsUntil &&
            Game.time > this.memory.suspendReactionsUntil
        ) {
            delete this.memory.suspendReactionsUntil;
        }
        // Get an active reaction if you don't have one
        if (!this.memory.activeReaction && !this.memory.suspendReactionsUntil) {
            const nextReaction = Abathur.getNextReaction(this.colony);
            // There's a 1 tick delay between generating the reaction and being able to request the resources from
            // the terminal network. The reason for this is that this needs to be placed in the run() phase because
            // Abathur.getNextReaction() calls TerminalNetwork.canObtainResource(), which requires that knowledge of
            // the colony request states have already been registered in the init() phase. In any case, this adds an
            // inefficiency of like 1 tick in ~6000 for a T3 compound, so you can just deal with it. :P
            if (nextReaction) {
                this.memory.activeReaction = nextReaction;
            } else {
                const sleepTime =
                    EvolutionChamber_1.settings.sleepTime + randint(0, 20);
                log.info(
                    `${this.print}: no reaction available; sleeping for ${sleepTime} ticks.`,
                );
                this.memory.suspendReactionsUntil = Game.time + sleepTime;
            }
        }
        // Run the reactions
        if (this.memory.status == LabStatus.Synthesizing) {
            const [lab1, lab2] = this.reagentLabs;
            for (const lab of this.productLabs) {
                if (lab.cooldown == 0 && !this.labReservations[lab.id]) {
                    const result = lab.runReaction(lab1, lab2);
                    // Bugfix: PC Operating labs could cause reaction labs to
                    // not have enough resources to react on and fill ALL destination labs
                    // in this case, (ERR_NOT_ENOUGH_RESOURCES) set status to unload labs
                    if (result == ERR_NOT_ENOUGH_RESOURCES) {
                        this.memory.status = LabStatus.UnloadingLabs;
                        this.memory.statusTick = Game.time;
                        return;
                    }
                    if (result == OK) {
                        // update total production amount in memory
                        const product = this.memory.activeReaction
                            ? this.memory.activeReaction.mineralType
                            : 'ERROR';
                        if (!this.memory.stats.totalProduction[product]) {
                            this.memory.stats.totalProduction[product] = 0;
                        }
                        this.memory.stats.totalProduction[
                            product
                        ] += LAB_REACTION_AMOUNT;
                    } else {
                        log.warning(
                            `${this.print}: couldn't run reaction for lab @ ${lab.pos.print}! (${result})`,
                        );
                    }
                }
            }
        }
        // Record stats
        this.stats();
    }
    drawLabReport(coord) {
        let { x, y } = coord;
        const height = 2;
        const titleCoords = Visualizer.section(
            `${this.colony.name} Evolution Chamber`,
            { x, y, roomName: this.room.name },
            9.5,
            height + 0.1,
        );
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        let status;
        switch (this.memory.status) {
            case LabStatus.Idle:
                status = 'IDLE';
                break;
            case LabStatus.AcquiringMinerals:
                status = 'acquire minerals';
                break;
            case LabStatus.LoadingLabs:
                status = 'loading labs';
                break;
            case LabStatus.Synthesizing:
                status = 'synthesizing';
                break;
            case LabStatus.UnloadingLabs:
                status = 'unloading labs';
                break;
            default:
                status = 'INVALID';
                break;
        }
        const activeReaction = this.memory.activeReaction;
        const mineral = activeReaction ? activeReaction.mineralType : 'NONE';
        Visualizer.text(`Status: ${status}`, {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        y += 1;
        if (this.memory.status == LabStatus.Synthesizing && activeReaction) {
            const amountDone = _.sum(
                _.map(this.productLabs, (lab) =>
                    lab.mineralType == activeReaction.mineralType
                        ? lab.mineralAmount
                        : 0,
                ),
            );
            Visualizer.text(activeReaction.mineralType, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(
                [amountDone, activeReaction.amount],
                { x: boxX + 4, y: y, roomName: this.room.name },
                5,
            );
            y += 1;
        } else {
            Visualizer.text(`Active reaction: ${mineral}`, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            y += 1;
        }
        return { x: x, y: y + 0.25 };
    }
    visuals(coord) {
        const vis = this.room.visual;
        // Lab visuals
        for (const lab of this.labs) {
            if (lab.mineralType) {
                vis.resource(lab.mineralType, lab.pos.x, lab.pos.y);
            }
        }
        // Draw lab report
        return this.drawLabReport(coord);
    }
    stats() {
        // Stats.log(`colonies.${this.colony.name}.evolutionChamber.totalProduction`, this.memory.stats.totalProduction);
        const labUsage =
            _.sum(this.productLabs, (lab) => (lab.cooldown > 0 ? 1 : 0)) /
            this.productLabs.length;
        this.memory.stats.avgUsage = ema(
            labUsage,
            this.memory.stats.avgUsage,
            LAB_USAGE_WINDOW,
        );
        Stats.log(
            `colonies.${this.colony.name}.evolutionChamber.avgUsage`,
            this.memory.stats.avgUsage,
        );
    }
});
EvolutionChamber.settings = {
    sleepTime: 100,
};
EvolutionChamber = EvolutionChamber_1 = __decorate([profile], EvolutionChamber);

/**
 * Spawns a dedicated hatchery attendant to refill spawns and extensions
 */
let QueenOverlord = class QueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.hatchery = hatchery;
        this.queenSetup =
            this.colony.storage && !this.colony.state.isRebuilding
                ? Setups.queens.default
                : Setups.queens.early;
        this.queens = this.zerg(Roles.queen);
        this.settings = {
            refillTowersBelow: 500,
        };
    }
    init() {
        const amount = 1; // this.hatchery.battery ? 2 : 3; // zGeneral 11/10/2023
        const prespawn =
            this.hatchery.spawns.length <= 1 ? 100 : DEFAULT_PRESPAWN;
        this.wishlist(amount, this.queenSetup, { prespawn: prespawn });
    }
    supplyActions(queen) {
        // Select the closest supply target out of the highest priority and refill it
        const request = this.hatchery.transportRequests.getPrioritizedClosestRequest(
            queen.pos,
            'supply',
        );
        if (request) {
            queen.task = Tasks.transfer(request.target);
        } else {
            this.rechargeActions(queen); // if there are no targets, refill yourself
        }
    }
    rechargeActions(queen) {
        if (this.hatchery.link && !this.hatchery.link.isEmpty) {
            queen.task = Tasks.withdraw(this.hatchery.link);
        } else if (this.hatchery.battery && this.hatchery.battery.energy > 0) {
            queen.task = Tasks.withdraw(this.hatchery.battery);
        } else {
            queen.task = Tasks.recharge();
        }
    }
    idleActions(queen) {
        if (this.hatchery.link) {
            // Can energy be moved from the link to the battery?
            if (
                this.hatchery.battery &&
                !this.hatchery.battery.isFull &&
                !this.hatchery.link.isEmpty
            ) {
                // Move energy to battery as needed
                if (queen.carry.energy < queen.carryCapacity) {
                    queen.task = Tasks.withdraw(this.hatchery.link);
                } else {
                    queen.task = Tasks.transfer(this.hatchery.battery);
                }
            } else {
                if (queen.carry.energy < queen.carryCapacity) {
                    // make sure you're recharged
                    if (!this.hatchery.link.isEmpty) {
                        queen.task = Tasks.withdraw(this.hatchery.link);
                    } else if (
                        this.hatchery.battery &&
                        !this.hatchery.battery.isEmpty
                    ) {
                        queen.task = Tasks.withdraw(this.hatchery.battery);
                    }
                }
            }
        } else {
            if (
                this.hatchery.battery &&
                queen.carry.energy < queen.carryCapacity
            ) {
                queen.task = Tasks.withdraw(this.hatchery.battery);
            }
        }
    }
    handleQueen(queen) {
        if (queen.carry.energy > 0) {
            this.supplyActions(queen);
        } else {
            this.rechargeActions(queen);
        }
        // If there aren't any tasks that need to be done, recharge the battery from link
        if (queen.isIdle) {
            this.idleActions(queen);
        }
        // // If all of the above is done and hatchery is not in emergencyMode, move to the idle point and renew as needed
        // if (!this.emergencyMode && queen.isIdle) {
        // 	if (queen.pos.isEqualTo(this.idlePos)) {
        // 		// If queen is at idle position, renew her as needed
        // 		if (queen.ticksToLive < this.settings.renewQueenAt && this.availableSpawns.length > 0) {
        // 			this.availableSpawns[0].renewCreep(queen.creep);
        // 		}
        // 	} else {
        // 		// Otherwise, travel back to idle position
        // 		queen.goTo(this.idlePos);
        // 	}
        // }
    }
    run() {
        for (const queen of this.queens) {
            // Get a task
            this.handleQueen(queen);
            // Run the task if you have one; else move back to idle pos
            if (queen.hasValidTask) {
                queen.run();
            } else {
                if (this.queens.length > 1) {
                    queen.goTo(this.hatchery.idlePos, { range: 1 });
                } else {
                    queen.goTo(this.hatchery.idlePos);
                }
            }
        }
    }
};
QueenOverlord = __decorate([profile], QueenOverlord);

function isSupplyStructure(structure) {
    return (
        structure.structureType == STRUCTURE_EXTENSION ||
        structure.structureType == STRUCTURE_LAB ||
        structure.structureType == STRUCTURE_TOWER ||
        structure.structureType == STRUCTURE_SPAWN
    );
}
function computeQuadrant(colony, quadrant) {
    const positions = _.map(quadrant, (coord) =>
        getPosFromBunkerCoord(coord, colony),
    );
    const structures = [];
    for (const pos of positions) {
        const structure = _.find(pos.lookFor(LOOK_STRUCTURES), (s) =>
            isSupplyStructure(s),
        );
        if (structure) {
            structures.push(structure);
        }
    }
    return structures;
}
/**
 * A modified version of the queen overlord which contains a number of hard-coded optimization for bunker-type rooms.
 * This overlord supercedes the default queen overlord once the colony has a storage with a minimum amount of energy.
 */
let BunkerQueenOverlord = class BunkerQueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.queenSetup = Setups.queens.default;
        this.queens = this.zerg(Roles.queen);
        this.batteries = _.filter(this.room.containers, (container) =>
            insideBunkerBounds(container.pos, this.colony),
        );
        this.links = _.filter(this.room.links, (link) =>
            insideBunkerBounds(link.pos, this.colony),
        );
        this.storeStructures = _.compact([
            this.colony.terminal,
            this.colony.storage,
            ...this.batteries,
            ...this.links,
        ]);
        this.quadrants = {
            lowerRight: $.structures(this, 'LR', () =>
                computeQuadrant(this.colony, quadrantFillOrder.lowerRight),
            ),
            upperLeft: $.structures(this, 'UL', () =>
                computeQuadrant(this.colony, quadrantFillOrder.upperLeft),
            ),
            lowerLeft: $.structures(this, 'LL', () =>
                computeQuadrant(this.colony, quadrantFillOrder.lowerLeft),
            ),
            upperRight: $.structures(this, 'UR', () =>
                computeQuadrant(this.colony, quadrantFillOrder.upperRight),
            ),
        };
        this.computeQueenAssignments();
    }
    computeQueenAssignments() {
        // Assign quadrants to queens
        this.assignments = _.zipObject(
            _.map(this.queens, (queen) => [queen.name, {}]),
        );
        const activeQueens = _.filter(this.queens, (queen) => !queen.spawning);
        this.numActiveQueens = activeQueens.length;
        if (this.numActiveQueens > 0) {
            const quadrantAssignmentOrder = [
                this.quadrants.lowerRight,
                this.quadrants.lowerLeft,
                this.quadrants.upperRight,
                this.quadrants.upperLeft,
            ];
            let i = 0;
            for (const quadrant of quadrantAssignmentOrder) {
                const queen = activeQueens[i % activeQueens.length];
                _.extend(
                    this.assignments[queen.name],
                    _.zipObject(_.map(quadrant, (s) => [s.id, true])),
                );
                i++;
            }
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'batteries', 'storeStructures');
        $.refreshObject(this, 'quadrants');
        // Re-compute queen assignments if the number of queens has changed
        if (
            _.filter(this.queens, (queen) => !queen.spawning).length !=
            this.numActiveQueens
        ) {
            this.computeQueenAssignments();
        }
    }
    init() {
        for (const battery of this.batteries) {
            if (hasMinerals(battery.store)) {
                // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(battery);
            }
        }
        // const amount = this.colony.spawns.length > 1 ? 2 : 1;
        const amount = this.colony.room.energyCapacityAvailable > 1300 ? 2 : 1;
        this.wishlist(amount, this.queenSetup);
    }
    // Builds a series of tasks to empty unnecessary carry contents, withdraw required resources, and supply structures
    buildSupplyTaskManifest(queen) {
        let tasks = [];
        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)
        let queenPos = queen.pos;
        if (sumStore(queen.carry) > 0) {
            let transferTarget = this.batteries[0];
            if (
                this.colony.storage &&
                this.colony.storage.storeCapacity >
                    sumStore(this.colony.storage.store)
            ) {
                transferTarget = this.colony.storage;
            }
            if (
                this.colony.terminal &&
                this.colony.terminal.storeCapacity >
                    sumStore(this.colony.terminal.store)
            ) {
                transferTarget = this.colony.terminal;
            }
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
                queenPos = transferTarget.pos;
            } else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        // Step 2: figure out what you need to supply for and calculate the needed resources
        const queenCarry = {};
        const allStore = mergeSum(
            _.map(this.storeStructures, (s) => storeIndex(s.store)),
        );
        const supplyRequests = [];
        for (const priority in this.colony.transportRequests.supply) {
            for (const request of this.colony.transportRequests.supply[
                priority
            ]) {
                if (this.assignments[queen.name][request.target.id]) {
                    supplyRequests.push(request);
                }
            }
        }
        const supplyTasks = [];
        for (const request of supplyRequests) {
            // stop when carry will be full
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0) break;
            // figure out how much you can withdraw
            let amount = Math.min(request.amount, remainingAmount);
            amount = Math.min(amount, allStore[request.resourceType] || 0);
            if (amount == 0) continue;
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // add a task to supply the target
            supplyTasks.push(
                Tasks.transfer(request.target, request.resourceType, amount),
            );
        }
        // Step 3: make withdraw tasks to get the needed resources
        const withdrawTasks = [];
        const neededResources = _.keys(queenCarry);
        const targets = _.filter(this.storeStructures, (s) =>
            _.all(
                neededResources,
                (resource) =>
                    (s.store[resource] || 0) >= (queenCarry[resource] || 0),
            ),
        );
        const withdrawTarget = minBy(
            targets,
            (target) => Pathing.distance(queenPos, target.pos) || Infinity,
        );
        if (withdrawTarget) {
            for (const resourceType of neededResources) {
                withdrawTasks.push(
                    Tasks.withdraw(
                        withdrawTarget,
                        resourceType,
                        queenCarry[resourceType],
                    ),
                );
            }
        } else {
            const closestTarget = minBy(
                this.storeStructures,
                (target) => Pathing.distance(queenPos, target.pos) || Infinity,
            );
            if (!closestTarget) {
                log.error(
                    `Can't seem to find any pathable store structures in ${this.colony.print}`,
                );
            } else {
                for (const resourceType of neededResources) {
                    if (
                        closestTarget.store[resourceType] >=
                        queenCarry[resourceType]
                    ) {
                        withdrawTasks.push(
                            Tasks.withdraw(
                                closestTarget,
                                resourceType,
                                queenCarry[resourceType],
                            ),
                        );
                    } else {
                        // TODO ordering tasks for fastest route, maybe a sortby for withdraw targets?
                        const hasResource = _.sortBy(
                            _.filter(
                                this.storeStructures,
                                (s) => s.store[resourceType] > 0,
                            ),
                            (s) => -s.store[resourceType],
                        ); // descending sort
                        let collected = 0;
                        for (const storeLoc of hasResource) {
                            // Might be bug in overwithdrawing
                            withdrawTasks.push(
                                Tasks.withdraw(
                                    storeLoc,
                                    resourceType,
                                    Math.min(
                                        queenCarry[resourceType] - collected,
                                        storeLoc.store[resourceType],
                                    ),
                                ),
                            );
                            collected += storeLoc.store[resourceType];
                            if (collected >= queenCarry[resourceType]) {
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (!withdrawTarget && withdrawTasks.length == 0) {
            log.warning(`Could not find adequate withdraw structure for ${
                queen.print
            }! (neededResources: 
			${neededResources}, queenCarry: ${JSON.stringify(queenCarry)})`);
            return null;
        }
        // Step 4: put all the tasks in the correct order, set nextPos for each, and chain them together
        tasks = tasks.concat(withdrawTasks, supplyTasks);
        return Tasks.chain(tasks);
    }
    // Builds a series of tasks to withdraw required resources from targets
    buildWithdrawTaskManifest(queen) {
        const tasks = [];
        const transferTarget =
            this.colony.terminal || this.colony.storage || this.batteries[0];
        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)
        if (sumStore(queen.carry) > 0) {
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
            } else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        // Step 2: figure out what you need to withdraw from
        const queenCarry = { energy: 0 };
        // let allWithdrawRequests = _.compact(_.flatten(_.map(this.assignments[queen.name],
        // 													struc => this.transportRequests.withdrawByID[struc.id])));
        const withdrawRequests = [];
        for (const priority in this.colony.transportRequests.withdraw) {
            for (const request of this.colony.transportRequests.withdraw[
                priority
            ]) {
                if (this.assignments[queen.name][request.target.id]) {
                    withdrawRequests.push(request);
                }
            }
        }
        for (const request of withdrawRequests) {
            // stop when carry will be full
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0) break;
            // figure out how much you can withdraw
            const amount = Math.min(request.amount, remainingAmount);
            if (amount == 0) continue;
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // add a task to supply the target
            tasks.push(
                Tasks.withdraw(request.target, request.resourceType, amount),
            );
        }
        // Step 3: put stuff in terminal/storage
        if (transferTarget) {
            tasks.push(Tasks.transferAll(transferTarget));
        } else {
            log.warning(`No transfer targets for ${queen.print}!`);
            return null;
        }
        // Step 4: return chained task manifest
        return Tasks.chain(tasks);
    }
    // private getChargingSpot(queen: Zerg): RoomPosition {
    // 	let chargeSpots = _.map(bunkerChargingSpots, coord => getPosFromBunkerCoord(coord, this.colony));
    // 	let chargeSpot = (_.first(this.assignments[queen.name]) || queen).pos.findClosestByRange(chargeSpots);
    // 	if (chargeSpot) {
    // 		return chargeSpot;
    // 	} else {
    // 		log.warning(`Could not determine charging spot for queen at ${queen.pos.print}!`);
    // 		return queen.pos;
    // 	}
    // }
    //
    // private idleActions(queen: Zerg): void {
    //
    // 	// // Refill any empty batteries
    // 	// for (let battery of this.batteries) {
    // 	// 	if (!battery.isFull) {
    // 	// 		let amount = Math.min(battery.storeCapacity - sumStore(battery.store), queen.carryCapacity);
    // 	// 		let target = this.colony.storage || this.colony.storage;
    // 	// 		if (target) {
    // 	// 			queen.task = Tasks.transfer(battery, RESOURCE_ENERGY, amount)
    // 	// 							  .fork(Tasks.withdraw(target, RESOURCE_ENERGY, amount))
    // 	// 			return;
    // 	// 		}
    // 	// 	}
    // 	// }
    //
    // 	// Go to recharging spot and get recharged
    // 	let chargingSpot = this.getChargingSpot(queen);
    // 	queen.goTo(chargingSpot, {range: 0});
    // 	// // TODO: this will cause oscillating behavior where recharge drains some energy and queen leaves to supply it
    // 	// if (queen.pos.getRangeTo(chargingSpot) == 0) {
    // 	// 	let chargingSpawn = _.first(queen.pos.findInRange(this.colony.spawns, 1));
    // 	// 	if (chargingSpawn && !chargingSpawn.spawning) {
    // 	// 		chargingSpawn.renewCreep(queen.creep);
    // 	// 	}
    // 	// }
    // }
    handleQueen(queen) {
        // Does something need withdrawing?
        if (
            this.colony.transportRequests.needsWithdrawing() &&
            _.any(
                _.keys(this.assignments[queen.name]),
                (id) => this.colony.transportRequests.withdrawByID[id],
            )
        ) {
            queen.task = this.buildWithdrawTaskManifest(queen);
        }
        // Does something need supplying?
        else if (
            this.colony.transportRequests.needsSupplying() &&
            _.any(
                _.keys(this.assignments[queen.name]),
                (id) => this.colony.transportRequests.supplyByID[id],
            )
        ) {
            queen.task = this.buildSupplyTaskManifest(queen);
        }
        // Do we need safemodes?
        else if (
            this.colony.level > 5 &&
            this.colony.controller.safeModeAvailable < 3 &&
            this.colony.terminal &&
            this.colony.terminal.store[RESOURCE_GHODIUM] >= 1000 &&
            queen.carryCapacity >= 1000
        ) {
            // Only use 1 queen to avoid adding 2 safemodes
            if (
                queen.name == _.first(_.sortBy(this.queens, (q) => q.name)).name
            ) {
                queen.task = Tasks.chain([
                    Tasks.transferAll(this.colony.terminal),
                    Tasks.withdraw(
                        this.colony.terminal,
                        RESOURCE_GHODIUM,
                        1000,
                    ),
                    Tasks.generateSafeMode(this.colony.controller),
                ]);
                log.alert(
                    `${this.colony.print} has ${this.colony.controller.safeModeAvailable} safemodes avaliable, ` +
                        `generating a new one`,
                );
            }
        }
        // Otherwise do idle actions
        if (queen.isIdle) {
            // this.idleActions(queen);
            delete queen.memory._go;
        }
    }
    run() {
        this.autoRun(this.queens, (queen) => this.handleQueen(queen));
    }
};
BunkerQueenOverlord = __decorate([profile], BunkerQueenOverlord);

const ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH = -20;
const ERR_SPECIFIED_SPAWN_BUSY = -21;
const getDefaultHatcheryMemory = () => ({
    stats: {
        overload: 0,
        uptime: 0,
        longUptime: 0,
    },
});
/**
 * The hatchery encompasses all spawning-related structures, like spawns, extensions, and some energy buffer containers,
 * and contains logic for spawning the creeps requested by overlords
 */
let Hatchery = class Hatchery extends HiveCluster {
    constructor(colony, headSpawn) {
        super(colony, headSpawn, 'hatchery');
        // Register structure components
        this.memory = Mem.wrap(
            this.colony.memory,
            'hatchery',
            getDefaultHatcheryMemory,
        );
        if (this.colony.layout == 'twoPart') {
            this.colony.destinations.push({ pos: this.pos, order: -1 });
        }
        this.spawns = colony.spawns;
        this.availableSpawns = _.filter(
            this.spawns,
            (spawn) => !spawn.spawning,
        );
        this.extensions = colony.extensions;
        this.towers = colony.commandCenter
            ? _.difference(colony.towers, colony.commandCenter.towers)
            : colony.towers;
        if (this.colony.layout == 'bunker') {
            this.battery = _.first(
                _.filter(this.room.containers, (cont) =>
                    insideBunkerBounds(cont.pos, this.colony),
                ),
            );
            $.set(this, 'energyStructures', () =>
                this.computeEnergyStructures(),
            );
        } else {
            this.link = this.pos.findClosestByLimitedRange(
                colony.availableLinks,
                2,
            );
            this.colony.linkNetwork.claimLink(this.link);
            this.battery = this.pos.findClosestByLimitedRange(
                this.room.containers,
                2,
            );
            this.energyStructures = [].concat(this.spawns, this.extensions);
        }
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this._waitTimes = undefined;
        this.settings = {
            refillTowersBelow: 750,
            linksRequestEnergyBelow: 0,
            suppressSpawning: false,
        };
        this.transportRequests = colony.transportRequests; // hatchery always uses colony transport group
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'hatchery',
            getDefaultHatcheryMemory,
        );
        $.refreshRoom(this);
        $.refresh(
            this,
            'spawns',
            'extensions',
            'energyStructures',
            'link',
            'towers',
            'battery',
        );
        this.availableSpawns = _.filter(
            this.spawns,
            (spawn) => !spawn.spawning,
        );
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this._waitTimes = undefined;
    }
    spawnMoarOverlords() {
        if (
            this.colony.layout == 'bunker' &&
            (this.colony.storage || this.colony.terminal) &&
            this.colony.assets[RESOURCE_ENERGY] > 10000
        ) {
            this.overlord = new BunkerQueenOverlord(this); // use bunker queen if has storage and enough energy
        } else {
            this.overlord = new QueenOverlord(this);
        }
    }
    /**
     * Returns the approximate aggregated time at which the hatchery will next be available to spawn a creep request
     * with a given priority.
     */
    getWaitTimeForPriority(priority) {
        if (!this._waitTimes) {
            const waitTimes = {};
            // Initialize wait time to what is currently spawning
            let waitTime =
                _.sum(this.spawns, (spawn) =>
                    spawn.spawning ? spawn.spawning.remainingTime : 0,
                ) / this.spawns.length;
            // Add in expected time for whatever else needs to be spawned, cumulative up to each priority
            for (const priority of _.sortBy(this.productionPriorities)) {
                for (const request of this.productionQueue[priority]) {
                    const { body, boosts } = request.setup.create(
                        this.colony,
                        true,
                    ); // use cached setup as estimate
                    waitTime +=
                        (CREEP_SPAWN_TIME * body.length) / this.spawns.length;
                }
                waitTimes[priority] = waitTime;
            }
            this._waitTimes = waitTimes;
        }
        if (this._waitTimes[priority] != undefined) {
            return this._waitTimes[priority];
        }
        const priorities = _.sortBy(this.productionPriorities);
        if (priorities.length == 0) {
            return 0;
        }
        if (priority < _.first(priorities)) {
            return 0;
        }
        // each slot represents time to spawn all of priority, so slot-1 puts you at the beginning of this new priority
        const priorityIndex = _.sortedIndex(priorities, priority) - 1;
        const waitTime = this._waitTimes[priorities[priorityIndex]];
        if (waitTime == undefined) {
            log.error(
                `${this.print}: Undefined wait time in wait times: ${this._waitTimes}!`,
            );
            return 0;
        }
        return waitTime;
    }
    // Idle position for queen
    get idlePos() {
        if (this.battery) {
            return this.battery.pos;
        } else {
            return this.spawns[0].pos.availableNeighbors(true)[0];
        }
    }
    computeEnergyStructures() {
        if (this.colony.layout == 'bunker') {
            const positions = _.map(energyStructureOrder, (coord) =>
                getPosFromBunkerCoord(coord, this.colony),
            );
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(
                this.spawns,
                this.extensions,
            );
            const energyStructures = [];
            for (const pos of positions) {
                const structure = _.find(
                    pos.lookFor(LOOK_STRUCTURES),
                    (s) =>
                        s.structureType == STRUCTURE_SPAWN ||
                        s.structureType == STRUCTURE_EXTENSION,
                );
                if (structure) {
                    energyStructures.push(
                        _.remove(
                            spawnsAndExtensions,
                            (s) => s.id == structure.id,
                        )[0],
                    );
                }
            }
            return _.compact(energyStructures.concat(spawnsAndExtensions));
        } else {
            // Ugly workaround to [].concat() throwing a temper tantrum
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(
                this.spawns,
                this.extensions,
            );
            return _.sortBy(spawnsAndExtensions, (structure) =>
                structure.pos.getRangeTo(this.idlePos),
            );
        }
    }
    /* Request more energy when appropriate either via link or hauler */
    registerEnergyRequests() {
        // Register requests for input into the hatchery (goes on colony store group)
        if (this.link && this.link.isEmpty) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        if (this.battery) {
            const threshold =
                this.colony.stage == ColonyStage.Larva ? 0.75 : 0.5;
            if (this.battery.energy < threshold * this.battery.storeCapacity) {
                this.colony.logisticsNetwork.requestInput(this.battery, {
                    multiplier: 1.5,
                });
            }
            // get rid of any minerals in the container if present
            if (hasMinerals(this.battery.store)) {
                this.colony.logisticsNetwork.requestOutputMinerals(
                    this.battery,
                );
            }
        }
        // Register energy transport requests (goes on hatchery store group, which can be colony store group)
        // let refillStructures = this.energyStructures;
        // if (this.colony.defcon > DEFCON.safe) {
        // 	for (let hostile of this.room.dangerousHostiles) {
        // 		// TODO: remove tranport requests if blocked by enemies
        // 	}
        // }
        // if (this.room.defcon > 0) {refillStructures = _.filter()}
        const energyInSpawns = _.sum(
            this.energyStructures,
            (structure) => structure.energy,
        );
        const spawnRefillPriority =
            energyInSpawns > 5000 ? Priority.NormalLow : Priority.NormalHigh;
        _.forEach(this.energyStructures, (struct) =>
            this.transportRequests.requestInput(struct, spawnRefillPriority),
        );
        // let refillSpawns = _.filter(this.spawns, spawn => spawn.energy < spawn.energyCapacity);
        // let refillExtensions = _.filter(this.extensions, extension => extension.energy < extension.energyCapacity);
        const refillTowers = _.filter(
            this.towers,
            (tower) => tower.energy < this.settings.refillTowersBelow,
        );
        // _.forEach(refillSpawns, spawn => this.transportRequests.requestInput(spawn, Priority.NormalLow));
        // _.forEach(refillExtensions, extension => this.transportRequests.requestInput(extension, Priority.NormalLow));
        _.forEach(refillTowers, (tower) =>
            this.transportRequests.requestInput(tower, Priority.NormalLow),
        );
    }
    // Creep queueing and spawning =====================================================================================
    generateCreepName(roleName) {
        // Generate a creep name based on the role and add a suffix to make it unique
        let i = 0;
        while (Game.creeps[roleName + '_' + i]) {
            i++;
        }
        return roleName + '_' + i;
    }
    spawnCreep(protoCreep, options = {}) {
        // If you can't build it, return this error
        if (bodyCost(protoCreep.body) > this.room.energyCapacityAvailable) {
            return ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH;
        }
        // Get a spawn to use
        let spawnToUse;
        if (options.spawn) {
            spawnToUse = options.spawn;
            if (spawnToUse.spawning) {
                return ERR_SPECIFIED_SPAWN_BUSY;
            } else {
                _.remove(
                    this.availableSpawns,
                    (spawn) => spawn.id == spawnToUse.id,
                ); // mark as used
            }
        } else {
            spawnToUse = this.availableSpawns.find(
                (spawn) => spawn.effects && spawn.effects.length > 0,
            );
            if (spawnToUse) {
                _.remove(
                    this.availableSpawns,
                    (spawn) => spawn.id == spawnToUse.id,
                ); // mark as used
            } else {
                spawnToUse = this.availableSpawns.shift();
            }
        }
        // If you have a spawn available then spawn the creep
        if (spawnToUse) {
            if (
                this.colony.bunker &&
                this.colony.bunker.coreSpawn &&
                spawnToUse.id == this.colony.bunker.coreSpawn.id &&
                !options.directions
            ) {
                options.directions = [TOP, RIGHT]; // don't spawn into the manager spot
            }
            protoCreep.name = this.generateCreepName(protoCreep.name); // modify the creep name to make it unique
            protoCreep.memory.data.origin = spawnToUse.pos.roomName;
            // Spawn the creep
            const result = spawnToUse.spawnCreep(
                protoCreep.body,
                protoCreep.name,
                {
                    memory: protoCreep.memory,
                    energyStructures: this.energyStructures,
                    directions: options.directions,
                },
            );
            if (result == OK) {
                // Creep has been successfully spawned; add cost into profiling
                const overlordRef = protoCreep.memory['O' /* OVERLORD */];
                const overlord = Overmind.overlords[overlordRef];
                if (overlord) {
                    if (overlord.memory['S' /* STATS */]) {
                        overlord.memory['S' /* STATS */].spawnCost += bodyCost(
                            protoCreep.body,
                        );
                    }
                } else {
                    // This shouldn't ever happen
                    log.error(
                        `No overlord for protocreep ${protoCreep.name} at hatchery ${this.print}!`,
                    );
                }
                return result;
            } else {
                this.availableSpawns.unshift(spawnToUse); // return the spawn to the available spawns list
                return result;
            }
        } else {
            // otherwise, if there's no spawn to use, return busy
            return ERR_BUSY;
        }
    }
    canSpawn(body) {
        return bodyCost(body) <= this.room.energyCapacityAvailable;
    }
    canSpawnZerg(zerg) {
        return this.canSpawn(_.map(zerg.body, (part) => part.type));
    }
    /* Generate (but not spawn) the largest creep possible, returns the protoCreep as an object */
    generateProtoCreep(setup, overlord) {
        // Generate the creep memory
        const creepMemory = {
            ['C' /* COLONY */]: overlord.colony.name,
            ['O' /* OVERLORD */]: overlord.ref,
            role: setup.role,
            task: null,
            data: {
                // rarely-changed data about the creep
                origin: '',
            },
        };
        // Generate the creep body
        const { body, boosts } = setup.create(this.colony);
        if (boosts.length > 0) {
            creepMemory.needBoosts = boosts; // tell the creep what boosts it will need to get
        }
        // Create the protocreep and return it
        const protoCreep = {
            // object to add to spawner queue
            body: body,
            name: setup.role,
            memory: creepMemory,
        };
        return protoCreep;
    }
    /**
     * Enqueues a spawn request to the hatchery production queue
     */
    enqueue(request) {
        // const protoCreep = this.generateProtoCreep(request.setup, request.overlord);
        // TODO: ^shouldn't need to do this at enqueue, just at spawn. Implement approximateSize() method?
        const priority = request.priority;
        // Spawn the creep yourself if you can
        this._waitTimes = undefined; // invalidate cache
        // this._queuedSpawnTime = undefined;
        if (!this.productionQueue[priority]) {
            this.productionQueue[priority] = [];
            this.productionPriorities.push(priority); // this is necessary because keys interpret number as string
        }
        this.productionQueue[priority].push(request);
    }
    spawnHighestPriorityCreep() {
        const sortedKeys = _.sortBy(this.productionPriorities);
        for (const priority of sortedKeys) {
            // if (this.colony.defcon >= DEFCON.playerInvasion
            // 	&& !this.colony.controller.safeMode
            // 	&& priority > OverlordPriority.warSpawnCutoff) {
            // 	continue; // don't spawn non-critical creeps during wartime
            // }
            const request = this.productionQueue[priority].shift();
            if (request) {
                // Generate a protocreep from the request
                const protoCreep = this.generateProtoCreep(
                    request.setup,
                    request.overlord,
                );
                if (
                    this.canSpawn(protoCreep.body) &&
                    protoCreep.body.length > 0
                ) {
                    // Try to spawn the creep
                    const result = this.spawnCreep(protoCreep, request.options);
                    if (result == OK) {
                        return result;
                    } else if (result == ERR_SPECIFIED_SPAWN_BUSY) {
                        return result; // continue to spawn other things while waiting on specified spawn
                    } else {
                        // If there's not enough energyCapacity to spawn, ignore and move on, otherwise block and wait
                        if (result != ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH) {
                            this.productionQueue[priority].unshift(request);
                            return result;
                        }
                    }
                } else {
                    log.debug(
                        `${this.room.print}: cannot spawn creep ${protoCreep.name} with body ` +
                            `${JSON.stringify(protoCreep.body)}!`,
                    );
                }
            }
        }
    }
    // Runtime operation ===============================================================================================
    init() {
        this.registerEnergyRequests();
    }
    run() {
        // Handle spawning
        if (!this.settings.suppressSpawning) {
            // Spawn all queued creeps that you can
            while (this.availableSpawns.length > 0) {
                const result = this.spawnHighestPriorityCreep();
                if (result == ERR_NOT_ENOUGH_ENERGY) {
                    // if you can't spawn something you want to
                    this.isOverloaded = true;
                }
                if (result != OK && result != ERR_SPECIFIED_SPAWN_BUSY) {
                    // Can't spawn creep right now
                    break;
                }
            }
            // Move creeps off of exit position to let the spawning creep out if necessary
            for (const spawn of this.spawns) {
                if (
                    spawn.spawning &&
                    spawn.spawning.remainingTime <= 1 &&
                    spawn.pos.findInRange(FIND_MY_CREEPS, 1).length > 0
                ) {
                    let directions;
                    if (spawn.spawning.directions) {
                        directions = spawn.spawning.directions;
                    } else {
                        directions = _.map(
                            spawn.pos.availableNeighbors(true),
                            (pos) => spawn.pos.getDirectionTo(pos),
                        );
                    }
                    const exitPos = Pathing.positionAtDirection(
                        spawn.pos,
                        _.first(directions),
                    );
                    Movement.vacatePos(exitPos);
                }
            }
        }
        this.recordStats();
    }
    recordStats() {
        // Compute uptime and overload status
        const spawnUsageThisTick =
            _.filter(this.spawns, (spawn) => spawn.spawning).length /
            this.spawns.length;
        const uptime = ema(
            spawnUsageThisTick,
            this.memory.stats.uptime,
            CREEP_LIFE_TIME,
        );
        const longUptime = ema(
            spawnUsageThisTick,
            this.memory.stats.longUptime,
            3 * CREEP_LIFE_TIME,
        );
        const overload = ema(
            this.isOverloaded ? 1 : 0,
            this.memory.stats.overload,
            CREEP_LIFE_TIME,
        );
        Stats.log(`colonies.${this.colony.name}.hatchery.uptime`, uptime);
        Stats.log(`colonies.${this.colony.name}.hatchery.overload`, overload);
        this.memory.stats = { overload, uptime, longUptime };
    }
    visuals(coord) {
        let { x, y } = coord;
        const spawning = [];
        const spawnProgress = [];
        _.forEach(this.spawns, function (spawn) {
            if (spawn.spawning) {
                spawning.push(spawn.spawning.name.split('_')[0]);
                const timeElapsed =
                    spawn.spawning.needTime - spawn.spawning.remainingTime;
                spawnProgress.push([timeElapsed, spawn.spawning.needTime]);
            }
        });
        const boxCoords = Visualizer.section(
            `${this.colony.name} Hatchery`,
            { x, y, roomName: this.room.name },
            9.5,
            3 + spawning.length + 0.1,
        );
        const boxX = boxCoords.x;
        y = boxCoords.y + 0.25;
        // Log energy
        Visualizer.text('Energy', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(
            [this.room.energyAvailable, this.room.energyCapacityAvailable],
            { x: boxX + 4, y: y, roomName: this.room.name },
            5,
        );
        y += 1;
        // Log uptime
        const uptime = this.memory.stats.uptime;
        Visualizer.text('Uptime', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(
            uptime,
            { x: boxX + 4, y: y, roomName: this.room.name },
            5,
        );
        y += 1;
        // Log overload status
        const overload = this.memory.stats.overload;
        Visualizer.text('Overload', {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        Visualizer.barGraph(
            overload,
            { x: boxX + 4, y: y, roomName: this.room.name },
            5,
        );
        y += 1;
        for (const i in spawning) {
            Visualizer.text(spawning[i], {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(
                spawnProgress[i],
                { x: boxX + 4, y: y, roomName: this.room.name },
                5,
            );
            y += 1;
        }
        return { x: x, y: y + 0.25 };
    }
};
Hatchery.restrictedRange = 6; // Don't stand idly within this range of hatchery
Hatchery = __decorate([profile], Hatchery);

var SporeCrawler_1;
/**
 * The spore crawler is the hive cluster for controlling towers within a room
 */
let SporeCrawler = (SporeCrawler_1 = class SporeCrawler extends HiveCluster {
    constructor(colony, tower) {
        super(colony, tower, 'sporeCrawler');
        // Register structure components
        this.towers = this.colony.towers;
    }
    refresh() {
        $.refreshRoom(this);
        $.refresh(this, 'towers');
    }
    spawnMoarOverlords() {}
    registerEnergyRequests() {
        // Request energy from transporters if below request threshold
        for (const tower of this.towers) {
            if (tower.energy < SporeCrawler_1.settings.requestThreshold) {
                let multiplier =
                    tower.energy <
                    SporeCrawler_1.settings.criticalEnergyThreshold
                        ? 2
                        : 1;
                if (this.colony.defcon >= DEFCON.playerInvasion) {
                    multiplier *= 10;
                }
                const dAmountdt = this.room.hostiles.length > 0 ? 10 : 0;
                this.colony.logisticsNetwork.requestInput(tower, {
                    multiplier: multiplier,
                    dAmountdt: dAmountdt,
                });
            }
        }
    }
    init() {
        this.registerEnergyRequests();
        this.updateEnemyHealingHitsPredicted();
    }
    updateEnemyHealingHitsPredicted() {
        const eventLog = this.room.getEventLog();
        const healEvents = eventLog.filter((eventItem) => {
            return eventItem.event === EVENT_HEAL;
        });
        const incomingHealing = healEvents.map((eventItem) => {
            if (eventItem.event === EVENT_HEAL) {
                return eventItem.data;
            }
        });
        const hostiles = this.room.hostiles;
        for (const hostile of hostiles) {
            for (const healData of incomingHealing) {
                if (hostile.id === healData.targetId) {
                    if (hostile.hitsPredicted == undefined) {
                        hostile.hitsPredicted = hostile.hits;
                    }
                    hostile.hitsPredicted += healData.amount;
                }
            }
        }
    }
    attack(target) {
        for (const tower of this.towers) {
            const result = tower.attack(target);
            if (result == OK) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                target.hitsPredicted -= CombatIntel.singleTowerDamage(
                    target.pos.getRangeTo(tower),
                );
            }
        }
    }
    scatterShot(targets) {
        targets = targets.filter((target) => {
            return (
                !target.hitsPredicted || target.hitsPredicted <= target.hitsMax
            );
        });
        if (!targets.length) {
            log.debug(`${this.print} Skipping scatter shot, no good targets`);
            return;
        }
        let pullableTargets = targets.slice();
        for (const tower of this.towers) {
            if (
                tower.store.getUsedCapacity(RESOURCE_ENERGY) <
                tower.store.getCapacity(RESOURCE_ENERGY) * 0.7
            ) {
                continue;
            }
            if (!pullableTargets.length) {
                pullableTargets = targets.slice();
            }
            const target = _.sample(pullableTargets);
            _.pull(pullableTargets, target);
            const result = tower.attack(target);
            if (result == OK) {
                if (target.hitsPredicted == undefined) {
                    target.hitsPredicted = target.hits;
                }
                target.hitsPredicted -= CombatIntel.singleTowerDamage(
                    target.pos.getRangeTo(tower),
                );
            }
        }
    }
    // private attackNearestEnemy(prioritizeHealers = false) {
    // 	if (prioritizeHealers) {
    // 		let healers = _.filter(this.room.hostiles, creep => creep.getActiveBodyparts(HEAL) > 0);
    // 		if (healers.length > 0) {
    // 			let healer = this.pos.findClosestByRange(healers);
    // 			if (healer) {
    // 				return this.tower.attack(healer);
    // 			}
    // 		}
    // 	}
    // 	let closestHostile = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
    // 	if (closestHostile) {
    // 		return this.tower.attack(closestHostile);
    // 	}
    // }
    // private healNearestAlly() {
    // 	var closestDamagedAlly = this.pos.findClosestByRange(FIND_MY_CREEPS, {
    // 		filter: (c: Creep) => c.hits < c.hitsMax,
    // 	});
    // 	if (closestDamagedAlly) {
    // 		return this.tower.heal(closestDamagedAlly);
    // 	}
    // }
    preventStructureDecay(includeRoads = true) {
        if (this.towers.length > 0) {
            // expensive to check all rampart hits; only run in intermediate RCL
            const dyingRamparts = _.filter(
                this.room.ramparts,
                (rampart) =>
                    rampart.hits <
                        WorkerOverlord.settings.barrierHits.critical &&
                    this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(
                        rampart.pos,
                    ),
            );
            if (dyingRamparts.length > 0) {
                for (const tower of this.towers) {
                    tower.repair(tower.pos.findClosestByRange(dyingRamparts));
                }
                return;
            }
            // repair roads
            if (includeRoads) {
                const decayingRoads = _.filter(
                    this.room.roads,
                    (road) =>
                        road.hits < 0.2 * road.hitsMax &&
                        this.colony.roomPlanner.roadShouldBeHere(road.pos),
                );
                if (decayingRoads.length > 0) {
                    const roadsToRepair = _.sample(
                        decayingRoads,
                        this.towers.length,
                    );
                    // ^ if |towers| > |roads| then this will have length of |roads|
                    for (const i in roadsToRepair) {
                        this.towers[i].repair(roadsToRepair[i]);
                    }
                }
            }
        }
    }
    // private repairNearestStructure() {
    // 	var closestDamagedStructure = this.pos.findClosestByRange(FIND_STRUCTURES, {
    // 		filter: (s: Structure) => s.hits < s.hitsMax &&
    // 								  s.structureType != STRUCTURE_WALL &&
    // 								  s.structureType != STRUCTURE_RAMPART,
    // 	});
    // 	if (closestDamagedStructure) {
    // 		return this.tower.repair(closestDamagedStructure);
    // 	}
    // }
    run() {
        if (this.room.hostiles.length > 0) {
            const myDefenders = _.filter(
                this.room.creeps,
                (creep) => creep.getActiveBodyparts(ATTACK) > 1,
            );
            const myRangedDefenders = _.filter(
                this.room.creeps,
                (creep) => creep.getActiveBodyparts(RANGED_ATTACK) > 1,
            );
            const myCreepDamage =
                ATTACK_POWER *
                    _.sum(myDefenders, (creep) =>
                        CombatIntel.getAttackPotential(creep),
                    ) +
                RANGED_ATTACK_POWER *
                    _.sum(myRangedDefenders, (creep) =>
                        CombatIntel.getRangedAttackPotential(creep),
                    );
            const HEAL_FUDGE_FACTOR = 0.9;
            const avgHealing =
                HEAL_FUDGE_FACTOR *
                CombatIntel.avgHostileHealingTo(this.room.hostiles);
            let possibleTargets = _.filter(this.room.hostiles, (hostile) => {
                // let healing = HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile);
                const damageTaken = CombatIntel.maxAllyDamageAtPos(hostile.pos);
                const damageMultiplier = CombatIntel.minimumDamageTakenMultiplier(
                    hostile,
                );
                // log.debug(`dT ${damageTaken} dM ${damageMultiplier} aH ${avgHealing}`);
                return damageTaken * damageMultiplier > avgHealing;
            });
            const scatterShotTargets = possibleTargets;
            // Only attack dancing targets (drain attack) which are far enough in rooms to be killed off by towers
            possibleTargets = _.filter(possibleTargets, (hostile) => {
                if (CombatIntel.isEdgeDancing(hostile)) {
                    const netDPS =
                        CombatIntel.towerDamageAtPos(hostile.pos) +
                        myCreepDamage -
                        HEAL_FUDGE_FACTOR *
                            CombatIntel.maxHostileHealingTo(hostile);
                    const isKillable =
                        netDPS * hostile.pos.rangeToEdge > hostile.hits;
                    if (isKillable) {
                        return true;
                    } else {
                        // Shoot if they get close enough
                        if (
                            this.colony.bunker &&
                            this.colony.bunker.anchor &&
                            hostile.pos.getRangeTo(this.colony.bunker.anchor) <=
                                6 + 2
                        ) {
                            return true;
                        }
                    }
                } else {
                    if (hostile.hits < hostile.hitsMax * 0.9) {
                        return true;
                    }
                    const netDPS =
                        CombatIntel.maxAllyDamageAtPos(hostile.pos) -
                        HEAL_FUDGE_FACTOR *
                            CombatIntel.maxHostileHealingTo(hostile);
                    const isDamageable = netDPS > 0;
                    // const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits/2;
                    log.debug(hostile, netDPS, hostile.hits);
                    return isDamageable;
                    // return true;
                }
            });
            // BOGDEN: Don't filter by nearby creeps
            possibleTargets = possibleTargets.filter(
                (enemy) =>
                    enemy.hits < enemy.hitsMax / 2 ||
                    enemy.pos.findInRange(FIND_MY_CREEPS, 4).length > 0 ||
                    enemy.pos.findInRange(FIND_MY_STRUCTURES, 3).length > 0,
            );
            // BOGDEN: Make sure they're in the room (as long as they can't attack anything)
            // TODO: Handle rooms with walls near exits
            possibleTargets = possibleTargets.filter(
                (enemy) =>
                    enemy.pos.rangeToEdge > 3 ||
                    enemy.pos.findInRange(FIND_MY_CREEPS, 4).length > 0,
            );
            const target = CombatTargeting.findBestCreepTargetForTowers(
                this.room,
                possibleTargets,
            );
            if (target) {
                return this.attack(target);
            } else if (
                Game.time % (Memory.settings.scatterShotFrequency || 10) == 0 ||
                this.room.invaders.length > 0
            ) {
                // just attack invaders
                // console.log('Scattershotting!');
                return this.scatterShot(scatterShotTargets);
            }
        }
        const damagedPowerCreep = _.filter(
            this.room.powerCreeps,
            (creep) => creep.hits < creep.hitsMax,
        );
        if (damagedPowerCreep.length > 0) {
            for (const tower of this.towers) {
                tower.heal(_.first(damagedPowerCreep));
            }
            return;
        }
        const closestDamagedAlly = this.pos.findClosestByRange(
            _.filter(this.room.creeps, (creep) => creep.hits < creep.hitsMax),
        );
        if (closestDamagedAlly) {
            for (const tower of this.towers) {
                tower.heal(closestDamagedAlly);
            }
            return;
        }
        // Towers build nuke response ramparts
        const nearbyNukeRamparts = _.filter(
            this.colony.overlords.work.nukeDefenseRamparts,
            (rampart) => this.pos.getRangeTo(rampart) <= TOWER_OPTIMAL_RANGE,
        );
        if (
            nearbyNukeRamparts.length > 0 &&
            this.colony.terminal &&
            !this.colony.state.isRebuilding
        ) {
            const nukes = this.colony.room.find(FIND_NUKES);
            const timeToImpact = _.min(_.map(nukes, (nuke) => nuke.timeToLand));
            if (timeToImpact) {
                const repairHitsRemaining = _.sum(
                    _.values(
                        this.colony.overlords.work.nukeDefenseHitsRemaining,
                    ),
                );
                const hitsRepairedPerTick =
                    this.towers.length * TOWER_POWER_REPAIR;
                // Only repair using towers if it looks like you won't finish repairs in time
                if (
                    repairHitsRemaining >
                    0.9 * hitsRepairedPerTick * timeToImpact
                ) {
                    for (const tower of this.towers) {
                        tower.repair(nearbyNukeRamparts[0]);
                    }
                    return;
                }
            } else {
                // Shouldn't get here
                log.warning(`No time to impact! (Why?)`);
            }
        }
        // Prevent rampart decay at early RCL
        this.preventStructureDecay();
    }
    visuals() {}
});
SporeCrawler.settings = {
    requestThreshold: 500,
    criticalEnergyThreshold: 250,
};
SporeCrawler = SporeCrawler_1 = __decorate([profile], SporeCrawler);

/**
 * Spawns an upgrader to upgrade the room controller
 */
let UpgradingOverlord = class UpgradingOverlord extends Overlord {
    constructor(upgradeSite, priority = OverlordPriority.upgrading.upgrade) {
        const upgraderPriority =
            upgradeSite.upgradePowerNeeded > 50
                ? OverlordPriority.upgrading.fastUpgrade
                : priority;
        super(upgradeSite, 'upgrade', upgraderPriority);
        this.upgradeSite = upgradeSite;
        this.upgraders = this.zerg(Roles.upgrader);
    }
    init() {
        if (this.colony.level < 3) {
            return;
        }

        if (this.colony.level === 3) {
            let quantity = 1;
            const constructionSites = this.colony.constructionSites.length;
            if (constructionSites < 5) quantity = 2;
            if (constructionSites < 2) quantity = 3;
            if (constructionSites === 0) quantity = 4;
            this.wishlist(quantity, Setups.upgraders.default);
            return;
        }

        if (this.colony.level === 8) {
            //if (this.colony.assets.energy <= UpgradeSite.settings.energyBuffer ) { //&& this.upgradeSite.controller.ticksToDowngrade <= 0
            //    return;
            //}

            let setup = Setups.upgraders.rcl8;
            if (this.upgradeSite.memory.speedFactor || 1 >= 2) {
                setup = Setups.upgraders.rcl8_boosted;
            }

            if (
                this.colony.assets[RESOURCE_BATTERY] > 30000 ||
                this.upgradeSite.controller.ticksToDowngrade < 60000
            ) {
                this.wishlist(1, setup);
            }
            return;
        }

        if (
            this.colony.assets.energy > UpgradeSite.settings.energyBuffer ||
            this.upgradeSite.controller.ticksToDowngrade > 0
        ) {
            const setup = Setups.upgraders.default;
            const upgradePowerEach = setup.getBodyPotential(WORK, this.colony);
            const upgradersNeeded = Math.min(
                Math.ceil(
                    this.upgradeSite.upgradePowerNeeded / upgradePowerEach,
                ),
                6,
            );
            if (upgradersNeeded > 3) {
                setup = Setups.upgraders.default_boosted;
            }
            this.wishlist(upgradersNeeded, setup);
        }
    }
    handleRepair(component, upgrader) {
        if (component && component.hits < component.hitsMax) {
            upgrader.task = Tasks.repair(component);
            return true;
        }
        return false;
    }

    handleWithdraw(source, upgrader) {
        if (source && source.energy > 0) {
            upgrader.task = Tasks.withdraw(source);
            return true;
        }
        return false;
    }

    handleUpgrader(upgrader) {
        const { link, battery, controller } = this.upgradeSite;
        const hasEnergy = upgrader.carry.energy > 0;

        if (hasEnergy) {
            // removed reoair and build, the worker should do them 9/2023 zGeneral
            return (upgrader.task = Tasks.upgrade(controller));
        } else {
            if (
                this.handleWithdraw(link, upgrader) ||
                this.handleWithdraw(battery, upgrader)
            )
                return;

            if (battery && battery.targetedBy.length === 0)
                return (upgrader.task = Tasks.recharge());
        }
    }

    run() {
        this.autoRun(this.upgraders, (upgrader) =>
            this.handleUpgrader(upgrader),
        );
    }
};
UpgradingOverlord = __decorate([profile], UpgradingOverlord);

var UpgradeSite_1;
/**
 * Upgrade sites group upgrade-related structures around a controller, such as an input link and energy container
 */
let UpgradeSite = (UpgradeSite_1 = class UpgradeSite extends HiveCluster {
    constructor(colony, controller) {
        super(colony, controller, 'upgradeSite');
        this.controller = controller;
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        this.upgradePowerNeeded = this.getUpgradePowerNeeded();
        if (this.memory.stats === undefined) {
            this.memory.stats = {
                downtime: 0,
                goal: 0,
            };
        } else if (this.memory.stats.downtime === undefined) {
            // bugfix when colony breaks down and has no spawn
            this.memory.stats.downtime = 0;
        }
        this.memory.stats.goal = this.upgradePowerNeeded;
        // Register battery
        $.set(this, 'battery', () => {
            const allowableContainers = _.filter(
                this.room.containers,
                (container) =>
                    container.pos.findInRange(FIND_SOURCES, 1).length == 0 && // only count containers that aren't near sources
                    !insideBunkerBounds(container.pos, this.colony),
            ); // only count containers not inside the bunker
            return this.pos.findClosestByLimitedRange(allowableContainers, 3);
        });
        this.batteryPos = $.pos(this, 'batteryPos', () => {
            if (this.battery) {
                return this.battery.pos;
            }
            const inputSite = this.findInputConstructionSite();
            if (inputSite) {
                return inputSite.pos;
            }
            const plannedPos = this.calculateBatteryPos();
            if (plannedPos) {
                return plannedPos;
            }
            if (!this.colony.roomPlanner.active) {
                log.alert(`Upgrade site at ${this.pos.print}: no batteryPos!`);
            }
            return undefined;
        });
        if (this.batteryPos) {
            this.colony.destinations.push({ pos: this.batteryPos, order: 0 });
        }
        // Register link
        $.set(this, 'link', () =>
            this.pos.findClosestByLimitedRange(colony.availableLinks, 3),
        );
        this.colony.linkNetwork.claimLink(this.link);
        // // Energy per tick is sum of upgrader body parts and nearby worker body parts
        // this.energyPerTick = $.number(this, 'energyPerTick', () =>
        // 	_.sum(this.overlord.upgraders, upgrader => upgrader.getActiveBodyparts(WORK)) +
        // 	_.sum(_.filter(this.colony.getCreepsByRole(WorkerSetup.role), worker =>
        // 			  worker.pos.inRangeTo((this.link || this.battery || this).pos, 2)),
        // 		  worker => worker.getActiveBodyparts(WORK)));
        // Compute stats
        this.stats();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        $.refreshRoom(this);
        $.refresh(this, 'controller', 'battery', 'link');
    }
    spawnMoarOverlords() {
        // Register overlord
        this.overlord = new UpgradingOverlord(this);
    }
    findInputConstructionSite() {
        const nearbyInputSites = this.pos.findInRange(
            this.room.constructionSites,
            4,
            {
                filter: (s) =>
                    s.structureType == STRUCTURE_CONTAINER ||
                    s.structureType == STRUCTURE_LINK,
            },
        );
        return _.first(nearbyInputSites);
    }
    getUpgradePowerNeeded() {
        return $.number(this, 'upgradePowerNeeded', () => {
            if (this.room.storage) {
                // Workers perform upgrading until storage is set up
                const amountOver = Math.max(
                    this.colony.assets.energy -
                        UpgradeSite_1.settings.energyBuffer,
                    0,
                );
                let upgradePower =
                    1 +
                    Math.floor(
                        amountOver / UpgradeSite_1.settings.energyPerBodyUnit,
                    );
                if (amountOver > 800000) {
                    upgradePower *= 4; // double upgrade power if we have lots of surplus energy
                } else if (amountOver > 500000) {
                    upgradePower *= 2;
                }
                if (this.controller.level === 8) {
                    if (this.room.storage.store.energy < 30000) {
                        upgradePower = 0;
                    } else {
                        upgradePower = Math.min(upgradePower, 15); // don't go above 15 work parts at RCL 8
                    }
                } else if (
                    this.controller.level >= 4 &&
                    this.memory.speedFactor
                ) {
                    // Can set a room to upgrade at an accelerated rate manually
                    upgradePower *= this.memory.speedFactor;
                }
                return upgradePower;
            } else {
                return 0;
            }
        });
    }
    init() {
        // Register energy requests
        if (
            this.link &&
            this.link.energy < UpgradeSite_1.settings.linksRequestBelow
        ) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        const inThreshold = this.colony.stage > ColonyStage.Larva ? 0.5 : 0.75;
        if (this.battery) {
            if (
                this.battery.energy <
                inThreshold * this.battery.storeCapacity
            ) {
                const energyPerTick =
                    UPGRADE_CONTROLLER_POWER * this.upgradePowerNeeded;
                this.colony.logisticsNetwork.requestInput(this.battery, {
                    dAmountdt: energyPerTick,
                });
            }
            if (hasMinerals(this.battery.store)) {
                // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(
                    this.battery,
                );
            }
        }
    }
    /**
     * Calculate where the input will be built for this site
     */
    calculateBatteryPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        } else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        } else {
            return undefined;
        }
        // Find all positions at range 2 from controller
        let inputLocations = [];
        for (const pos of this.pos.getPositionsAtRange(2)) {
            if (pos.isWalkable(true) && !insideBunkerBounds(pos, this.colony)) {
                inputLocations.push(pos);
            }
        }
        const usableNeighbors = (pos) => {
            return _.filter(
                pos.neighbors,
                (p) =>
                    p.isWalkable(true) && !insideBunkerBounds(p, this.colony),
            ).length;
        };
        // Try to find locations where there is maximal standing room
        const maxNeighbors = _.max(
            _.map(inputLocations, (pos) => usableNeighbors(pos)),
        );
        inputLocations = _.filter(
            inputLocations,
            (pos) => usableNeighbors(pos) >= maxNeighbors,
        );
        // Return location closest to storage by path
        const inputPos = originPos.findClosestByPath(inputLocations);
        if (inputPos) {
            return inputPos;
        }
    }
    /**
     * Build a container output at the optimal location
     */
    buildBatteryIfMissing() {
        if (!this.battery && !this.findInputConstructionSite()) {
            const buildHere = this.batteryPos;
            if (buildHere) {
                const result = buildHere.createConstructionSite(
                    STRUCTURE_CONTAINER,
                );
                if (result == OK) {
                    return;
                } else {
                    log.warning(
                        `Upgrade site at ${this.pos.print}: cannot build battery! Result: ${result}`,
                    );
                }
            }
        }
    }
    stats() {
        const defaults = {
            downtime: 0,
            goal: 0,
        };
        if (!this.memory.stats) {
            this.memory.stats = defaults;
        }
        _.defaults(this.memory.stats, defaults);
        // Compute downtime
        this.memory.stats.downtime =
            (this.memory.stats.downtime * (CREEP_LIFE_TIME - 1) +
                (this.battery ? +this.battery.isEmpty : 0)) /
            CREEP_LIFE_TIME;
        Stats.log(
            `colonies.${this.colony.name}.upgradeSite.downtime`,
            this.memory.stats.downtime,
        );
    }
    run() {
        if (Game.time % 25 == 7 && this.colony.level >= 2) {
            this.buildBatteryIfMissing();
        }
    }
    visuals(coord) {
        let { x, y } = coord;
        const height = this.controller.level === 8 ? 2.1 : 4.1;
        const boxCoords = Visualizer.section(
            `${this.colony.name} UpgradeSite`,
            { x, y, roomName: this.room.name },
            9.5,
            height,
        );
        const boxX = boxCoords.x;
        y = boxCoords.y + 0.25;
        if (this.controller.level !== 8) {
            Visualizer.text('Progress (×1000)', {
                x: boxX,
                y,
                roomName: this.room.name,
            });
            y += 1;
            Visualizer.barGraph(
                [
                    this.controller.progress / 1000,
                    Math.floor(this.controller.progressTotal / 1000),
                ],
                { x: boxX, y, roomName: this.room.name },
                9,
            );
            y += 1;
        }
        Visualizer.text('Downtime', { x: boxX, y, roomName: this.room.name });
        Visualizer.barGraph(
            this.memory.stats.downtime,
            { x: boxX + 4, y, roomName: this.room.name },
            5,
        );
        y += 1;
        Visualizer.text(
            `SpeedGoal: ${this.memory.stats.goal} @ x${
                this.memory.speedFactor || 1
            }`,
            { x: boxX, y, roomName: this.room.name },
        );
        y += 1;
        return { x, y: y + 0.25 };
    }
});
// energyPerTick: number;
UpgradeSite.settings = {
    energyBuffer: 50000,
    energyPerBodyUnit: 5000,
    linksRequestBelow: 200,
    minLinkDistance: 10,
};
UpgradeSite = UpgradeSite_1 = __decorate([profile], UpgradeSite);

/**
 * The link network controls the flow of energy through various links in a room and uses a greedy matching algorithm
 * to determine where to send energy to
 */
let LinkNetwork = class LinkNetwork {
    constructor(colony) {
        this.colony = colony;
        this.receive = [];
        this.transmit = [];
        this.settings = {
            linksTrasmitAt: LINK_CAPACITY - 100,
        };
    }
    refresh() {
        this.receive = [];
        this.transmit = [];
    }
    claimLink(link) {
        if (link) {
            _.remove(this.colony.availableLinks, (l) => l.id == link.id);
        }
    }
    requestReceive(link) {
        this.receive.push(link);
    }
    requestTransmit(link) {
        this.transmit.push(link);
    }
    /**
     * Number of ticks until a dropoff link is available again to deposit energy to
     */
    getDropoffAvailability(link) {
        const dest = this.colony.commandCenter
            ? this.colony.commandCenter.pos
            : this.colony.pos;
        const usualCooldown = link.pos.getRangeTo(dest);
        if (link.energy > this.settings.linksTrasmitAt) {
            // Energy will be sent next time cooldown == 0
            return link.cooldown + usualCooldown;
        } else {
            return link.cooldown;
        }
    }
    init() {
        // for (let link of this.colony.dropoffLinks) {
        // 	if (link.energy > this.settings.linksTrasmitAt) {
        // 		this.requestTransmit(link);
        // 	}
        // }
    }
    /**
     * Examine the link resource requests and try to efficiently (but greedily) match links that need energy in and
     * out, then send the remaining resourceOut link requests to the command center link
     */
    run() {
        // For each receiving link, greedily get energy from the closest transmitting link - at most 9 operations
        for (const receiveLink of this.receive) {
            const closestTransmitLink = receiveLink.pos.findClosestByRange(
                this.transmit,
            );
            // If a send-receive match is found, transfer that first, then remove the pair from the link lists
            if (closestTransmitLink) {
                // Send min of (all the energy in sender link, amount of available space in receiver link)
                const amountToSend = _.min([
                    closestTransmitLink.energy,
                    receiveLink.energyCapacity - receiveLink.energy,
                ]);
                closestTransmitLink.transferEnergy(receiveLink, amountToSend);
                _.remove(this.transmit, (link) => link == closestTransmitLink);
                // _.remove(this.receive, link => link == receiveLink);
            }
        }
        // Now send all remaining transmit link requests to the command center
        if (this.colony.commandCenter && this.colony.commandCenter.link) {
            for (const transmitLink of this.transmit) {
                transmitLink.transferEnergy(this.colony.commandCenter.link);
            }
        }
    }
};
LinkNetwork = __decorate([profile], LinkNetwork);

var ansiRegex = function () {
    return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

var ansiRegex$1 = ansiRegex();

var stripAnsi = function (str) {
    return typeof str === 'string' ? str.replace(ansiRegex$1, '') : str;
};

var clone_1 = createCommonjsModule(function (module) {
    var clone = (function () {
        /**
         * Clones (copies) an Object using deep copying.
         *
         * This function supports circular references by default, but if you are certain
         * there are no circular references in your object, you can save some CPU time
         * by calling clone(obj, false).
         *
         * Caution: if `circular` is false and `parent` contains circular references,
         * your program may enter an infinite loop and crash.
         *
         * @param `parent` - the object to be cloned
         * @param `circular` - set to true if the object to be cloned may contain
         *    circular references. (optional - true by default)
         * @param `depth` - set to a number if the object is only to be cloned to
         *    a particular depth. (optional - defaults to Infinity)
         * @param `prototype` - sets the prototype to be used when cloning an object.
         *    (optional - defaults to parent prototype).
         */
        function clone(parent, circular, depth, prototype) {
            var filter;
            if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                filter = circular.filter;
                circular = circular.circular;
            }
            // maintain two arrays for circular references, where corresponding parents
            // and children have the same index
            var allParents = [];
            var allChildren = [];

            var useBuffer = typeof Buffer != 'undefined';

            if (typeof circular == 'undefined') circular = true;

            if (typeof depth == 'undefined') depth = Infinity;

            // recurse this function so we don't reset allParents and allChildren
            function _clone(parent, depth) {
                // cloning null always returns null
                if (parent === null) return null;

                if (depth == 0) return parent;

                var child;
                var proto;
                if (typeof parent != 'object') {
                    return parent;
                }

                if (clone.__isArray(parent)) {
                    child = [];
                } else if (clone.__isRegExp(parent)) {
                    child = new RegExp(parent.source, __getRegExpFlags(parent));
                    if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if (clone.__isDate(parent)) {
                    child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                    if (Buffer.allocUnsafe) {
                        // Node.js >= 4.5.0
                        child = Buffer.allocUnsafe(parent.length);
                    } else {
                        // Older Node.js versions
                        child = new Buffer(parent.length);
                    }
                    parent.copy(child);
                    return child;
                } else {
                    if (typeof prototype == 'undefined') {
                        proto = Object.getPrototypeOf(parent);
                        child = Object.create(proto);
                    } else {
                        child = Object.create(prototype);
                        proto = prototype;
                    }
                }

                if (circular) {
                    var index = allParents.indexOf(parent);

                    if (index != -1) {
                        return allChildren[index];
                    }
                    allParents.push(parent);
                    allChildren.push(child);
                }

                for (var i in parent) {
                    var attrs;
                    if (proto) {
                        attrs = Object.getOwnPropertyDescriptor(proto, i);
                    }

                    if (attrs && attrs.set == null) {
                        continue;
                    }
                    child[i] = _clone(parent[i], depth - 1);
                }

                return child;
            }

            return _clone(parent, depth);
        }

        /**
         * Simple flat clone using prototype, accepts only objects, usefull for property
         * override on FLAT configuration object (no nested props).
         *
         * USE WITH CAUTION! This may not behave as you wish if you do not know how this
         * works.
         */
        clone.clonePrototype = function clonePrototype(parent) {
            if (parent === null) return null;

            var c = function () {};
            c.prototype = parent;
            return new c();
        };

        // private utility functions

        function __objToStr(o) {
            return Object.prototype.toString.call(o);
        }
        clone.__objToStr = __objToStr;

        function __isDate(o) {
            return typeof o === 'object' && __objToStr(o) === '[object Date]';
        }
        clone.__isDate = __isDate;

        function __isArray(o) {
            return typeof o === 'object' && __objToStr(o) === '[object Array]';
        }
        clone.__isArray = __isArray;

        function __isRegExp(o) {
            return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
        }
        clone.__isRegExp = __isRegExp;

        function __getRegExpFlags(re) {
            var flags = '';
            if (re.global) flags += 'g';
            if (re.ignoreCase) flags += 'i';
            if (re.multiline) flags += 'm';
            return flags;
        }
        clone.__getRegExpFlags = __getRegExpFlags;

        return clone;
    })();

    if (module.exports) {
        module.exports = clone;
    }
});

var defaults = function (options, defaults) {
    options = options || {};

    Object.keys(defaults).forEach(function (key) {
        if (typeof options[key] === 'undefined') {
            options[key] = clone_1(defaults[key]);
        }
    });

    return options;
};

var combining = [
    [0x0300, 0x036f],
    [0x0483, 0x0486],
    [0x0488, 0x0489],
    [0x0591, 0x05bd],
    [0x05bf, 0x05bf],
    [0x05c1, 0x05c2],
    [0x05c4, 0x05c5],
    [0x05c7, 0x05c7],
    [0x0600, 0x0603],
    [0x0610, 0x0615],
    [0x064b, 0x065e],
    [0x0670, 0x0670],
    [0x06d6, 0x06e4],
    [0x06e7, 0x06e8],
    [0x06ea, 0x06ed],
    [0x070f, 0x070f],
    [0x0711, 0x0711],
    [0x0730, 0x074a],
    [0x07a6, 0x07b0],
    [0x07eb, 0x07f3],
    [0x0901, 0x0902],
    [0x093c, 0x093c],
    [0x0941, 0x0948],
    [0x094d, 0x094d],
    [0x0951, 0x0954],
    [0x0962, 0x0963],
    [0x0981, 0x0981],
    [0x09bc, 0x09bc],
    [0x09c1, 0x09c4],
    [0x09cd, 0x09cd],
    [0x09e2, 0x09e3],
    [0x0a01, 0x0a02],
    [0x0a3c, 0x0a3c],
    [0x0a41, 0x0a42],
    [0x0a47, 0x0a48],
    [0x0a4b, 0x0a4d],
    [0x0a70, 0x0a71],
    [0x0a81, 0x0a82],
    [0x0abc, 0x0abc],
    [0x0ac1, 0x0ac5],
    [0x0ac7, 0x0ac8],
    [0x0acd, 0x0acd],
    [0x0ae2, 0x0ae3],
    [0x0b01, 0x0b01],
    [0x0b3c, 0x0b3c],
    [0x0b3f, 0x0b3f],
    [0x0b41, 0x0b43],
    [0x0b4d, 0x0b4d],
    [0x0b56, 0x0b56],
    [0x0b82, 0x0b82],
    [0x0bc0, 0x0bc0],
    [0x0bcd, 0x0bcd],
    [0x0c3e, 0x0c40],
    [0x0c46, 0x0c48],
    [0x0c4a, 0x0c4d],
    [0x0c55, 0x0c56],
    [0x0cbc, 0x0cbc],
    [0x0cbf, 0x0cbf],
    [0x0cc6, 0x0cc6],
    [0x0ccc, 0x0ccd],
    [0x0ce2, 0x0ce3],
    [0x0d41, 0x0d43],
    [0x0d4d, 0x0d4d],
    [0x0dca, 0x0dca],
    [0x0dd2, 0x0dd4],
    [0x0dd6, 0x0dd6],
    [0x0e31, 0x0e31],
    [0x0e34, 0x0e3a],
    [0x0e47, 0x0e4e],
    [0x0eb1, 0x0eb1],
    [0x0eb4, 0x0eb9],
    [0x0ebb, 0x0ebc],
    [0x0ec8, 0x0ecd],
    [0x0f18, 0x0f19],
    [0x0f35, 0x0f35],
    [0x0f37, 0x0f37],
    [0x0f39, 0x0f39],
    [0x0f71, 0x0f7e],
    [0x0f80, 0x0f84],
    [0x0f86, 0x0f87],
    [0x0f90, 0x0f97],
    [0x0f99, 0x0fbc],
    [0x0fc6, 0x0fc6],
    [0x102d, 0x1030],
    [0x1032, 0x1032],
    [0x1036, 0x1037],
    [0x1039, 0x1039],
    [0x1058, 0x1059],
    [0x1160, 0x11ff],
    [0x135f, 0x135f],
    [0x1712, 0x1714],
    [0x1732, 0x1734],
    [0x1752, 0x1753],
    [0x1772, 0x1773],
    [0x17b4, 0x17b5],
    [0x17b7, 0x17bd],
    [0x17c6, 0x17c6],
    [0x17c9, 0x17d3],
    [0x17dd, 0x17dd],
    [0x180b, 0x180d],
    [0x18a9, 0x18a9],
    [0x1920, 0x1922],
    [0x1927, 0x1928],
    [0x1932, 0x1932],
    [0x1939, 0x193b],
    [0x1a17, 0x1a18],
    [0x1b00, 0x1b03],
    [0x1b34, 0x1b34],
    [0x1b36, 0x1b3a],
    [0x1b3c, 0x1b3c],
    [0x1b42, 0x1b42],
    [0x1b6b, 0x1b73],
    [0x1dc0, 0x1dca],
    [0x1dfe, 0x1dff],
    [0x200b, 0x200f],
    [0x202a, 0x202e],
    [0x2060, 0x2063],
    [0x206a, 0x206f],
    [0x20d0, 0x20ef],
    [0x302a, 0x302f],
    [0x3099, 0x309a],
    [0xa806, 0xa806],
    [0xa80b, 0xa80b],
    [0xa825, 0xa826],
    [0xfb1e, 0xfb1e],
    [0xfe00, 0xfe0f],
    [0xfe20, 0xfe23],
    [0xfeff, 0xfeff],
    [0xfff9, 0xfffb],
    [0x10a01, 0x10a03],
    [0x10a05, 0x10a06],
    [0x10a0c, 0x10a0f],
    [0x10a38, 0x10a3a],
    [0x10a3f, 0x10a3f],
    [0x1d167, 0x1d169],
    [0x1d173, 0x1d182],
    [0x1d185, 0x1d18b],
    [0x1d1aa, 0x1d1ad],
    [0x1d242, 0x1d244],
    [0xe0001, 0xe0001],
    [0xe0020, 0xe007f],
    [0xe0100, 0xe01ef],
];

var DEFAULTS = {
    nul: 0,
    control: 0,
};

var wcwidth_1 = function wcwidth(str) {
    return wcswidth(str, DEFAULTS);
};

var config = function (opts) {
    opts = defaults(opts || {}, DEFAULTS);
    return function wcwidth(str) {
        return wcswidth(str, opts);
    };
};

/*
 *  The following functions define the column width of an ISO 10646
 *  character as follows:
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value
 *    of -1.
 *  - Non-spacing and enclosing combining characters (general category
 *    code Mn or Me in the
 *    Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode
 *    database) and ZERO WIDTH
 *    SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *    have a column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian
 *    Full-width (F) category as
 *    defined in Unicode Technical Report #11 have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and
 *    WGL4 characters, Unicode control characters, etc.) have a column
 *    width of 1.
 *  This implementation assumes that characters are encoded in ISO 10646.
 */

function wcswidth(str, opts) {
    if (typeof str !== 'string') return wcwidth(str, opts);

    var s = 0;
    for (var i = 0; i < str.length; i++) {
        var n = wcwidth(str.charCodeAt(i), opts);
        if (n < 0) return -1;
        s += n;
    }

    return s;
}

function wcwidth(ucs, opts) {
    // test for 8-bit control characters
    if (ucs === 0) return opts.nul;
    if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control;

    // binary search in table of non-spacing characters
    if (bisearch(ucs)) return 0;

    // if we arrive here, ucs is not a combining or C0/C1 control character
    return (
        1 +
        (ucs >= 0x1100 &&
            (ucs <= 0x115f || // Hangul Jamo init. consonants
                ucs == 0x2329 ||
                ucs == 0x232a ||
                (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) || // CJK ... Yi
                (ucs >= 0xac00 && ucs <= 0xd7a3) || // Hangul Syllables
                (ucs >= 0xf900 && ucs <= 0xfaff) || // CJK Compatibility Ideographs
                (ucs >= 0xfe10 && ucs <= 0xfe19) || // Vertical forms
                (ucs >= 0xfe30 && ucs <= 0xfe6f) || // CJK Compatibility Forms
                (ucs >= 0xff00 && ucs <= 0xff60) || // Fullwidth Forms
                (ucs >= 0xffe0 && ucs <= 0xffe6) ||
                (ucs >= 0x20000 && ucs <= 0x2fffd) ||
                (ucs >= 0x30000 && ucs <= 0x3fffd)))
    );
}

function bisearch(ucs) {
    var min = 0;
    var max = combining.length - 1;
    var mid;

    if (ucs < combining[0][0] || ucs > combining[max][1]) return false;

    while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1]) min = mid + 1;
        else if (ucs < combining[mid][0]) max = mid - 1;
        else return true;
    }

    return false;
}
wcwidth_1.config = config;

var width = function (str) {
    return wcwidth_1(stripAnsi(str));
};

/**
 * repeat string `str` up to total length of `len`
 *
 * @param String str string to repeat
 * @param Number len total length of output string
 */

function repeatString(str, len) {
    return Array.apply(null, { length: len + 1 })
        .join(str)
        .slice(0, len);
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padRight(str, max, chr) {
    str = str != null ? str : '';
    str = String(str);
    var length = max - width(str);
    if (length <= 0) return str;
    return str + repeatString(chr || ' ', length);
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padCenter will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padCenter(str, max, chr) {
    str = str != null ? str : '';
    str = String(str);
    var length = max - width(str);
    if (length <= 0) return str;
    var lengthLeft = Math.floor(length / 2);
    var lengthRight = length - lengthLeft;
    return (
        repeatString(chr || ' ', lengthLeft) +
        str +
        repeatString(chr || ' ', lengthRight)
    );
}

/**
 * Pad `str` up to total length `max` with `chr`, on the left.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padLeft(str, max, chr) {
    str = str != null ? str : '';
    str = String(str);
    var length = max - width(str);
    if (length <= 0) return str;
    return repeatString(chr || ' ', length) + str;
}

/**
 * Split a String `str` into lines of maxiumum length `max`.
 * Splits on word boundaries. Preserves existing new lines.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @return Array Array containing lines.
 */

function splitIntoLines(str, max) {
    function _splitIntoLines(str, max) {
        return str
            .trim()
            .split(' ')
            .reduce(function (lines, word) {
                var line = lines[lines.length - 1];
                if (line && width(line.join(' ')) + width(word) < max) {
                    lines[lines.length - 1].push(word); // add to line
                } else lines.push([word]); // new line
                return lines;
            }, [])
            .map(function (l) {
                return l.join(' ');
            });
    }
    return str
        .split('\n')
        .map(function (str) {
            return _splitIntoLines(str, max);
        })
        .reduce(function (lines, line) {
            return lines.concat(line);
        }, []);
}

/**
 * Add spaces and `truncationChar` between words of
 * `str` which are longer than `max`.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @param Number truncationChar character to append to split words
 * @return String
 */

function splitLongWords(str, max, truncationChar) {
    str = str.trim();
    var result = [];
    var words = str.split(' ');
    var remainder = '';

    var truncationWidth = width(truncationChar);

    while (remainder || words.length) {
        if (remainder) {
            var word = remainder;
            remainder = '';
        } else {
            var word = words.shift();
        }

        if (width(word) > max) {
            // slice is based on length no wcwidth
            var i = 0;
            var wwidth = 0;
            var limit = max - truncationWidth;
            while (i < word.length) {
                var w = width(word.charAt(i));
                if (w + wwidth > limit) {
                    break;
                }
                wwidth += w;
                ++i;
            }

            remainder = word.slice(i); // get remainder
            // save remainder for next loop

            word = word.slice(0, i); // grab truncated word
            word += truncationChar; // add trailing … or whatever
        }
        result.push(word);
    }

    return result.join(' ');
}

/**
 * Truncate `str` into total width `max`
 * If `str` is shorter than `max`,  will return `str` unaltered.
 *
 * @param String str string to truncated
 * @param Number max total wcwidth of output string
 * @return String truncated str
 */

function truncateString(str, max) {
    str = str != null ? str : '';
    str = String(str);

    if (max == Infinity) return str;

    var i = 0;
    var wwidth = 0;
    while (i < str.length) {
        var w = width(str.charAt(i));
        if (w + wwidth > max) break;
        wwidth += w;
        ++i;
    }
    return str.slice(0, i);
}

/**
 * Exports
 */

var padRight_1 = padRight;
var padCenter_1 = padCenter;
var padLeft_1 = padLeft;
var splitIntoLines_1 = splitIntoLines;
var splitLongWords_1 = splitLongWords;
var truncateString_1 = truncateString;

var utils = {
    padRight: padRight_1,
    padCenter: padCenter_1,
    padLeft: padLeft_1,
    splitIntoLines: splitIntoLines_1,
    splitLongWords: splitLongWords_1,
    truncateString: truncateString_1,
};

var padRight$1 = utils.padRight;
var padCenter$1 = utils.padCenter;
var padLeft$1 = utils.padLeft;
var splitIntoLines$1 = utils.splitIntoLines;
var splitLongWords$1 = utils.splitLongWords;
var truncateString$1 = utils.truncateString;

var DEFAULT_HEADING_TRANSFORM = function DEFAULT_HEADING_TRANSFORM(key) {
    return key.toUpperCase();
};

var DEFAULT_DATA_TRANSFORM = function DEFAULT_DATA_TRANSFORM(
    cell,
    column,
    index,
) {
    return cell;
};

var DEFAULTS$1 = Object.freeze({
    maxWidth: Infinity,
    minWidth: 0,
    columnSplitter: ' ',
    truncate: false,
    truncateMarker: '…',
    preserveNewLines: false,
    paddingChr: ' ',
    showHeaders: true,
    headingTransform: DEFAULT_HEADING_TRANSFORM,
    dataTransform: DEFAULT_DATA_TRANSFORM,
});

var columnify = function (items) {
    var options =
        arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var columnConfigs = options.config || {};
    delete options.config; // remove config so doesn't appear on every column.

    var maxLineWidth = options.maxLineWidth || Infinity;
    if (maxLineWidth === 'auto')
        maxLineWidth = process.stdout.columns || Infinity;
    delete options.maxLineWidth; // this is a line control option, don't pass it to column

    // Option defaults inheritance:
    // options.config[columnName] => options => DEFAULTS
    options = mixin({}, DEFAULTS$1, options);

    options.config = options.config || Object.create(null);

    options.spacing = options.spacing || '\n'; // probably useless
    options.preserveNewLines = !!options.preserveNewLines;
    options.showHeaders = !!options.showHeaders;
    options.columns = options.columns || options.include; // alias include/columns, prefer columns if supplied
    var columnNames = options.columns || []; // optional user-supplied columns to include

    items = toArray(items, columnNames);

    // if not suppled column names, automatically determine columns from data keys
    if (!columnNames.length) {
        items.forEach(function (item) {
            for (var columnName in item) {
                if (columnNames.indexOf(columnName) === -1)
                    columnNames.push(columnName);
            }
        });
    }

    // initialize column defaults (each column inherits from options.config)
    var columns = columnNames.reduce(function (columns, columnName) {
        var column = Object.create(options);
        columns[columnName] = mixin(column, columnConfigs[columnName]);
        return columns;
    }, Object.create(null));

    // sanitize column settings
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        column.name = columnName;
        column.maxWidth = Math.ceil(column.maxWidth);
        column.minWidth = Math.ceil(column.minWidth);
        column.truncate = !!column.truncate;
        column.align = column.align || 'left';
    });

    // sanitize data
    items = items.map(function (item) {
        var result = Object.create(null);
        columnNames.forEach(function (columnName) {
            // null/undefined -> ''
            result[columnName] =
                item[columnName] != null ? item[columnName] : '';
            // toString everything
            result[columnName] = '' + result[columnName];
            if (columns[columnName].preserveNewLines) {
                // merge non-newline whitespace chars
                result[columnName] = result[columnName].replace(
                    /[^\S\n]/gim,
                    ' ',
                );
            } else {
                // merge all whitespace chars
                result[columnName] = result[columnName].replace(/\s/gim, ' ');
            }
        });
        return result;
    });

    // transform data cells
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        items = items.map(function (item, index) {
            var col = Object.create(column);
            item[columnName] = column.dataTransform(
                item[columnName],
                col,
                index,
            );

            var changedKeys = Object.keys(col);
            // disable default heading transform if we wrote to column.name
            if (changedKeys.indexOf('name') !== -1) {
                if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM)
                    return;
                column.headingTransform = function (heading) {
                    return heading;
                };
            }
            changedKeys.forEach(function (key) {
                return (column[key] = col[key]);
            });
            return item;
        });
    });

    // add headers
    var headers = {};
    if (options.showHeaders) {
        columnNames.forEach(function (columnName) {
            var column = columns[columnName];

            if (!column.showHeaders) {
                headers[columnName] = '';
                return;
            }

            headers[columnName] = column.headingTransform(column.name);
        });
        items.unshift(headers);
    }
    // get actual max-width between min & max
    // based on length of data in columns
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        column.width = items
            .map(function (item) {
                return item[columnName];
            })
            .reduce(function (min, cur) {
                // if already at maxWidth don't bother testing
                if (min >= column.maxWidth) return min;
                return Math.max(
                    min,
                    Math.min(
                        column.maxWidth,
                        Math.max(column.minWidth, width(cur)),
                    ),
                );
            }, 0);
    });

    // split long words so they can break onto multiple lines
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        items = items.map(function (item) {
            item[columnName] = splitLongWords$1(
                item[columnName],
                column.width,
                column.truncateMarker,
            );
            return item;
        });
    });

    // wrap long lines. each item is now an array of lines.
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        items = items.map(function (item, index) {
            var cell = item[columnName];
            item[columnName] = splitIntoLines$1(cell, column.width);

            // if truncating required, only include first line + add truncation char
            if (column.truncate && item[columnName].length > 1) {
                item[columnName] = splitIntoLines$1(
                    cell,
                    column.width - width(column.truncateMarker),
                );
                var firstLine = item[columnName][0];
                if (!endsWith(firstLine, column.truncateMarker))
                    item[columnName][0] += column.truncateMarker;
                item[columnName] = item[columnName].slice(0, 1);
            }
            return item;
        });
    });

    // recalculate column widths from truncated output/lines
    columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        column.width = items
            .map(function (item) {
                return item[columnName].reduce(function (min, cur) {
                    if (min >= column.maxWidth) return min;
                    return Math.max(
                        min,
                        Math.min(
                            column.maxWidth,
                            Math.max(column.minWidth, width(cur)),
                        ),
                    );
                }, 0);
            })
            .reduce(function (min, cur) {
                if (min >= column.maxWidth) return min;
                return Math.max(
                    min,
                    Math.min(column.maxWidth, Math.max(column.minWidth, cur)),
                );
            }, 0);
    });

    var rows = createRows(items, columns, columnNames, options.paddingChr); // merge lines into rows
    // conceive output
    return rows
        .reduce(function (output, row) {
            return output.concat(
                row.reduce(function (rowOut, line) {
                    return rowOut.concat(line.join(options.columnSplitter));
                }, []),
            );
        }, [])
        .map(function (line) {
            return truncateString$1(line, maxLineWidth);
        })
        .join(options.spacing);
};

/**
 * Convert wrapped lines into rows with padded values.
 *
 * @param Array items data to process
 * @param Array columns column width settings for wrapping
 * @param Array columnNames column ordering
 * @return Array items wrapped in arrays, corresponding to lines
 */

function createRows(items, columns, columnNames, paddingChr) {
    return items.map(function (item) {
        var row = [];
        var numLines = 0;
        columnNames.forEach(function (columnName) {
            numLines = Math.max(numLines, item[columnName].length);
        });
        // combine matching lines of each rows

        var _loop = function _loop(i) {
            row[i] = row[i] || [];
            columnNames.forEach(function (columnName) {
                var column = columns[columnName];
                var val = item[columnName][i] || ''; // || '' ensures empty columns get padded
                if (column.align === 'right')
                    row[i].push(padLeft$1(val, column.width, paddingChr));
                else if (column.align === 'center' || column.align === 'centre')
                    row[i].push(padCenter$1(val, column.width, paddingChr));
                else row[i].push(padRight$1(val, column.width, paddingChr));
            });
        };

        for (var i = 0; i < numLines; i++) {
            _loop(i);
        }
        return row;
    });
}

/**
 * Object.assign
 *
 * @return Object Object with properties mixed in.
 */

function mixin() {
    var _Object;

    if (Object.assign)
        return (_Object = Object).assign.apply(_Object, arguments);
    return ObjectAssign.apply(undefined, arguments);
}

function ObjectAssign(target, firstSource) {
    if (target === undefined || target === null)
        throw new TypeError('Cannot convert first argument to object');

    var to = Object(target);

    var hasPendingException = false;
    var pendingException;

    for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) continue;

        var keysArray = Object.keys(Object(nextSource));
        for (
            var nextIndex = 0, len = keysArray.length;
            nextIndex < len;
            nextIndex++
        ) {
            var nextKey = keysArray[nextIndex];
            try {
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== undefined && desc.enumerable)
                    to[nextKey] = nextSource[nextKey];
            } catch (e) {
                if (!hasPendingException) {
                    hasPendingException = true;
                    pendingException = e;
                }
            }
        }

        if (hasPendingException) throw pendingException;
    }
    return to;
}

/**
 * Adapted from String.prototype.endsWith polyfill.
 */

function endsWith(target, searchString, position) {
    position = position || target.length;
    position = position - searchString.length;
    var lastIndex = target.lastIndexOf(searchString);
    return lastIndex !== -1 && lastIndex === position;
}

function toArray(items, columnNames) {
    if (Array.isArray(items)) return items;
    var rows = [];
    for (var key in items) {
        var item = {};
        item[columnNames[0] || 'key'] = key;
        item[columnNames[1] || 'value'] = items[key];
        rows.push(item);
    }
    return rows;
}

let Matcher = class Matcher {
    constructor(menPrefs, womenPrefs) {
        this.menPrefs = menPrefs;
        this.womenPrefs = womenPrefs;
        this.men = _.keys(menPrefs);
        this.women = _.keys(womenPrefs);
        this.menFree = _.zipObject(
            this.men,
            _.map(this.men, (man) => true),
        );
        this.womenFree = _.zipObject(
            this.women,
            _.map(this.women, (woman) => true),
        );
        this.couples = {};
    }
    /* Return whether the woman prefer man1 over man2 */
    prefers(woman, man1, man2) {
        return (
            _.indexOf(this.womenPrefs[woman], man1) <
            _.indexOf(this.womenPrefs[woman], man2)
        );
    }
    /* Engage a couple <3 */
    engage(man, woman) {
        this.menFree[man] = false;
        this.womenFree[woman] = false;
        _.remove(this.menPrefs[man], (w) => w == woman); // Remove the woman that the man proposed to
        // Don't remove from women prefs since we're matching from men side
        this.couples[man] = woman;
    }
    /* Break up a couple... </3 :'( */
    breakup(man, woman) {
        this.menFree[man] = true;
        this.womenFree[woman] = true;
        // Don't do anything to the preferences of men or women since they've already proposed
        delete this.couples[man];
    }
    /* Return the first free man who still has someone left to propose to */
    nextMan() {
        return _.find(
            this.men,
            (man) => this.menFree[man] && this.menPrefs[man].length > 0,
        );
    }
    match() {
        const MAX_ITERATIONS = 1000;
        let count = 0;
        let man = this.nextMan();
        while (man) {
            // While there exists a free man who still has someone to propose to
            if (count > MAX_ITERATIONS) {
                console.log('Stable matching timed out!');
                return this.couples;
            }
            const woman = _.first(this.menPrefs[man]); // Get first woman on man's list
            if (this.womenFree[woman]) {
                // If woman is free, get engaged
                this.engage(man, woman);
            } else {
                // Else if woman prefers this man to her current, swap men
                const currentMan = _.findKey(this.couples, (w) => w == woman);
                if (this.prefers(woman, man, currentMan)) {
                    this.breakup(currentMan, woman);
                    this.engage(man, woman);
                } else {
                    _.remove(this.menPrefs[man], (w) => w == woman); // Record an unsuccessful proposal
                }
            }
            man = this.nextMan();
            count++;
        }
        return this.couples;
    }
};
Matcher = __decorate([profile], Matcher);

/* tslint:disable:variable-name */
var LogisticsNetwork_1;
const ALL_RESOURCE_TYPE_ERROR = `Improper logistics request: 'all' can only be used for store structure or tombstone!`;
const getDefaultLogisticsMemory = () => ({
    transporterCache: {},
});
/**
 * Logistics network: efficiently partners resource requests with transporters using a stable matching algorithm to
 * provide general-purpose resource transport. For a better explanation of how this system works, see my blog post:
 * https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/
 */
let LogisticsNetwork = (LogisticsNetwork_1 = class LogisticsNetwork {
    constructor(colony) {
        this.memory = Mem.wrap(
            colony.memory,
            'logisticsNetwork',
            getDefaultLogisticsMemory,
        );
        this.requests = [];
        this.targetToRequest = {};
        this.colony = colony;
        // this.transporters = _.filter(colony.getCreepsByRole(TransporterSetup.role),
        // 							 creep => !creep.spawning &&
        // 									  creep.carryCapacity >= LogisticsNetwork.settings.carryThreshold);
        this.buffers = _.compact([colony.storage, colony.terminal]);
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {},
        };
        // this.logisticPositions = {};
        // for (let room of this.colony.rooms) {
        // 	this.logisticPositions[room.name] = _.map([...room.storageUnits, ...room.links], s => s.pos);
        // }
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'logisticsNetwork',
            getDefaultLogisticsMemory,
        );
        this.requests = [];
        this.targetToRequest = {};
        this._matching = undefined;
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {},
        };
    }
    // Request and provide functions ===================================================================================
    /**
     * Request for resources to be deposited into this target
     */
    // @customProfile
    requestInput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (target.room != this.colony.room) {
            log.warning(
                `${target.ref} at ${target.pos.print} is outside colony room; shouldn't request!`,
            );
            return;
        }
        if (opts.resourceType == 'all') {
            log.warning(
                `Logistics request error: 'all' can only be used for output requests`,
            );
            return;
        }
        if (!opts.amount) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    // @customProfile
    requestOutput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });

        if (opts.resourceType == 'all' && !isResource(target)) {
            if (sumStore(target.store) == target.store.energy) {
                opts.resourceType = RESOURCE_ENERGY; // convert "all" requests to energy if that's all they have
            }
        }
        if (!opts.amount) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        opts.amount *= -1;
        opts.dAmountdt *= -1;
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        /*
        if(target.pos.roomName == 'W45N44' && !!target.deathTime) { // 8/2023 debug
            console.log('W45N44 target ',target.deathTime,target.pos.x,target.pos.y,this.requests[this.requests.length - 1].target.id,this.requests[this.requests.length - 1].amount);
        }
        */

        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Requests output for every mineral in a requestor object
     */
    // @customProfile
    requestOutputMinerals(target, opts = {}) {
        for (const [resourceType, amount] of target.store.contents) {
            if (resourceType == RESOURCE_ENERGY) continue;
            if (amount > 0) {
                opts.resourceType = resourceType;
                this.requestOutput(target, opts);
            }
        }
    }
    // @customProfile
    getInputAmount(target, resourceType) {
        // if (target instanceof DirectivePickup) {
        // 	return target.storeCapacity - sumStore(target.store);
        // } else
        if (isResource(target) || isTombstone(target) || isRuin(target)) {
            log.error(
                `Improper logistics request: should not request input for resource or tombstone!`,
            );
            return 0;
        }
        // @ts-ignore
        return target.store.getFreeCapacity(resourceType) || 0;
        // else if (isStoreStructure(target)) {
        // 	return target.storeCapacity - sumStore(target.store);
        // } else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
        // 	return target.energyCapacity - target.energy;
        // }
        // // else if (target instanceof Zerg) {
        // // 	return target.carryCapacity - sumStore(target.carry);
        // // }
        // else {
        // 	if (target instanceof StructureLab) {
        // 		if (resourceType == target.mineralType) {
        // 			return target.mineralCapacity - target.mineralAmount;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	} else if (target instanceof StructureNuker) {
        // 		if (resourceType == RESOURCE_GHODIUM) {
        // 			return target.ghodiumCapacity - target.ghodium;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	} else if (target instanceof StructurePowerSpawn) {
        // 		if (resourceType == RESOURCE_POWER) {
        // 			return target.powerCapacity - target.power;
        // 		} else if (resourceType == RESOURCE_ENERGY) {
        // 			return target.energyCapacity - target.energy;
        // 		}
        // 	}
        // }
        // log.warning('Could not determine input amount!');
        // return 0;
    }
    // @customProfile
    getOutputAmount(target, resourceType) {
        if (resourceType == 'all') {
            if (isResource(target)) {
                log.error(ALL_RESOURCE_TYPE_ERROR);
                return 0;
            } else {
                // @ts-ignore
                return target.store.getUsedCapacity();
            }
        } else {
            if (isResource(target)) {
                return target.amount;
            } else {
                // @ts-ignore
                return target.store.getUsedCapacity(resourceType);
            }
            // Legacy code
            // else if (isTombstone(target)) {
            // 	return target.store[resourceType] || 0;
            // } else if (isStoreStructure(target)) {
            // 	return target.store[resourceType] || 0;
            // } else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
            // 	return target.energy;
            // }
            // // else if (target instanceof Zerg) {
            // // 	return target.carry[resourceType]!;
            // // }
            // else {
            // 	if (target instanceof StructureLab) {
            // 		if (resourceType == target.mineralType) {
            // 			return target.mineralAmount;
            // 		} else if (resourceType == RESOURCE_ENERGY) {
            // 			return target.energy;
            // 		}
            // 	} else if (target instanceof StructureNuker) {
            // 		if (resourceType == RESOURCE_GHODIUM) {
            // 			return target.ghodium;
            // 		} else if (resourceType == RESOURCE_ENERGY) {
            // 			return target.energy;
            // 		}
            // 	} else if (target instanceof StructurePowerSpawn) {
            // 		if (resourceType == RESOURCE_POWER) {
            // 			return target.power;
            // 		} else if (resourceType == RESOURCE_ENERGY) {
            // 			return target.energy;
            // 		}
            // 	}
            // }
        }
        // log.warning('Could not determine output amount!');
        // return 0;
    }
    // Transporter availability and predictive functions ===============================================================
    // @customProfile
    computeNextAvailability(transporter) {
        if (transporter.task) {
            let approximateDistance = transporter.task.eta;
            let pos = transporter.pos;
            const targetPositions = transporter.task.targetPosManifest;
            // If there is a well-defined task ETA, use that as the first leg, else set dist to zero and use range
            if (approximateDistance) {
                for (const targetPos of targetPositions.slice(1)) {
                    // The path lengths between any two logistics targets should be well-memorized
                    approximateDistance += Math.ceil(
                        pos.getMultiRoomRangeTo(targetPos) *
                            LogisticsNetwork_1.settings.rangeToPathHeuristic,
                    );
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            } else {
                // This probably shouldn't happen...
                approximateDistance = 0;
                for (const targetPos of targetPositions) {
                    approximateDistance += Math.ceil(
                        pos.getMultiRoomRangeTo(targetPos) *
                            LogisticsNetwork_1.settings.rangeToPathHeuristic,
                    );
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            }
            return [approximateDistance, pos];
        } else {
            // Report the transporter as being near a logistics target so that Pathing.distance() won't waste CPU
            // let nearbyLogisticPositions = transporter.pos.findInRange(this.logisticPositions[transporter.room.name], 2);
            return [0, transporter.pos];
        }
    }
    /**
     * Number of ticks until the transporter is available and where it will be
     */
    // @customProfile
    nextAvailability(transporter) {
        if (!this.cache.nextAvailability[transporter.name]) {
            this.cache.nextAvailability[
                transporter.name
            ] = this.computeNextAvailability(transporter);
        }
        return this.cache.nextAvailability[transporter.name];
    }
    // @customProfile
    static targetingTransporters(target, excludedTransporter) {
        const targetingZerg = _.map(
            target.targetedBy,
            (name) => Overmind.zerg[name],
        );
        const targetingTransporters = _.filter(
            targetingZerg,
            (zerg) => zerg && zerg.roleName == Roles.transport,
        );
        if (excludedTransporter) {
            _.remove(
                targetingTransporters,
                (transporter) => transporter.name == excludedTransporter.name,
            );
        }
        return targetingTransporters;
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its current task
     */
    // @customProfile
    computePredictedTransporterCarry(transporter, nextAvailability) {
        /*
        _.forEach(this.requests,request=>{
            if(request && request.target && isTombstone(request.target) && request.target.pos.roomName =='W45N44') {
            console.log('W45N44  computePredictedTransporterCarry for tombstone ',request.target.pos.roomName,request.target.pos.x,request.target.pos.y); //8/2023 debug
            }
        })
        */
        if (transporter.task && transporter.task.target) {
            const requestID = this.targetToRequest[transporter.task.target.ref];
            if (requestID) {
                const request = this.requests[requestID];
                if (request) {
                    const carry = storeIndex(transporter.carry);
                    const remainingCapacity =
                        transporter.carryCapacity - _.sum(carry);
                    const resourceAmount =
                        -1 *
                        this.predictedRequestAmount(
                            transporter,
                            request,
                            nextAvailability,
                        );
                    // ^ need to multiply amount by -1 since transporter is doing complement of what request needs
                    if (request.resourceType == 'all') {
                        if (isResource(request.target)) {
                            log.error(ALL_RESOURCE_TYPE_ERROR);
                            return { energy: 0 };
                        }
                        for (const [resourceType, storeAmt] of request.target
                            .store.contents) {
                            const resourceFraction =
                                storeAmt / sumStore(request.target.store);
                            if (carry[resourceType]) {
                                carry[resourceType] +=
                                    resourceAmount * resourceFraction;
                                carry[resourceType] = minMax(
                                    carry[resourceType],
                                    0,
                                    remainingCapacity,
                                );
                            } else {
                                carry[resourceType] = minMax(
                                    resourceAmount,
                                    0,
                                    remainingCapacity,
                                );
                            }
                        }
                    } else {
                        if (carry[request.resourceType]) {
                            carry[request.resourceType] += resourceAmount;
                            carry[request.resourceType] = minMax(
                                carry[request.resourceType],
                                0,
                                remainingCapacity,
                            );
                        } else {
                            carry[request.resourceType] = minMax(
                                resourceAmount,
                                0,
                                remainingCapacity,
                            );
                        }
                    }
                    return carry;
                }
            }
        }
        return storeIndex(transporter.carry);
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its task
     */
    // @customProfile
    predictedTransporterCarry(transporter) {
        if (!this.cache.predictedTransporterCarry[transporter.name]) {
            this.cache.predictedTransporterCarry[
                transporter.name
            ] = this.computePredictedTransporterCarry(transporter);
        }
        return this.cache.predictedTransporterCarry[transporter.name];
    }
    /**
     * Returns the effective amount that a transporter will see upon arrival, accounting for other targeting creeps
     */
    // @customProfile
    predictedRequestAmount(transporter, request, nextAvailability) {
        // Figure out when/where the transporter will be free
        let busyUntil;
        let newPos;
        if (!nextAvailability) {
            [busyUntil, newPos] = this.nextAvailability(transporter);
        } else {
            [busyUntil, newPos] = nextAvailability;
        }
        // let eta = busyUntil + Pathing.distance(newPos, request.target.pos);
        const eta =
            busyUntil +
            LogisticsNetwork_1.settings.rangeToPathHeuristic *
                newPos.getMultiRoomRangeTo(request.target.pos);
        const predictedDifference = request.dAmountdt * eta; // dAmountdt has same sign as amount
        // Account for other transporters targeting the target
        const otherTargetingTransporters = LogisticsNetwork_1.targetingTransporters(
            request.target,
            transporter,
        );
        // let closerTargetingTransporters = _.filter(otherTargetingTransporters,
        // 										   transporter => this.nextAvailability(transporter)[0] < eta);
        if (request.amount > 0) {
            // input state, resources into target
            let predictedAmount = request.amount + predictedDifference;
            // if (isStoreStructure(request.target)) { 	// cap predicted amount at storeCapacity
            // 	predictedAmount = Math.min(predictedAmount, request.target.storeCapacity);
            // } else if (isEnergyStructure(request.target)) {
            // 	predictedAmount = Math.min(predictedAmount, request.target.energyCapacity);
            // }
            if (!isResource(request.target)) {
                predictedAmount = minMax(
                    predictedAmount,
                    0,
                    // todo fix this
                    // @ts-ignore
                    request.target.store.getCapacity(request.resourceType),
                );
            }
            const resourceInflux = _.sum(
                _.map(
                    otherTargetingTransporters,
                    (other) => other.carry[request.resourceType] || 0,
                ),
            );
            predictedAmount = Math.max(predictedAmount - resourceInflux, 0);
            return predictedAmount;
        } else {
            // output state, resources withdrawn from target
            let predictedAmount = request.amount + predictedDifference;
            // if (isStoreStructure(request.target)) { 	// cap predicted amount at -1 * storeCapacity
            // 	predictedAmount = Math.max(predictedAmount, -1 * request.target.storeCapacity);
            // } else if (isEnergyStructure(request.target)) {
            // 	predictedAmount = Math.min(predictedAmount, -1 * request.target.energyCapacity);
            // }
            if (isTombstone(request.target)) {
                // zGENERAL MAJOR FIX FOR TOMBSTONES 8/2023
                predictedAmount = minMax(
                    predictedAmount,
                    // todo fix this
                    // @ts-ignore
                    -1 * request.target.store[request.resourceType],
                    0,
                );
            } else if (!isResource(request.target)) {
                predictedAmount = minMax(
                    predictedAmount,
                    // todo fix this
                    // @ts-ignore
                    -1 * request.target.store.getCapacity(request.resourceType),
                    0,
                );
            }
            const resourceOutflux = _.sum(
                _.map(
                    otherTargetingTransporters,
                    (other) => other.carryCapacity - sumStore(other.carry),
                ),
            );
            predictedAmount = Math.min(predictedAmount + resourceOutflux, 0);
            return predictedAmount;
        }
    }
    // Functions for computing resource change rate ====================================================================
    /**
     * Consider all possibilities of buffer structures to visit on the way to fulfilling the request
     */
    // @customProfile
    bufferChoices(transporter, request) {
        const [ticksUntilFree, newPos] = this.nextAvailability(transporter);
        const choices = [];
        const amount = this.predictedRequestAmount(transporter, request, [
            ticksUntilFree,
            newPos,
        ]);

        let carry;
        if (!transporter.task || transporter.task.target != request.target) {
            // If you are not targeting the requestor, use predicted carry after completing current task
            carry = this.predictedTransporterCarry(transporter);
        } else {
            // If you are targeting the requestor, use current carry for computations
            carry = storeIndex(transporter.carry);
        }
        if (amount > 0) {
            // requestInput instance, needs refilling
            if (request.resourceType == 'all') {
                log.warning(
                    `Improper resourceType in bufferChoices! Type 'all' is only allowable for outputs!`,
                );
                return [];
            }
            // Change in resources if transporter goes straight to the input
            const dQ_direct = Math.min(
                amount,
                carry[request.resourceType] || 0,
            );
            // let dt_direct = Pathing.distance(newPos, request.target.pos) + ticksUntilFree;
            const dt_direct =
                ticksUntilFree +
                newPos.getMultiRoomRangeTo(request.target.pos) *
                    LogisticsNetwork_1.settings.rangeToPathHeuristic;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref,
            });
            if (
                (carry[request.resourceType] || 0) > amount ||
                _.sum(carry) == transporter.carryCapacity
            ) {
                return choices; // Return early if you already have enough resources to go direct or are already full
            }
            // Change in resources if transporter picks up resources from a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(
                    amount,
                    transporter.carryCapacity,
                    buffer.store[request.resourceType] || 0,
                );
                const dt_buffer =
                    newPos.getMultiRoomRangeTo(buffer.pos) *
                        LogisticsNetwork_1.settings.rangeToPathHeuristic +
                    (Pathing.distance(buffer.pos, request.target.pos) ||
                        Infinity) +
                    ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref,
                });
            }
        } else if (amount < 0) {
            // requestOutput instance, needs pickup
            // Change in resources if transporter goes straight to the output
            const remainingCarryCapacity =
                transporter.carryCapacity - _.sum(carry);
            const dQ_direct = Math.min(
                Math.abs(amount),
                remainingCarryCapacity,
            );
            const dt_direct =
                newPos.getMultiRoomRangeTo(request.target.pos) *
                    LogisticsNetwork_1.settings.rangeToPathHeuristic +
                ticksUntilFree;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref,
            });
            if (
                remainingCarryCapacity >= Math.abs(amount) ||
                remainingCarryCapacity == transporter.carryCapacity
            ) {
                // zGeneral 8/2023 test
                return choices; // Return early you have sufficient free space or are empty
            }
            // Change in resources if transporter drops off resources at a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(
                    Math.abs(amount),
                    transporter.carryCapacity,
                    buffer.storeCapacity - sumStore(buffer.store),
                );
                const dt_buffer =
                    newPos.getMultiRoomRangeTo(buffer.pos) *
                        LogisticsNetwork_1.settings.rangeToPathHeuristic +
                    (Pathing.distance(buffer.pos, request.target.pos) ||
                        Infinity) +
                    ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref,
                });
            }
            // if (store.resourceType == RESOURCE_ENERGY) {
            // 	// Only for when you're picking up more energy: check to see if you can put to available links
            // 	for (let link of this.colony.dropoffLinks) {
            // 		let linkDeltaResource = Math.min(Math.abs(amount), transporter.carryCapacity,
            // 			2 * link.energyCapacity);
            // 		let ticksUntilDropoff = Math.max(Pathing.distance(newPos, link.pos),
            // 										 this.colony.linkNetwork.getDropoffAvailability(link));
            // 		let linkDistance = ticksUntilDropoff +
            // 						   Pathing.distance(link.pos, store.target.pos) + ticksUntilFree;
            // 		choices.push({
            // 						 deltaResource: linkDeltaResource,
            // 						 deltaTicks   : linkDistance,
            // 						 targetRef    : link.ref
            // 					 });
            // 	}
            // }
        }
        return choices;
    }
    /**
     * Compute the best possible value of |dResource / dt|
     */
    // @customProfile
    resourceChangeRate(transporter, request) {
        if (!this.cache.resourceChangeRate[request.id]) {
            this.cache.resourceChangeRate[request.id] = {};
        }
        if (!this.cache.resourceChangeRate[request.id][transporter.name]) {
            const choices = this.bufferChoices(transporter, request);
            const dQ_dt = _.map(
                choices,
                (choice) =>
                    (request.multiplier * choice.dQ) / Math.max(choice.dt, 0.1),
            );
            this.cache.resourceChangeRate[request.id][transporter.name] = _.max(
                dQ_dt,
            );
        }
        return this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Generate requestor preferences in terms of transporters
     */
    // @customProfile
    requestPreferences(request, transporters) {
        // Requestors priortize transporters by change in resources per tick until pickup/delivery
        return _.sortBy(
            transporters,
            (transporter) => -1 * this.resourceChangeRate(transporter, request),
        ); // -1 -> desc
    }
    /**
     * Generate transporter preferences in terms of store structures
     */
    // @customProfile
    transporterPreferences(transporter) {
        // Transporters prioritize requestors by change in resources per tick until pickup/delivery

        /*
        _.forEach(this.requests,request=>{
            if(request && request.target && isTombstone(request.target) && request.target.pos.roomName =='W45N44') {
            console.log('W45N44  transporterPreferences for tombstone ',request.target.pos.roomName,request.target.pos.x,request.target.pos.y); //8/2023 debug
            }
        })
        */

        let ret = _.sortBy(
            this.requests,
            (request) => -1 * this.resourceChangeRate(transporter, request),
        );
        let request = _.first(ret);

        return ret; // -1 -> desc
    }
    /**
     * Invalidates relevant portions of the cache once a transporter is assigned to a task
     */
    invalidateCache(transporter, request) {
        delete this.cache.nextAvailability[transporter.name];
        delete this.cache.predictedTransporterCarry[transporter.name];
        delete this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Logs the output of the stable matching result
     */
    summarizeMatching() {
        const requests = this.requests.slice();
        const transporters = _.filter(
            this.colony.getCreepsByRole(Roles.transport),
            (creep) => !creep.spawning,
        );
        const unmatchedTransporters = _.remove(
            transporters,
            (transporter) => !_.keys(this._matching).includes(transporter.name),
        );
        const unmatchedRequests = _.remove(
            requests,
            (request) => !_.values(this._matching).includes(request),
        );
        console.log(`Stable matching for ${this.colony.name} at ${Game.time}`);
        for (const transporter of transporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            const request = this._matching[transporter.name];
            const requestStr =
                request.target.ref + ' ' + request.target.pos.print;
            console.log(`${transporterStr.padRight(30)} : ${requestStr}`);
        }
        for (const transporter of unmatchedTransporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            console.log(`${transporterStr.padRight(30)} : ${''}`);
        }
        for (const request of unmatchedRequests) {
            const requestStr = request.target.ref + ' ' + request.target.pos;
            console.log(`${''.padRight(30)} : ${requestStr}`);
        }
        console.log();
    }
    /**
     * Logs the current state of the logistics group to the console; useful for debugging
     */
    summarize() {
        /*
        _.forEach(this.requests,request=>{
            if(request && request.target && isTombstone(request.target) && request.target.pos.roomName =='W45N44') {
            console.log('W45N44  summarize for tombstone ',request.target.pos.roomName,request.target.pos.x,request.target.pos.y); //8/2023 debug
            }
        })
        */
        // console.log(`Summary of logistics group for ${this.colony.name} at time ${Game.time}`);
        let info = [];
        for (const request of this.requests) {
            let targetType;
            if (isResource(request.target)) {
                targetType = 'resource';
            } else if (isTombstone(request.target)) {
                targetType = 'tombstone';
            } else if (isRuin(request.target)) {
                targetType = 'ruin';
            } else {
                targetType = request.target.structureType;
            }
            let amount = 0;
            if (isResource(request.target)) {
                amount = request.target.amount;
            } else {
                if (request.resourceType == 'all') {
                    if (!isResource(request.target)) {
                        amount = sumStore(request.target.store);
                    } else {
                        amount = -0.001;
                    }
                } else {
                    if (isResource(request.target)) {
                        amount = request.target.amount;
                    } else {
                        amount = request.target.store[request.resourceType];
                    }
                }
            }
            const targetingTprtrNames = _.map(
                LogisticsNetwork_1.targetingTransporters(request.target),
                (c) => c.name,
            );
            info.push({
                target: targetType,
                resourceType: request.resourceType,
                requestAmount: request.amount,
                currentAmount: amount,
                targetedBy: targetingTprtrNames,
                pos: request.target.pos.print,
            });
        }
        console.log('Requests: \n' + columnify(info) + '\n');
        info = [];
        for (const transporter of this.colony.overlords.logistics
            .transporters) {
            const task = transporter.task ? transporter.task.name : 'none';
            const target = transporter.task
                ? transporter.task.proto._target.ref +
                  ' ' +
                  transporter.task.targetPos.printPlain
                : 'none';
            const nextAvailability = this.nextAvailability(transporter);
            info.push({
                creep: transporter.name,
                pos: transporter.pos.printPlain,
                task: task,
                target: target,
                availability: `available in ${nextAvailability[0]} ticks at ${nextAvailability[1].print}`,
            });
        }
        console.log('Transporters: \n' + columnify(info) + '\n');
    }
    get matching() {
        if (!this._matching) {
            this._matching = this.stableMatching(
                this.colony.overlords.logistics.transporters,
            );
        }
        return this._matching;
    }
    /**
     * Generate a stable matching of transporters to requests with Gale-Shapley algorithm
     */
    stableMatching(transporters) {
        /*
        _.forEach(this.requests,request=>{
            if(request && request.target && isTombstone(request.target) && request.target.pos.roomName =='W45N44') {
            console.log('W45N44  stableMatching for tombstone ',request.target.pos.roomName,request.target.pos.x,request.target.pos.y); //8/2023 debug
            }
        })
        */
        const tPrefs = {};
        for (const transporter of transporters) {
            tPrefs[transporter.name] = _.map(
                this.transporterPreferences(transporter),
                (request) => request.id,
            );
        }
        const rPrefs = {};
        for (const request of this.requests) {
            rPrefs[request.id] = _.map(
                this.requestPreferences(request, transporters),
                (transporter) => transporter.name,
            );
        }
        const stableMatching = new Matcher(tPrefs, rPrefs).match();
        const requestMatch = _.mapValues(stableMatching, (reqID) =>
            _.find(this.requests, (request) => request.id == reqID),
        );
        return requestMatch;
    }
});
LogisticsNetwork.settings = {
    flagDropAmount: 1000,
    rangeToPathHeuristic: 1.1,
    carryThreshold: 800,
    droppedEnergyThreshold: 200,
};
LogisticsNetwork = LogisticsNetwork_1 = __decorate([profile], LogisticsNetwork);

var RoadLogistics_1;
const ROAD_CACHE_TIMEOUT = 25;
/**
 * RoadLogistics: groups roads in a single object for more intelligent repair requests
 */
let RoadLogistics = (RoadLogistics_1 = class RoadLogistics {
    constructor(colony) {
        this.colony = colony;
        this.ref = this.colony.name + ':roadLogistics';
        this._assignedWorkers = {};
    }
    refresh() {
        this._assignedWorkers = {};
    }
    /**
     * Whether a road in the network needs repair
     */
    workerShouldRepaveRoom(worker, room) {
        // Room should be repaved if there is a road with critical HP or if energy to repave >= worker carry capacity
        const otherAssignedWorkers = _.filter(
            this.assignedWorkers(room),
            (name) => name != worker.name,
        );
        if (
            otherAssignedWorkers.length <
            RoadLogistics_1.settings.allowedPaversPerRoom
        ) {
            if (this.assignedWorkers(room).includes(worker.name)) {
                // If worker is already working in the room, have it repair until all roads are at acceptable level
                return this.repairableRoads(room).length > 0;
            } else {
                // If worker is not already assigned, repair if critical roads or repaving energy >= carry capacity
                return (
                    this.criticalRoads(room).length > 0 // || //zGeneral 2/2024
                    // this.energyToRepave(room.name) >= worker.carryCapacity //zGeneral 2/2024
                );
            }
        } else {
            return false;
        }
    }
    /**
     * Get the room the worker should repave, if any
     */
    workerShouldRepave(worker) {
        // If the worker is already working in a room and should keep doing so, return that first
        if (worker.task && worker.task.name == repairTaskName) {
            const room = Game.rooms[worker.task.targetPos.roomName];
            if (
                room &&
                this.assignedWorkers(room).includes(worker.name) &&
                this.workerShouldRepaveRoom(worker, room)
            ) {
                return room;
            }
        }
        // Otherwise scan through rooms and see if needs repaving
        for (const room of this.colony.rooms) {
            if (
                this.colony.isRoomActive(room.name) &&
                room.isSafe &&
                this.workerShouldRepaveRoom(worker, room)
            ) {
                return room;
            }
        }
    }
    criticalRoads(room) {
        return $.structures(
            this,
            'criticalRoads:' + room.name,
            () => {
                const criticalRoads = _.filter(
                    room.roads,
                    (road) =>
                        road.hits <
                            road.hitsMax *
                                RoadLogistics_1.settings.criticalThreshold &&
                        this.colony.roomPlanner.roadShouldBeHere(road.pos),
                );
                return _.sortBy(criticalRoads, (road) =>
                    road.pos.getMultiRoomRangeTo(this.colony.pos),
                );
            },
            ROAD_CACHE_TIMEOUT,
        );
    }
    repairableRoads(room) {
        return $.structures(
            this,
            'repairableRoads:' + room.name,
            () => {
                const repairRoads = _.filter(
                    room.roads,
                    (road) =>
                        road.hits <
                            road.hitsMax *
                                RoadLogistics_1.settings.repairThreshold &&
                        this.colony.roomPlanner.roadShouldBeHere(road.pos),
                );
                return _.sortBy(repairRoads, (road) =>
                    road.pos.getMultiRoomRangeTo(this.colony.pos),
                );
            },
            ROAD_CACHE_TIMEOUT,
        );
    }
    unbuiltRoads(room) {
        return $.list(
            this,
            'repairableRoads:' + room.name,
            () => {
                const roadPositions = this.colony.roomPlanner.roadPlanner.getRoadPositions(
                    room.name,
                );
                const unbuiltPositions = _.filter(
                    roadPositions,
                    (pos) => !pos.lookForStructure(STRUCTURE_ROAD),
                );
                return _.sortBy(unbuiltPositions, (pos) =>
                    pos.getMultiRoomRangeTo(this.colony.pos),
                );
            },
            ROAD_CACHE_TIMEOUT,
        );
    }
    /**
     * Total amount of energy needed to repair all roads in the room and build all needed roads
     */
    energyToRepave(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return $.number(
                this,
                'energyToRepave:' + room.name,
                () => {
                    const repairEnergy =
                        _.sum(
                            this.repairableRoads(room),
                            (road) => road.hitsMax - road.hits,
                        ) / REPAIR_POWER;
                    const terrain = room.getTerrain();
                    const buildEnergy =
                        _.sum(this.unbuiltRoads(room), (pos) => {
                            if (
                                terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP
                            ) {
                                return (
                                    CONSTRUCTION_COST.road *
                                    CONSTRUCTION_COST_ROAD_SWAMP_RATIO
                                );
                            } else if (
                                terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL
                            ) {
                                return (
                                    CONSTRUCTION_COST.road *
                                    CONSTRUCTION_COST_ROAD_WALL_RATIO
                                );
                            } else {
                                return CONSTRUCTION_COST.road;
                            }
                        }) / BUILD_POWER;
                    return repairEnergy + buildEnergy;
                },
                ROAD_CACHE_TIMEOUT,
            );
        } else {
            const cached = $.numberRecall(this, 'energyToRepave:' + roomName);
            if (cached) {
                return cached;
            } else {
                return 0;
            }
        }
    }
    /**
     * Check that the worker is in the assignedWorker cache; avoids bugs where duplicate workers get assigned
     * on the same tick
     */
    registerWorkerAssignment(worker, room) {
        if (this._assignedWorkers[room.name]) {
            if (!this._assignedWorkers[room.name].includes(worker.name)) {
                this._assignedWorkers[room.name].push(worker.name);
            }
        } else {
            this._assignedWorkers[room.name] = [worker.name];
        }
    }
    assignedWorkers(room) {
        return this._assignedWorkers[room.name] || [];
    }
    init() {
        const workers = this.colony.overlords.work.workers;
        for (const worker of workers) {
            if (worker.task && worker.task.name == repairTaskName) {
                const roomName = worker.task.targetPos.roomName;
                if (!this._assignedWorkers[roomName]) {
                    this._assignedWorkers[roomName] = [];
                }
                this._assignedWorkers[roomName].push(worker.name);
            }
        }
    }
    buildPavingManifest(worker, room) {
        let energy = worker.carry.energy;
        const targetRefs = {};
        const tasks = [];
        let target;
        let previousPos;
        while (true) {
            if (energy <= 0) break;
            if (previousPos) {
                target = _.find(
                    this.repairableRoads(room),
                    (road) =>
                        road.hits < road.hitsMax &&
                        !targetRefs[road.id] &&
                        road.pos.getRangeTo(previousPos) <= 1,
                );
            } else {
                target = _.find(
                    this.repairableRoads(room),
                    (road) => road.hits < road.hitsMax && !targetRefs[road.id],
                );
            }
            if (target) {
                previousPos = target.pos;
                targetRefs[target.id] = true;
                energy -= (target.hitsMax - target.hits) / REPAIR_POWER;
                tasks.push(Tasks.repair(target));
            } else {
                break;
            }
        }
        return Tasks.chain(tasks);
    }
    run() {}
});
RoadLogistics.settings = {
    allowedPaversPerRoom: 1,
    criticalThreshold: 0.25,
    repairThreshold: 0.9,
};
RoadLogistics = RoadLogistics_1 = __decorate([profile], RoadLogistics);

/**
 * This overlord contains the default actions for any creeps which lack an overlord (for example, miners whose
 * miningSite is no longer visible, or guards with no directive)
 */
let DefaultOverlord = class DefaultOverlord extends Overlord {
    constructor(colony) {
        super(colony, 'default', OverlordPriority.default);
        this.idleZerg = [];
    }
    init() {
        // Zergs are collected at end of init phase; by now anything needing to be claimed already has been
        const idleCreeps = _.filter(
            this.colony.creeps,
            (creep) => !getOverlord(creep),
        );
        this.idleZerg = _.map(
            idleCreeps,
            (creep) => Overmind.zerg[creep.name] || new Zerg(creep),
        );
        for (const zerg of this.idleZerg) {
            zerg.refresh();
        }
    }
    run() {}
};
DefaultOverlord = __decorate([profile], DefaultOverlord);

/**
 * The transport overlord handles energy transport throughout a colony
 */
let TransportOverlord = class TransportOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.transport) {
        super(colony, 'logistics', priority);
        this.transporters = this.zerg(Roles.transport);
    }
    neededTransportPower() {
        if (
            !this.colony.storage &&
            !(this.colony.hatchery && this.colony.hatchery.battery) &&
            !this.colony.upgradeSite.battery
        ) {
            return 0;
        }
        let transportPower = 0;
        const scaling = 2; // this.colony.stage == ColonyStage.Larva ? 1.5 : 2.0; // aggregate round-trip multiplier
        // Add contributions to transport power from hauling energy from mining sites
        for (const flagName in this.colony.miningSites) {
            const o = this.colony.miningSites[flagName].overlords.mine;
            if (!o.isSuspended && o.miners.length > 0) {
                if (
                    Cartographer.roomType(Game.flags[flagName].pos.roomName) ==
                    ROOMTYPE_SOURCEKEEPER
                ) {
                    // zGeneral 8/2023 adjust for skroom
                    transportPower +=
                        o.energyPerTick * scaling * o.distance * 1.0;
                }
                // Only count sites which have a container output and which have at least one miner present
                // (this helps in difficult "rebooting" situations)
                else if ((o.container && !o.link) || o.allowDropMining) {
                    transportPower += o.energyPerTick * scaling * o.distance;
                }
            }
        }
        // Add transport power needed to move to upgradeSite
        if (this.colony.upgradeSite.battery) {
            transportPower +=
                UPGRADE_CONTROLLER_POWER *
                this.colony.upgradeSite.upgradePowerNeeded *
                scaling *
                (Pathing.distance(
                    this.colony.pos,
                    this.colony.upgradeSite.battery.pos,
                ) || 0);
        }
        if (this.colony.state.lowPowerMode) {
            // Reduce needed transporters when colony is in low power mode
            transportPower *= 0.5;
        }
        return transportPower / CARRY_CAPACITY;
    }
    init() {
        const ROAD_COVERAGE_THRESHOLD = 0.75; // switch from 1:1 to 2:1 transporters above this coverage threshold
        const setup =
            this.colony.roomPlanner.roadPlanner.roadCoverage <
            ROAD_COVERAGE_THRESHOLD
                ? Setups.transporters.default // early zGeneral 3/2024
                : Setups.transporters.default;
        const transportPowerEach = setup.getBodyPotential(CARRY, this.colony);
        const neededTransportPower = this.neededTransportPower();
        let numTransporters = Math.ceil(
            neededTransportPower / transportPowerEach + 0.1,
        ); // div by zero error // zGeneral 7/2023 add an extra transporter
        if (neededTransportPower === 0) {
            numTransporters = 0;
        }
        if (this.transporters.length == 0) {
            this.wishlist(numTransporters, setup, {
                priority: OverlordPriority.ownedRoom.firstTransport,
            });
        } else {
            this.wishlist(numTransporters, setup);
        }
    }
    handleTransporter(transporter, request) {
        /*
        if(request && request.target && isTombstone(request.target) && request.target.pos.roomName =='W45N44') {
            console.log('W45N44  transporter going for tombstone ',request.target.pos.x,request.target.pos.y); //8/2023 debug
        }
        */
        if (transporter.hits < transporter.hitsMax * 0.8) {
            transporter.goToRoom(transporter.memory.C);
            return;
        }
        if (request) {
            const choices = this.colony.logisticsNetwork.bufferChoices(
                transporter,
                request,
            );
            const bestChoice = _.last(
                _.sortBy(
                    choices,
                    (choice) =>
                        (request.multiplier * choice.dQ) /
                        Math.max(choice.dt, 0.1),
                ),
            );
            let task = null;
            const amount = this.colony.logisticsNetwork.predictedRequestAmount(
                transporter,
                request,
            );
            // Target is requesting input
            if (amount > 0) {
                if (isResource(request.target) || isTombstone(request.target)) {
                    log.warning(
                        `Improper logistics request: should not request input for resource or tombstone!`,
                    );
                    return;
                } else if (request.resourceType == 'all') {
                    log.error(`${this.print}: cannot request 'all' as input!`);
                    return;
                } else {
                    task = Tasks.transfer(request.target, request.resourceType);
                }
                if (bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to get more stuff
                    const buffer = deref(bestChoice.targetRef);
                    const withdrawAmount = Math.min(
                        buffer.store[request.resourceType] || 0,
                        transporter.carryCapacity - sumStore(transporter.carry),
                        amount,
                    );
                    task = task.fork(
                        Tasks.withdraw(
                            buffer,
                            request.resourceType,
                            withdrawAmount,
                        ),
                    );
                    if (
                        transporter.hasMineralsInCarry &&
                        request.resourceType == RESOURCE_ENERGY
                    ) {
                        task = task.fork(Tasks.transferAll(buffer));
                    }
                }
            }
            // Target is requesting output
            else if (amount < 0) {
                if (isResource(request.target)) {
                    task = Tasks.pickup(request.target);
                } else {
                    //if(request && request.target && isTombstone(request.target)) {
                    //console.log('transporter going for tombstone ',request.target.pos.roomName,request.target.pos.x,request.target.pos.y); //8/2023 debug
                    //}
                    if (request.resourceType == 'all') {
                        if (isResource(request.target)) {
                            log.error(this.print + ALL_RESOURCE_TYPE_ERROR);
                            return;
                        }
                        task = Tasks.withdrawAll(request.target);
                    } else {
                        task = Tasks.withdraw(
                            request.target,
                            request.resourceType,
                        );
                    }
                }
                if (task && bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to deposit stuff
                    const buffer = deref(bestChoice.targetRef);
                    task = task.fork(Tasks.transferAll(buffer));
                }
            } else {
                // console.log(`${transporter.name} chooses a store with 0 amount!`);
                transporter.park();
            }
            // Assign the task to the transporter
            transporter.task = task;
            this.colony.logisticsNetwork.invalidateCache(transporter, request);
        } else {
            // If nothing to do, put everything in a store structure
            if (sumStore(transporter.carry) > 0) {
                if (transporter.hasMineralsInCarry) {
                    const target = this.colony.terminal || this.colony.storage;
                    if (target) {
                        transporter.task = Tasks.transferAll(target);
                    }
                } else {
                    const dropoffPoints = _.compact([this.colony.storage]);
                    // , ...this.colony.dropoffLinks]);
                    // let bestDropoffPoint = minBy(dropoffPoints, function(dropoff: StructureLink | StructureStorage) {
                    // 	let range = transporter.pos.getMultiRoomRangeTo(dropoff.pos);
                    // 	if (dropoff instanceof StructureLink) {
                    // 		return Math.max(range, this.colony.linkNetwork.getDropoffAvailability(dropoff));
                    // 	} else {
                    // 		return range;
                    // 	}
                    // });
                    const bestDropoffPoint = transporter.pos.findClosestByMultiRoomRange(
                        dropoffPoints,
                    );
                    if (bestDropoffPoint) {
                        transporter.task = Tasks.transfer(bestDropoffPoint);
                    }
                }
            } else {
                let parkingSpot = transporter.pos;
                if (this.colony.storage) {
                    parkingSpot = this.colony.storage.pos;
                } else if (this.colony.roomPlanner.storagePos) {
                    parkingSpot = this.colony.roomPlanner.storagePos;
                }
                transporter.park(parkingSpot);
            }
        }
        // console.log(JSON.stringify(transporter.memory.task));
    }
    handleBigTransporter(bigTransporter) {
        const bestRequestViaStableMatching = this.colony.logisticsNetwork
            .matching[bigTransporter.name];
        this.handleTransporter(bigTransporter, bestRequestViaStableMatching);
    }
    /* Handles small transporters, which don't do well with the logisticsNetwork's stable matching system */
    handleSmolTransporter(smolTransporter) {
        // if(this.transporterShortCircuit(smolTransporter)) return;
        // Just perform a single-sided greedy selection of all requests
        const bestRequestViaGreedy = _.first(
            this.colony.logisticsNetwork.transporterPreferences(
                smolTransporter,
            ),
        );
        this.handleTransporter(smolTransporter, bestRequestViaGreedy);
    }
    pickupDroppedResources(transporter) {
        const droppedResource = transporter.pos.lookFor(LOOK_RESOURCES)[0];
        if (droppedResource) {
            transporter.pickup(droppedResource);
            return;
        }
        const tombstone = transporter.pos.lookFor(LOOK_TOMBSTONES)[0];
        if (tombstone) {
            const resourceType = _.last(
                _.sortBy(
                    _.keys(tombstone.store),
                    (resourceType) => tombstone.store[resourceType] || 0,
                ),
            );
            transporter.withdraw(tombstone, resourceType);
        }
    }
    // @customProfile
    // private transporterShortCircuit(transporter: Zerg): boolean {
    // 	if(Cartographer.roomType(transporter.room.name) == ROOMTYPE_CORE
    // 	|| Cartographer.roomType(transporter.room.name) == ROOMTYPE_SOURCEKEEPER) return false;
    // 	// the below should only be executed if the transporter has no task
    // 	if (transporter.avoidDanger({dropEnergy: false})) return true;
    // 	if(transporter.room.isOutpost && !transporter.isFull()) {
    // 		const target = maxBy(transporter.room.rechargeables, (x: rechargeObjectType) => {
    // 			return isResource(x) ? x.amount : _.sum(x.store);
    // 		}) as StructureContainer;
    // 		if(target) {
    // 			if(transporter.pos.isNearTo(target)) {
    // 				if(!isResource(target)) {
    // 					const freeCapacity = transporter.carryCapacity - _.sum(transporter.carry);
    // 					if(_.sum(target.store) > 200 || freeCapacity < 200) {
    // 						transporter.task = Tasks.withdrawAll(target);
    // 					}
    // 				} else {
    // 					transporter.task = Tasks.pickup(target);
    // 				}
    // 				return true;
    // 			} else {
    // 				transporter.goTo(target,{range:1});
    // 				return true;
    // 			}
    // 		}
    // 		return false;
    // 	}
    // 	if(!transporter.isIdle && _.sum(transporter.carry) == 0 && transporter.room.name != this.colony.name) {
    // 		transporter.task = Tasks.goToRoom(this.colony.name);
    // 		return true;
    // 	}
    // 	if(transporter.isFull() && !transporter.inColonyRoom && this.colony.storage) {
    // 		transporter.task = Tasks.transferAll(this.colony.storage);
    // 		return true;
    // 	}
    // 	return false;
    // }
    run() {
        this.autoRun(this.transporters, (transporter) => this.handleSmolTransporter(transporter)); //zGeneral 8/2023
        /*
        this.autoRun(this.transporters, (transporter) => {
            if (
                transporter.store.getCapacity() > 1000 &&
                Game.cpu.bucket >= 9000
            ) {
                this.handleBigTransporter(transporter);
            } else {
                this.handleSmolTransporter(transporter);
            }
        });
        */
    }
};
__decorate(
    [customProfile],
    TransportOverlord.prototype,
    'handleSmolTransporter',
    null,
);
__decorate([customProfile], TransportOverlord.prototype, 'run', null);
TransportOverlord = __decorate([profile], TransportOverlord);

const DEFAULT_NUM_SCOUTS = 0;
/**
 * Sends out scouts which randomly traverse rooms to uncover possible expansion locations and gather intel
 */
let RandomWalkerScoutOverlord = class RandomWalkerScoutOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.scouting.randomWalker) {
        super(colony, 'randomWalkScout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    refresh() {
        super.refresh();
    }
    init() {
        if (
            Game.cpu.bucket < Memory.settings.bucketThresholds.randomWalkScouts
        ) {
            return;
        }
        this.wishlist(DEFAULT_NUM_SCOUTS, Setups.scout);
    }
    squashCSites(scout) {
        if (scout.room.my || scout.room.isAllyColony) {
            return false;
        }
        const enemyConstructionSites = scout.room.hostileConstructionSites.filter(
            (csite) =>
                !!Game.getObjectById(csite.id) &&
                csite.progress > 0 &&
                csite.pos.isWalkable(true),
        );
        const squashTarget = _.first(enemyConstructionSites);
        if (squashTarget) {
            scout.goTo(squashTarget);
            return true;
        }
        return false;
    }
    deadEnd(scout) {
        const indestructibleWalls = _.filter(
            scout.room.walls,
            (wall) => wall.hits == undefined,
        );
        if (indestructibleWalls.length > 0) {
            // go back to origin colony if you find a room near newbie zone
            scout.task = Tasks.goToRoom(this.colony.room.name); // todo: make this more precise
            return true;
        }
        return false;
    }
    handleScout(scout) {
        if (this.deadEnd(scout)) return;
        if (this.squashCSites(scout)) return;
        // Pick a new room
        const neighboringRooms = _.values(
            Game.map.describeExits(scout.pos.roomName),
        );
        const roomName = _.sample(neighboringRooms);
        if (
            RoomIntel.getRoomStatus(roomName).status ===
            RoomIntel.getMyZoneStatus()
        ) {
            scout.task = Tasks.goToRoom(roomName);
        }
    }
    run() {
        if (
            Game.cpu.bucket < Memory.settings.bucketThresholds.randomWalkScouts
        ) {
            return;
        }
        this.autoRun(this.scouts, (scout) => this.handleScout(scout));
    }
};
__decorate(
    [customProfile],
    RandomWalkerScoutOverlord.prototype,
    'refresh',
    null,
);
__decorate([customProfile], RandomWalkerScoutOverlord.prototype, 'init', null);
__decorate(
    [customProfile],
    RandomWalkerScoutOverlord.prototype,
    'squashCSites',
    null,
);
__decorate(
    [customProfile],
    RandomWalkerScoutOverlord.prototype,
    'deadEnd',
    null,
);
__decorate(
    [customProfile],
    RandomWalkerScoutOverlord.prototype,
    'handleScout',
    null,
);
__decorate([customProfile], RandomWalkerScoutOverlord.prototype, 'run', null);
RandomWalkerScoutOverlord = __decorate([profile], RandomWalkerScoutOverlord);

var ColonyStage;
(function (ColonyStage) {
    ColonyStage[(ColonyStage['Larva'] = 0)] = 'Larva';
    ColonyStage[(ColonyStage['Pupa'] = 1)] = 'Pupa';
    ColonyStage[(ColonyStage['Adult'] = 2)] = 'Adult';
})(ColonyStage || (ColonyStage = {}));
var DEFCON;
(function (DEFCON) {
    DEFCON[(DEFCON['safe'] = 0)] = 'safe';
    DEFCON[(DEFCON['invasionNPC'] = 1)] = 'invasionNPC';
    DEFCON[(DEFCON['boostedInvasionNPC'] = 2)] = 'boostedInvasionNPC';
    DEFCON[(DEFCON['playerInvasion'] = 2)] = 'playerInvasion';
    DEFCON[(DEFCON['bigPlayerInvasion'] = 3)] = 'bigPlayerInvasion';
})(DEFCON || (DEFCON = {}));
function getAllColonies() {
    return _.values(Overmind.colonies);
}
var OutpostDisableReason;
(function (OutpostDisableReason) {
    OutpostDisableReason['active'] = 'active';
    OutpostDisableReason['inactiveCPU'] = 'i_cpu';
    OutpostDisableReason['inactiveUpkeep'] = 'i_upkeep';
    OutpostDisableReason['inactiveHarassment'] = 'i_harassment';
    OutpostDisableReason['inactiveStronghold'] = 'i_stronghold';
})(OutpostDisableReason || (OutpostDisableReason = {}));
const getDefaultColonyMemory = () => ({
    defcon: {
        level: DEFCON.safe,
        tick: -Infinity,
    },
    expansionData: {
        possibleExpansions: {},
        expiration: 0,
    },
    maxLevel: 0,
    outposts: {},
});
/**
 * Colonies are the highest-level object other than the global Overmind. A colony groups together all rooms, structures,
 * creeps, utilities, etc. which are run from a single owned room.
 */
let Colony = class Colony {
    constructor(id, roomName, outposts) {
        // Primitive colony setup
        this.id = id;
        this.name = roomName;
        this.ref = roomName;
        this.memory = Mem.wrap(
            Memory.colonies,
            roomName,
            getDefaultColonyMemory,
        );
        // Format outpost state memory
        _.forEach(outposts, (outpost) => {
            if (!this.memory.outposts[outpost]) {
                this.memory.outposts[outpost] = { active: true };
            }
        });
        _.forEach(_.keys(_.clone(this.memory.outposts)), (roomName) => {
            if (!outposts.includes(roomName)) {
                delete this.memory.outposts[roomName];
            }
        });
        // Register colony globally to allow 'W1N1' and 'w1n1' to refer to Overmind.colonies.W1N1
        global[this.name] = this;
        global[this.name.toLowerCase()] = this;
        // Build the colony
        this.build(roomName, outposts);
    }
    /**
     * Pretty-print the colony name in the console
     */
    get print() {
        return (
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.room.name +
            '">[' +
            this.name +
            ']</a>'
        );
    }
    /**
     * Pretty-print the colony colony name right-padded with spaces to fit E**S** in the console
     */
    get printAligned() {
        const msg =
            '<a href="#!/room/' +
            Game.shard.name +
            '/' +
            this.room.name +
            '">[' +
            this.name +
            ']</a>';
        const extraSpaces = 'E12S34'.length - this.room.name.length;
        return msg + ' '.repeat(extraSpaces);
    }
    toString() {
        return this.print;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    /**
     * Builds the colony object
     */
    build(roomName, outposts) {
        // Register rooms
        this.room = Game.rooms[roomName];
        this.roomNames = [roomName].concat(outposts);
        // Register outposts
        this.outposts = _.compact(
            _.map(outposts, (outpost) => Game.rooms[outpost]),
        );
        this.rooms = [this.room].concat(this.outposts);
        this.miningSites = {}; // filled in by harvest directives
        this.extractionSites = {}; // filled in by extract directives
        // this.praiseSite = undefined;
        // Register creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(
            this.creeps,
            (creep) => creep.memory.role,
        );
        // Register the rest of the colony components; the order in which these are called is important!
        this.registerRoomObjects_cached(); // Register real colony components
        this.registerOperationalState(); // Set the colony operational state
        this.registerUtilities(); // Register logistics utilities, room planners, and layout info
        this.registerHiveClusters(); // Build the hive clusters
        /* Colony.spawnMoarOverlords() gets called from Overmind.ts, along with Directive.spawnMoarOverlords() */
    }
    /**
     * Refreshes the state of the colony object
     */
    refresh() {
        this.memory = Memory.colonies[this.room.name];
        // Refresh rooms
        this.room = Game.rooms[this.room.name];
        const outpostRoomNames = _.filter(
            this.roomNames,
            (roomName) => this.room.name != roomName,
        );
        this.outposts = _.compact(
            _.map(outpostRoomNames, (outpost) => Game.rooms[outpost]),
        );
        this.rooms = [this.room].concat(this.outposts);
        // refresh creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(
            this.creeps,
            (creep) => creep.memory.role,
        );
        // Register the rest of the colony components; the order in which these are called is important!
        this.refreshRoomObjects();
        this.registerOperationalState();
        this.refreshUtilities();
        this.refreshHiveClusters();
        // calc storage amount - save _.sum() results
        this.storageAmount = this.storage ? sumStore(this.storage.store) : 0;
        this.terminalAmount = this.terminal ? sumStore(this.terminal.store) : 0;
        this.assetsAmount = this.assets ? _.sum(this.assets) : 0;
    }
    /**
     * Registers physical game objects to the colony
     */
    registerRoomObjects() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = []; // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.spawns = _.sortBy(
            _.filter(this.room.spawns, (spawn) => spawn.my),
            (spawn) => spawn.ref,
        ); // zGeneral 8/2023 removed  && spawn.isActive() && from the condition
        this.extensions = this.room.extensions;
        this.storage =
            this.room.storage && this.room.controller.level > 3
                ? this.room.storage
                : undefined;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.terminal = this.room.terminal // zGeneral 8/2023 removed && this.room.terminal.isActive() from the condition
            ? this.room.terminal
            : undefined;
        this.factory = this.room.factory // zGeneral 8/2023 removed && this.room.factory.isActive() from the condition
            ? this.room.factory
            : undefined;
        this.towers = this.room.towers;
        this.labs = _.sortBy(
            _.filter(this.room.labs, (lab) => lab.my),
            (lab) => 50 * lab.pos.y + lab.pos.x,
        ); // Labs are sorted in reading order of positions // zGeneral 8/2023 removed && lab.isActive() from the condition
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        this.pos = (
            this.storage ||
            this.terminal ||
            this.spawns[0] ||
            this.controller
        ).pos;
        // Register physical objects across all rooms in the colony
        this.sources = _.sortBy(
            _.flatten(_.map(this.rooms, (room) => room.sources)),
            (source) => source.pos.getMultiRoomRangeTo(this.pos),
        );
        this.extractors = _(this.rooms)
            .map((room) => room.extractor)
            .compact()
            .filter(
                (extractor) =>
                    (extractor.my && extractor.room.my) ||
                    Cartographer.roomType(extractor.room.name) !=
                        ROOMTYPE_CONTROLLER,
            )
            .sortBy((extractor) => extractor.pos.getMultiRoomRangeTo(this.pos))
            .value();
        this.constructionSites = _.flatten(
            _.map(this.rooms, (room) => room.constructionSites),
        );
        this.tombstones = _.flatten(_.map(this.rooms, (room) => room.tombstones),);// zGeneral 2/2024
        this.ruins = _.flatten(_.map(this.rooms, (room) => room.ruins)); // zGeneral 2/2024
        this.drops = _.merge(_.map(this.rooms, (room) => room.drops)); // zGeneral 2/2024
        this.repairables = _.flatten(
            _.map(this.rooms, (room) => room.repairables),
        );
        this.rechargeables = _.flatten(
            _.map(this.rooms, (room) => room.rechargeables),
        );
        // Register assets
        this.assets = this.computeAssets();
    }
    /**
     * Version of Colony.registerRoomObjects with additional caching functionality
     */
    registerRoomObjects_cached() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = []; // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.extensions = this.room.extensions;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.towers = this.room.towers;
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        $.set(this, 'spawns', () =>
            _.sortBy(
                _.filter(this.room.spawns, (spawn) => spawn.my),
                (spawn) => spawn.ref,
            ),
        ); // zGeneral 8/2023 removed && spawn.isactive() from the condition
        $.set(this, 'storage', () =>
            this.room.storage // zGeneral 8/2023 removed && .isactive() from the condition
                ? this.room.storage
                : undefined,
        );
        $.set(this, 'terminal', () =>
            this.room.terminal // zGeneral 8/2023 removed && .isactive() from the condition
                ? this.room.terminal
                : undefined,
        );
        $.set(this, 'factory', () =>
            this.room.factory // zGeneral 8/2023 removed && .isactive() from the condition
                ? this.room.factory
                : undefined,
        );
        $.set(this, 'labs', () =>
            _.sortBy(
                _.filter(this.room.labs, (lab) => lab.my),
                (lab) => 50 * lab.pos.y + lab.pos.x,
            ),
        ); // zGeneral 8/2023 removed && lab.isActive() from the condition
        this.pos = (
            this.storage ||
            this.terminal ||
            this.spawns[0] ||
            this.controller
        ).pos;
        // Register physical objects across all rooms in the colony
        $.set(this, 'sources', () =>
            _.sortBy(
                _.flatten(_.map(this.rooms, (room) => room.sources)),
                (source) => source.pos.getMultiRoomRangeTo(this.pos),
            ),
        );
        $.set(this, 'extractors', () =>
            _(this.rooms)
                .map((room) => room.extractor)
                .compact()
                .filter(
                    (e) =>
                        (e.my && e.room.my) ||
                        Cartographer.roomType(e.room.name) !=
                            ROOMTYPE_CONTROLLER,
                )
                .sortBy((e) => e.pos.getMultiRoomRangeTo(this.pos))
                .value(),
        );
        $.set(this, 'repairables', () =>
            _.flatten(_.map(this.rooms, (room) => room.repairables)),
        );
        $.set(this, 'rechargeables', () =>
            _.flatten(_.map(this.rooms, (room) => room.rechargeables)),
        );
        $.set(
            this,
            'constructionSites',
            () =>
                _.flatten(_.map(this.rooms, (room) => room.constructionSites)),
            10,
        );
        $.set(
            this,
            'tombstones',
            () => _.flatten(_.map(this.rooms, (room) => room.tombstones)),
            5,
        );
        $.set(
            this,
            'ruins',
            () => _.flatten(_.map(this.rooms, (room) => room.ruins)),
            5,
        );
        this.drops =  _.merge(_.map(this.rooms, (room) => room.drops)); // zGeneral 2/2024
        // Register assets
        this.assets = this.computeAssets();
    }
    /**
     * Refresh the state of all physical game objects in the colony
     */
    refreshRoomObjects() {
        $.refresh(
            this,
            'controller',
            'extensions',
            'links',
            'towers',
            'powerSpawn',
            'nuker',
            'observer',
            'spawns',
            'storage',
            'terminal',
            'factory',
            'labs',
            'sources',
            'extractors',
            'constructionSites',
            'repairables',
            'rechargeables',
        );
        $.set(
            this,
            'constructionSites',
            () =>
                _.flatten(_.map(this.rooms, (room) => room.constructionSites)),
            10,
        );
        $.set(
            this,
            'tombstones',
            () => _.flatten(_.map(this.rooms, (room) => room.tombstones)),
            5,
        );
        $.set(
            this,
            'ruins',
            () => _.flatten(_.map(this.rooms, (room) => room.ruins)),
            5,
        );
        this.drops = _.merge(_.map(this.rooms, (room) => room.drops)); //zGeneral 2/2024
        // Re-compute assets
        this.assets = this.computeAssets();
    }
    /**
     * Registers the operational state of the colony, computing things like colony maturity, DEFCON level, etc.
     */
    registerOperationalState() {
        this.level = this.controller.level;
        // Set colony stage
        if (this.storage && this.spawns[0]) {
            // TODO: remove colony stage
            if (this.controller.level == 8) {
                this.stage = ColonyStage.Adult;
            } else {
                this.stage = ColonyStage.Pupa;
            }
        } else {
            this.stage = ColonyStage.Larva;
        }
        // Set DEFCON level TODO: finish this
        let defcon = DEFCON.safe;
        const defconDecayTime = 200;
        if (
            this.room.dangerousHostiles.length > 0 &&
            !this.controller.safeMode
        ) {
            const effectiveHostileCount = _.sum(
                this.room.dangerousHostiles,
                (hostile) =>
                    CombatIntel.uniqueBoosts(hostile).length > 0 ? 2 : 1,
            );
            if (effectiveHostileCount >= 3) {
                defcon = DEFCON.boostedInvasionNPC;
            } else {
                defcon = DEFCON.invasionNPC;
            }
        }
        if (this.memory.defcon) {
            if (defcon < this.memory.defcon.level) {
                // decay defcon level over time if defcon less than memory value
                if (this.memory.defcon.tick + defconDecayTime < Game.time) {
                    this.memory.defcon.level = defcon;
                    this.memory.defcon.tick = Game.time;
                }
            } else if (defcon > this.memory.defcon.level) {
                // refresh defcon time if it increases by a level
                this.memory.defcon.level = defcon;
                this.memory.defcon.tick = Game.time;
            }
        } else {
            this.memory.defcon = {
                level: defcon,
                tick: Game.time,
            };
        }
        this.defcon = this.memory.defcon.level;
        // Set colony state to blank - other directives can modify this
        this.state = {};
        if (Energetics.lowPowerMode(this)) {
            this.state.lowPowerMode = true;
        }
    }
    /**
     * Registers utility classes such as logistics networks
     */
    registerUtilities() {
        // Resource requests
        this.linkNetwork = new LinkNetwork(this);
        this.logisticsNetwork = new LogisticsNetwork(this);
        this.transportRequests = new TransportRequestGroup();
        // Register a room planner
        this.roomPlanner = new RoomPlanner(this);
        if (
            this.roomPlanner.memory.bunkerData &&
            this.roomPlanner.memory.bunkerData.anchor
        ) {
            this.layout = 'bunker';
            const anchor = derefRoomPosition(
                this.roomPlanner.memory.bunkerData.anchor,
            );
            // log.debug(JSON.stringify(`anchor for ${this.name}: ${anchor}`));
            const spawnPositions = _.map(
                bunkerLayout[8].buildings.spawn.pos,
                (c) => getPosFromBunkerCoord(c, this),
            );
            // log.debug(JSON.stringify(`spawnPositions for ${this.name}: ${spawnPositions}`));
            const rightSpawnPos = maxBy(spawnPositions, (pos) => pos.x);
            const topSpawnPos = minBy(spawnPositions, (pos) => pos.y);
            const coreSpawnPos = anchor.findClosestByRange(spawnPositions);
            // log.debug(JSON.stringify(`spawnPoses: ${rightSpawnPos}, ${topSpawnPos}, ${coreSpawnPos}`));
            this.bunker = {
                anchor: anchor,
                topSpawn: topSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                coreSpawn: coreSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                rightSpawn: rightSpawnPos.lookForStructure(STRUCTURE_SPAWN),
            };
        } else {
            this.layout = 'twoPart';
        }
        // Register road network
        this.roadLogistics = new RoadLogistics(this);
        // // "Organism Abathur with you."
        // this.abathur = new Abathur(this);
        // Add colony to TerminalNetwork if applicable
        if (this.terminal) {
            Overmind.terminalNetwork.addColony(this);
        }
    }
    /**
     * Calls utility.refresh() for each registered utility
     */
    refreshUtilities() {
        this.linkNetwork.refresh();
        this.logisticsNetwork.refresh();
        this.transportRequests.refresh();
        this.roomPlanner.refresh();
        if (this.bunker) {
            if (this.bunker.topSpawn) {
                this.bunker.topSpawn = Game.getObjectById(
                    this.bunker.topSpawn.id,
                );
            }
            if (this.bunker.coreSpawn) {
                this.bunker.coreSpawn = Game.getObjectById(
                    this.bunker.coreSpawn.id,
                );
            }
            if (this.bunker.rightSpawn) {
                this.bunker.rightSpawn = Game.getObjectById(
                    this.bunker.rightSpawn.id,
                );
            }
        }
        this.roadLogistics.refresh();
        // this.abathur.refresh();
    }
    /**
     * Builds hive clusters for each structural group in a colony
     */
    registerHiveClusters() {
        this.hiveClusters = [];
        // Instantiate the command center if there is storage in the room - this must be done first!
        if (this.storage) {
            this.commandCenter = new CommandCenter(this, this.storage);
        }
        // Instantiate the hatchery - the incubation directive assignes hatchery to incubator's hatchery if none exists
        if (this.spawns[0]) {
            this.hatchery = new Hatchery(this, this.spawns[0]);
        }
        // Instantiate evolution chamber once there are three labs all in range 2 of each other
        if (
            this.terminal &&
            _.filter(this.labs, (lab) =>
                _.all(this.labs, (otherLab) => lab.pos.inRangeTo(otherLab, 2)),
            ).length >= 3
        ) {
            this.evolutionChamber = new EvolutionChamber(this, this.terminal);
        }
        // Instantiate the upgradeSite
        this.upgradeSite = new UpgradeSite(this, this.controller);
        // Instantiate spore crawlers to wrap towers
        if (this.towers[0]) {
            this.sporeCrawler = new SporeCrawler(this, this.towers[0]);
        }
        // Reverse the hive clusters for correct order for init() and run()
        this.hiveClusters.reverse();
        //console.log(this.hiveClusters.length);
    }
    /**
     * Refreshes the state of each hive cluster
     */
    refreshHiveClusters() {
        for (let i = this.hiveClusters.length - 1; i >= 0; i--) {
            this.hiveClusters[i].refresh();
        }
    }
    /**
     * Returns whether a room is part of this colony and is actively being maintained
     */
    isRoomActive(roomName) {
        if (roomName == this.room.name) {
            return true;
        } else if (!this.roomNames.includes(roomName)) {
            return false;
        } else {
            return (
                this.memory.outposts[roomName] &&
                this.memory.outposts[roomName].active
            );
        }
    }
    /**
     * Deactivates an outpost and suspends operations in that room
     */
    suspendOutpost(roomName, reason, duration) {
        this.memory.outposts[roomName] = {
            active: false,
            suspendReason: reason,
            ['X' /* EXPIRATION */]: Game.time + duration,
        };
    }
    handleReactivatingOutposts() {
        for (const roomName in this.memory.outposts) {
            const outpostData = this.memory.outposts[roomName];
            if (
                !outpostData.active &&
                Game.time >= (outpostData['X' /* EXPIRATION */] || Infinity)
            ) {
                this.memory.outposts[roomName] = { active: true };
            }
        }
    }
    /**
     * Instantiate all overlords for the colony
     */
    spawnMoarOverlords() {
        this.overlords = {
            default: new DefaultOverlord(this),
            work: new WorkerOverlord(this),
            logistics: new TransportOverlord(this),
        };
        //if (!this.observer) {
        //    this.overlords.scout = new RandomWalkerScoutOverlord(this);
        //}
        for (const hiveCluster of this.hiveClusters) {
            hiveCluster.spawnMoarOverlords();
        }
    }
    /**
     * Get a list of creeps in the colony which have a specified role name
     */
    getCreepsByRole(roleName) {
        return this.creepsByRole[roleName] || [];
    }
    /**
     * Get a list of zerg in the colony which have a specified role name
     */
    getZergByRole(roleName) {
        return _.compact(
            _.map(
                this.getCreepsByRole(roleName),
                (creep) => Overmind.zerg[creep.name],
            ),
        ); // 8/2023 zgeneral
    }

    /**
     * Summarizes the total of all resources in colony store structures, labs, and some creeps. Will always return
     * 0 for an asset that it has none of (not undefined)
     */
    computeAssets(verbose = false) {
        // Include storage structures, lab contents, and manager carry
        const assetStructures = _.compact([
            this.storage,
            this.terminal,
            this.factory,
            ...this.labs,
        ]);
        const assetCreeps = [
            ...this.getCreepsByRole(Roles.queen),
            ...this.getCreepsByRole(Roles.manager),
        ];
        const assetStores = _.map(
            [...assetStructures, ...assetCreeps],
            (thing) => storeIndex(thing.store),
        );
        const allAssets = mergeSum([...assetStores, ALL_ZERO_ASSETS]);
        if (verbose) {
            log.debug(
                `${this.room.print} assets: ` + JSON.stringify(allAssets),
            );
        }
        return allAssets;
    }
    /**
     * Initializes the state of the colony each tick
     */
    init() {
        
        
        _.forEach(this.hiveClusters, (hiveCluster) => hiveCluster.init()); // Initialize each hive cluster
        
        
        
        this.roadLogistics.init(); // Initialize the road network
        
        
        
        this.linkNetwork.init(); // Initialize link network
        
        
        
        this.roomPlanner.init(); // Initialize the room planner
        
        
        
        if (Game.time % EXPANSION_EVALUATION_FREQ == 5 * this.id) {
            // Re-evaluate expansion data if needed
            ExpansionEvaluator.refreshExpansionData(
                this.memory.expansionData,
                this.room.name,
            );
        }
        
    }
    /**
     * Runs the colony, performing state-changing actions each tick
     */
    run() {
        
        _.forEach(this.hiveClusters, (hiveCluster) => hiveCluster.run()); // Run each hive cluster
        
        
        
        this.linkNetwork.run(); // Run the link network
        
        
        
        this.roadLogistics.run(); // Run the road network
        
        
        
        this.roomPlanner.run(); // Run the room planner
        
        
       
        this.stats(); // Log stats per tick
       
    }
    /**
     * Register colony-wide statistics
     */
    stats() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            // Log energy and rcl
            Stats.log(
                `colonies.${this.name}.storage.energy`,
                this.storage ? this.storage.energy : undefined,
            );
            Stats.log(`colonies.${this.name}.rcl.level`, this.controller.level);
            Stats.log(
                `colonies.${this.name}.rcl.progress`,
                this.controller.progress,
            );
            Stats.log(
                `colonies.${this.name}.rcl.progressTotal`,
                this.controller.progressTotal,
            );
            // Log average miningSite usage and uptime and estimated colony energy income
            const numSites = _.keys(this.miningSites).length;
            const avgDowntime =
                _.sum(
                    this.miningSites,
                    (site) => site.memory['d' /* DOWNTIME */],
                ) / numSites;
            const avgUsage =
                _.sum(
                    this.miningSites,
                    (site) => site.memory['u' /* USAGE */],
                ) / numSites;
            const energyInPerTick = _.sum(
                this.miningSites,
                (site) =>
                    site.overlords.mine.energyPerTick *
                    site.memory['u' /* USAGE */],
            );
            Stats.log(
                `colonies.${this.name}.miningSites.avgDowntime`,
                avgDowntime,
            );
            Stats.log(`colonies.${this.name}.miningSites.avgUsage`, avgUsage);
            Stats.log(
                `colonies.${this.name}.miningSites.energyInPerTick`,
                energyInPerTick,
            );
            Stats.log(`colonies.${this.name}.assets`, this.assets);
            // Log defensive properties
            Stats.log(`colonies.${this.name}.defcon`, this.defcon);
            Stats.log(
                `colonies.${this.name}.threatLevel`,
                this.room.threatLevel,
            );
            const avgBarrierHits =
                _.sum(this.room.barriers, (barrier) => barrier.hits) /
                this.room.barriers.length;
            Stats.log(`colonies.${this.name}.avgBarrierHits`, avgBarrierHits);
        }
    }
    drawCreepReport(coord) {
        let { x, y } = coord;
        const roledata = Overmind.overseer.getCreepReport(this);
        const tablePos = new RoomPosition(x, y, this.room.name);
        y = Visualizer.infoBox(`${this.name} Creeps`, roledata, tablePos, 7);
        return { x, y };
    }
    visuals() {
        let x = 1;
        let y = 8.5;
        let coord;
        coord = this.drawCreepReport({ x, y });
        x = coord.x;
        y = coord.y;
        for (const hiveCluster of _.compact([
            this.hatchery,
            this.commandCenter,
            this.evolutionChamber,
            this.upgradeSite,
        ])) {
            coord = hiveCluster.visuals({ x, y });
            x = coord.x;
            y = coord.y;
        }
    }
};
Colony.settings = {
    remoteSourcesByLevel: {
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 9,
    },
    maxSourceDistance: 100,
};
Colony = __decorate([profile, assimilationLocked], Colony);

const REBUILD_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in a rebuild state, which pushes resources out of a room which is undergoing reconstruction
 * while maintaining a small reserve of energy
 */
let DirectiveTerminalRebuildState = class DirectiveTerminalRebuildState extends Directive {
    // colony: Colony | undefined; // this is technically unallowable, but at end of life, colony can be undefined
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isRebuilding = true;
    }
    spawnMoarOverlords() {}
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (this.colony.assets[resource] > 0) {
                    if (resource == RESOURCE_ENERGY) {
                        // keep a little energy just to keep the room functioning
                        Overmind.terminalNetwork.exportResource(
                            this.colony,
                            resource,
                            {
                                target: 25000,
                                tolerance: 5000,
                                surplus: 35000,
                            },
                        );
                    } else {
                        Overmind.terminalNetwork.exportResource(
                            this.colony,
                            resource,
                        );
                    }
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: rebuild terminal state active!`);
        }
        this.alert('Rebuild terminal state active!', NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (
            !this.colony ||
            !this.colony.terminal ||
            Game.time >
                (this.memory['T' /* TICK */] || 0) + REBUILD_STATE_TIMEOUT
        ) {
            this.remove();
        }
    }
};
DirectiveTerminalRebuildState.directiveName = 'rebuildState';
DirectiveTerminalRebuildState.color = COLOR_BROWN;
DirectiveTerminalRebuildState.secondaryColor = COLOR_YELLOW;
DirectiveTerminalRebuildState = __decorate(
    [profile],
    DirectiveTerminalRebuildState,
);

/**
 * Code for calculating the minCut in a room, written by Saruss,
 * adapted for Typescript and flexible room subsets by Chobobobo,
 * modified and debugged by Muon.
 */
const UNWALKABLE = -10;
const RANGE_MODIFIER = 1; // this parameter sets the scaling of weights to prefer walls closer protection bounds
const RANGE_PADDING = 3; // max range to reduce weighting; RANGE_MODIFIER * RANGE_PADDING must be < PROTECTED
const NORMAL = 0;
const PROTECTED = 10;
const CANNOT_BUILD = 20;
const EXIT = 30;
class Graph {
    constructor(totalVertices) {
        this.totalVertices = totalVertices;
        this.level = Array(totalVertices);
        // An array of edges for each vertex
        this.edges = Array(totalVertices)
            .fill(0)
            .map((x) => []);
    }
    /**
     * Create a new edge in the graph as well as a corresponding reverse edge on the residual graph
     * @param from - vertex edge starts at
     * @param to - vertex edge leads to
     * @param capacity - max flow capacity for this edge
     */
    newEdge(from, to, capacity) {
        // Normal forward Edge
        this.edges[from].push({
            to,
            resEdge: this.edges[to].length,
            capacity,
            flow: 0,
        });
        // reverse Edge for Residual Graph
        this.edges[to].push({
            to: from,
            resEdge: this.edges[from].length - 1,
            capacity: 0,
            flow: 0,
        });
    }
    /**
     * Uses Breadth First Search to see if a path exists to the vertex 'to' and generate the level graph
     * @param from - vertex to start from
     * @param to - vertex to try and reach
     */
    createLevelGraph(from, to) {
        if (to >= this.totalVertices) {
            return false;
        }
        this.level.fill(-1); // reset old levels
        this.level[from] = 0;
        const q = []; // queue with s as starting point
        q.push(from);
        let u = 0;
        let edge = null;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {
                    this.level[edge.to] = this.level[u] + 1;
                    q.push(edge.to);
                }
            }
        }
        return this.level[to] >= 0; // return if theres a path, no level, no path!
    }
    /**
     * Depth First Search-like: send flow at along path from from->to recursively while increasing the level of the
     * visited vertices by one
     * @param start - the vertex to start at
     * @param end - the vertex to try and reach
     * @param targetFlow - the amount of flow to try and achieve
     * @param count - keep track of which vertices have been visited so we don't include them twice
     */
    calcFlow(start, end, targetFlow, count) {
        if (start === end) {
            // Sink reached , abort recursion
            return targetFlow;
        }
        let edge;
        let flowTillHere = 0;
        let flowToT = 0;
        while (count[start] < this.edges[start].length) {
            // Visit all edges of the vertex one after the other
            edge = this.edges[start][count[start]];
            if (
                this.level[edge.to] === this.level[start] + 1 &&
                edge.flow < edge.capacity
            ) {
                // Edge leads to Vertex with a level one higher, and has flow left
                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);
                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);
                if (flowToT > 0) {
                    edge.flow += flowToT; // Add Flow to current edge
                    // subtract from reverse Edge -> Residual Graph neg. Flow to use backward direction of BFS/DFS
                    this.edges[edge.to][edge.resEdge].flow -= flowToT;
                    return flowToT;
                }
            }
            count[start]++;
        }
        return 0;
    }
    /**
     * Uses Breadth First Search to find the vertices in the minCut for the graph
     * - Must call calcMinCut first to prepare the graph
     * @param from - the vertex to start from
     */
    getMinCut(from) {
        const eInCut = [];
        this.level.fill(-1);
        this.level[from] = 1;
        const q = [];
        q.push(from);
        let u = 0;
        let edge;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (edge.flow < edge.capacity) {
                    if (this.level[edge.to] < 1) {
                        this.level[edge.to] = 1;
                        q.push(edge.to);
                    }
                }
                if (edge.flow === edge.capacity && edge.capacity > 0) {
                    // blocking edge -> could be in min cut
                    eInCut.push({ to: edge.to, unreachable: u });
                }
            }
        }
        const minCut = [];
        let cutEdge;
        for (cutEdge of eInCut) {
            if (this.level[cutEdge.to] === -1) {
                // Only edges which are blocking and lead to the sink from unreachable vertices are in the min cut
                minCut.push(cutEdge.unreachable);
            }
        }
        return minCut;
    }
    /**
     * Calculates min-cut graph using Dinic's Algorithm.
     * use getMinCut to get the actual verticies in the minCut
     * @param source - Source vertex
     * @param sink - Sink vertex
     */
    calcMinCut(source, sink) {
        if (source === sink) {
            return -1;
        }
        let ret = 0;
        let count = [];
        let flow = 0;
        while (this.createLevelGraph(source, sink)) {
            count = Array(this.totalVertices + 1).fill(0);
            do {
                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);
                if (flow > 0) {
                    ret += flow;
                }
            } while (flow);
        }
        return ret;
    }
}
/**
 * An Array with Terrain information: -1 not usable, 2 Sink (Leads to Exit)
 * @param room - the room to generate the terrain map from
 */
function get2DArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const room2D = Array(50)
        .fill(NORMAL)
        .map((d) => Array(50).fill(NORMAL)); // Array for room tiles
    let x;
    let y;
    const terrain = Game.map.getRoomTerrain(roomName);
    for (x = bounds.x1; x <= bounds.x2; x++) {
        for (y = bounds.y1; y <= bounds.y2; y++) {
            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                room2D[x][y] = UNWALKABLE; // Mark unwalkable
            } else if (
                x === bounds.x1 ||
                y === bounds.y1 ||
                x === bounds.x2 ||
                y === bounds.y2
            ) {
                room2D[x][y] = EXIT; // Mark exit tiles
            }
        }
    }
    // Marks tiles as unbuildable if they are proximate to exits
    for (y = bounds.y1 + 1; y <= bounds.y2 - 1; y++) {
        if (room2D[bounds.x1][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x1 + 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x1 + 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[bounds.x2][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x2 - 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x2 - 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
    }
    for (x = bounds.x1 + 1; x <= bounds.x2 - 1; x++) {
        if (room2D[x][bounds.y1] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y1 + 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y1 + 1] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[x][bounds.y2] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y2 - 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y2 - 1] = CANNOT_BUILD;
                }
            }
        }
    }
    return room2D;
}
/**
 * Function to create Source, Sink, Tiles arrays: takes a rectangle-Array as input for Tiles that are to Protect
 * @param room - the room to consider
 * @param toProtect - the coordinates to protect inside the walls
 * @param bounds - the area to consider for the minCut
 */
function createGraph(
    roomName,
    toProtect,
    preferCloserBarriers = true,
    preferCloserBarrierLimit = Infinity, // ignore the toProtect[n] for n > this value
    visualize = true,
    bounds = { x1: 0, y1: 0, x2: 49, y2: 49 },
) {
    const visual = new RoomVisual(roomName);
    const roomArray = get2DArray(roomName, bounds);
    // For all Rectangles, set edges as source (to protect area) and area as unused
    let r;
    let x;
    let y;
    for (r of toProtect) {
        if (
            bounds.x1 >= bounds.x2 ||
            bounds.y1 >= bounds.y2 ||
            bounds.x1 < 0 ||
            bounds.y1 < 0 ||
            bounds.x2 > 49 ||
            bounds.y2 > 49
        ) {
            return console.log('ERROR: Invalid bounds', JSON.stringify(bounds));
        } else if (r.x1 >= r.x2 || r.y1 >= r.y2) {
            return console.log(
                'ERROR: Rectangle',
                JSON.stringify(r),
                'invalid.',
            );
        } else if (
            r.x1 < bounds.x1 ||
            r.x2 > bounds.x2 ||
            r.y1 < bounds.y1 ||
            r.y2 > bounds.y2
        ) {
            return console.log(
                'ERROR: Rectangle',
                JSON.stringify(r),
                'out of bounds:',
                JSON.stringify(bounds),
            );
        }
        for (x = r.x1; x <= r.x2; x++) {
            for (y = r.y1; y <= r.y2; y++) {
                if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {
                    if (roomArray[x][y] === NORMAL) {
                        roomArray[x][y] = PROTECTED;
                    }
                } else {
                    roomArray[x][y] = UNWALKABLE;
                }
            }
        }
    }
    // Preferentially weight closer tiles
    if (preferCloserBarriers) {
        for (r of _.take(toProtect, preferCloserBarrierLimit)) {
            const [xmin, xmax] = [
                Math.max(r.x1 - RANGE_PADDING, 0),
                Math.min(r.x2 + RANGE_PADDING, 49),
            ];
            const [ymin, ymax] = [
                Math.max(r.y1 - RANGE_PADDING, 0),
                Math.min(r.y2 + RANGE_PADDING, 49),
            ];
            for (x = xmin; x <= xmax; x++) {
                for (y = ymin; y <= ymax; y++) {
                    if (
                        roomArray[x][y] >= NORMAL &&
                        roomArray[x][y] < PROTECTED
                    ) {
                        const x1range = Math.max(r.x1 - x, 0);
                        const x2range = Math.max(x - r.x2, 0);
                        const y1range = Math.max(r.y1 - y, 0);
                        const y2range = Math.max(y - r.y2, 0);
                        const rangeToBorder = Math.max(
                            x1range,
                            x2range,
                            y1range,
                            y2range,
                        );
                        const modifiedWeight =
                            NORMAL +
                            RANGE_MODIFIER * (RANGE_PADDING - rangeToBorder);
                        roomArray[x][y] = Math.max(
                            roomArray[x][y],
                            modifiedWeight,
                        );
                        if (visualize) {
                            visual.text(`${roomArray[x][y]}`, x, y);
                        }
                    }
                }
            }
        }
    }
    // ********************** Visualization
    if (visualize) {
        for (x = bounds.x1; x <= bounds.x2; x++) {
            for (y = bounds.y1; y <= bounds.y2; y++) {
                if (roomArray[x][y] === UNWALKABLE) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#1b1b9f',
                        opacity: 0.3,
                    });
                } else if (
                    roomArray[x][y] > UNWALKABLE &&
                    roomArray[x][y] < NORMAL
                ) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#42cce8',
                        opacity: 0.3,
                    });
                } else if (roomArray[x][y] === NORMAL) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#bdb8b8',
                        opacity: 0.3,
                    });
                } else if (
                    roomArray[x][y] > NORMAL &&
                    roomArray[x][y] < PROTECTED
                ) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#9929e8',
                        opacity: 0.3,
                    });
                } else if (roomArray[x][y] === PROTECTED) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#e800c6',
                        opacity: 0.3,
                    });
                } else if (roomArray[x][y] === CANNOT_BUILD) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#e8000f',
                        opacity: 0.3,
                    });
                } else if (roomArray[x][y] === EXIT) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: '#000000',
                        opacity: 0.3,
                    });
                }
            }
        }
    }
    // initialise graph
    // possible 2*50*50 +2 (st) Vertices (Walls etc set to unused later)
    const g = new Graph(2 * 50 * 50 + 2);
    const infini = Number.MAX_VALUE;
    const surr = [
        [0, -1],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ];
    // per Tile (0 in Array) top + bot with edge of c=1 from top to bott  (use every tile once!)
    // infini edge from bot to top vertices of adjacent tiles if they not protected (array =1)
    // (no reverse edges in normal graph)
    // per prot. Tile (1 in array) Edge from source to this tile with infini cap.
    // per exit Tile (2in array) Edge to sink with infini cap.
    // source is at  pos 2*50*50, sink at 2*50*50+1 as first tile is 0,0 => pos 0
    // top vertices <-> x,y : v=y*50+x   and x= v % 50  y=v/50 (math.floor?)
    // bot vertices <-> top + 2500
    const source = 2 * 50 * 50;
    const sink = 2 * 50 * 50 + 1;
    let top = 0;
    let bot = 0;
    let dx = 0;
    let dy = 0;
    // max = 49;
    const baseCapacity = 10;
    const modifyWeight = preferCloserBarriers ? 1 : 0;
    for (x = bounds.x1 + 1; x < bounds.x2; x++) {
        for (y = bounds.y1 + 1; y < bounds.y2; y++) {
            top = y * 50 + x;
            bot = top + 2500;
            if (roomArray[x][y] >= NORMAL && roomArray[x][y] <= PROTECTED) {
                if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                    g.newEdge(
                        top,
                        bot,
                        baseCapacity - modifyWeight * roomArray[x][y],
                    ); // add surplus weighting
                } else if (roomArray[x][y] === PROTECTED) {
                    // connect this to the source
                    g.newEdge(source, top, infini);
                    g.newEdge(
                        top,
                        bot,
                        baseCapacity -
                            modifyWeight * RANGE_PADDING * RANGE_MODIFIER,
                    );
                }
                for (let i = 0; i < 8; i++) {
                    // attach adjacent edges
                    dx = x + surr[i][0];
                    dy = y + surr[i][1];
                    if (
                        (roomArray[dx][dy] >= NORMAL &&
                            roomArray[dx][dy] < PROTECTED) ||
                        roomArray[dx][dy] === CANNOT_BUILD
                    ) {
                        g.newEdge(bot, dy * 50 + dx, infini);
                    }
                }
            } else if (roomArray[x][y] === CANNOT_BUILD) {
                // near Exit
                g.newEdge(top, sink, infini);
            }
        }
    } // graph finished
    return g;
}
/**
 * Main function to be called by user: calculate min cut tiles from room using rectangles as protected areas
 * @param room - the room to use
 * @param rectangles - the areas to protect, defined as rectangles
 * @param bounds - the area to be considered for the minCut
 */
function getCutTiles(
    roomName,
    toProtect,
    preferCloserBarriers = true,
    preferCloserBarrierLimit = Infinity,
    visualize = true,
    bounds = { x1: 0, y1: 0, x2: 49, y2: 49 },
) {
    const graph = createGraph(
        roomName,
        toProtect,
        preferCloserBarriers,
        preferCloserBarrierLimit,
        visualize,
        bounds,
    );
    if (!graph) {
        return [];
    }
    let x;
    let y;
    const source = 2 * 50 * 50; // Position Source / Sink in Room-Graph
    const sink = 2 * 50 * 50 + 1;
    const count = graph.calcMinCut(source, sink);
    // console.log('Number of Tiles in Cut:', count);
    const positions = [];
    if (count > 0) {
        const cutVertices = graph.getMinCut(source);
        let v;
        for (v of cutVertices) {
            // x= vertex % 50  y=v/50 (math.floor?)
            x = v % 50;
            y = Math.floor(v / 50);
            positions.push({ x, y });
        }
    }
    // Visualise Result
    if (positions.length > 0) {
        const visual = new RoomVisual(roomName);
        for (let i = positions.length - 1; i >= 0; i--) {
            visual.circle(positions[i].x, positions[i].y, {
                radius: 0.5,
                fill: '#ff7722',
                opacity: 0.9,
            });
        }
    } else {
        return [];
    }
    const wholeRoom =
        bounds.x1 === 0 &&
        bounds.y1 === 0 &&
        bounds.x2 === 49 &&
        bounds.y2 === 49;
    return wholeRoom ? positions : pruneDeadEnds(roomName, positions);
}
/**
 * Removes unnecessary tiles if they are blocking the path to a dead end
 * Useful if minCut has been run on a subset of the room
 * @param roomName - Room to work in
 * @param cutTiles - Array of tiles which are in the minCut
 */
function pruneDeadEnds(roomName, cutTiles) {
    // Get Terrain and set all cut-tiles as unwalkable
    const roomArray = get2DArray(roomName);
    let tile;
    for (tile of cutTiles) {
        roomArray[tile.x][tile.y] = UNWALKABLE;
    }
    // Floodfill from exits: save exit tiles in array and do a BFS-like search
    const unvisited = [];
    let y;
    let x;
    for (y = 0; y < 49; y++) {
        if (roomArray[0][y] === EXIT) {
            console.log('prune: toExit', 0, y);
            unvisited.push(50 * y);
        }
        if (roomArray[49][y] === EXIT) {
            console.log('prune: toExit', 49, y);
            unvisited.push(50 * y + 49);
        }
    }
    for (x = 0; x < 49; x++) {
        if (roomArray[x][0] === EXIT) {
            console.log('prune: toExit', x, 0);
            unvisited.push(x);
        }
        if (roomArray[x][49] === EXIT) {
            console.log('prune: toExit', x, 49);
            unvisited.push(2450 + x); // 50*49=2450
        }
    }
    // Iterate over all unvisited EXIT tiles and mark neigbours as EXIT tiles if walkable, add to unvisited
    const surr = [
        [0, -1],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ];
    let currPos;
    let dx;
    let dy;
    while (unvisited.length > 0) {
        currPos = unvisited.pop();
        x = currPos % 50;
        y = Math.floor(currPos / 50);
        for (let i = 0; i < 8; i++) {
            dx = x + surr[i][0];
            dy = y + surr[i][1];
            if (dx < 0 || dx > 49 || dy < 0 || dy > 49) {
                continue;
            }
            if (
                (roomArray[dx][dy] >= NORMAL &&
                    roomArray[dx][dy] < PROTECTED) ||
                roomArray[dx][dy] === CANNOT_BUILD
            ) {
                unvisited.push(50 * dy + dx);
                roomArray[dx][dy] = EXIT;
            }
        }
    }
    // Remove min-Cut-Tile if there is no EXIT reachable by it
    let leadsToExit;
    const validCut = [];
    for (tile of cutTiles) {
        leadsToExit = false;
        for (let j = 0; j < 8; j++) {
            dx = tile.x + surr[j][0];
            dy = tile.y + surr[j][1];
            if (roomArray[dx][dy] === EXIT) {
                leadsToExit = true;
            }
        }
        if (leadsToExit) {
            validCut.push(tile);
        }
    }
    return validCut;
}

var BarrierPlanner_1;
const getDefaultBarrierPlannerMemory = () => ({
    barrierCoordsPacked: '',
});
let BarrierPlanner = (BarrierPlanner_1 = class BarrierPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(
            this.colony.memory,
            'barrierPlanner',
            getDefaultBarrierPlannerMemory,
        );
        this.barrierPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'barrierPlanner',
            getDefaultBarrierPlannerMemory,
        );
        this.barrierPositions = [];
    }
    computeBunkerBarrierPositions(bunkerPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (bunkerPos) {
            const { x, y } = bunkerPos;
            const r = BUNKER_RADIUS - 1;
            let [x1, y1] = [
                Math.max(x - r - padding, 0),
                Math.max(y - r - padding, 0),
            ];
            let [x2, y2] = [
                Math.min(x + r + padding, 49),
                Math.min(y + r + padding, 49),
            ];
            // Make sure you don't leave open walls
            x1 = minMax(x1, 3, 50 - 3);
            x2 = minMax(x2, 3, 50 - 3);
            y1 = minMax(y1, 3, 50 - 3);
            y2 = minMax(y2, 3, 50 - 3);
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(
            this.colony.name,
            rectArray,
            false,
            2,
            false,
        );
        let positions = _.map(
            barrierCoords,
            (coord) => new RoomPosition(coord.x, coord.y, this.colony.name),
        );
        positions = positions.concat(upgradeSitePos.availableNeighbors(true));
        return positions;
    }
    computeBarrierPositions(hatcheryPos, commandCenterPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (hatcheryPos) {
            const { x, y } = hatcheryPos;
            const [x1, y1] = [
                Math.max(x - 5 - padding, 0),
                Math.max(y - 4 - padding, 0),
            ];
            const [x2, y2] = [
                Math.min(x + 5 + padding, 49),
                Math.min(y + 6 + padding, 49),
            ];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (commandCenterPos) {
            const { x, y } = commandCenterPos;
            const [x1, y1] = [
                Math.max(x - 3 - padding, 0),
                Math.max(y - 0 - padding, 0),
            ];
            const [x2, y2] = [
                Math.min(x + 0 + padding, 49),
                Math.min(y + 5 + padding, 49),
            ];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (upgradeSitePos) {
            const { x, y } = upgradeSitePos;
            const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
            const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(
            this.colony.name,
            rectArray,
            true,
            2,
            false,
        );
        return _.map(
            barrierCoords,
            (coord) => new RoomPosition(coord.x, coord.y, this.colony.name),
        );
    }
    init() {}
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        if (this.barrierPositions.length == 0) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(
                    this.roomPlanner.bunkerPos,
                    this.colony.controller.pos,
                );
            } else if (
                this.roomPlanner.storagePos &&
                this.roomPlanner.hatcheryPos
            ) {
                this.barrierPositions = this.computeBarrierPositions(
                    this.roomPlanner.hatcheryPos,
                    this.roomPlanner.storagePos,
                    this.colony.controller.pos,
                );
            } else {
                log.error(
                    `${this.colony.print} BARRIER PLANNER: couldn't generate barrier plan!`,
                );
                return;
            }
        }
        this.memory.barrierCoordsPacked = packCoordList(this.barrierPositions);
    }
    /* Quick lookup for if a barrier should be in this position. Barriers returning false won't be maintained. */
    barrierShouldBeHere(pos) {
        // Once you are high level, only maintain ramparts at bunker or controller
        if (
            this.colony.layout == 'bunker' &&
            this.colony.level >= BarrierPlanner_1.settings.bunkerizeRCL
        ) {
            return (
                insideBunkerBounds(pos, this.colony) ||
                pos.getRangeTo(this.colony.controller) == 1
            );
        }
        // Otherwise look up from memory
        if (this._barrierLookup == undefined) {
            this._barrierLookup = _.memoize((p) =>
                this.memory.barrierCoordsPacked.includes(packCoord(p)),
            );
        }
        return this._barrierLookup(pos);
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissingRamparts() {
        // Max buildings that can be placed each tick
        let count =
            RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Build missing ramparts
        const barrierPositions = unpackCoordListAsPosList(
            this.memory.barrierCoordsPacked,
            this.colony.room.name,
        );
        // Add critical structures to barrier lookup
        const criticalStructures = _.compact([
            ...this.colony.towers,
            ...this.colony.spawns,
            this.colony.storage,
            this.colony.terminal,
        ]);
        for (const structure of criticalStructures) {
            barrierPositions.push(structure.pos);
        }
        for (const pos of barrierPositions) {
            if (
                count > 0 &&
                RoomPlanner.canBuild(STRUCTURE_RAMPART, pos) &&
                this.barrierShouldBeHere(pos)
            ) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(
                        `${this.colony.name}: couldn't create rampart site at ${pos.print}. Result: ${ret}`,
                    );
                } else {
                    count--;
                }
            }
        }
    }
    buildMissingBunkerRamparts() {
        if (!this.roomPlanner.bunkerPos) return;
        const bunkerCoords = getAllStructureCoordsFromLayout(
            bunkerLayout,
            this.colony.level,
        );
        bunkerCoords.push(bunkerLayout.data.anchor); // add center bunker tile
        let bunkerPositions = _.map(
            bunkerCoords,
            (coord) => new RoomPosition(coord.x, coord.y, this.colony.name),
        );
        bunkerPositions = translatePositions(
            bunkerPositions,
            bunkerLayout.data.anchor,
            this.roomPlanner.bunkerPos,
        );
        let count =
            RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        for (const pos of bunkerPositions) {
            if (
                count > 0 &&
                !pos.lookForStructure(STRUCTURE_RAMPART) &&
                pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0 &&
                pos.lookFor(LOOK_TERRAIN)[0] != 'wall'
            ) {
                // zGen: check for walls
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    console.log(
                        `${this.colony.name}: couldn't create bunker rampart at ${pos.print}. Result: ${ret}`,
                    );
                } else {
                    count--;
                }
            }
        }
    }
    run() {
        if (this.roomPlanner.active) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(
                    this.roomPlanner.bunkerPos,
                    this.colony.controller.pos,
                );
            } else if (
                this.roomPlanner.storagePos &&
                this.roomPlanner.hatcheryPos
            ) {
                this.barrierPositions = this.computeBarrierPositions(
                    this.roomPlanner.hatcheryPos,
                    this.roomPlanner.storagePos,
                    this.colony.controller.pos,
                );
            }
            this.visuals();
        } else {
            if (
                !this.roomPlanner.memory.relocating &&
                this.colony.level >=
                    BarrierPlanner_1.settings.buildBarriersAtRCL &&
                this.roomPlanner.shouldRecheck(2)
            ) {
                this.buildMissingRamparts();
                if (this.colony.layout == 'bunker' && this.colony.level >= 7) {
                    this.buildMissingBunkerRamparts();
                }
            }
        }
    }
    visuals() {
        for (const pos of this.barrierPositions) {
            this.colony.room.visual.structure(pos.x, pos.y, STRUCTURE_RAMPART);
        }
    }
});
BarrierPlanner.settings = {
    buildBarriersAtRCL: 3,
    padding: 3,
    bunkerizeRCL: 7,
};
BarrierPlanner = BarrierPlanner_1 = __decorate([profile], BarrierPlanner);

/* tslint:disable */
// @formatter:off
var commandCenterLayout = {
    data: { anchor: { x: 25, y: 25 } },
    3: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '3',
        buildings: { tower: { pos: [{ x: 24, y: 27 }] } },
    },
    4: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '4',
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            storage: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
        },
    },
    5: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '5',
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
        },
    },
    6: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '6',
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 24, y: 29 },
                ],
            },
        },
    },
    7: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '7',
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: {
                pos: [
                    { x: 23, y: 27 },
                    { x: 24, y: 27 },
                ],
            },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 24, y: 29 },
                    { x: 25, y: 29 },
                ],
            },
        },
    },
    8: {
        name: 'commandCenter',
        shard: 'shard0',
        rcl: '8',
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            nuker: { pos: [{ x: 22, y: 25 }] },
            powerSpawn: { pos: [{ x: 23, y: 25 }] },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            observer: { pos: [{ x: 22, y: 26 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: {
                pos: [
                    { x: 23, y: 27 },
                    { x: 24, y: 27 },
                ],
            },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 24, y: 29 },
                    { x: 25, y: 29 },
                    { x: 22, y: 30 },
                    { x: 23, y: 30 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                ],
            },
        },
    },
};

/* tslint:disable */
// @formatter:off
var hatcheryLayout = {
    data: { anchor: { x: 25, y: 24 } },
    1: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '1',
        buildings: { spawn: { pos: [{ x: 25, y: 24 }] } },
    },
    2: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '2',
        buildings: {
            extension: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 27, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    3: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '3',
        buildings: {
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    4: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '4',
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    5: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '5',
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 27, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 29, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    6: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '6',
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 29, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    7: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '7',
        buildings: {
            extension: {
                pos: [
                    { x: 21, y: 20 },
                    { x: 22, y: 20 },
                    { x: 28, y: 20 },
                    { x: 29, y: 20 },
                    { x: 20, y: 21 },
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 30, y: 21 },
                    { x: 20, y: 22 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 30, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 20, y: 29 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                    { x: 30, y: 29 },
                ],
            },
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            spawn: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 24, y: 25 },
                ],
            },
            tower: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    8: {
        name: 'hatchery',
        shard: 'shard0',
        rcl: '8',
        buildings: {
            extension: {
                pos: [
                    { x: 20, y: 20 },
                    { x: 21, y: 20 },
                    { x: 22, y: 20 },
                    { x: 28, y: 20 },
                    { x: 29, y: 20 },
                    { x: 30, y: 20 },
                    { x: 20, y: 21 },
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 30, y: 21 },
                    { x: 20, y: 22 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 30, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 20, y: 28 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 30, y: 28 },
                    { x: 20, y: 29 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                    { x: 30, y: 29 },
                    { x: 20, y: 30 },
                    { x: 21, y: 30 },
                    { x: 22, y: 30 },
                    { x: 28, y: 30 },
                    { x: 29, y: 30 },
                    { x: 30, y: 30 },
                ],
            },
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            tower: {
                pos: [
                    { x: 25, y: 21 },
                    { x: 21, y: 25 },
                    { x: 29, y: 25 },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 24, y: 25 },
                    { x: 26, y: 25 },
                ],
            },
            container: { pos: [{ x: 25, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
};

var RoadPlanner_1;
const ROAD_PLANNER_PLAIN_COST = 3;
const ROAD_PLANNER_SWAMP_COST = 4;
const ROAD_PLANNER_TUNNEL_COST = 15 * ROAD_PLANNER_PLAIN_COST;
const EXISTING_PATH_COST = ROAD_PLANNER_PLAIN_COST - 1;
const getDefaultRoadPlannerMemory = () => ({
    roadCoordsPacked: {},
    roadCoverage: 0.0,
    roadCoverages: {},
});
let RoadPlanner = (RoadPlanner_1 = class RoadPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(
            this.colony.memory,
            'roadPlanner',
            getDefaultRoadPlannerMemory,
        );
        this.costMatrices = {};
        this.roadPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'roadPlanner',
            getDefaultRoadPlannerMemory,
        );
        // this.costMatrices = {}; // zGeneral 3/2024
        this.roadPositions = [];
    }
    get roadCoverage() {
        return this.memory.roadCoverage;
    }
    deleteRoadCoverage() {
        if (this.memory.roadCoverage !== undefined) {
            console.log('Deleting roadCoverage from memory.');
            delete this.memory.roadCoverage;
        } else {
            console.log('No roadCoverage found in memory to delete.');
        }
    }
    recomputeRoadCoverages(storagePos, ignoreInactiveRooms = true) {
        // Compute coverage for each path
        for (const destination of this.colony.destinations) {
            const destName = destination.pos.readableName;
            if (!!this.memory.roadCoordsPacked[destination.pos.roomName]) {
                if (
                    !this.memory.roadCoverages[destName] ||
                    Game.time > this.memory.roadCoverages[destName].exp
                ) {
                    const roadCoverage = this.computeRoadCoverage(
                        storagePos,
                        destination.pos,
                    );
                    if (roadCoverage != undefined) {
                        // Set expiration to be longer if road is nearly complete
                        const expiration =
                            roadCoverage.roadCount / roadCoverage.length >= 0.75
                                ? getCacheExpiration(
                                      RoadPlanner_1.settings
                                          .recomputeCoverageInterval,
                                  )
                                : getCacheExpiration(
                                      3 *
                                          RoadPlanner_1.settings
                                              .recomputeCoverageInterval,
                                  );
                        this.memory.roadCoverages[destName] = {
                            roadCount: roadCoverage.roadCount,
                            length: roadCoverage.length,
                            exp: expiration,
                        };
                    } else {
                        if (this.memory.roadCoverages[destName]) {
                            // if you already have some data, use it for a little while
                            const waitTime = onPublicServer() ? 500 : 200;
                            this.memory.roadCoverages[destName].exp += waitTime;
                        } else {
                            // otherwise put in a placeholder
                            const waitTime = onPublicServer() ? 300 : 100;
                            this.memory.roadCoverages[destName] = {
                                roadCount: 0,
                                length: 1,
                                exp: Game.time + waitTime,
                            };
                        }
                    }
                    log.debug(
                        `Recomputing road coverage from ${storagePos.print} to ${destination.pos.print}... ` +
                            `Coverage: ${JSON.stringify(roadCoverage)}`,
                    );
                }
            }
        }
        // Store the aggregate roadCoverage score
        let totalRoadCount = 0;
        let totalPathLength = 0;
        for (const destName in this.memory.roadCoverages) {
            const destPos = posFromReadableName(destName);
            if (
                ignoreInactiveRooms &&
                !this.colony.isRoomActive(destPos.roomName)
            ) {
                continue;
            }
            const { roadCount, length, exp } = this.memory.roadCoverages[
                destName
            ];
            totalRoadCount += roadCount;
            totalPathLength += length;
        }
        this.memory.roadCoverage = totalRoadCount / totalPathLength;
    }
    /*
    computeRoadCoverage(storagePos, destination) {
        const ret = Pathing.findPath(storagePos, destination, {
            terrainCosts: { plainCost: 2, swampCost: 10 },
        });
        const path = ret.path;
        const roomNames = _.unique(_.map(path, (pos) => pos.roomName));
        // If you have vision or cached vision of the room
        if (
            _.all(
                roomNames,
                (roomName) =>
                    Game.rooms[roomName] ||
                    $.costMatrixRecall(roomName, MatrixTypes.default),
            )
        ) {
            let roadCount = 0;
            for (const pos of path) {
                if (Game.rooms[pos.roomName]) {
                    if (pos.lookForStructure(STRUCTURE_ROAD)) {
                        roadCount++;
                    }
                } else {
                    const mat = $.costMatrixRecall(
                        pos.roomName,
                        MatrixTypes.default,
                    );
                    if (mat) {
                        if (mat.get(pos.x, pos.y) == 1) {
                            roadCount++;
                        }
                    } else {
                        // shouldn't happen
                        log.warning(
                            `No vision or recalled cost matrix in room ${pos.roomName}! (Why?)`,
                        );
                    }
                }
            }
            return { roadCount: roadCount, length: path.length };
        }
    }
    */
    recalculateRoadNetwork(storagePos, obstacles) {
        this.buildRoadNetwork(storagePos, obstacles);
        this.finalize();
    }
    
    computeRoadCoverage(storagePos, destination, drawPath = false, drawHeatMap = false) {
        let cpuBefore = Game.cpu.getUsed();
        // Custom callback to use the generated cost matrix
        const roomCallback = (roomName) => {
            // Check if we already have a cost matrix for this room
            if (!this.costMatrices[roomName]) {
                // If not, generate it considering the current obstacles
                this.costMatrices[roomName] = this.generateRoadPlanningCostMatrix(roomName, []); // Assuming `this.obstacles` holds your current obstacles
            }
            // Optionally draw the heat map of the cost matrix if drawHeatMap is true
            if (drawHeatMap) {
                const visual = new RoomVisual(roomName);
                const matrix = this.costMatrices[roomName];
                for(let y = 0; y < 50; ++y) {
                    for(let x = 0; x < 50; ++x) {
                        const cost = matrix.get(x, y);
                        // Ensure cost does not exceed 255 for color calculation
                        const cappedCost = Math.min(cost, 255);
                        // Calculate hue from green (0 cost, 120°) to red (255 cost, 0°)
                        const hue = 120 - (120 * cappedCost / 255);
                        // Construct the HSL color string
                        let color = `hsl(${hue}, 100%, 50%)`;
                        visual.rect(x - 0.5, y - 0.5, 1, 1, {fill: color, opacity: 0.4});
                    }
                }
            }

            return this.costMatrices[roomName];
        };
        const ret = PathFinder.search(
            storagePos,
            { pos: destination, range: 1 },
            { roomCallback: roomCallback, maxOps: 40000 },
        );
    
        if (ret.incomplete) {
            console.log(`Road coverage computation failed from ${storagePos} to ${destination}`);
            return; // Handle incomplete path as needed
        }
    
        const path = ret.path;
        let roadCount = 0;
        // Count existing roads along the path
        for (const pos of path) {
            // Adjust this check as needed, for example using lookFor(LOOK_STRUCTURES)
            if (Game.rooms[pos.roomName] && pos.lookFor(LOOK_STRUCTURES).some(s => s.structureType === STRUCTURE_ROAD)) {
                roadCount++;
            }
        }
    
        // Optionally draw the path if drawPath is true
        if (drawPath) {
            path.forEach((pos, index) => {
                const visual = new RoomVisual(pos.roomName);
                visual.circle(pos, {radius: 0.2, fill: 'lightblue', stroke: 'blue'});
                
            });
        }
    
        // console.log('used cpu ',(Game.cpu.getUsed() - cpuBefore).toFixed(1),'% computeRoadCoverage for ', 'from ',storagePos, 'to ', destination,' roadCount ',roadCount, ' coverage ', (roadCount*100/path.length).toFixed(1));
        return {
            roadCount: roadCount,
            length: path.length,
        };
    }

    // Connect commandCenter to hatchery, upgradeSites, and all miningSites, and place containers
    buildRoadNetwork(storagePos, obstacles) {
        // this.costMatrices = {}; // zGeneral 3/2024
        this.roadPositions = [];
        const destinations = _.sortBy(
            this.colony.destinations,
            (destination) => destination.order,
        );
        // Connect commandCenter to each destination in colony
        for (const destination of destinations) {
            this.planRoad(storagePos, destination.pos, obstacles);
        }
        this.formatRoadPositions();
    }
    // Plan a road between two locations avoiding a list of planned obstacles; pos1 should be storage for best results
    planRoad(pos1, pos2, obstacles) {
        // Find the shortest path, preferentially stepping on tiles with road routing flags on them
        const roadPath = this.generateRoadPath(pos1, pos2, obstacles);
        if (roadPath) {
            this.roadPositions = this.roadPositions.concat(roadPath);
        }
    }
    generateRoadPlanningCostMatrix(roomName, obstacles) {
    // Key for identifying the specific cost matrix in the cache (you might want to include obstacle info in the key)
    const key = 'roadPlanning' + obstacles.length; // Example key, adjust as needed

    // Use the caching mechanism to retrieve or generate the cost matrix
    return $.costMatrix(roomName, key, () => {
        const matrix = new PathFinder.CostMatrix();
        const terrain = Game.map.getRoomTerrain(roomName);
        /*
    generateRoadPlanningCostMatrix(roomName, obstacles) {
        const matrix = new PathFinder.CostMatrix();
        const terrain = Game.map.getRoomTerrain(roomName);
        */
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                switch (terrain.get(x, y)) {
                    case TERRAIN_MASK_SWAMP:
                        matrix.set(x, y, ROAD_PLANNER_SWAMP_COST);
                        break;
                    case TERRAIN_MASK_WALL:
                        if (x != 0 && y != 0 && x != 49 && y != 49) {
                            // Can't tunnel through walls on edge tiles
                            matrix.set(x, y, ROAD_PLANNER_TUNNEL_COST); //ROAD_PLANNER_TUNNEL_COST
                        } else {
                            matrix.set(x, y, 255); //not sure if this is still required!, but it does not harm!
                        }
                        break;
                    default:
                        // plain
                        matrix.set(x, y, ROAD_PLANNER_PLAIN_COST);
                        break;
                }
            }
        }
        for (const pos of obstacles) {
            if (pos.roomName == roomName) {
                matrix.set(pos.x, pos.y, 0xff);
            }
        }

        const room = Game.rooms[roomName];
        if (room) {
            // Initialize groups and other variables
            let Group1 = [];
            let Group2 = [];

            // Fetch all relevant structures in a single room.find call
            let allStructures = room.find(FIND_STRUCTURES); 
            let myConstructionSites = room.find(FIND_MY_CONSTRUCTION_SITES);

            // Single pass for structures to populate groups and set matrix values
            allStructures.forEach((s) => {
                // Non-walkable structures
                if (!s.isWalkable) {
                    matrix.set(s.pos.x, s.pos.y, 0xff);
                }

                // Special structures for groups
                if (s.structureType === STRUCTURE_EXTRACTOR) {
                    Group1.push(s);
                    Group2.push(s);
                } else if (
                    s.structureType === STRUCTURE_KEEPER_LAIR &&
                    !room.controller
                ) {
                    Group2.push(s);
                }
            });

            // Single pass for my construction sites
            myConstructionSites.forEach((site) => {
                if (!site.isWalkable) {
                    matrix.set(site.pos.x, site.pos.y, 0xff);
                }
            });

            // Directly add the room's controller to Group2 if it's owned by you
            if (room.controller && room.controller.my) {
                Group2.push(room.controller);
            }

            // Add sources to both groups
            let sources = room.find(FIND_SOURCES);
            Group1.push(...sources);
            Group2.push(...sources);

            const MaxCost = 255;
            const DefaultCost = 3;
            const K = 0.71; // Maximum influence value
            const n = 0.18; // Decay factor
            const SIZE = 50; // Assuming the room size is 50x50

            // Loop through sources and minerals
            Group1.forEach(({ pos: { x, y } }) => {
                matrix.set(x, y, MaxCost);

                for (let nx = 0; nx < SIZE; nx++) {
                    for (let ny = 0; ny < SIZE; ny++) {
                        const d = Math.sqrt(
                            Math.pow(x - nx, 2) + Math.pow(y - ny, 2),
                        );
                        const influence = K / Math.pow(d + 1, n);
                        let scaledInfluence = Math.min(
                            MaxCost - DefaultCost,
                            influence,
                        );

                        // Round to the nearest integer
                        scaledInfluence = Math.round(scaledInfluence);

                        // Get current cost and apply boundary checks after subtraction
                        const currentCost = matrix.get(nx, ny);
                        const newCost = Math.max(
                            0,
                            Math.min(MaxCost, currentCost - scaledInfluence),
                        );

                        // Update the matrix
                        if (
                            currentCost !== MaxCost &&
                            currentCost !== ROAD_PLANNER_TUNNEL_COST &&
                            currentCost !== 30 &&
                            nx > 0 &&
                            nx < SIZE &&
                            ny > 0 &&
                            ny < SIZE
                        ) {
                            matrix.set(nx, ny, newCost);
                        }
                    }
                }
            });

            // Loop through sources to set a range
            Group2.forEach(({ pos: { x, y } }) => {
                const range = room.controller && room.controller.my ? 3 : 2;
                for (let dx = -range; dx <= range; dx++) {
                    for (let dy = -range; dy <= range; dy++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < SIZE && ny > 0 && ny < SIZE) {
                            const currentCost = matrix.get(nx, ny);
                            if (
                                currentCost !== MaxCost &&
                                currentCost !== ROAD_PLANNER_TUNNEL_COST &&
                                currentCost !== 30
                            ) {
                                matrix.set(nx, ny, 2 * ROAD_PLANNER_SWAMP_COST);
                            }
                        }
                    }
                }
            });
        }

        return matrix;
    }); // remove this to rollback
    }

    /* Generates a road path and modifies cost matrices to encourage merging with future roads */
    generateRoadPath(origin, destination, obstacles) {
        const callback = (roomName) => {
            if (!this.colony.roomNames.includes(roomName)) {
                // only route through colony rooms
                return false;
            }
            if (
                Pathing.shouldAvoid(roomName) &&
                roomName != origin.roomName &&
                roomName != destination.roomName
            ) {
                return false;
            }
            if (!this.costMatrices[roomName]) {
                console.log('generateRoadPath',roomName, 'costMatrix recalculated');
                this.costMatrices[
                    roomName
                ] = this.generateRoadPlanningCostMatrix(roomName, obstacles);
            }
            return this.costMatrices[roomName];
        };
        const ret = PathFinder.search(
            origin,
            { pos: destination, range: 1 },
            { roomCallback: callback, maxOps: 40000 },
        );
        if (ret.incomplete) {
            log.warning(
                `Roadplanner for ${this.colony.print}: could not plan road path in ${ret.ops}!`,
            );
            return;
        }
        // Reduce the cost of planned paths to encourage road overlap for future pathing
        if (RoadPlanner_1.settings.encourageRoadMerging) {
            for (const i of _.range(ret.path.length)) {
                const pos = ret.path[i];
                if (
                    i % 2 == 0 &&
                    this.costMatrices[pos.roomName] &&
                    !pos.isEdge
                ) {
                    this.costMatrices[pos.roomName].set(
                        pos.x,
                        pos.y,
                        EXISTING_PATH_COST,
                    );
                }
            }
        }
        // Return the pathfinder results
        return ret.path;
    }
    /* Ensure that the roads doesn't overlap with roads from this.map and that the positions are unique */
    formatRoadPositions() {
        // Make road position list unique
        this.roadPositions = _.unique(this.roadPositions);
        // Remove roads located on exit tiles
        _.remove(this.roadPositions, (pos) => pos.isEdge);
        // Remove any roads duplicated in this.map
        const roomPlannerRoads = this.roomPlanner.plannedStructurePositions(
            STRUCTURE_ROAD,
        );
        if (roomPlannerRoads != undefined) {
            _.remove(this.roadPositions, (pos) =>
                roomPlannerRoads.includes(pos),
            );
        }
    }
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        // Collect all roads from this and from room planner
        let roomPlannerRoads;
        if (_.keys(this.roomPlanner.map).length > 0) {
            // use active map
            roomPlannerRoads = this.roomPlanner.map[STRUCTURE_ROAD];
        } else {
            // retrieve from memory
            if (
                this.roomPlanner.memory.bunkerData &&
                this.roomPlanner.memory.bunkerData.anchor
            ) {
                const layout = this.roomPlanner.getStructureMapForBunkerAt(
                    this.roomPlanner.memory.bunkerData.anchor,
                );
                roomPlannerRoads = layout[STRUCTURE_ROAD];
            } else if (this.roomPlanner.memory.mapsByLevel) {
                roomPlannerRoads = _.map(
                    this.roomPlanner.memory.mapsByLevel[8][STRUCTURE_ROAD],
                    (protoPos) => derefRoomPosition(protoPos),
                );
            } else {
                log.error(
                    `RoadPlanner@${this.colony.room.print}: could not get road positions from room planner!`,
                );
                roomPlannerRoads = [];
            }
        }
        const allRoadPos = _.compact(
            this.roadPositions.concat(roomPlannerRoads),
        );
        const allRoadPosByRoomName = _.groupBy(
            allRoadPos,
            (pos) => pos.roomName,
        );
        this.memory.roadCoordsPacked = {};
        for (const roomName in allRoadPosByRoomName) {
            this.memory.roadCoordsPacked[roomName] = packCoordList(
                allRoadPosByRoomName[roomName],
            );
        }
    }
    init() {}
    static shouldBuild(structureType, pos) {
        if (!pos.room) return false;
        const buildings = _.filter(
            pos.lookFor(LOOK_STRUCTURES),
            (s) => s && s.structureType == structureType,
        );
        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);
        if (!buildings || buildings.length == 0) {
            if (!sites || sites.length == 0) {
                return true;
            }
        }
        return false;
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissing() {
        // Max buildings that can be placed each tick
        let count =
            RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Build missing roads
        let roadPositions = [];
        for (const roomName in this.memory.roadCoordsPacked) {
            if (Game.rooms[roomName] !== undefined) {
                roadPositions = roadPositions.concat(
                    unpackCoordListAsPosList(
                        this.memory.roadCoordsPacked[roomName],
                        roomName,
                    ),
                );
            }
        }
        const origin = (
            this.colony.storage ||
            this.colony.hatchery ||
            this.colony
        ).pos;
        roadPositions = _.sortBy(roadPositions, (pos) =>
            pos.getMultiRoomRangeTo(origin),
        );
        let needsRoad = false;
        for (const pos of roadPositions) {
            const road = pos.lookForStructure(STRUCTURE_ROAD);
            if (!road) {
                needsRoad = true;
                if (count > 0) {
                    const ret = pos.createConstructionSite(STRUCTURE_ROAD);
                    if (ret != OK) {
                        if (ret == ERR_NOT_OWNER) {
                            if (Game.time % 50 == 0) {
                                log.warning(
                                    `${this.colony.print}: couldn't create road site at ${pos.print}; room ` +
                                        `is reserved/owned by hostile forces!`,
                                );
                            }
                        } else if (ret == ERR_FULL) {
                            // For some reason, when you place a construction site, the last check they run to see if
                            // you're already at max placed sites searches through EVERY SINGLE GAME OBJECT you have
                            // access to, which is quite expensive! Don't try to make a bunch more of these or you'll
                            // murder your CPU.
                            log.warning(
                                `${this.colony.print}: couldn't create road site at ${pos.print}, too many ` +
                                    `construction sites!`,
                            );
                            break;
                        } else {
                            log.warning(
                                `${this.colony.print}: couldn't create road site at ${pos.print} (${ret})`,
                            );
                        }
                    } else {
                        count--;
                    }
                }
            }
        }
        if (needsRoad) {
            this.roomPlanner.requestRecheck(100);
        }
    }
    /**
     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.
     */
    roadShouldBeHere(pos) {
        if (this._roadLookup == undefined) {
            this._roadLookup = _.memoize((p) =>
                (this.memory.roadCoordsPacked[p.roomName] || '').includes(
                    packCoord(p),
                ),
            );
        }
        return this._roadLookup(pos);
    }
    /**
     * Enumerate the positions in a room which should have roads on them
     */
    getRoadPositions(roomName) {
        if (this.memory.roadCoordsPacked[roomName]) {
            return unpackCoordListAsPosList(
                this.memory.roadCoordsPacked[roomName],
                roomName,
            );
        } else {
            return [];
        }
    }
    /* Clean up leftover road coverage locations from remotes that aren't mined or old structures */
    cleanRoadCoverage() {
        const colonyDestinations = this.colony.destinations.map(
            (dest) => `${dest.pos.roomName}:${dest.pos.x}:${dest.pos.y}`,
        );
        log.debug(
            `Colony ${this.colony.print} has destinations of ${JSON.stringify(
                colonyDestinations,
            )}`,
        ); // zGen: PR192
        for (const roadCoverageKey of Object.keys(this.memory.roadCoverages)) {
            // console.log(`Colony ${this.colony.name} Road coverage of ${roadCoverageKey}`);
            if (colonyDestinations.includes(roadCoverageKey));
            else {
                log.debug(
                    `Colony does not have destination of ${roadCoverageKey}, deleting.`,
                ); // zGen: PR192
                delete this.memory.roadCoverages[roadCoverageKey];
            }
        }
    }
    run() {
        if (this.roomPlanner.active) {
            if (this.roomPlanner.storagePos) {
                this.buildRoadNetwork(
                    this.roomPlanner.storagePos,
                    this.roomPlanner.getObstacles(),
                );
            }
            this.visuals();
        } else {
            // Once in a blue moon, recalculate the entire network and write to memory to keep it up to date
            if (
                Game.time %
                    RoadPlanner_1.settings.recalculateRoadNetworkInterval ==
                this.colony.id
            ) {
                if (this.roomPlanner.storagePos) {
                    this.cleanRoadCoverage();
                    this.recalculateRoadNetwork(
                        this.roomPlanner.storagePos,
                        this.roomPlanner.getObstacles(),
                    );
                }
            }
            // Recompute coverage to destinations
            if (
                Game.time % getAllColonies().length == this.colony.id &&
                this.roomPlanner.storagePos
            ) {
                this.recomputeRoadCoverages(this.roomPlanner.storagePos);
            }
            // Build missing roads
            if (
                this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL &&
                this.roomPlanner.shouldRecheck(3)
            ) {
                this.buildMissing();
            }
        }
    }
    visuals() {
        // Draw the map
        Visualizer.drawRoads(this.roadPositions);
    }
});
RoadPlanner.settings = {
    encourageRoadMerging: true,
    recalculateRoadNetworkInterval: onPublicServer() ? 1000 : 1100, // zGeneral 3/2024 from 250 to 1000
    recomputeCoverageInterval: onPublicServer() ? 1000 : 2000,  // zGeneral 3/2024 from 250 to 2000
    buildRoadsAtRCL: 4,
};
RoadPlanner = RoadPlanner_1 = __decorate([profile], RoadPlanner);

var RoomPlanner_1;
const getDefaultRoomPlannerMemory = () => ({
    active: true,
    savedFlags: [],
});
function getAllStructureCoordsFromLayout(layout, rcl) {
    if (!layout[rcl]) {
        return [];
    }
    const positionsByType = layout[rcl].buildings;
    let coords = [];
    for (const structureType in positionsByType) {
        coords = coords.concat(positionsByType[structureType].pos);
    }
    return _.unique(coords, (coord) => coord.x + 50 * coord.y);
}
function translatePositions(positions, fromAnchor, toAnchor) {
    const dx = toAnchor.x - fromAnchor.x;
    const dy = toAnchor.y - fromAnchor.y;
    const newPositions = [];
    for (const pos of positions) {
        newPositions.push(
            new RoomPosition(pos.x + dx, pos.y + dy, pos.roomName),
        );
    }
    return newPositions;
}
/**
 * The room planner handles structure placement within a room automatically or (in manual or semiautomatic mode) with
 * manual guidance from room planner flags.
 */
let RoomPlanner = (RoomPlanner_1 = class RoomPlanner {
    constructor(colony) {
        this.colony = colony;
        this.memory = Mem.wrap(
            this.colony.memory,
            'roomPlanner',
            getDefaultRoomPlannerMemory,
        );
        this.barrierPlanner = new BarrierPlanner(this);
        this.roadPlanner = new RoadPlanner(this);
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(
            this.colony.memory,
            'roomPlanner',
            getDefaultRoomPlannerMemory,
        );
        this.placements = {
            hatchery: undefined,
            commandCenter: undefined,
            bunker: undefined,
        };
        this.plan = {};
        this.map = {};
        this.barrierPlanner.refresh();
        this.roadPlanner.refresh();
        if (this.active && Game.time % 25 == 0) {
            log.alert(
                `RoomPlanner for ${this.colony.room.print} is still active! Close to save CPU.`,
            );
        }
    }
    get active() {
        return this.memory.active;
    }
    set active(active) {
        this.memory.active = active;
        if (active) {
            this.reactivate();
        }
    }
    /**
     * Recall or reconstruct the appropriate map from memory
     */
    recallMap(level = this.colony.controller.level) {
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            this.map = this.getStructureMapForBunkerAt(
                this.memory.bunkerData.anchor,
                level,
            );
        } else if (this.memory.mapsByLevel) {
            this.map = _.mapValues(this.memory.mapsByLevel[level], (posArr) =>
                _.map(posArr, (protoPos) => derefRoomPosition(protoPos)),
            );
        }
    }
    /**
     * Return a list of room positions for planned structure locations at RCL8 (or undefined if plan isn't made yet)
     */
    plannedStructurePositions(structureType) {
        if (this.map[structureType]) {
            return this.map[structureType];
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return this.getBunkerStructurePlacement(
                structureType,
                this.memory.bunkerData.anchor,
            );
        }
        const roomMap = this.memory.mapsByLevel
            ? this.memory.mapsByLevel[8]
            : undefined;
        if (roomMap && roomMap[structureType]) {
            return _.map(roomMap[structureType], (protoPos) =>
                derefRoomPosition(protoPos),
            );
        }
    }
    /**
     * Return the planned location of the storage structure
     */
    get storagePos() {
        if (this.placements.commandCenter) {
            return this.placements.commandCenter;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_STORAGE);
        if (positions) {
            return positions[0];
        }
    }
    /**
     * Return the planned location of the spawning structure
     */
    get hatcheryPos() {
        if (this.placements.hatchery) {
            return this.placements.hatchery;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_SPAWN);
        if (positions) {
            return positions[0];
        }
    }
    get bunkerPos() {
        if (this.placements.bunker) {
            return this.placements.bunker;
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return new RoomPosition(
                this.memory.bunkerData.anchor.x,
                this.memory.bunkerData.anchor.y,
                this.colony.name,
            );
        }
    }
    reactivate() {
        // Reinstantiate flags
        for (const protoFlag of this.memory.savedFlags) {
            const pos = derefRoomPosition(protoFlag.pos);
            const result = pos.createFlag(
                undefined,
                COLOR_WHITE,
                protoFlag.secondaryColor,
            );
            if (typeof result == 'string') {
                Memory.flags[result] = protoFlag.memory; // restore old memory
            }
        }
        this.memory.savedFlags = [];
        // Display the activation message
        const msg = [
            `Room planner activated for ${this.colony.name}. Reinstantiating flags from previous session on next tick.`,
            'Place colony components with room planner flags:',
            bullet + 'Place bunker (recommended)  white/red',
            bullet + 'Place hatchery:             white/green',
            bullet + 'Place command center:       white/blue',
            // 'Set component rotation by writing an angle (0,90,180,270 or 0,1,2,3) to flag.memory.rotation.',
            'Finalize layout ',
        ];
        _.forEach(msg, (command) => console.log(command));
    }
    /**
     * Run the room planner to generate a plan and map
     */
    make(level = 8) {
        // Reset everything
        this.plan = {};
        this.map = {};
        // Generate a plan, placing components by flags
        this.plan = this.generatePlan(level);
        // Flatten it into a map
        this.map = this.mapFromPlan(this.plan);
    }
    /**
     * Adds the specified structure directly to the map. Only callable after this.map is generated.
     * Doesn't check for conflicts, so don't use freely.
     */
    placeStructure(type, pos) {
        if (!this.map[type]) this.map[type] = [];
        this.map[type].push(pos);
    }
    addComponent(componentName, pos, rotation = 0) {
        this.placements[componentName] = pos;
    }
    /**
     * Switcher that takes a component name and returns a layout
     */
    getLayout(name) {
        switch (name) {
            case 'hatchery':
                return hatcheryLayout;
            case 'commandCenter':
                return commandCenterLayout;
            case 'bunker':
                return bunkerLayout;
        }
    }
    /**
     * Generate a plan of component placements for a given RCL
     */
    generatePlan(level = 8) {
        const plan = {};
        for (const name in this.placements) {
            const layout = this.getLayout(name);
            if (layout) {
                const anchor = layout.data.anchor;
                const pos = this.placements[name];
                if (!pos) continue;
                // let rotation: number = pos!.lookFor(LOOK_FLAGS)[0]!.memory.rotation || 0;
                const componentMap = this.parseLayout(layout, level);
                this.translateComponent(componentMap, anchor, pos);
                // if (rotation != 0) this.rotateComponent(componentMap, pos!, rotation);
                plan[name] = {
                    map: componentMap,
                    pos: new RoomPosition(anchor.x, anchor.y, this.colony.name),
                    rotation: 0,
                };
            }
        }
        return plan;
    }
    /**
     * Generate a map of (structure type: RoomPositions[]) for a given layout
     */
    parseLayout(structureLayout, level = 8) {
        const map = {};
        const layout = structureLayout[level];
        if (layout) {
            for (const buildingName in layout.buildings) {
                map[buildingName] = _.map(
                    layout.buildings[buildingName].pos,
                    (pos) => new RoomPosition(pos.x, pos.y, this.colony.name),
                );
            }
        }
        return map;
    }
    /**
     * Generate a flatened map from a plan
     */
    mapFromPlan(plan) {
        const map = {};
        const componentMaps = _.map(plan, (componentPlan) => componentPlan.map);
        const structureNames = _.unique(
            _.flatten(_.map(componentMaps, (map) => _.keys(map))),
        );
        for (const name of structureNames) {
            map[name] = _.compact(
                _.flatten(_.map(componentMaps, (map) => map[name])),
            );
        }
        return map;
    }
    /**
     * Aligns the component position to the desired position; operations done in-place
     */
    translateComponent(map, fromPos, toPos) {
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                pos.x += dx;
                pos.y += dy;
            }
        }
    }
    // No-fixTODO: component rotation isn't currently fully supported
    /* Rotates component positions about a pivot point counterclockwise by the given angle; done in-place */
    rotateComponent(map, pivot, angle) {
        let R = ([x, y]) => [x, y];
        if (angle == 0) {
            return;
        } else if (angle == 90 || angle == 1) {
            R = ([x, y]) => [-y, x];
        } else if (angle == 180 || angle == 2) {
            R = ([x, y]) => [-x, -y];
        } else if (angle == 270 || angle == 3) {
            R = ([x, y]) => [y, -x];
        }
        // Apply the rotation to the map
        let offset, dx, dy;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                offset = [pos.x - pivot.x, pos.y - pivot.y];
                [dx, dy] = R(offset);
                pos.x = pivot.x + dx;
                pos.y = pivot.y + dy;
            }
        }
    }
    /**
     * Get bunker building placements as a StructureMap
     */
    getStructureMapForBunkerAt(anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const structureLayout = _.mapValues(
            bunkerLayout[level].buildings,
            (obj) => obj.pos,
        );
        return _.mapValues(structureLayout, (coordArr) =>
            _.map(
                coordArr,
                (coord) =>
                    new RoomPosition(
                        coord.x + dx,
                        coord.y + dy,
                        this.colony.name,
                    ),
            ),
        );
    }
    /**
     * Get the placement for a single type of structure for bunker layout
     */
    getBunkerStructurePlacement(structureType, anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        return _.map(
            bunkerLayout[level].buildings[structureType].pos,
            (coord) =>
                new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name),
        );
    }
    /**
     * Generates a list of impassible obstacles from this.map or from this.memory.map
     */
    getObstacles() {
        let obstacles = [];
        // Add sources and extractors to impassibles for tunnels
        obstacles.concat(_.map(this.colony.sources, (source) => source.pos));
        obstacles.concat(_.map(this.colony.extractors, (extr) => extr.pos));
        const passableStructureTypes = [
            STRUCTURE_ROAD,
            STRUCTURE_CONTAINER,
            STRUCTURE_RAMPART,
        ];
        if (_.keys(this.map).length > 0) {
            // if room planner has made the map, use that
            for (const structureType in this.map) {
                if (!passableStructureTypes.includes(structureType)) {
                    obstacles = obstacles.concat(this.map[structureType]);
                }
            }
        } else {
            // else, serialize from memory
            if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
                const structureMap = this.getStructureMapForBunkerAt(
                    this.memory.bunkerData.anchor,
                );
                for (const structureType in structureMap) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(
                            structureMap[structureType],
                        );
                    }
                }
            } else if (this.memory.mapsByLevel) {
                for (const structureType in this.memory.mapsByLevel[8]) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(
                            _.map(
                                this.memory.mapsByLevel[8][structureType],
                                (protoPos) => derefRoomPosition(protoPos),
                            ),
                        );
                    }
                }
            }
        }
        return _.unique(obstacles);
    }
    /**
     * Check to see if there are any structures that can't be built
     */
    findCollision(ignoreRoads = false) {
        const terrain = Game.map.getRoomTerrain(this.colony.room.name);
        for (const structureType in this.map) {
            if (ignoreRoads && structureType == STRUCTURE_ROAD) {
                continue;
            }
            for (const pos of this.map[structureType]) {
                if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                    return pos;
                }
            }
        }
    }
    /**
     * Write everything to memory at the end of activation. If ignoreRoads is set, it will allow collisions with
     * roads, but will continue to alert you every time it fails to build a road in the terrain pos (WIP)
     */
    finalize(ignoreRoads = false) {
        const collision = this.findCollision(ignoreRoads);
        if (collision) {
            log.warning(
                `Invalid layout: collision detected at ${collision.print}!`,
            );
            return;
        }
        const layoutIsValid =
            (!!this.placements.commandCenter && !!this.placements.hatchery) ||
            !!this.placements.bunker;
        if (layoutIsValid) {
            // Write everything to memory
            // Generate maps for each rcl
            delete this.memory.bunkerData;
            delete this.memory.mapsByLevel;
            if (this.placements.bunker) {
                this.memory.bunkerData = {
                    anchor: this.placements.bunker,
                };
            } else {
                this.memory.mapsByLevel = {};
                for (let rcl = 1; rcl <= 8; rcl++) {
                    this.make(rcl);
                    this.memory.mapsByLevel[rcl] = this.map;
                }
            }
            // Finalize the barrier planner
            this.barrierPlanner.finalize();
            // Finalize the road planner
            this.roadPlanner.finalize();
            // Save flags and remove them
            const flagsToWrite = _.filter(
                this.colony.flags,
                (flag) => flag.color == COLOR_WHITE,
            );
            for (const flag of flagsToWrite) {
                this.memory.savedFlags.push({
                    secondaryColor: flag.secondaryColor,
                    pos: flag.pos,
                    memory: flag.memory,
                });
                flag.remove();
            }
            this.memory.lastGenerated = Game.time;
            console.log('Room layout and flag positions have been saved.');
            // Destroy needed buildings
            if (this.colony.level == 1) {
                // clear out room if setting in for first time
                this.demolishMisplacedStructures(true, true);
                // Demolish all barriers that aren't yours
                for (const barrier of this.colony.room.barriers) {
                    if (
                        barrier.structureType == STRUCTURE_WALL ||
                        !barrier.my
                    ) {
                        barrier.destroy();
                    }
                }
            }
            this.memory.recheckStructuresAt = Game.time + 3;
            this.active = false;
        } else {
            log.warning(
                'Not a valid room layout! Must have both hatchery and commandCenter placements ' +
                    'or bunker placement.',
            );
        }
    }
    /**
     * Whether a constructionSite should be placed at a position
     */
    static canBuild(structureType, pos) {
        if (!pos.room) return false;
        const structure = pos.lookForStructure(structureType);
        const constructionSite = pos.lookFor(LOOK_CONSTRUCTION_SITES)[0];
        return !structure && !constructionSite;
    }
    /**
     * Whether a structure (or constructionSite) of given type should be at location.
     */
    structureShouldBeHere(
        structureType,
        pos,
        level = this.colony.controller.level,
    ) {
        if (structureType == STRUCTURE_ROAD) {
            return this.roadShouldBeHere(pos);
        } else if (structureType == STRUCTURE_RAMPART) {
            return this.barrierPlanner.barrierShouldBeHere(pos);
        } else if (structureType == STRUCTURE_EXTRACTOR) {
            return pos.lookFor(LOOK_MINERALS).length > 0;
        } else {
            if (_.isEmpty(this.map)) {
                this.recallMap(level);
            }
            const positions = this.map[structureType];
            if (positions && _.find(positions, (p) => p.isEqualTo(pos))) {
                return true;
            }
            if (structureType === STRUCTURE_CONTAINER) {
                if (
                    this.colony.upgradeSite.batteryPos &&
                    this.colony.upgradeSite.batteryPos.isEqualTo(pos)
                ) {
                    return true;
                }
                const thingsBuildingContainers = _.map(
                    [...this.colony.room.sources, this.colony.room.mineral],
                    (thing) => thing.pos,
                );
                return pos.findInRange(thingsBuildingContainers, 1).length > 0;
            } else if (structureType === STRUCTURE_LINK) {
                const thingsBuildingLinks = _.map(
                    [...this.colony.room.sources, this.colony.controller],
                    (thing) => thing.pos,
                );
                return pos.findInRange(thingsBuildingLinks, 3).length > 0;
            }
        }
        return false;
    }
    /**
     * Demolish all hostile structures in the room
     */
    demolishHostileStructures(destroyStorageUnits = false) {
        _.forEach(this.colony.room.walls, (wall) => wall.destroy()); // overmind never uses walls
        for (const structure of _.filter(this.colony.room.hostileStructures)) {
            if (
                (structure.structureType != STRUCTURE_STORAGE &&
                    structure.structureType != STRUCTURE_TERMINAL) ||
                destroyStorageUnits
            ) {
                structure.destroy();
            }
        }
    }
    /**
     * Remove all hostile constructionSites and ones which are misplaced
     */
    removeMisplacedConstructionSites() {
        for (const site of this.colony.room.find(FIND_CONSTRUCTION_SITES)) {
            if (site.owner.username != MY_USERNAME) {
                site.remove();
            } else if (
                !this.structureShouldBeHere(site.structureType, site.pos)
            ) {
                site.remove();
            }
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    demolishMisplacedStructures(
        skipRamparts = true,
        destroyAllStructureTypes = false,
    ) {
        this.demolishHostileStructures();
        this.removeMisplacedConstructionSites();
        if (getAllColonies().length <= 1 && !this.colony.storage) {
            return; // Not safe to move structures until you have multiple colonies or a storage
        }
        // Start terminal evacuation if it needs to be moved
        if (this.colony.terminal) {
            if (
                (this.colony.storage &&
                    !this.structureShouldBeHere(
                        STRUCTURE_STORAGE,
                        this.colony.storage.pos,
                    )) ||
                !this.structureShouldBeHere(
                    STRUCTURE_TERMINAL,
                    this.colony.terminal.pos,
                )
            ) {
                DirectiveTerminalRebuildState.createIfNotPresent(
                    this.colony.terminal.pos,
                    'pos',
                );
            }
        }
        // Max buildings that can be placed each tick
        const count =
            RoomPlanner_1.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || this.map == {}) {
            // in case a map hasn't been generated yet
            log.info(
                this.colony.name +
                    ' does not have a room plan yet! Unable to demolish errant structures.',
            );
        }
        // Destroy extractor if needed
        if (this.colony.room.extractor && !this.colony.room.extractor.my) {
            this.colony.room.extractor.destroy();
        }
        // Build missing structures from room plan
        this.memory.relocating = false;
        for (const priority of DemolishStructurePriorities) {
            const structureType = priority.structureType;
            // // don't demolish bunker baby ramparts until the new ones are sufficiently big
            // if (structureType == STRUCTURE_RAMPART && this.colony.layout == 'bunker') {
            // 	let bunkerBarriers = _.filter(this.colony.room.barriers, b => insideBunkerBounds(b.pos, this.colony));
            // 	let avgBarrierHits = (_.sum(bunkerBarriers, barrier => barrier.hits) / bunkerBarriers.length) || 0;
            // 	if (avgBarrierHits < 1e+6) continue;
            // }
            const maxRemoved = priority.maxRemoved || Infinity;
            let removeCount = 0;
            let structures = _.filter(
                this.colony.room.find(FIND_STRUCTURES),
                (s) => s.structureType == structureType,
            );
            if (structureType == STRUCTURE_WALL) {
                structures = _.filter(
                    structures,
                    (wall) => wall.hits != undefined,
                ); // can't destroy newbie walls
            }
            // Loop through all structures and conditionally remove ones which are misplaced
            for (const structure of structures) {
                if (
                    !this.structureShouldBeHere(structureType, structure.pos) ||
                    (isOwnedStructure(structure) && !structure.my)
                ) {
                    // Don't demolish your own ramparts, just let them decay
                    if (
                        skipRamparts &&
                        !destroyAllStructureTypes &&
                        structure.structureType == STRUCTURE_RAMPART &&
                        structure.my
                    ) {
                        continue;
                    }
                    // remove misplaced structures or hostile owned structures, with exceptions below
                    if (
                        this.colony.level < 4 &&
                        (structureType == STRUCTURE_STORAGE ||
                            structureType == STRUCTURE_TERMINAL)
                    ) {
                        break; // don't destroy terminal or storage when under RCL4 - can use energy inside
                    }
                    if (
                        this.colony.level < 6 &&
                        structureType == STRUCTURE_TERMINAL &&
                        hasMinerals(structure.store)
                    ) {
                        break; // don't destroy terminal when under RCL6 if there are resources available.
                    }
                    if (
                        structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART
                    ) {
                        this.memory.relocating = true;
                    }
                    // Don't remove the terminal until you have rebuilt storage
                    if (
                        this.colony.level >= 6 &&
                        structureType == STRUCTURE_TERMINAL
                    ) {
                        if (!this.colony.storage) {
                            log.info(
                                `${this.colony.name}: waiting until storage is built to remove terminal`,
                            );
                            return;
                        } else if (
                            this.colony.terminal &&
                            sumStore(this.colony.terminal.store) -
                                this.colony.terminal.energy >
                                1000
                        ) {
                            log.info(
                                `${this.colony.name}: waiting on resources to evacuate before removing terminal`,
                            );
                            return;
                        } else if (
                            this.colony.storage &&
                            this.structureShouldBeHere(
                                STRUCTURE_STORAGE,
                                this.colony.storage.pos,
                            ) &&
                            this.colony.storage.energy <
                                Energetics.settings.storage.energy
                                    .destroyTerminalThreshold
                        ) {
                            log.info(
                                `${this.colony.name}: waiting to move energy to storage before removing terminal`,
                            );
                            return;
                        }
                    }
                    // Only remove a maximum number of structures at a time
                    const amountMissing =
                        CONTROLLER_STRUCTURES[structureType][
                            this.colony.level
                        ] -
                        structures.length +
                        removeCount;
                    if (amountMissing < maxRemoved) {
                        if (
                            structureType == STRUCTURE_SPAWN &&
                            this.colony.spawns.length == 1
                        ) {
                            const spawnCost = 25000;
                            if (
                                this.colony.assets[RESOURCE_ENERGY] < spawnCost
                            ) {
                                log.warning(
                                    `${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                        `${this.colony.assets[RESOURCE_ENERGY]}/${spawnCost} energy available`,
                                );
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                            const workTicksNeeded = 25000 / BUILD_POWER;
                            const workTicksAvailable = _.sum(
                                this.colony.overlords.work.workers,
                                (worker) =>
                                    worker.getActiveBodyparts(WORK) *
                                    (worker.ticksToLive || 0),
                            );
                            if (workTicksAvailable < workTicksNeeded) {
                                log.warning(
                                    `${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                        `${workTicksAvailable}/${workTicksNeeded} [WORK * ticks] available`,
                                );
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                        }
                        // TODO: adding this for safety for now; remove later
                        const result = 'destroy() disabled'; // structure.destroy();
                        if (result != OK) {
                            log.warning(
                                `${this.colony.name}: couldn't destroy structure of type ` +
                                    `"${structureType}" at ${structure.pos.print}. Result: ${result}`,
                            );
                        } else {
                            log.info(
                                `${this.colony.name}: destroyed ${structureType} at ${structure.pos.print}`,
                            );
                        }
                        removeCount++;
                        this.memory.recheckStructuresAt =
                            Game.time + RoomPlanner_1.settings.recheckAfter;
                    }
                }
            }
            if (this.memory.relocating && !destroyAllStructureTypes) {
                return;
            }
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    buildMissingStructures() {
        // Max buildings that can be placed each tick
        let count =
            RoomPlanner_1.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || this.map == {}) {
            // in case a map hasn't been generated yet
            log.info(
                this.colony.name +
                    ' does not have a room plan yet! Unable to build missing structures.',
            );
        }
        // Build missing structures from room plan
        for (const structureType of BuildPriorities) {
            if (this.map[structureType]) {
                for (const pos of this.map[structureType]) {
                    if (
                        (structureType == STRUCTURE_SPAWN || count > 0) &&
                        RoomPlanner_1.canBuild(structureType, pos)
                    ) {
                        const result = pos.createConstructionSite(
                            structureType,
                        );
                        // If spawn fails to be placed, it might be move of first spawn
                        if (
                            result != OK &&
                            !(
                                structureType == STRUCTURE_SPAWN &&
                                result == ERR_RCL_NOT_ENOUGH
                            )
                        ) {
                            const structures = pos.lookFor(LOOK_STRUCTURES);
                            for (const structure of structures) {
                                // let thisImportance = _.findIndex(BuildPriorities, type => type == structureType);
                                // let existingImportance = _.findIndex(BuildPriorities,
                                // 									 type => type == structure.structureType);
                                const safeTypes = [
                                    STRUCTURE_STORAGE,
                                    STRUCTURE_TERMINAL,
                                    STRUCTURE_SPAWN,
                                ];
                                // Destroy the structure if it is less important and not protected
                                if (
                                    !this.structureShouldBeHere(
                                        structure.structureType,
                                        pos,
                                    ) &&
                                    !safeTypes.includes(structure.structureType)
                                ) {
                                    const result = 'destroy() disabled'; // structure.destroy();
                                    if (result == OK) {
                                        log.info(
                                            `${this.colony.name}: destroyed ${structure.structureType} at` +
                                                ` ${structure.pos.print}`,
                                        );
                                        this.memory.recheckStructuresAt =
                                            Game.time +
                                            RoomPlanner_1.settings.recheckAfter;
                                    } else {
                                        log.warning(
                                            `${this.colony.name}: couldn't destroy ${structure.structureType}` +
                                                ` at ${structure.pos.print}! Result: ${result}`,
                                        );
                                    }
                                }
                            }
                            log.warning(
                                `${this.colony.name}: couldn't create construction site of type ` +
                                    `"${structureType}" at ${pos.print}. Result: ${result}`,
                            );
                        } else {
                            count--;
                            this.memory.recheckStructuresAt =
                                Game.time + RoomPlanner_1.settings.recheckAfter;
                        }
                    }
                }
            }
        }
        // Build extractor on mineral deposit if not already present
        const mineral = this.colony.room.find(FIND_MINERALS)[0];
        if (mineral) {
            const extractor = mineral.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            if (!extractor) {
                mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
            }
        }
    }
    /**
     * Calculate where the link will be built
     */
    calculateLinkPos(anchor) {
        if (anchor.isEqualTo(this.colony.controller.pos)) {
            return this.calculateUpgradeSiteLinkPos();
        }
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        } else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(anchor, originPos).path;
            return _.find(path, (pos) => anchor.getRangeTo(pos) == 2);
        }
    }
    /**
     * Calculate where the link will be built for this site
     */
    calculateUpgradeSiteLinkPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        } else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos && this.colony.upgradeSite.batteryPos) {
            // Build link at last location on path from origin to battery
            const path = Pathing.findShortestPath(
                this.colony.upgradeSite.batteryPos,
                originPos,
            ).path;
            return path[0];
        }
    }
    nextNeededLinkAnchor() {
        const linksEtAl = _.map(
            [].concat(
                this.colony.links,
                _.filter(
                    this.colony.constructionSites,
                    (site) => site.structureType == STRUCTURE_LINK,
                ),
            ),
            (s) => s.pos,
        );
        // UpgradeSite goes first
        const upgradeLink = this.colony.controller.pos.findClosestByLimitedRange(
            linksEtAl,
            3,
        );
        if (!upgradeLink) return this.colony.controller.pos;
        // MiningSites by decreasing distance
        const origin = (
            this.colony.storage ||
            this.colony.terminal ||
            _.first(this.colony.spawns) ||
            this.colony
        ).pos;
        const farthestSources = _.sortBy(
            this.colony.room.sources,
            (source) => -1 * (Pathing.distance(origin, source.pos) || Infinity),
        );
        for (const source of farthestSources) {
            const sourceLink = source.pos.findClosestByLimitedRange(
                linksEtAl,
                2,
            );
            if (!sourceLink) return source.pos;
        }
    }
    /**
     * Builds links as they become available. UpgradeSite gets link first, then miningSites by distance.
     */
    buildNeededLinks() {
        const numLinks =
            this.colony.links.length +
            _.filter(
                this.colony.constructionSites,
                (site) => site.structureType == STRUCTURE_LINK,
            ).length;
        const numLinksAllowed = CONTROLLER_STRUCTURES.link[this.colony.level];
        if (
            numLinksAllowed > numLinks &&
            (this.colony.bunker ||
                (this.colony.hatchery && this.colony.hatchery.link)) &&
            this.colony.commandCenter &&
            this.colony.commandCenter.link
        ) {
            const anchor = this.nextNeededLinkAnchor();
            if (!anchor) {
                return;
            }
            const linkPos = this.calculateLinkPos(anchor);
            if (!linkPos) {
                log.warning(
                    `Could not calculate link position for anchor at ${anchor.print}!`,
                );
                return;
            }
            linkPos.createConstructionSite(STRUCTURE_LINK);
        }
    }
    /**
     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.
     */
    roadShouldBeHere(pos) {
        return this.roadPlanner.roadShouldBeHere(pos);
    }
    init() {
        if (this.active) {
            Overmind.overseer.notifier.alert(
                `Room planner active!`,
                this.colony.room.name,
            );
        }
        if (
            this.active &&
            getAutonomyLevel() == Autonomy.Automatic &&
            !this.memory.bunkerData
        ) {
            let bunkerAnchor;
            if (this.colony.spawns.length > 0) {
                // in case of very first spawn
                const lowerRightSpawn = maxBy(
                    this.colony.spawns,
                    (s) => 50 * s.pos.y + s.pos.x,
                );
                const spawnPos = lowerRightSpawn.pos;
                bunkerAnchor = new RoomPosition(
                    spawnPos.x - 4,
                    spawnPos.y,
                    spawnPos.roomName,
                );
            } else {
                const expansionData = RoomIntel.getExpansionData(
                    this.colony.room.name,
                );
                if (expansionData) {
                    bunkerAnchor = expansionData.bunkerAnchor;
                } else {
                    log.error(
                        `Cannot determine anchor! No spawns or expansionData.bunkerAnchor for ` +
                            `${this.colony.print}!`,
                    );
                    return;
                }
            }
            this.addComponent('bunker', bunkerAnchor);
        }
        this.barrierPlanner.init();
        this.roadPlanner.init();
    }
    requestRecheck(ticksFromNow = 1) {
        this.memory.recheckStructuresAt = Game.time + ticksFromNow;
    }
    shouldRecheck(offset = 0) {
        if (
            Game.time ==
            (this.memory.recheckStructuresAt || Infinity) + offset
        ) {
            return true;
        } else {
            const checkFreq =
                RoomPlanner_1.settings.siteCheckFrequency * this.colony.level;
            return (
                Game.time % checkFreq ==
                (2 * this.colony.id + offset) % checkFreq
            );
        }
    }
    run() {
        if (this.active) {
            this.make();
            this.visuals();
        } else {
            // Build missing structures from the layout
            if (this.shouldRecheck()) {
                this.demolishMisplacedStructures();
            } else if (this.shouldRecheck(1)) {
                this.buildMissingStructures();
            }
            // Build missing links as needed
            if (Game.time % RoomPlanner_1.settings.linkCheckFrequency == 3) {
                this.buildNeededLinks();
            }
        }
        // Run the barrier planner
        this.barrierPlanner.run();
        // Run the road planner
        this.roadPlanner.run();
        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {
            if (this.placements.bunker) {
                this.finalize();
            } else {
                log.warning(`No bunker placement!`);
            }
        }
    }
    visuals() {
        // Draw the map
        if (getAutonomyLevel() < Autonomy.Automatic) {
            const expansionData = RoomIntel.getExpansionData(
                this.colony.room.name,
            );
            if (expansionData) {
                Visualizer.drawLayout(
                    bunkerLayout,
                    expansionData.bunkerAnchor,
                    {
                        opacity: 0.2,
                    },
                );
            }
        }
        Visualizer.drawStructureMap(this.map);
    }
});
RoomPlanner.settings = {
    recheckAfter: 50,
    siteCheckFrequency: onPublicServer() ? 50 : 20,
    linkCheckFrequency: 100,
    maxSitesPerColony: onPublicServer() ? 10 : 25,
    maxDismantleCount: 5,
};
RoomPlanner = RoomPlanner_1 = __decorate([profile], RoomPlanner);

/* tslint:disable */
const BUNKER_RADIUS = 6;
const bunkerLayout = {
    data: {
        anchor: { x: 25, y: 25 },
    },
    1: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '1',
        buildings: {
            spawn: { pos: [{ x: 29, y: 25 }] },
        },
    },
    2: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '2',
        buildings: {
            extension: {
                pos: [
                    { x: 28, y: 26 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    {
                        x: 27,
                        y: 28,
                    },
                    { x: 29, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    3: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '3',
        buildings: {
            tower: { pos: [{ x: 25, y: 26 }] },
            extension: {
                pos: [
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    {
                        x: 27,
                        y: 27,
                    },
                    { x: 27, y: 28 },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    {
                        x: 27,
                        y: 29,
                    },
                    { x: 29, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    4: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '4',
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [] },
            nuker: { pos: [] },
            tower: { pos: [{ x: 25, y: 26 }] },
            powerSpawn: { pos: [] },
            link: { pos: [] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 23,
                        y: 20,
                    },
                    { x: 24, y: 28 },
                    { x: 23, y: 29 },
                    { x: 23, y: 30 },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: { pos: [] },
            extension: {
                pos: [
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 24,
                        y: 30,
                    },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    { x: 24, y: 29 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    5: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '5',
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                ],
            },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 23,
                        y: 20,
                    },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: { pos: [] },
            extension: {
                pos: [
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 23,
                        y: 27,
                    },
                    { x: 24, y: 28 },
                    { x: 23, y: 28 },
                    { x: 22, y: 27 },
                    { x: 21, y: 27 },
                    {
                        x: 22,
                        y: 28,
                    },
                    { x: 23, y: 29 },
                    { x: 21, y: 28 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    {
                        x: 26,
                        y: 30,
                    },
                    { x: 29, y: 26 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 30, y: 27 },
                    {
                        x: 25,
                        y: 29,
                    },
                    { x: 22, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    6: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '6',
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                ],
            },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 22,
                        y: 22,
                    },
                    { x: 23, y: 23 },
                    { x: 23, y: 20 },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: {
                pos: [
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    { x: 28, y: 23 },
                ],
            },
            extension: {
                pos: [
                    { x: 22, y: 24 },
                    { x: 22, y: 23 },
                    { x: 21, y: 23 },
                    {
                        x: 30,
                        y: 24,
                    },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    { x: 20, y: 24 },
                    { x: 20, y: 25 },
                    {
                        x: 20,
                        y: 26,
                    },
                    { x: 21, y: 22 },
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    {
                        x: 27,
                        y: 27,
                    },
                    { x: 27, y: 28 },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    {
                        x: 27,
                        y: 29,
                    },
                    { x: 26, y: 28 },
                    { x: 22, y: 26 },
                    { x: 23, y: 27 },
                    { x: 24, y: 28 },
                    {
                        x: 23,
                        y: 28,
                    },
                    { x: 22, y: 27 },
                    { x: 21, y: 27 },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    {
                        x: 22,
                        y: 29,
                    },
                    { x: 21, y: 28 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    {
                        x: 29,
                        y: 26,
                    },
                    { x: 21, y: 24 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    7: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '7',
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                    { x: 25, y: 23 },
                ],
            },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 27, y: 22 },
                    { x: 28, y: 21 },
                    {
                        x: 23,
                        y: 25,
                    },
                    { x: 27, y: 25 },
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
            observer: { pos: [] },
            lab: {
                pos: [
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    { x: 28, y: 22 },
                    {
                        x: 28,
                        y: 23,
                    },
                    { x: 29, y: 23 },
                    { x: 29, y: 22 },
                ],
            },
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 23, y: 23 },
                    { x: 22, y: 24 },
                    {
                        x: 22,
                        y: 23,
                    },
                    { x: 23, y: 22 },
                    { x: 23, y: 21 },
                    { x: 22, y: 22 },
                    { x: 21, y: 23 },
                    {
                        x: 25,
                        y: 20,
                    },
                    { x: 26, y: 20 },
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 20,
                        y: 24,
                    },
                    { x: 20, y: 25 },
                    { x: 20, y: 26 },
                    { x: 22, y: 21 },
                    { x: 21, y: 22 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 22,
                        y: 26,
                    },
                    { x: 23, y: 27 },
                    { x: 24, y: 28 },
                    { x: 23, y: 28 },
                    { x: 22, y: 27 },
                    {
                        x: 21,
                        y: 27,
                    },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    { x: 22, y: 29 },
                    { x: 21, y: 28 },
                    {
                        x: 24,
                        y: 30,
                    },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    { x: 21, y: 24 },
                    {
                        x: 26,
                        y: 21,
                    },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    { x: 27, y: 20 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 29, y: 25 },
                    { x: 26, y: 24 },
                ],
            },
            container: {
                pos: [
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
        },
    },
    8: {
        name: 'bunkerCore',
        shard: 'shard2',
        rcl: '8',
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            //'nuker'		: {'pos': [{'x': 23, 'y': 27}]},			 // zGen: relocate nuker
            factory: { pos: [{ x: 24, y: 24 }] },
            tower: {
                pos: [
                    { x: 27, y: 25 },
                    { x: 23, y: 25 },
                    { x: 25, y: 27 },
                    {
                        x: 25,
                        y: 23,
                    },
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                ],
            },
            powerSpawn: { pos: [{ x: 24, y: 26 }] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
            observer: { pos: [{ x: 21, y: 25 }] },
            lab: {
                pos: [
                    { x: 26, y: 22 },
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    {
                        x: 27,
                        y: 22,
                    },
                    { x: 27, y: 21 },
                    { x: 28, y: 22 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    {
                        x: 28,
                        y: 21,
                    },
                    { x: 29, y: 22 },
                ],
            },
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 23, y: 23 },
                    { x: 22, y: 24 },
                    {
                        x: 22,
                        y: 23,
                    },
                    { x: 23, y: 22 },
                    { x: 23, y: 21 },
                    { x: 22, y: 22 },
                    { x: 21, y: 23 },
                    {
                        x: 24,
                        y: 20,
                    },
                    { x: 25, y: 20 },
                    { x: 26, y: 20 },
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    {
                        x: 30,
                        y: 26,
                    },
                    { x: 20, y: 24 },
                    { x: 20, y: 25 },
                    { x: 20, y: 26 },
                    { x: 22, y: 21 },
                    {
                        x: 21,
                        y: 22,
                    },
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    {
                        x: 27,
                        y: 28,
                    },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    {
                        x: 26,
                        y: 28,
                    },
                    { x: 22, y: 26 },
                    { x: 24, y: 28 },
                    { x: 23, y: 27 },
                    { x: 23, y: 28 },
                    {
                        x: 22,
                        y: 27,
                    },
                    { x: 21, y: 27 },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    { x: 22, y: 29 },
                    {
                        x: 21,
                        y: 28,
                    },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    {
                        x: 21,
                        y: 24,
                    },
                    { x: 26, y: 21 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    {
                        x: 27,
                        y: 20,
                    },
                    { x: 30, y: 27 },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 29, y: 25 },
                    { x: 26, y: 24 },
                    { x: 25, y: 21 },
                ],
            },
            container: {
                pos: [
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
        },
    },
};
let _allBunkerCoords = {};
for (let rcl of [1, 2, 3, 4, 5, 6, 7, 8]) {
    if (bunkerLayout[rcl].buildings) {
        _allBunkerCoords[rcl] = getAllStructureCoordsFromLayout(
            bunkerLayout,
            rcl,
        );
    }
    if (rcl == 7 || rcl == 8) {
        // add center tile for advanced bunkers
        _allBunkerCoords[rcl].push(bunkerLayout.data.anchor);
    }
}
const allBunkerCoords = _allBunkerCoords;
const bunkerCoordLookup = _.mapValues(_allBunkerCoords, (coordArr) =>
    _.zipObject(_.map(coordArr, (c) => [packCoord(c), true])),
);
// Fast function for checking if a position is inside the bunker
function insideBunkerBounds(pos, colony) {
    if (
        colony.roomPlanner.memory.bunkerData &&
        colony.roomPlanner.memory.bunkerData.anchor
    ) {
        const dx =
            bunkerLayout.data.anchor.x -
            colony.roomPlanner.memory.bunkerData.anchor.x;
        const dy =
            bunkerLayout.data.anchor.y -
            colony.roomPlanner.memory.bunkerData.anchor.y;
        const coord = { x: pos.x + dx, y: pos.y + dy };
        return !!bunkerCoordLookup[colony.level][packCoord(coord)];
    }
    return false;
}
function getPosFromBunkerCoord(coord, colony) {
    if (
        colony.roomPlanner.memory.bunkerData &&
        colony.roomPlanner.memory.bunkerData.anchor
    ) {
        let dx =
            colony.roomPlanner.memory.bunkerData.anchor.x -
            bunkerLayout.data.anchor.x;
        let dy =
            colony.roomPlanner.memory.bunkerData.anchor.y -
            bunkerLayout.data.anchor.y;
        return new RoomPosition(coord.x + dx, coord.y + dy, colony.room.name);
    }
    console.log(
        "getPosFromBunkerCoord: shouldn't reach here! Unprotected call from non-bunker?",
    );
    return new RoomPosition(-1, -1, 'invalid');
}
const reagentLabSpots = [
    { x: 27, y: 22 },
    { x: 28, y: 23 },
];
// Efficient, hard-coded order in which to refill extensions, spawns, labs, and towers
const quadrantFillOrder = {
    lowerRight: [
        { x: 30, y: 24 },
        { x: 30, y: 25 },
        { x: 29, y: 25 },
        { x: 29, y: 26 },
        { x: 28, y: 26 },
        {
            x: 27,
            y: 25,
        },
        { x: 28, y: 27 },
        { x: 27, y: 27 },
        { x: 27, y: 28 },
        { x: 26, y: 28 },
        { x: 27, y: 29 },
        {
            x: 28,
            y: 29,
        },
        { x: 28, y: 28 },
        { x: 29, y: 28 },
        { x: 29, y: 27 },
        { x: 30, y: 27 },
        { x: 30, y: 26 },
    ],
    lowerLeft: [
        { x: 22, y: 26 },
        { x: 22, y: 27 },
        { x: 23, y: 27 },
        { x: 23, y: 28 },
        {
            x: 24,
            y: 28,
        },
        { x: 25, y: 27 },
        { x: 24, y: 29 },
        { x: 25, y: 29 },
        { x: 25, y: 30 },
        { x: 26, y: 30 },
        {
            x: 24,
            y: 30,
        },
        { x: 23, y: 30 },
        { x: 23, y: 29 },
        { x: 22, y: 29 },
        { x: 22, y: 28 },
        { x: 21, y: 28 },
        {
            x: 21,
            y: 27,
        },
    ],
    upperLeft: [
        { x: 23, y: 21 },
        { x: 23, y: 22 },
        { x: 24, y: 22 },
        { x: 23, y: 23 },
        {
            x: 22,
            y: 23,
        },
        { x: 22, y: 24 },
        { x: 23, y: 25 },
        { x: 21, y: 24 },
        { x: 21, y: 25 },
        { x: 20, y: 25 },
        {
            x: 20,
            y: 26,
        },
        { x: 22, y: 21 },
        { x: 22, y: 22 },
        { x: 21, y: 22 },
        { x: 21, y: 23 },
        { x: 20, y: 23 },
        {
            x: 20,
            y: 24,
        },
    ],
    upperRight: [
        { x: 24, y: 20 },
        { x: 25, y: 20 },
        { x: 25, y: 21 },
        { x: 26, y: 21 },
        {
            x: 26,
            y: 22,
        },
        { x: 27, y: 22 },
        { x: 27, y: 23 },
        { x: 25, y: 23 },
        { x: 28, y: 23 },
        { x: 28, y: 24 },
        {
            x: 29,
            y: 23,
        },
        { x: 29, y: 22 },
        { x: 28, y: 22 },
        { x: 28, y: 21 },
        { x: 27, y: 21 },
        { x: 27, y: 20 },
        {
            x: 26,
            y: 20,
        },
    ],
};
// Used to generate energy structure ordering for spawn.spawnCreep()
const energyStructureOrder = [].concat(
    quadrantFillOrder.lowerRight,
    quadrantFillOrder.upperLeft,
    quadrantFillOrder.lowerLeft,
    quadrantFillOrder.upperRight,
);

const MAX_SAMPLE = 10;
const MAX_TOTAL_PATH_LENGTH = 25 * 3;
let BasePlanner = class BasePlanner {
    static getBunkerLocation(room, visualize = true) {
        const colony = Overmind.colonies[room.name];
        if (colony && colony.bunker && colony.bunker.anchor) {
            return colony.bunker.anchor;
        }
        let allowableLocations = this.getAllowableBunkerLocations(
            room,
            visualize,
        );
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        const minimizePathLengthTo = _.map(
            _.compact([...room.sources, room.controller]),
            (obj) => obj.pos,
        );
        const totalPathLength = function (anchor) {
            let totalDistance = 0;
            for (const pos of minimizePathLengthTo) {
                const ret = Pathing.findShortestPath(anchor, pos, {
                    ignoreStructures: true,
                });
                if (!ret.incomplete) {
                    totalDistance += ret.path.length;
                } else {
                    totalDistance += Infinity;
                }
            }
            return totalDistance;
        };
        const bestAnchor = minBy(allowableLocations, (pos) =>
            totalPathLength(pos),
        );
        if (
            bestAnchor &&
            totalPathLength(bestAnchor) <= MAX_TOTAL_PATH_LENGTH
        ) {
            return bestAnchor;
        }
    }
    static getAllowableBunkerLocations(room, visualize = true) {
        let allowableLocations = this.getNonIntersectingBunkerLocations(
            room.name,
            visualize,
        );
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        // Filter intersection with controller
        if (!room.controller) return [];
        allowableLocations = _.filter(
            allowableLocations,
            (anchor) =>
                !this.bunkerIntersectsWith(anchor, room.controller.pos, 3),
        );
        // Filter intersection with miningSites
        const sitesAndMineral = _.map(
            _.compact([...room.sources, room.mineral]),
            (obj) => obj.pos,
        );
        allowableLocations = _.filter(
            allowableLocations,
            (anchor) =>
                !_.any(sitesAndMineral, (pos) =>
                    this.bunkerIntersectsWith(anchor, pos, 1),
                ),
        );
        if (visualize) {
            const vis = room.visual;
            for (const pos of allowableLocations) {
                vis.circle(pos.x, pos.y, { fill: 'purple' });
            }
        }
        return allowableLocations;
    }
    static getNonIntersectingBunkerLocations(roomName, visualize = true) {
        const dt = distanceTransform(roomName);
        const coords = [];
        let x, y;
        for (y of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
            for (x of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
                if (dt.get(x, y) >= BUNKER_RADIUS + 1) {
                    // If it fits, I sits
                    coords.push({ x, y });
                } else if (
                    dt.get(x, y) >= BUNKER_RADIUS - 1 &&
                    !this.terrainIntersectsWithBunker({ x, y }, dt)
                ) {
                    // If it might not fits, check that it fits before I sits
                    coords.push({ x, y });
                }
            }
        }
        if (visualize) {
            const vis = new RoomVisual(roomName);
            for (const coord of coords) {
                vis.text(dt.get(coord.x, coord.y).toString(), coord.x, coord.y);
            }
        }
        return _.map(
            coords,
            (coord) => new RoomPosition(coord.x, coord.y, roomName),
        );
    }
    static terrainIntersectsWithBunker(anchor, distanceMatrix) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const bunkerCoordsAtAnchor = _.map(
            allBunkerCoords[8],
            function (coord) {
                return { x: coord.x + dx, y: coord.y + dy };
            },
        );
        return _.any(
            bunkerCoordsAtAnchor,
            (coord) => distanceMatrix.get(coord.x, coord.y) == 0,
        );
    }
    static bunkerIntersectsWith(anchor, obstacle, padding = 1) {
        const dx = bunkerLayout.data.anchor.x - anchor.x;
        const dy = bunkerLayout.data.anchor.y - anchor.y;
        let x, y;
        for (x of _.range(
            obstacle.x + dx - padding,
            obstacle.x + dx + padding + 1,
        )) {
            for (y of _.range(
                obstacle.y + dy - padding,
                obstacle.y + dy + padding + 1,
            )) {
                if (bunkerCoordLookup[8][packCoord({ x, y })]) {
                    return true;
                }
            }
        }
        return false;
    }
};
BasePlanner = __decorate([profile], BasePlanner);

const EXPANSION_EVALUATION_FREQ = 500;
const MIN_EXPANSION_DISTANCE = 2;
let ExpansionEvaluator = class ExpansionEvaluator {
    static refreshExpansionData(expansionData, colonyRoomName) {
        // This method is typed a little strangely to avoid some circular dependency problems
        // This only gets run once per colony
        if (
            _.keys(expansionData.possibleExpansions).length == 0 ||
            Game.time > expansionData.expiration
        ) {
            // Generate a list of rooms which can possibly be settled in
            const nearbyRooms = Cartographer.recursiveRoomSearch(
                colonyRoomName,
                5,
            );
            let possibleExpansions = [];
            for (const depth in nearbyRooms) {
                if (parseInt(depth, 10) <= MIN_EXPANSION_DISTANCE) continue;
                possibleExpansions = possibleExpansions.concat(
                    nearbyRooms[depth],
                );
            }
            for (const roomName of possibleExpansions) {
                if (Cartographer.roomType(roomName) == ROOMTYPE_CONTROLLER) {
                    expansionData.possibleExpansions[roomName] = true;
                }
            }
        }
        // This gets run whenever function is called
        for (const roomName in expansionData.possibleExpansions) {
            if (expansionData.possibleExpansions[roomName] == true) {
                if (Memory.rooms[roomName]) {
                    const roomExpansionData = RoomIntel.getExpansionData(
                        roomName,
                    );
                    if (roomExpansionData == false) {
                        expansionData.possibleExpansions[roomName] = false;
                    } else if (roomExpansionData && roomExpansionData.score) {
                        expansionData.possibleExpansions[roomName] =
                            roomExpansionData.score;
                    }
                }
            }
        }
    }
    /**
     * Returns the net energy income per cpu spent
     * @param dropoffLocation point of origin
     * @param room
     * @param verbose
     */
    static computeTheoreticalMiningEfficiency(
        dropoffLocation,
        room,
        verbose = false,
    ) {
        const roomName = room;
        const roomType = Cartographer.roomType(roomName);
        let cpuCost = 0;
        let creepEnergyCost = 0;
        let spawnTimeCost = 0;
        const sourcePositions = RoomIntel.getSourceInfo(roomName);
        if (sourcePositions == undefined) {
            if (verbose) {
                log.info(
                    `No memory of outpost room: ${roomName}. Aborting score calculation!`,
                );
            }
            return false;
        }
        // Compute Path length
        // TODO have it track how many swamp/plain/tunnel
        const sourcePathLengths = {};
        for (const source of sourcePositions) {
            if (!source.containerPos) {
                log.info(
                    `Can't find container position for source ${source} during efficiency calc`,
                );
                return false;
            }
            // TODO Need to factor in where roads would go
            const path = Pathing.findShortestPath(
                dropoffLocation,
                source.containerPos,
                { ignoreStructures: true, allowHostile: true },
            );
            if (path.incomplete) {
                log.error(
                    `Couldn't find path to source ${source} for mining efficiency calc`,
                );
                return false;
            }
            sourcePathLengths[source.pos.print] = path.path.length;
        }
        // Compute Energy Supply
        const energyPerSource =
            roomType == ROOMTYPE_CONTROLLER
                ? SOURCE_ENERGY_CAPACITY
                : SOURCE_ENERGY_KEEPER_CAPACITY;
        // Compute miner upkeep
        for (const source of sourcePositions) {
            const setup =
                roomType == ROOMTYPE_CONTROLLER
                    ? Setups.drones.miners.standard.generateMaxedBody()
                    : Setups.drones.miners.sourceKeeper.generateMaxedBody();
            const effectiveCreepUptime =
                CREEP_LIFE_TIME - sourcePathLengths[source.pos.print];
            creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
            spawnTimeCost +=
                (setup.length * CREEP_SPAWN_TIME) / effectiveCreepUptime;
            // Always harvesting, sometimes replacement is moving
            cpuCost += 0.2 + 0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
        }
        // Compute reserver/skReaper upkeep
        if (roomType == ROOMTYPE_CONTROLLER) {
            const controller = RoomIntel.getControllerInfo(roomName);
            if (!controller) {
                log.error(
                    `Expansion Efficiency Calc: Can't find controller for room ${roomName}`,
                );
                return false;
            } else {
                const setup = Setups.infestors.reserve.generateMaxedBody();
                const controllerPath = Pathing.findShortestPath(
                    dropoffLocation,
                    controller.pos,
                    { ignoreStructures: true, allowHostile: true },
                );
                if (controllerPath.incomplete) {
                    log.error(
                        `Couldn't find path to controller ${controller} for mining efficiency calc`,
                    );
                    return false;
                }
                const claimPower = _.filter(setup, (part) => part == CLAIM)
                    .length;
                const effectiveLifetimeReservationGeneration =
                    (CREEP_CLAIM_LIFE_TIME - controllerPath.path.length) *
                    claimPower;
                creepEnergyCost +=
                    bodyCost(setup) / effectiveLifetimeReservationGeneration;
                spawnTimeCost +=
                    (setup.length * CREEP_SPAWN_TIME) /
                    effectiveLifetimeReservationGeneration;
                cpuCost +=
                    (0.2 * CREEP_CLAIM_LIFE_TIME) /
                    effectiveLifetimeReservationGeneration;
            }
        } else if (roomType == ROOMTYPE_SOURCEKEEPER) {
            // Handle SK
            const setup = CombatSetups.zerglings.sourceKeeper.generateMaxedBody();
            const skPath = Pathing.findPathToRoom(dropoffLocation, roomName, {
                ignoreStructures: true,
                allowHostile: true,
            });
            if (skPath.incomplete) {
                log.error(
                    `Couldn't find path to sk room ${roomName} for mining efficiency calc`,
                );
                return false;
            }
            const effectiveCreepUptime = CREEP_LIFE_TIME - skPath.path.length;
            creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
            spawnTimeCost +=
                (setup.length * CREEP_SPAWN_TIME) / effectiveCreepUptime;
            //  Increased cost, always moving, frequent attack/move+heal intents, and during overlap 2nd creep moving to room
            cpuCost +=
                0.2 + 0.15 + 0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
            // TODO examine for accuracy Increased cost, frequent attack/move+heal intents
        }
        // Compute transporter upkeep
        for (const source of sourcePositions) {
            const setup = Setups.transporters.default.generateMaxedBody();
            // Calculate amount of hauling each transporter provides in a lifetime
            const transporterCarryParts = _.filter(
                setup,
                (part) => part == CARRY,
            ).length;
            const effectiveEnergyTransportedPerTick =
                (transporterCarryParts * CARRY_CAPACITY) /
                (2 * sourcePathLengths[source.pos.print]); // round trip
            const transportersPerSource =
                energyPerSource /
                ENERGY_REGEN_TIME /
                effectiveEnergyTransportedPerTick;
            creepEnergyCost +=
                (bodyCost(setup) * transportersPerSource) / CREEP_LIFE_TIME;
            spawnTimeCost +=
                (setup.length * CREEP_SPAWN_TIME * transportersPerSource) /
                CREEP_LIFE_TIME;
            cpuCost += 0.2 * transportersPerSource;
        }
        const netIncome =
            (energyPerSource * sourcePositions.length) / ENERGY_REGEN_TIME -
            creepEnergyCost;
        let msg = `(Potential) Outpost ${room} type ${roomType} evaluated for colony at ${dropoffLocation.roomName} with per tick results \n`;
        msg += `Income: ${
            (energyPerSource * sourcePositions.length) / ENERGY_REGEN_TIME
        } Net Income: ${netIncome} Net Energy per CPU: ${
            netIncome / cpuCost
        }\n`;
        msg += `Creep Costs: Energy ${creepEnergyCost}, Spawn Time ${spawnTimeCost}, and CPU ${cpuCost} \n`;
        log.alert(msg);
        return netIncome / cpuCost;
    }
    // Compute the total score for a room
    static computeExpansionData(room, verbose = false) {
        if (verbose) log.info(`Computing score for ${room.print}...`);
        if (!room.controller) {
            RoomIntel.setExpansionData(room.name, false);
            return false;
        }
        // compute possible outposts (includes host room)
        const possibleOutposts = Cartographer.findRoomsInRange(room.name, 2);
        // find source positions
        const outpostSourcePositions = {};
        for (const roomName of possibleOutposts) {
            if (
                Cartographer.roomType(roomName) == ROOMTYPE_ALLEY ||
                Cartographer.roomType(roomName) == ROOMTYPE_CROSSROAD
            ) {
                continue;
            }
            const sourcePositions = RoomIntel.getSourceInfo(roomName);
            if (sourcePositions == undefined) {
                if (verbose) {
                    log.info(
                        `No memory of neighbor: ${roomName}. Aborting score calculation!`,
                    );
                }
                return false;
            } else {
                outpostSourcePositions[roomName] = _.map(
                    sourcePositions,
                    (src) => src.pos,
                );
            }
        }
        // compute a possible bunker position
        const bunkerLocation = BasePlanner.getBunkerLocation(room, false);
        if (!bunkerLocation) {
            RoomIntel.setExpansionData(room.name, false);
            log.info(
                `Room ${room.name} is uninhabitable because a bunker can't be built here!`,
            );
            return false;
        }
        // evaluate energy contribution and compute outpost scores
        if (verbose) log.info(`Origin: ${bunkerLocation.print}`);
        const outpostScores = {};
        for (const roomName in outpostSourcePositions) {
            if (verbose) log.info(`Analyzing neighbor ${roomName}`);
            const sourcePositions = outpostSourcePositions[roomName];
            let valid = true;
            const roomType = Cartographer.roomType(roomName);
            let energyPerSource = SOURCE_ENERGY_CAPACITY;
            if (roomType == ROOMTYPE_SOURCEKEEPER) {
                energyPerSource = 0.6 * SOURCE_ENERGY_KEEPER_CAPACITY; // don't favor SK rooms too heavily -- more CPU
            } else if (roomType == ROOMTYPE_CORE) {
                energyPerSource = SOURCE_ENERGY_KEEPER_CAPACITY;
            }
            let roomScore = 0;
            for (const position of sourcePositions) {
                const msg = verbose
                    ? `Computing distance from ${bunkerLocation.print} to ${position.print}... `
                    : '';
                const ret = Pathing.findShortestPath(bunkerLocation, position, {
                    ignoreStructures: true,
                    allowHostile: true,
                });
                if (
                    ret.incomplete ||
                    ret.path.length >
                        100 /* Colony.settings.maxSourceDistance */
                ) {
                    if (verbose) log.info(msg + 'incomplete path!');
                    valid = false;
                    break;
                }
                if (verbose) log.info(msg + ret.path.length);
                const offset = 25; // prevents over-sensitivity to very close sources
                roomScore += energyPerSource / (ret.path.length + offset);
            }
            if (valid) {
                outpostScores[roomName] = Math.floor(roomScore);
            }
        }
        // Compute the total score of the room as the maximum energy score of max number of sources harvestable
        let totalScore = 0;
        let sourceCount = 0;
        const roomsByScore = _.sortBy(
            _.keys(outpostScores),
            (roomName) => -1 * outpostScores[roomName],
        );
        for (const roomName of roomsByScore) {
            if (sourceCount > 9 /*Colony.settings.remoteSourcesByLevel[8]*/) {
                break;
            }
            const factor = roomName == room.name ? 2 : 1; // weight owned room scores more heavily
            totalScore += outpostScores[roomName];
            sourceCount += outpostSourcePositions[roomName].length;
        }
        totalScore = Math.floor(totalScore);
        if (verbose) log.info(`Score: ${totalScore}`);
        const existingExpansionData = RoomIntel.getExpansionData(room.name);
        if (existingExpansionData === false) {
            log.error(`ExpansionEvaluator: shouldn't be here!`);
            return false;
        }
        if (
            existingExpansionData == undefined ||
            totalScore > existingExpansionData.score
        ) {
            RoomIntel.setExpansionData(room.name, {
                score: totalScore,
                bunkerAnchor: bunkerLocation,
                outposts: outpostScores,
            });
        }
        return true;
    }
};
ExpansionEvaluator = __decorate([profile], ExpansionEvaluator);

// Room intel - provides information related to room structure and occupation
var RoomIntel_1;
const RECACHE_TIME = 5000;
const OWNED_RECACHE_TIME = 1000;
const SCORE_RECALC_PROB = 0.05;
const FALSE_SCORE_RECALC_PROB = 0.01;
const defaultRoomIntelMemory = {
    portalRooms: [],
};
let RoomIntel = (RoomIntel_1 = class RoomIntel {
    constructor() {
        _.defaultsDeep(Memory.roomIntel, defaultRoomIntelMemory);
    }
    // Making this a static getter prevents us from having to call Overmind.roomIntel.whatever() all the time
    static get memory() {
        return Memory.roomIntel;
    }
    static cleanMemory() {
        // // Clean out memory of inactive portals // this actually gets done automatically with recordPermanentObjects
        // for (const portalRoomName in this.memory.portalRooms) {
        // 	const portals = this.memory.portalRooms[portalRoomName];
        // 	if (portals) {
        // 		for (const portal of portals) {
        // 			if (portal[MEM.EXPIRATION]) {
        // 				// TODO
        // 			}
        // 		}
        // 	}
        // }
    }
    /**
     * Mark a room as being visible this tick
     */
    static markVisible(room) {
        room.memory['T' /* TICK */] = Game.time;
    }
    /**
     * Returns the last tick at which the room was visible, or -100
     */
    static lastVisible(roomName) {
        if (Memory.rooms[roomName]) {
            return Memory.rooms[roomName]['T' /* TICK */] || -100;
        } else {
            return -100;
        }
    }
    /**
     * Gets expansion data from a room in readable format. Undefined means that a data is not present, while false
     * means that the room has been analyzed and determined to be unsuitable for expansion. Be sure to use === when
     * comparing to false!
     */
    static getExpansionData(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['e' /* EXPANSION_DATA */]
        ) {
            return;
        }
        const data = Memory.rooms[roomName]['e' /* EXPANSION_DATA */];
        if (data === 0) {
            return false;
        }
        return {
            score: data['s' /* SCORE */],
            bunkerAnchor: unpackCoordAsPos(
                data['a' /* BUNKER_ANCHOR */],
                roomName,
            ),
            outposts: data['o' /* OUTPOSTS */],
        };
    }
    /**
     * Sets expansion data for a room. Setting the data to false marks the room as uninhabitable.
     */
    static setExpansionData(roomName, data) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        if (data === false) {
            Memory.rooms[roomName]['e' /* EXPANSION_DATA */] = 0;
        } else {
            Memory.rooms[roomName]['e' /* EXPANSION_DATA */] = {
                ['s' /* SCORE */]: data.score,
                ['a' /* BUNKER_ANCHOR */]: packCoord(data.bunkerAnchor),
                ['o' /* OUTPOSTS */]: data.outposts,
            };
        }
    }
    /**
     * Returns information about intra-shard portals in a given room
     */
    static getPortalInfo(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['pr' /* PORTALS */]
        ) {
            return [];
        }
        const localPortals = _.filter(
            Memory.rooms[roomName]['pr' /* PORTALS */],
            (savedPortal) => typeof savedPortal.dest == 'string',
        );
        const nonExpiredPortals = _.filter(
            localPortals,
            (portal) => Game.time < portal['X' /* EXPIRATION */],
        );
        return _.map(nonExpiredPortals, (savedPortal) => {
            const pos = unpackCoordAsPos(savedPortal.c, roomName);
            const destinationPos = unpackPos(savedPortal.dest);
            const expiration = savedPortal['X' /* EXPIRATION */];
            return {
                pos: pos,
                destination: destinationPos,
                expiration: expiration,
            };
        });
    }
    /**
     * Returns information about intra-shard portals in a given room
     */
    static getSourceInfo(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['s' /* SOURCES */]
        ) {
            return;
        }
        return _.map(
            Memory.rooms[roomName]['s' /* SOURCES */],
            (savedSource) => ({
                pos: unpackCoordAsPos(savedSource.c, roomName),
                containerPos: savedSource.cn
                    ? unpackCoordAsPos(savedSource.cn, roomName)
                    : undefined,
            }),
        );
    }
    /**
     * Returns information about intra-shard portals in a given room
     */
    static getKeeperLairInfo(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['k' /* SKLAIRS */]
        ) {
            return;
        }
        return _.map(
            Memory.rooms[roomName]['k' /* SKLAIRS */],
            (savedLair) => ({
                pos: unpackCoordAsPos(savedLair.c, roomName),
                chillPos: savedLair.cp
                    ? unpackCoordAsPos(savedLair.cp, roomName)
                    : undefined,
            }),
        );
    }
    /**
     * Unpackages saved information about a room's controller
     */
    static getControllerInfo(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['c' /* CONTROLLER */]
        ) {
            return;
        }
        const ctlr = Memory.rooms[roomName]['c' /* CONTROLLER */];
        return {
            pos: unpackCoordAsPos(ctlr.c, roomName),
            level: ctlr['l' /* LEVEL */],
            owner: ctlr['o' /* OWNER */],
            reservation: ctlr['r' /* RESERVATION */]
                ? {
                      username:
                          ctlr['r' /* RESERVATION */]['u' /* RES_USERNAME */],
                      ticksToEnd:
                          ctlr['r' /* RESERVATION */]['t' /* RES_TICKSTOEND */],
                  }
                : undefined,
            safemode: ctlr['s' /* SAFEMODE */],
            safemodeAvailable: ctlr['sa' /* SAFEMODE_AVAILABLE */],
            safemodeCooldown: ctlr['sc' /* SAFEMODE_COOLDOWN */],
            progress: ctlr['p' /* PROGRESS */],
            progressTotal: ctlr['pt' /* PROGRESS_TOTAL */],
        };
    }
    static getImportantStructureInfo(roomName) {
        if (
            !Memory.rooms[roomName] ||
            !Memory.rooms[roomName]['i' /* IMPORTANT_STRUCTURES */]
        ) {
            return;
        }
        const data = Memory.rooms[roomName]['i' /* IMPORTANT_STRUCTURES */];
        return {
            storagePos: data['s' /* STORAGE */]
                ? unpackCoordAsPos(data['s' /* STORAGE */], roomName)
                : undefined,
            terminalPos: data['e' /* TERMINAL */]
                ? unpackCoordAsPos(data['e' /* TERMINAL */], roomName)
                : undefined,
            towerPositions: unpackCoordListAsPosList(
                data['t' /* TOWERS */],
                roomName,
            ),
            spawnPositions: unpackCoordListAsPosList(
                data['sp' /* SPAWNS */],
                roomName,
            ),
            wallPositions: unpackCoordListAsPosList(
                data['w' /* WALLS */],
                roomName,
            ),
            rampartPositions: unpackCoordListAsPosList(
                data['r' /* RAMPARTS */],
                roomName,
            ),
        };
    }
    /**
     * Retrieves all info for permanent room objects and returns it in a more readable/useful form
     */
    static getAllRoomObjectInfo(roomName) {
        const mem = Memory.rooms[roomName];
        if (mem) {
            const savedController = mem['c' /* CONTROLLER */];
            const savedSources = mem['s' /* SOURCES */] || [];
            const savedMineral = mem['m' /* MINERAL */];
            const savedSkLairs = mem['k' /* SKLAIRS */] || [];
            const savedImportantStructures =
                mem['i' /* IMPORTANT_STRUCTURES */];
            const returnObject = {
                controller: this.getControllerInfo(roomName),
                portals: this.getPortalInfo(roomName),
                sources: _.map(savedSources, (src) =>
                    src.cn
                        ? {
                              pos: unpackCoordAsPos(src.c, roomName),
                              containerPos: unpackCoordAsPos(src.cn, roomName),
                          }
                        : { pos: unpackCoordAsPos(src.c, roomName) },
                ),
                mineral: savedMineral
                    ? {
                          pos: unpackCoordAsPos(savedMineral.c, roomName),
                          mineralType: savedMineral['t' /* MINERALTYPE */],
                          density: savedMineral['d' /* DENSITY */],
                      }
                    : undefined,
                skLairs: _.map(savedSkLairs, (lair) => ({
                    pos: unpackCoordAsPos(lair.c, roomName),
                })),
                importantStructures: this.getImportantStructureInfo(roomName),
            };
            return returnObject;
        }
    }
    /**
     * Records all info for permanent room objects, e.g. sources, controllers, etc.
     */
    static recordPermanentObjects(room) {
        room.memory['T' /* TICK */] = Game.time;
        if (room.sources.length > 0) {
            room.memory['s' /* SOURCES */] = _.map(room.sources, (source) => {
                const coord = packCoord(source.pos);
                const container = source.pos.findClosestByLimitedRange(
                    room.containers,
                    2,
                );
                return container
                    ? { c: coord, cn: packCoord(container.pos) }
                    : { c: coord };
            });
        } else {
            delete room.memory['s' /* SOURCES */];
        }
        if (room.controller) {
            room.memory['c' /* CONTROLLER */] = {
                c: packCoord(room.controller.pos),
                ['l' /* LEVEL */]: room.controller.level,
                ['o' /* OWNER */]: room.controller.owner
                    ? room.controller.owner.username
                    : undefined,
                ['r' /* RESERVATION */]: room.controller.reservation
                    ? {
                          ['u' /* RES_USERNAME */]:
                              room.controller.reservation.username,
                          ['t' /* RES_TICKSTOEND */]:
                              room.controller.reservation.ticksToEnd,
                      }
                    : undefined,
                ['s' /* SAFEMODE */]: room.controller.safeMode,
                ['sa' /* SAFEMODE_AVAILABLE */]:
                    room.controller.safeModeAvailable,
                ['sc' /* SAFEMODE_COOLDOWN */]:
                    room.controller.safeModeCooldown,
                ['p' /* PROGRESS */]: room.controller.progress,
                ['pt' /* PROGRESS_TOTAL */]: room.controller.progressTotal,
            };
        } else {
            delete room.memory['c' /* CONTROLLER */];
        }
        if (room.mineral) {
            room.memory['m' /* MINERAL */] = {
                c: packCoord(room.mineral.pos),
                ['d' /* DENSITY */]: room.mineral.density,
                ['t' /* MINERALTYPE */]: room.mineral.mineralType,
            };
        } else {
            delete room.memory['m' /* MINERAL */];
        }
        if (room.keeperLairs.length > 0) {
            room.memory['k' /* SKLAIRS */] = _.map(room.keeperLairs, (lair) => {
                // Keeper logic is to just move to the first _.find([...sources, mineral], range <=5); see
                // https://github.com/screeps/engine/blob/master/src/processor/intents/creeps/keepers/pretick.js
                const keeperTarget = _.find(
                    _.compact([...room.sources, room.mineral]),
                    (thing) => thing.pos.getRangeTo(lair.pos) <= 5,
                );
                let chillPos;
                if (keeperTarget) {
                    // should always be true
                    chillPos =
                        lair.pos.findClosestByPath(
                            keeperTarget.pos.neighbors,
                        ) || undefined;
                }
                return chillPos
                    ? { c: packCoord(lair.pos), cp: packCoord(chillPos) }
                    : { c: packCoord(lair.pos) };
            });
        } else {
            delete room.memory['k' /* SKLAIRS */];
        }
        this.recordOwnedRoomStructures(room);
        this.recordPortalInfo(room);
    }
    static recordOwnedRoomStructures(room) {
        if (room.controller && room.controller.owner) {
            room.memory['i' /* IMPORTANT_STRUCTURES */] = {
                ['t' /* TOWERS */]: packCoordList(
                    _.map(room.towers, (t) => t.pos),
                ),
                ['sp' /* SPAWNS */]: packCoordList(
                    _.map(room.spawns, (s) => s.pos),
                ),
                ['w' /* WALLS */]: packCoordList(
                    _.map(room.walls, (w) => w.pos),
                ),
                ['r' /* RAMPARTS */]: packCoordList(
                    _.map(room.ramparts, (r) => r.pos),
                ),
                ['s' /* STORAGE */]: room.storage
                    ? packCoord(room.storage.pos)
                    : undefined,
                ['e' /* TERMINAL */]: room.terminal
                    ? packCoord(room.terminal.pos)
                    : undefined,
            };
        } else {
            delete room.memory['i' /* IMPORTANT_STRUCTURES */];
        }
    }
    static recordPortalInfo(room) {
        if (room.portals.length > 0) {
            room.memory['pr' /* PORTALS */] = _.map(room.portals, (portal) => {
                const dest =
                    portal.destination instanceof RoomPosition
                        ? packPos(portal.destination)
                        : portal.destination;
                const expiration =
                    portal.ticksToDecay != undefined
                        ? Game.time + portal.ticksToDecay
                        : Game.time + 1000000;
                return {
                    c: packCoord(portal.pos),
                    dest: dest,
                    ['X' /* EXPIRATION */]: expiration,
                };
            });
            const uniquePortals = _.unique(room.portals, (portal) =>
                portal.destination instanceof RoomPosition
                    ? packPos(portal.destination)
                    : portal.destination,
            );
            if (!this.memory.portalRooms.includes(room.name)) {
                this.memory.portalRooms.push(room.name);
            }
        } else {
            delete room.memory['pr' /* PORTALS */];
            _.pull(this.memory.portalRooms, room.name);
        }
    }
    /**
     * Update time-sensitive reservation and safemode info
     */
    static recordControllerInfo(controller) {
        const savedController = controller.room.memory['c' /* CONTROLLER */];
        if (savedController) {
            savedController['r' /* RESERVATION */] = controller.reservation
                ? {
                      ['u' /* RES_USERNAME */]: controller.reservation.username,
                      ['t' /* RES_TICKSTOEND */]:
                          controller.reservation.ticksToEnd,
                  }
                : undefined;
            savedController['s' /* SAFEMODE */] = controller.safeMode;
            savedController['sc' /* SAFEMODE_COOLDOWN */] =
                controller.safeModeCooldown;
        }
    }
    static inSafeMode(roomName) {
        if (
            !!Memory.rooms[roomName] &&
            !!Memory.rooms[roomName]['c' /* CONTROLLER */]
        ) {
            const safemode =
                Memory.rooms[roomName]['c' /* CONTROLLER */][
                    's' /* SAFEMODE */
                ];
            const tick = Memory.rooms[roomName]['X' /* EXPIRATION */];
            if (safemode && tick) {
                return Game.time < tick + safemode;
            }
        }
        return false;
    }
    static safeModeCooldown(roomName) {
        if (
            Memory.rooms[roomName] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */][
                'sc' /* SAFEMODE_COOLDOWN */
            ]
        ) {
            const smcooldown =
                Memory.rooms[roomName]['c' /* CONTROLLER */][
                    'sc' /* SAFEMODE_COOLDOWN */
                ];
            const tick = Memory.rooms[roomName]['X' /* EXPIRATION */];
            if (smcooldown && tick) {
                return smcooldown - (Game.time - tick);
            }
        }
    }
    static recomputeScoreIfNecessary(room) {
        if (room.memory['e' /* EXPANSION_DATA */] === 0) {
            // room is uninhabitable or owned
            if (Math.random() < FALSE_SCORE_RECALC_PROB) {
                // false scores get evaluated very occasionally
                return ExpansionEvaluator.computeExpansionData(room);
            }
        } else {
            // if the room is not uninhabitable
            if (
                !room.memory['e' /* EXPANSION_DATA */] ||
                Math.random() < SCORE_RECALC_PROB
            ) {
                // recompute some of the time
                return ExpansionEvaluator.computeExpansionData(room);
            }
        }
        return false;
    }
    static updateInvasionData(room) {
        if (!room.memory['v' /* INVASION_DATA */]) {
            room.memory['v' /* INVASION_DATA */] = {
                ['h' /* HARVESTED */]: 0,
                ['l' /* LAST_SEEN */]: 0,
            };
        }
        const sources = room.sources;
        const invasionData = room.memory['v' /* INVASION_DATA */];
        for (const source of sources) {
            if (source.ticksToRegeneration == 1) {
                invasionData['h' /* HARVESTED */] +=
                    source.energyCapacity - source.energy;
            }
        }
        if (room.invaders.length > 0) {
            invasionData['h' /* HARVESTED */] = 0;
            invasionData['l' /* LAST_SEEN */] = Game.time;
        }
    }
    // private static updateHarvestData(room: Room): void {
    // 	if (!room.memory[RMEM.HARVEST]) {
    // 		room.memory[RMEM.HARVEST] = {
    // 			[MEM_AVGS.AMOUNT] : 0,
    // 			[MEM_AVGS.AVG10K] : _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM_AVGS.AVG100K]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM_AVGS.AVG1M]  : _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM.TICK]             : Game.time,
    // 		};
    // 	}
    // 	const harvest = room.memory[RMEM.HARVEST] as RollingStats;
    // 	for (const source of room.sources) {
    // 		if (source.ticksToRegeneration == 1) {
    // 			const dEnergy = source.energyCapacity - source.energy;
    // 			const dTime = Game.time - harvest[MEM.TICK] + 1; // +1 to avoid division by zero errors
    // 			harvest[MEM_AVGS.AMOUNT] += dEnergy;
    // 			harvest[MEM_AVGS.AVG10K] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG10K], dTime, 10000)).toFixed(7);
    // 			harvest[MEM_AVGS.AVG100K] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG100K], dTime, 100000)).toFixed(7);
    // 			harvest[MEM_AVGS.AVG1M] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG1M], dTime, 1000000)).toFixed(7);
    // 			harvest[MEM.TICK] = Game.time;
    // 		}
    // 	}
    // }
    // private static updateCasualtyData(room: Room): void {
    // 	if (!room.memory[RMEM.CASUALTIES]) {
    // 		room.memory[RMEM.CASUALTIES] = {
    // 			cost: {
    // 				[MEM_AVGS.AMOUNT] : 0,
    // 				[MEM_AVGS.AVG10K] : 0,
    // 				[MEM_AVGS.AVG100K]: 0,
    // 				[MEM_AVGS.AVG1M]  : 0,
    // 				[MEM.TICK]             : Game.time,
    // 			}
    // 		};
    // 	}
    // 	const casualtiesCost = room.memory[RMEM.CASUALTIES]!.cost as RollingStats;
    // 	for (const tombstone of room.tombstones) {
    // 		if (tombstone.ticksToDecay == 1) {
    // 			// record any casualties, which are my creeps which died prematurely
    // 			if ((tombstone.creep.ticksToLive || 0) > 1 && tombstone.creep.owner.username == MY_USERNAME
    // 				&& isCreep(tombstone.creep)) {
    // 				const body = _.map(tombstone.creep.body, part => part.type);
    // 				const lifetime = body.includes(CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
    // 				const dCost = bodyCost(body) * (tombstone.creep.ticksToLive || 0) / lifetime;
    // 				const dTime = Game.time - casualtiesCost[MEM.TICK] + 1;
    // 				casualtiesCost[MEM_AVGS.AMOUNT] += dCost;
    // 				casualtiesCost[MEM_AVGS.AVG10K] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG10K], dTime, 10000)).toFixed(7);
    // 				casualtiesCost[MEM_AVGS.AVG100K] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG100K], dTime, 100000)).toFixed(7);
    // 				casualtiesCost[MEM_AVGS.AVG1M] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG1M], dTime, 1000000)).toFixed(7);
    // 				casualtiesCost[MEM.TICK] = Game.time;
    // 			}
    // 		}
    // 	}
    // }
    static getExitPositions(roomName) {
        const terrain = Game.map.getRoomTerrain(roomName);
        const exitPositions = [];
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        for (let x = 0; x < 50; x++) {
            for (let y = 0; y < 50; y += 49) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        return exitPositions;
    }
    /**
     * Get the pos a creep was in on the previous tick, returning the same position as the creep if no data was
     * gathered on the previous tick.
     */
    static getPreviousPos(creep) {
        const prevPositions = creep.room.memory['pp' /* PREV_POSITIONS */];
        if (prevPositions) {
            const packedId = packId(creep.id);
            if (prevPositions[packedId]) {
                return unpackCoordAsPos(
                    prevPositions[packedId],
                    creep.room.name,
                );
            }
        }
        return creep.pos; // no data
    }
    static recordCreepPositions(room) {
        const positions = {};
        for (const creep of room.find(FIND_CREEPS)) {
            positions[packId(creep.id)] = packCoord(creep.pos);
        }
        room.memory['pp' /* PREV_POSITIONS */] = {};
    }
    // private static recordCreepOccupancies(room: Room): void {
    // 	if (!room.memory[RMEM.CREEPS_IN_ROOM]) {
    // 		room.memory[RMEM.CREEPS_IN_ROOM] = {};
    // 	}
    // 	const creepsInRoom = room.memory[RMEM.CREEPS_IN_ROOM]!;
    // 	for (const tick in creepsInRoom) {
    // 		if (parseInt(tick, 10) < Game.time - ROOM_CREEP_HISTORY_TICKS) {
    // 			delete creepsInRoom[tick];
    // 		}
    // 	}
    // 	creepsInRoom[Game.time] = _.map(room.hostiles, creep => creep.name);
    // }
    /**
     * Records threat levels, visibility, consecutive safe/unsafe ticks and other data on visible or invisible rooms.
     * Must be run in RoomIntel.init(), as it populates several room properties used elsewhere // TODO: expensive
     */
    static recordSafety(roomName) {
        // Make sure the memory objects are there
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        Memory.rooms[roomName]['f' /* SAFETY */] = Memory.rooms[roomName][
            'f' /* SAFETY */
        ] || {
            ['t' /* THREAT_LEVEL */]: 0,
            ['s' /* SAFE_FOR */]: 0,
            ['u' /* UNSAFE_FOR */]: 0,
            ['v' /* LAST_SEEN */]: 0,
        };
        const safetyData = Memory.rooms[roomName]['f' /* SAFETY */];
        const room = Game.rooms[roomName];
        if (room) {
            safetyData['v' /* LAST_SEEN */] = Game.time;
            if (room.dangerousHostiles.length > 0) {
                safetyData['s' /* SAFE_FOR */] = 0;
                safetyData['u' /* UNSAFE_FOR */] += 1;
            } else {
                safetyData['s' /* SAFE_FOR */] += 1;
                safetyData['u' /* UNSAFE_FOR */] = 0;
            }
            if (room.my || room.isOutpost) {
                // Record combat potentials of creeps in room
                const potentials = CombatIntel.getCombatPotentials(
                    room.dangerousPlayerHostiles,
                );
                safetyData['c' /* COMBAT_POTENTIALS */] = {
                    ['a' /* ATTACK */]: potentials.attack,
                    ['r' /* RANGED */]: potentials.ranged,
                    ['h' /* HEAL */]: potentials.heal,
                };
                if (potentials.dismantle) {
                    safetyData['c' /* COMBAT_POTENTIALS */][
                        'd' /* DISMANTLE */
                    ] = potentials.dismantle;
                }
                // Record hostile counts
                safetyData['nh' /* NUM_HOSTILES */] = room.hostiles.length; // this records ALL hostiles!
                safetyData['nb' /* NUM_BOOSTED_HOSTILES */] = _.filter(
                    room.hostiles,
                    (hostile) => hostile.boosts.length > 0,
                ).length;
            } else {
                delete safetyData['c' /* COMBAT_POTENTIALS */];
                delete safetyData['nh' /* NUM_HOSTILES */];
                delete safetyData['nb' /* NUM_BOOSTED_HOSTILES */];
            }
        }
        // this should not be required as we have moved from Invisible for to LAST_SEEN concept
        // else {
        //     safetyData[RMEM_SAFETY.LAST_SEEN] += 1;
        // }
        // Instantaneous threat level for a room scales from 0 to 1, with presence from non-player hostiles capped at
        // a threat levle of 0.5.
        let instantaneousThreatLevel;
        if (!room) {
            // TODO: never reach this as recordSafety will only run now for visible rooms
            // TODO: this value will always be the last one when the room was visible
            instantaneousThreatLevel = 0.5;
        } else {
            if (room.controller && room.controller.safeMode) {
                instantaneousThreatLevel = 0;
            } else {
                if (room.dangerousPlayerHostiles.length > 0) {
                    instantaneousThreatLevel = 1;
                } else if (room.dangerousHostiles.length > 0) {
                    instantaneousThreatLevel = 0.5;
                } else {
                    instantaneousThreatLevel = 0;
                }
            }
        }
        // Average it over time, using different averaging windows depending on the scenario
        const numBoostedHostiles =
            safetyData['nb' /* NUM_BOOSTED_HOSTILES */] || 0;
        switch (instantaneousThreatLevel) {
            case 0:
                safetyData['t' /* THREAT_LEVEL */] = ema(
                    instantaneousThreatLevel,
                    safetyData['t' /* THREAT_LEVEL */],
                    CREEP_LIFE_TIME / 2,
                );
                break;
            case 0.5:
                safetyData['t' /* THREAT_LEVEL */] = ema(
                    instantaneousThreatLevel,
                    safetyData['t' /* THREAT_LEVEL */],
                    CREEP_LIFE_TIME / (1 + numBoostedHostiles),
                );
                break;
            case 1:
                safetyData['t' /* THREAT_LEVEL */] = ema(
                    instantaneousThreatLevel,
                    safetyData['t' /* THREAT_LEVEL */],
                    CREEP_LIFE_TIME / (4 + numBoostedHostiles),
                );
                break;
        }
        // // Compute rolling averages
        // const dTime = Game.time - safetyData[RMEM_SAFETY.TICK];
        // safetyData[RMEM_SAFETY.SAFETY_1K] = +(irregularEma(
        // 	safety, safetyData[RMEM_SAFETY.SAFETY_1K], dTime, 1000)).toFixed(5);
        // safetyData[RMEM_SAFETY.SAFETY_10K] = +(irregularEma(
        // 	safety, safetyData[RMEM_SAFETY.SAFETY_10K], dTime, 10000)).toFixed(5);
        // Populate the per-tick properties on the room object itself
        if (room) {
            room.instantaneousThreatLevel = instantaneousThreatLevel;
            room.threatLevel = safetyData['t' /* THREAT_LEVEL */];
            room.isSafe =
                room.instantaneousThreatLevel == 0 &&
                (room.threatLevel < 0.15 ||
                    safetyData['s' /* SAFE_FOR */] > 50);
        }
    }
    static getSafetyData(roomName) {
        const data = Memory.rooms[roomName]['f' /* SAFETY */];
        return {
            threatLevel: data['t' /* THREAT_LEVEL */],
            safeFor: data['s' /* SAFE_FOR */],
            unsafeFor: data['u' /* UNSAFE_FOR */],
            lastSeen: data['v' /* LAST_SEEN */],
            combatPotentials: data['c' /* COMBAT_POTENTIALS */],
            numHostiles: data['nh' /* NUM_HOSTILES */],
            numBoostedHostiles: data['nb' /* NUM_BOOSTED_HOSTILES */],
        };
    }
    static isInvasionLikely(room) {
        const data = room.memory['v' /* INVASION_DATA */];
        if (!data) return false;
        const harvested = data['h' /* HARVESTED */];
        const lastSeen = data['l' /* LAST_SEEN */];
        if (Game.time - lastSeen > 20000) {
            // maybe room is surrounded by owned/reserved rooms and invasions aren't possible
            return false;
        }
        switch (room.sources.length) {
            case 1:
                return harvested > 90000;
            case 2:
                return harvested > 75000;
            case 3:
                return harvested > 65000;
            default:
                // shouldn't ever get here
                return false;
        }
    }
    static roomOwnedBy(roomName) {
        if (
            Memory.rooms[roomName] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */]['o' /* OWNER */]
        ) {
            if (
                Game.time - (Memory.rooms[roomName]['T' /* TICK */] || 0) <
                25000
            ) {
                // ownership expires after 25k ticks
                return Memory.rooms[roomName]['c' /* CONTROLLER */][
                    'o' /* OWNER */
                ];
            }
        }
    }
    static roomReservedBy(roomName) {
        if (
            Memory.rooms[roomName] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */]['r' /* RESERVATION */]
        ) {
            if (
                Game.time - (Memory.rooms[roomName]['T' /* TICK */] || 0) <
                10000
            ) {
                // reservation expires after 10k ticks
                return Memory.rooms[roomName]['c' /* CONTROLLER */][
                    'r' /* RESERVATION */
                ]['u' /* RES_USERNAME */];
            }
        }
    }
    static roomReservationRemaining(roomName) {
        if (
            Memory.rooms[roomName] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */] &&
            Memory.rooms[roomName]['c' /* CONTROLLER */]['r' /* RESERVATION */]
        ) {
            const ticksToEnd =
                Memory.rooms[roomName]['c' /* CONTROLLER */][
                    'r' /* RESERVATION */
                ]['t' /* RES_TICKSTOEND */];
            const timeSinceLastSeen =
                Game.time - (Memory.rooms[roomName]['T' /* TICK */] || 0);
            return ticksToEnd - timeSinceLastSeen;
        }
        return 0;
    }
    /**
     * Returns the portals that are within a specified range of a colony indexed by their room
     */
    static findPortalsInRange(roomName, range, includeIntershard = false) {
        const potentialPortalRooms = Cartographer.findRoomsInRange(
            roomName,
            range,
        ).filter(
            (roomName) => Cartographer.roomType(roomName) == ROOMTYPE_CORE,
        );
        // Examine for portals
        const portalRooms = potentialPortalRooms.filter(
            (roomName) =>
                Memory.rooms[roomName] &&
                !!Memory.rooms[roomName]['pr' /* PORTALS */],
        );
        const rooms = {};
        for (const roomName of portalRooms) {
            const roomPortals = Memory.rooms[roomName]['pr' /* PORTALS */]; // to prevent TS errors
            if (roomPortals != undefined && roomPortals.length > 0) {
                rooms[roomName] = roomPortals;
            }
        }
        return rooms;
    }
    // static requestZoneData() {
    // 	const checkOnTick = 123;
    // 	if (Game.time % 1000 == checkOnTick - 2) {
    // 		Segmenter.requestForeignSegment('LeagueOfAutomatedNations', 96);
    // 	} else if (Game.time % 1000 == checkOnTick - 1) {
    // 		const loanData = Segmenter.getForeignSegment();
    // 		if (loanData) {
    // 			Memory.zoneRooms = loanData;
    // 		} else {
    // 			log.error('Empty LOAN data');
    // 		}
    // 	}
    // }
    /**
     * Cached version of Game.map.getRoomStatus() which retrieves compressed status data and converts to RoomStatus
     */
    static getRoomStatus(roomName) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        // Recalculate if you haven't seen this room before or if the timestamp is expired
        if (
            !Memory.rooms[roomName]['rs' /* ROOM_STATUS */] ||
            new Date().getTime() >
                new Date(
                    Memory.rooms[roomName]['rs' /* ROOM_STATUS */][1] * 1000,
                ).getTime()
        ) {
            let { status, timestamp } = Game.map.getRoomStatus(roomName);
            if (timestamp == null) {
                // null timestamp means indefinite, but not really; let's recheck in a few days
                const extraMilliseconds = 3 * 24 * 60 * 60 * 1000; // check again in 3 days
                timestamp = new Date().getTime() + extraMilliseconds;
            }
            timestamp = Math.floor(timestamp / 1000); // don't need milliseconds; seconds will do
            switch (status) {
                case 'normal':
                    Memory.rooms[roomName]['rs' /* ROOM_STATUS */] = [
                        'nm' /* normal */,
                        timestamp,
                    ];
                    break;
                case 'closed':
                    Memory.rooms[roomName]['rs' /* ROOM_STATUS */] = [
                        'cl' /* closed */,
                        timestamp,
                    ];
                    break;
                case 'novice':
                    Memory.rooms[roomName]['rs' /* ROOM_STATUS */] = [
                        'nv' /* novice */,
                        timestamp,
                    ];
                    break;
                case 'respawn':
                    Memory.rooms[roomName]['rs' /* ROOM_STATUS */] = [
                        're' /* respawn */,
                        timestamp,
                    ];
                    break;
            }
        }
        const [statusCompressed, timestampCompressed] = Memory.rooms[roomName][
            'rs' /* ROOM_STATUS */
        ];
        const timestamp = timestampCompressed * 1000;
        switch (statusCompressed) {
            case 'nm' /* normal */:
                return { status: 'normal', timestamp: null };
            case 'cl' /* closed */:
                return { status: 'closed', timestamp: null };
            case 'nv' /* novice */:
                return { status: 'novice', timestamp: timestamp };
            case 're' /* respawn */:
                return { status: 'respawn', timestamp: timestamp };
        }
    }
    /**
     * Returns the type of zone that your empire is in
     */
    static getMyZoneStatus() {
        const oneOfMyColonies = _.first(_.values(Overmind.colonies));
        if (!oneOfMyColonies) return 'normal';
        return RoomIntel_1.getRoomStatus(oneOfMyColonies.name).status;
    }
    /**
     * RoomIntel.init() is the very first thing that is run in the init phase of each tick. The only stuff that should
     * go in here is critical and inexpensive stuff that is necessary information for this tick.
     */
    static init() {
        // for (const roomName in Game.rooms) {
        //     Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        // }
        // for (const roomName in Memory.rooms) {
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            this.recordSafety(roomName);
            //this.recordSafetyShortCircuit(roomName);
            if (room) {
                this.markVisible(room);
            }
        }
    }
    static recordSafetyShortCircuit(roomName) {
        const room = Game.rooms[roomName];
        let instantaneousThreatLevel;
        if (!room) {
            instantaneousThreatLevel = 0.5;
        } else {
            if (room.controller && room.controller.safeMode) {
                instantaneousThreatLevel = 0;
            } else {
                if (room.dangerousPlayerHostiles.length > 0) {
                    instantaneousThreatLevel = 1;
                } else if (room.dangerousHostiles.length > 0) {
                    instantaneousThreatLevel = 0.5;
                } else {
                    instantaneousThreatLevel = 0;
                }
            }
        }
        if (room) {
            room.instantaneousThreatLevel = instantaneousThreatLevel;
            room.threatLevel = instantaneousThreatLevel;
            room.isSafe = room.hostiles.length > 0 ? false : true;
        }
    }
    /**
     * RoomIntel.run() is the very last thing that is run in the run phase of each tick. If something times out earlier
     * in the script, then this will not be fully executed, so do not put critical stuff here.
     */
    static run() {
        
        let alreadyComputedScore = false;
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            // Track invasion data, harvesting, and casualties for all colony rooms and outposts
            if (Overmind.colonyMap[room.name]) {
                // if it is an owned or outpost room
                this.updateInvasionData(room);
                // this.updateHarvestData(room);
                // this.updateCasualtyData(room);
            }
            // Record previous creep positions (RoomIntel.run() is executed at end of each tick)
            /*
            
            this.recordCreepPositions(room); //zGeneral 2/2024 CPU OPtimization
            //if (room.my) {
            //    this.recordCreepOccupancies(room);
            //}
            
            */
            
            // Record location of permanent objects in room and recompute score as needed
            if (Game.time >= (room.memory['X' /* EXPIRATION */] || 0)) {
                this.recordPermanentObjects(room);
                if (false && !alreadyComputedScore) { // zGeneral 3/2024 not needed
                    alreadyComputedScore = this.recomputeScoreIfNecessary(room);
                }
                // Refresh cache
                const recacheTime = room.owner
                    ? OWNED_RECACHE_TIME
                    : RECACHE_TIME;
                room.memory['X' /* EXPIRATION */] = getCacheExpiration(
                    recacheTime,
                    250,
                );
            }
            if (room.controller && Game.time % 151 == 0) { // zGeneral 3/2024 not needed, changed from 5 to 151
                this.recordControllerInfo(room.controller);
            }
        }
        if (Game.time % 20 == 0) {
            this.cleanMemory();
        }
        
    }
    static visuals() {
        const until = Memory.settings.intelVisualsUntil;
        if (!Visualizer.enabled || until === undefined || Game.time > until) {
            return;
        }
        for (const name in Memory.rooms) {
            const x = 40;
            let y = 7;
            const exp = RoomIntel_1.getExpansionData(name);
            if (exp === undefined) {
                continue;
            }
            Visualizer.text(`Intel`, { x: x, y: y, roomName: name });
            y++;
            if (exp === false) {
                Visualizer.text(`Uninhabitable`, {
                    x: x,
                    y: y,
                    roomName: name,
                });
                y++;
            } else {
                Visualizer.text(`Score ${exp.score}`, {
                    x: x,
                    y: y,
                    roomName: name,
                });
                y++;
                Visualizer.text(`Bunker Anchor ${exp.bunkerAnchor}`, {
                    x: x,
                    y: y,
                    roomName: name,
                });
                y++;
                if (_.keys(exp.outposts).length !== 0) {
                    Visualizer.text(`Outposts:`, {
                        x: x,
                        y: y,
                        roomName: name,
                    });
                    y++;
                    for (const outpost in exp.outposts) {
                        Visualizer.text(
                            `${outpost}: ${exp.outposts[outpost]}`,
                            {
                                x: x,
                                y: y,
                                roomName: name,
                            },
                        );
                        y++;
                    }
                }
            }
        }
    }
});
RoomIntel = RoomIntel_1 = __decorate([profile], RoomIntel);
// For debugging purposes
global.RoomIntel = RoomIntel;

const rechargeTaskName = 'recharge';
// This is a "dispenser task" which is not itself a valid task, but dispenses a task when assigned to a creep.
let TaskRecharge = class TaskRecharge extends Task {
    constructor(target, minEnergy = 0, options = {}) {
        super(
            rechargeTaskName,
            { ref: '', pos: { x: -1, y: -1, roomName: '' } },
            options,
        );
        this.data.minEnergy = minEnergy;
    }
    rechargeRateForCreep(creep, obj) {
        if (
            creep.colony &&
            creep.colony.hatchery &&
            creep.colony.hatchery.battery &&
            obj.id == creep.colony.hatchery.battery.id &&
            creep.roleName != 'queen'
        ) {
            return false; // only queens can use the hatchery battery
        }
        let amount = isResource(obj) ? obj.amount : obj.store[RESOURCE_ENERGY];
        if (amount < this.data.minEnergy) {
            return false;
        }
        const otherTargeters = this.otherTargeters(obj);
        const resourceOutflux = _.sum(
            _.map(
                otherTargeters,
                (other) => other.carryCapacity - sumStore(other.carry),
            ),
        );
        amount = minMax(amount - resourceOutflux, 0, creep.carryCapacity);
        const effectiveAmount =
            amount / (creep.pos.getMultiRoomRangeTo(obj.pos) + 1);
        if (effectiveAmount <= 0) {
            return false;
        } else {
            return effectiveAmount;
        }
    }
    otherTargeters(target) {
        return _.filter(
            _.map(target.targetedBy, (name) => Overmind.zerg[name]),
            (zerg) =>
                !!zerg &&
                zerg.memory._task &&
                (zerg.memory._task.name == withdrawTaskName ||
                    zerg.memory._task.name == pickupTaskName),
        );
    }
    findBestAvailableSource(creep, potentialSources) {
        const availableSources = _.filter(potentialSources, function (source) {
            const filledSource =
                source.energy > 0 || source.ticksToRegeneration < 20;
            // Only harvest from sources which aren't surrounded by creeps excluding yourself
            const isSurrounded =
                source.pos.availableNeighbors(false).length == 0;
            return (
                !source.room.notMe &&
                filledSource &&
                (!isSurrounded || creep.pos.isNearTo(source))
            );
        });
        return creep.pos.findClosestByMultiRoomRange(availableSources);
    }
    mineFromRemote(creep) {
        const remotes = Cartographer.findRoomsInRange(creep.room.name, 1);
        const remoteSources = remotes
            .map((room) => RoomIntel.getAllRoomObjectInfo(room))
            .map(
                (roomInfo) =>
                    (roomInfo === null || roomInfo === void 0
                        ? void 0
                        : roomInfo.sources) || [],
            )
            .reduce((acc, val) => acc.concat(val))
            .map((source) => source.pos);
        const target = creep.pos.findClosestByLimitedRange(remoteSources, 100);
        if (target) {
            if (target.room) {
                const availableSource = this.findBestAvailableSource(
                    creep,
                    target.room.sources,
                );
                if (availableSource) {
                    creep.task = new TaskHarvest(availableSource);
                    return;
                }
            }
            // todo: wrangle the task system to walk into room and then mine source
        }
    }
    mineFromSource(creep) {
        const colony = Overmind.colonies[creep.room.name];
        let potentialSources = creep.room.sources;
        if (colony) {
            potentialSources = colony.sources;
        }
        const availableSource = this.findBestAvailableSource(
            creep,
            potentialSources,
        );
        if (availableSource) {
            creep.task = new TaskHarvest(availableSource);
            return;
        }
        // Did not find any adequate source to mine from, go to remotes
        this.mineFromRemote(creep);
    }
    // Override creep setter to dispense a valid recharge task
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
        // Choose the target to maximize your energy gain subject to other targeting workers
        const possibleTargets =
            creep.colony && creep.inColonyRoom
                ? creep.colony.rechargeables
                : creep.room.rechargeables;
        const target = maxBy(possibleTargets, (o) =>
            this.rechargeRateForCreep(creep, o),
        );
        if (!target || creep.pos.getMultiRoomRangeTo(target.pos) > 40) {
            // workers shouldn't harvest; let drones do it (disabling this check can destabilize early economy)
            const canHarvest =
                creep.getActiveBodyparts(WORK) > 0 &&
                creep.roleName != 'worker';
            if (canHarvest) {
                this.mineFromSource(creep);
                return;
            }
        }
        if (target) {
            if (isResource(target)) {
                creep.task = new TaskPickup(target);
                return;
            } else {
                creep.task = new TaskWithdraw(target);
                return;
            }
        }
        creep.task = null;
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    isValid() {
        return false;
    }
    get isWorking() {
        return false;
    }
    moveToTarget(range = this.settings.targetRange) {
        return 0;
    }
    work() {
        log.warning(`BAD RESULT: Should not get here...`);
        return ERR_INVALID_TARGET;
    }
};
TaskRecharge = __decorate([profile], TaskRecharge);

// Reinstantiation of a task object from ProtoTask data
/**
 * The task initializer maps serialized prototasks to Task instances
 */
function initializeTask(protoTask) {
    // Retrieve name and target data from the ProtoTask
    const taskName = protoTask.name;
    const target = deref(protoTask._target.ref);
    let task;
    // Create a task object of the correct type
    switch (taskName) {
        case attackTaskName:
            task = new TaskAttack(target);
            break;
        case buildTaskName:
            task = new TaskBuild(target);
            break;
        case claimTaskName:
            task = new TaskClaim(target);
            break;
        case dismantleTaskName:
            task = new TaskDismantle(target);
            break;
        case dropTaskName:
            task = new TaskDrop(derefRoomPosition(protoTask._target._pos));
            break;
        // case fleeTaskName:
        // 	task = new TaskFlee(derefRoomPosition(ProtoTask._target._pos) as fleeTargetType);
        // 	break;
        case fortifyTaskName:
            task = new TaskFortify(target);
            break;
        case getBoostedTaskName:
            task = new TaskGetBoosted(target, protoTask.data.resourceType);
            break;
        case getRenewedTaskName:
            task = new TaskGetRenewed(target);
            break;
        case goToTaskName:
            // task = new TaskGoTo(derefRoomPosition(ProtoTask._target._pos) as goToTargetType);
            task = new TaskInvalid();
            break;
        case goToRoomTaskName:
            task = new TaskGoToRoom(protoTask._target._pos.roomName);
            break;
        case harvestTaskName:
            task = new TaskHarvest(target);
            break;
        case healTaskName:
            task = new TaskHeal(target);
            break;
        case meleeAttackTaskName:
            task = new TaskMeleeAttack(target);
            break;
        case pickupTaskName:
            task = new TaskPickup(target);
            break;
        case rangedAttackTaskName:
            task = new TaskRangedAttack(target);
            break;
        case rechargeTaskName:
            task = new TaskRecharge(null);
            break;
        case repairTaskName:
            task = new TaskRepair(target);
            break;
        case reserveTaskName:
            task = new TaskReserve(target);
            break;
        case signControllerTaskName:
            task = new TaskSignController(target);
            break;
        case transferTaskName:
            task = new TaskTransfer(target);
            break;
        case transferAllTaskName:
            task = new TaskTransferAll(target);
            break;
        case upgradeTaskName:
            task = new TaskUpgrade(target);
            break;
        case withdrawTaskName:
            task = new TaskWithdraw(target);
            break;
        case withdrawAllTaskName:
            task = new TaskWithdrawAll(target);
            break;
        case generateSafeModeTaskName:
            task = new TaskGenerateSafeMode(target);
            break;
        default:
            log.error(
                `Invalid task name: ${taskName}! task.creep: ${protoTask._creep.name}. Deleting from memory!`,
            );
            task = new TaskInvalid();
            break;
    }
    // Modify the task object to reflect any changed properties
    task.proto = protoTask;
    // Return it
    return task;
}
screepsProfiler.registerFN(initializeTask, 'initializeTask');
function drawCostMatrixHeatMap(roomName, costMatrix) {
    if (!Game.rooms[roomName]) {
        console.log('Heat map drawing skipped. Room not visible:', roomName);
        return;
    }

    const visual = new RoomVisual(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            const cost = costMatrix.get(x, y);
            if (cost > 0) {
                let color = `hsl(${(1 - cost / 255) * 120}, 100%, 50%)`; // Green to red
                visual.rect(x - 0.5, y - 0.5, 1, 1, {fill: color, opacity: 0.4});
            }
        }
    }
}
function plotPath(path, color = '#FF0000', displayDistance = false, plotType = 'circle') {
  const roomVisual = new RoomVisual(path[0].roomName);

  if (plotType === 'circle') {
    path.forEach((pos, index) => {
      roomVisual.circle(pos.x, pos.y, { fill: color });
      if (displayDistance) {
        roomVisual.text(String(index), pos.x, pos.y);
      }
    });
  } else if (plotType === 'line') {
    const points = path.map(pos => [pos.x, pos.y]);
    roomVisual.poly(points, {
      stroke: color,
      strokeWidth: 0.15,
      opacity: 0.5,
      lineStyle: 'solid'
    });
  }

  roomVisual.text("S", path[0].x + 1, path[0].y + 1);
  roomVisual.text("D", path[path.length - 1].x - 2, path[path.length - 1].y - 1);
}

function drawHeatmap(matrix, roomName) {

    const visual = new RoomVisual(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            const cost = matrix.get(x, y);
            let color = '#00FF00'; // Default: green for low plains

            switch (cost) {
                case 2:
                    color = '#8FBC8F'; // Dark Sea Green (slightly higher plains)
                    break;
                case 3:
                    color = '#556B2F'; // Olive Drab (even higher plains)
                    break;
                case 4:
                    color = '#8B4513'; // Saddle Brown (lower mountains)
                    break;
                case 8:
                    color = '#A52A2A'; // Brown (higher mountains)
                    break;
                case 45:
                    color = '#000000'; // Black (very high cost, rough terrain)
                    break;
                case 255:
                    color = '#FF0000'; // Red (impassable)
                    break;
                default:
                    continue; // Skip drawing if the cost is not one of the specified values
            }
            
            visual.rect(x - 0.5, y - 0.5, 1, 1, {fill: color, opacity: 0.5});
        }
    }
}

function sandbox() {
    
// Iterate over each colony using lodash _.forEach for simplicity
_.forEach(Overmind.colonies, colony => {
  // Check if the terminal is ready and the power is less than 3000
  if (colony.terminal && colony.terminal.cooldown === 0 && (colony.assets['power'] || 0) < 3000) {
    console.log(`Colony ${colony.name} needs power. it has ${colony.assets['power']}`);

    // Fetch the best sell order for power that offers at least 100 power and at a price not exceeding 1500
    const orders = Game.market.getAllOrders({
      type: ORDER_SELL,
      resourceType: RESOURCE_POWER
    });

    // Filter orders to find those offering 100 or more power, with a price <= 1500, and not from player 'Taki'
    const validOrders = orders.filter(order =>
      order.amount >= 100 &&
      order.price <= 1500 &&
      order.roomName !== 'E2S25'
    );

    if (validOrders.length > 0) {
      // Sort by price to find the cheapest order
      const bestOrder = validOrders.reduce((best, order) => best.price < order.price ? best : order);

      // console.log(`Best order found for ${bestOrder.amount} power at price ${bestOrder.price} per unit.`);

      // Always attempt to buy 3000 power, but not more than what's available in the best order
      const amountToBuy = Math.min(3000, bestOrder.amount);

      // Execute the trade
      const result = Game.market.deal(bestOrder.id, amountToBuy, colony.name);

      if (result === OK) {
        console.log(`Successfully bought ${amountToBuy} power for Colony ${colony.name}.`);
      } else {
        // console.log(`Failed to buy power for Colony ${colony.name}. Error: ${result}`);
      }
    } else {
      // console.log('No suitable power sell orders found or all orders are above price limit or from player Taki.');
    }
  }
});


}




var TerminalNetworkV2_1;
const getDefaultTerminalNetworkMemory = () => ({});
const getDefaultTerminalNetworkStats = () => ({
    assets: {},
    fractionalEnergyTransferCost: 0.25,
    incomingResources: {},
    outgoingResources: {},
    sendCosts: {},
    terminals: {
        avgCooldown: {},
        overload: {},
    },
    states: {
        activeProviders: {},
        passiveProviders: {},
        equilibriumNodes: {},
        passiveRequestors: {},
        activeRequestors: {},
    },
});
const DEFAULT_TARGET = 2 * LAB_MINERAL_CAPACITY + 1000; // 7000 is default for most resources
const DEFAULT_SURPLUS = 15 * LAB_MINERAL_CAPACITY; // 45000 is default surplus
const ENERGY_SURPLUS = 500000;
const DEFAULT_TOLERANCE = LAB_MINERAL_CAPACITY / 3; // 1000 is default tolerance
const THRESHOLDS_DEFAULT = {
    // mostly for raw mineals
    target: 10000,
    tolerance: 3000,
    surplus: DEFAULT_SURPLUS,
};
const THRESHOLDS_BOOSTS_T3_CRITICAL = {
    // Buy below 20000 / 45000 +/- 25000 (20000-70000)/ Sell@ > 75000
    target: 45000,
    tolerance: 25000,
    surplus: 75000,
};
const THRESHOLDS_BOOSTS_T3_WAR = {
    // Buy below 10,000 / 25,000 +/- 15,000 (10,000-40,000)/ Sell@ > 50,000
    target: 40000, //25000,
    tolerance: 15000,
    surplus: 70000, //50000,
};
const THRESHOLDS_BOOSTS_T3_DEFAULT = {
    // Buy below 10,000 / 17500 +/- 7500 (10,000-25,000)/ Sell@ > 30,000
    target: 25000, //17500,
    tolerance: 7500,
    surplus: 50000, //30000,
};
const THRESHOLDS_BOOSTS_T2 = {
    // DON'T Buy / 7000 +/- 7000  (0-14000)/ Sell@ > 15000
    target: DEFAULT_TARGET,
    tolerance: DEFAULT_TARGET,
    surplus: undefined,
};
const THRESHOLDS_BOOSTS_T1 = {
    // DON'T Buy / 7000 +/- 7000  (0-14000)/ Sell@ > 15000
    target: DEFAULT_TARGET,
    tolerance: DEFAULT_TARGET,
    surplus: undefined,
};
// except for RESOURCE_HYDROXIDE which is THRESHOLDS_DEFAULT
const THREHSOLDS_INTERMEDIATE_REACTANTS = {
    // DON'T Buy / 3000 +/- 3000  (0-6000)/ Sell@ > 9000
    target: 3000,
    tolerance: 3000,
    surplus: undefined,
};
const THRESHOLDS_GHODIUM = {
    // Buy below 5000 / 10000 +/- 5000 (5000-15000)/ Sell@ > 20000
    target: 10000,
    tolerance: 5000,
    surplus: 20000,
};
const THRESHOLDS_DONT_WANT = {
    // thresholds for stuff you actively don't want
    target: 0,
    tolerance: 0,
    surplus: 0,
};
// for isDepositResource and isCommodity
const THRESHOLDS_DONT_CARE = {
    // thresholds for stuff you don't need but don't not want (i.e do not sell)
    target: 0,
    tolerance: 0,
    surplus: undefined,
};
const THRESHOLDS_POWER = {
    // Buy below 1500 / 2500 +/- 1000 (1500-35000)/ DON'T SELL
    target: 2500,
    tolerance: 1000,
    surplus: undefined,
};
const THRESHOLDS_OPS = {
    // DON'T Buy / 2500 +/- 2500  (0-5000)/ DON'T SELL
    target: 2500,
    tolerance: 2500,
    surplus: undefined,
};
const THRESHOLDS_BATTERY = {
    target: DEFAULT_TARGET,
    tolerance: DEFAULT_TARGET,
    surplus: undefined,
};
function getThresholds(resource) {
    /*// Energy gets special treatment - see TradeNetwork.getEnergyThresholds()
    if (resource == RESOURCE_ENERGY) {
        return THRESHOLDS_DONT_CARE;
    }*/
    // Power and ops get their own treatment
    if (resource == RESOURCE_POWER) {
        return THRESHOLDS_POWER;
    }
    if (resource == RESOURCE_OPS) {
        return THRESHOLDS_OPS;
    }
    if (resource == RESOURCE_BATTERY) {
        return THRESHOLDS_BATTERY;
    }
    // All mineral compounds below
    if (Abathur.isBaseMineral(resource)) {
        // base minerals get default treatment
        return THRESHOLDS_DEFAULT;
    }
    if (Abathur.isIntermediateReactant(resource)) {
        // reaction intermediates get default
        if (resource == RESOURCE_HYDROXIDE) {
            // this takes a long time to make so let's keep a bit more of it around
            return THRESHOLDS_DEFAULT;
        } else {
            return THREHSOLDS_INTERMEDIATE_REACTANTS;
        }
    }
    if (resource == RESOURCE_GHODIUM) {
        return THRESHOLDS_GHODIUM;
    }
    if (Abathur.isBoost(resource)) {
        const tier = Abathur.getBoostTier(resource);
        if (tier == 'T3') {
            if (
                Abathur.isMoveBoost(resource) ||
                Abathur.isMoveBoost(resource)
            ) {
                return THRESHOLDS_BOOSTS_T3_CRITICAL;
            } else if (
                Abathur.isAttackBoost(resource) ||
                Abathur.isRangedBoost(resource) ||
                Abathur.isToughBoost(resource)
            ) {
                return THRESHOLDS_BOOSTS_T3_WAR;
            } else {
                return THRESHOLDS_BOOSTS_T3_DEFAULT;
            }
        } else if (tier == 'T2') {
            return THRESHOLDS_BOOSTS_T2;
        } else if (tier == 'T1') {
            return THRESHOLDS_BOOSTS_T1;
        }
    }
    if (Abathur.isMineralOrCompound(resource)) {
        // all other boosts and resources are default
        return THRESHOLDS_DEFAULT;
    }
    // Base deposit resources
    if (Abathur.isDepositResource(resource)) {
        return THRESHOLDS_DONT_CARE;
    }
    // Everything else should be a commodity
    if (Abathur.isCommodity(resource)) {
        return THRESHOLDS_DONT_CARE;
    }
    // Shouldn't reach here since I've handled everything above
    log.error(
        `Shouldn't reach here! Unhandled resource ${resource} in getThresholds()!`,
    );
    return THRESHOLDS_DONT_CARE;
}
// Contains threshold values to use for all non-execeptional colonies so we don't recompute this every time
const ALL_THRESHOLDS = _.object(
    RESOURCES_ALL_EXCEPT_ENERGY,
    _.map(RESOURCES_ALL_EXCEPT_ENERGY, (res) => getThresholds(res)),
);
// The order in which resources are handled within the network
const _resourcePrioritiesOrdered = [
    // TODO: The order can be revised later, in my case (zGeneral) these are my priorities.
    RESOURCE_ENERGY,
    RESOURCE_POWER,
    RESOURCE_BATTERY,
    ...BOOSTS_T3,
    ...BASE_RESOURCES,
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    RESOURCE_OPS,
];
const _resourcePrioritiesEverythingElse = _.filter(
    RESOURCES_ALL,
    (res) => !_resourcePrioritiesOrdered.includes(res),
);
const RESOURCE_EXCHANGE_ORDER = [
    ..._resourcePrioritiesOrdered,
    ..._resourcePrioritiesEverythingElse,
];
const _resourceExchangePrioritiesLookup = _.zipObject(
    RESOURCE_EXCHANGE_ORDER,
    _.map(RESOURCE_EXCHANGE_ORDER, (res) =>
        _.indexOf(RESOURCE_EXCHANGE_ORDER, res),
    ),
);
const EMPTY_COLONY_TIER = _.zipObject(
    RESOURCES_ALL,
    _.map(RESOURCES_ALL, (i) => []),
);
// const defaultRequestOpts: Full<RequestOpts> = {
// 	allowDivvying              : false,
// 	takeFromColoniesBelowTarget: false,
// 	sendTargetPlusTolerance    : false,
// 	allowMarketBuy             : Game.market.credits > TraderJoe.settings.market.credits.canBuyAbove,
// 	receiveOnlyOncePerTick     : false,
// 	complainIfUnfulfilled      : true,
// 	dryRun                     : false,
// };
//
// const defaultProvideOpts: Full<ProvideOpts> = {
// 	allowPushToOtherRooms: true,
// 	allowMarketSell      : true,
// 	complainIfUnfulfilled: true,
// 	dryRun               : false,
// };
/**
 * The TerminalNetwork manages internal resource transfers between owned colonies and tries to get resources where
 * they need to be as fast as possible. This second version of the TerminalNetwork is inspired by Factorio's logistics
 * system. (Factorio is a fantastic game if you haven't played it but it's literally the video game equivalent of
 * Mexican black tar heroin and will consume your life if you let it, kind of like Screeps...) It works like this:
 * - Each colony with a terminal can be in one of 5 states for each resource depending on how much of the resource
 *   it has and on other conditions:
 *   - Active providers will actively push resources from the room into other rooms in the terminal network
 *     which are requestors or will sell the resource on the market no receiving rooms are available
 *   - Passive providers will place their resources at the disposal of the terminal network
 *   - Equilibrium nodes are rooms which are near their desired amount for the resource and prefer to stay there
 *   - Passive requestors are rooms which have less than their desired amount of the resource but which don't have an
 *     immediate need for it; they will request resources from activeProviders and passiveProviders
 *   - Active requestors are rooms which have an immediate need for and insufficient amounts of a resource; they will
 *     request resources from any room which is not also an activeRequestor
 * - The state of each room is determined by a `Thresholds` object, which has `target`, `tolerance`, and (posisbly
 *   undefined) `surplus` properties. Conditions for each state are based on `amount` of resource in a colony:
 *   - Active provider: `amount > surplus` (if defined) or `amont > target + tolerance` and room is near capacity
 *   - Passive provider: `surplus >= amount > target + tolerance`
 *   - Equilibrium: `target + tolerance >= amount >= target - tolerance`
 *   - Passive requestor: `target - tolerance > amount`
 *   - Active requestor: colonies can only be placed in this state by an active call to
 *     `TerminalNetwork.requestResource()` while `target > amount`
 * - To determine which room to request/provide resources from/to, a heuristic is used which tries to minimize
 *   transaction cost while accounting for:
 *   - If a terminal has a high output load (often on cooldown), receivers will de-prioritize it
 * 	 - If a terminal is far away, receivers will wait longer to find a less expensive sender
 * 	 - Bigger transactions with higher costs will wait longer for a closer colony, while smaller transactions are
 * 	   less picky
 */
let TerminalNetworkV2 = (TerminalNetworkV2_1 = class TerminalNetworkV2 {
    constructor() {
        this.name = 'TerminalNetwork';
        this.colonies = [];
        this.refresh();
    }
    /**
     * Clears all the threshold and request data from the previous tick
     */
    refresh() {
        this.colonyThresholds = {};
        this.colonyLockedAmounts = {};
        this._energyThresholds = undefined;
        this.colonyStates = {};
        this._colonyStatesAssigned = false;
        this.activeProviders = {}; // _.clone(EMPTY_COLONY_TIER);
        this.passiveProviders = {}; // _.clone(EMPTY_COLONY_TIER);
        this.equilibriumNodes = {}; // _.clone(EMPTY_COLONY_TIER);
        this.passiveRequestors = {}; // _.clone(EMPTY_COLONY_TIER);
        this.activeRequestors = {}; // _.clone(EMPTY_COLONY_TIER);
        this.assets = {}; // populated when getAssets() is called in init()
        this.terminalOverload = {};
        this.notifications = [];
        this.memory = Mem.wrap(
            Memory.Overmind,
            'terminalNetwork',
            getDefaultTerminalNetworkMemory,
        );
        this.stats = Mem.wrap(
            Memory.stats.persistent,
            'terminalNetwork',
            getDefaultTerminalNetworkStats,
        );
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert('TerminalNetwork:', args);
        }
    }
    /**
     * Adds a colony to the terminal network; should be populated following constructor() phase
     */
    addColony(colony) {
        if (!(colony.terminal && colony.terminal.my && colony.level >= 6)) {
            log.error(`Cannot add colony ${colony.print} to terminal network!`);
        } else {
            this.colonies.push(colony); // add colony to list
        }
    }
    getAssets() {
        if (_.isEmpty(this.assets)) {
            this.assets = mergeSum(
                _.map(this.colonies, (colony) => colony.assets),
            );
        }
        return this.assets;
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    /**
     * Transfer resources from one terminal to another, logging the results
     */
    transfer(sender, receiver, resourceType, amount, description) {
        const cost = Game.market.calcTransactionCost(
            amount,
            sender.room.name,
            receiver.room.name,
        );
        const response = sender.send(
            resourceType,
            amount,
            receiver.room.name,
            description,
        );
        if (response == OK) {
            let msg;
            const floorAmt = Math.floor(amount);
            if (description == 'provide') {
                msg =
                    `${printRoomName(
                        sender.room.name,
                        true,
                    )} ${rightArrow} ${floorAmt} ${resourceType} ` +
                    `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
            } else if (description == 'request') {
                msg =
                    `${printRoomName(
                        receiver.room.name,
                        true,
                    )} ${leftArrow} ${floorAmt} ${resourceType} ` +
                    `${leftArrow} ${printRoomName(sender.room.name, true)} `;
            } else {
                msg =
                    `${printRoomName(
                        sender.room.name,
                        true,
                    )} ${rightArrow} ${floorAmt} ${resourceType} ` +
                    `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
                if (description) {
                    msg += `(${description})`;
                }
            }
            this.notify(msg);
            // this.logTransfer(resourceType, amount, sender.room.name, receiver.room.name);
        } else {
            log.warning(
                `Could not send ${amount} ${resourceType} from ${sender.room.print} to ` +
                    `${receiver.room.print}! Response: ${response}`,
            );
            if (
                response === ERR_NOT_ENOUGH_RESOURCES ||
                response === ERR_TIRED
            ) {
                this.terminalOverload[sender.room.name] = true;
            }
        }
        return response;
    }
    /**
     * Returns the remaining amount of capacity in a colony. Overfilled storages (from OPERATE_STORAGE) are
     * counted as just being at 100% capacity. Optionally takes an additionalAssets argument that asks whether the
     * colony would be near capacity if additionalAssets amount of resources were added.
     */
    getRemainingSpace(colony, includeFactoryCapacity = false) {
        let totalAssets = colony.assetsAmount;
        // Overfilled storage gets counted as just 100% full
        if (colony.storageAmount > STORAGE_CAPACITY) {
            totalAssets -= colony.storageAmount - STORAGE_CAPACITY;
        }
        const roomCapacity =
            (colony.terminal ? TERMINAL_CAPACITY : 0) +
            (colony.storage ? STORAGE_CAPACITY : 0) +
            (colony.factory && includeFactoryCapacity ? FACTORY_CAPACITY : 0);
        return roomCapacity - totalAssets;
    }
    /**
     * Computes the dynamically-changing energy thresholds object
     */
    getEnergyThresholds() {
        if (!this._energyThresholds) {
            const nonExceptionalColonies = _.filter(
                this.colonies,
                (colony) =>
                    colony.storage &&
                    !(
                        this.colonyThresholds[colony.name] &&
                        this.colonyThresholds[colony.name][RESOURCE_ENERGY]
                    ),
            );
            const avgEnergy =
                _.sum(
                    nonExceptionalColonies,
                    (colony) => colony.assets.energy,
                ) / nonExceptionalColonies.length;
            this._energyThresholds = {
                target: avgEnergy,
                surplus: ENERGY_SURPLUS,
                tolerance: avgEnergy / 5,
            };
        }
        return this._energyThresholds;
    }
    /**
     * Compute the default state of a colony for a given resource
     */
    getColonyState(colony, resource) {
        const { target, surplus, tolerance } = this.thresholds(
            colony,
            resource,
        );
        const amount = colony.assets[resource];
        // Active provider if the room is above surplus amount or if the room is above target+tolerance and near full
        if (
            (surplus != undefined && amount > surplus) ||
            (amount > target + tolerance &&
                this.getRemainingSpace(colony) <
                    TerminalNetworkV2_1.settings.minColonySpace)
        ) {
            return 5 /* activeProvider */;
        }
        // Passive provider if the room has below surplus but above target+tolerance
        if (
            (surplus != undefined ? surplus : Infinity) >= amount &&
            amount > target + tolerance
        ) {
            return 4 /* passiveProvider */;
        }
        // Equilibrium state if room has within +/- tolerance of target amount
        if (
            target + tolerance >= amount &&
            amount >= Math.max(target - tolerance, 0)
        ) {
            return 3 /* equilibrium */;
        }
        // Passive requestor if room has below target-tolerance
        if (amount < Math.max(target - tolerance, 0)) {
            return 2 /* passiveRequestor */;
        }
        // Active requestor if room has below target amount and there is an immediate need for the resource
        // This can only be triggered with an override from another part of the program
        // Should never reach here
        log.error(`Shouldn't reach this part of TerminalNetwork code!`);
        return 0 /* error */;
    }
    /**
     * Gets the thresholds for a given resource for a specific colony
     */
    thresholds(colony, resource) {
        if (
            this.colonyThresholds[colony.name] &&
            this.colonyThresholds[colony.name][resource]
        ) {
            return this.colonyThresholds[colony.name][resource];
        } else {
            if (resource == RESOURCE_ENERGY) {
                return this.getEnergyThresholds();
            } else {
                return ALL_THRESHOLDS[resource];
            }
        }
    }
    lockedAmount(colony, resource) {
        if (
            this.colonyLockedAmounts[colony.name] &&
            this.colonyLockedAmounts[colony.name][resource]
        ) {
            return this.colonyLockedAmounts[colony.name][resource];
        } else {
            return 0;
        }
    }
    /**
     * Request resources from the terminal network, placing the colony in an activeRequestor state; amount is the
     * quantity of TOTAL resources you need, including requestor.assets!
     */
    requestResource(requestor, resource, totalAmount, tolerance = 0) {
        if (PHASE != 'init') {
            log.error(
                `TerminalNetwork.requestResource must be called in the init() phase!`,
            );
        }
        // If you already have enough resources, you shouldn't have made the request so throw an error message
        if (requestor.assets[resource] >= totalAmount) {
            log.error(
                `TerminalNetwork.requestResource() called for ${requestor.print} requesting ${totalAmount} ` +
                    `of ${resource}, but colony already has ${requestor.assets[resource]} amount!`,
            );
            return;
        }
        if (!this.colonyThresholds[requestor.name]) {
            this.colonyThresholds[requestor.name] = {};
        }
        // If you already requested the resource via a different method, throw a warning and override
        if (this.colonyThresholds[requestor.name][resource] !== undefined) {
            log.warning(
                `TerminalNetwork.colonyThresholds[${requestor.print}][${resource}] already set to: ` +
                    `${
                        this.colonyThresholds[requestor.name][resource].target
                    }; overriding with ${totalAmount}!`,
            );
        }
        // Set the thresholds and set state to activeRequestor
        this.colonyThresholds[requestor.name][resource] = {
            target: totalAmount,
            surplus: undefined,
            tolerance: tolerance,
        };
        this.colonyStates[requestor.name][resource] = 1 /* activeRequestor */;
    }
    /**
     * Locks a given amount of resources from being withdrawn by the terminal network. Useful if you have obtained the
     * resources for something and want to keep them around until you can use them (for example, boosting a creep).
     * Subsequent calls to this method will increase the amount of the locked resource.
     */
    lockResource(requestor, resource, lockAmount) {
        if (PHASE != 'init') {
            log.error(
                `TerminalNetwork.lockResource() must be called in the init() phase!`,
            );
        }
        if (!this.colonyLockedAmounts[requestor.name]) {
            this.colonyLockedAmounts[requestor.name] = {};
        }
        const alreadyLockedAmount =
            this.colonyLockedAmounts[requestor.name][resource] || 0;
        const newLockAmount = alreadyLockedAmount + lockAmount;
        // Need to have the resources to lock them
        /*
        if (requestor.assets[resource] < newLockAmount) {
            log.warning(`TerminalNetwork.lockResource() called for ${requestor.print} locking ${lockAmount} ` +
                `(total: ${newLockAmount}) of ${resource}, but colony only has ` +
                `${requestor.assets[resource]} amount!`);
        }
        */
        // Lock this amount of resources
        this.colonyLockedAmounts[requestor.name][resource] = newLockAmount;
    }
    /**
     * Requests that the colony export (and not import) a resource, offloading it through the terminal network or
     * selling it on the market. If thresholds is specified, the room will actively export thresholds.surplus amount of
     * resource and will maintain target +/- tolerance amount in the room (so in/out, not necessarily a strict export)
     */
    exportResource(provider, resource, thresholds = THRESHOLDS_DONT_WANT) {
        if (PHASE != 'init') {
            log.error(
                `TerminalNetwork.exportResource must be called in the init() phase!`,
            );
        }
        // If you already requested the resource via a different method, throw a warning and override
        if (
            this.colonyThresholds[provider.name] &&
            this.colonyThresholds[provider.name][resource] != undefined
        ) {
            log.warning(
                `TerminalNetwork.colonyThresholds[${provider.name}][${resource}] already set to:` +
                    `${
                        this.colonyThresholds[provider.name][resource]
                    }; overriding previous export!`,
            );
        }
        // Set the thresholds, but in this case we don't set the state to activeProvider - this is automatically done
        if (!this.colonyThresholds[provider.name]) {
            this.colonyThresholds[provider.name] = {};
        }
        this.colonyThresholds[provider.name][resource] = thresholds;
    }
    /**
     * Returns whether the terminal network would be able to fulfill an activeRequest for an amount of resource.
     * Performs a dry run of the request handling logic and returns true if the transfer would have been made.
     */
    canObtainResource(requestor, resource, totalAmount) {
        if (PHASE != 'run') {
            // need to have all the information from init() about colony states first
            log.error(
                `TerminalNetwork.canObtainResource() must be called in the run() phase!`,
            );
            return false;
        }
        const requestAmount = totalAmount - requestor.assets[resource];
        if (requestAmount <= 0) {
            log.error(
                `TerminalNetwork.canObtainResource() called when you already have the resource! :thonk:`,
            );
            return true;
        }
        const opts = {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            requestType: 'active',
            allowMarketBuy:
                Game.market.credits >
                TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: true,
        };
        this.assignColonyStates(); // this is cached once computed so it's OK to call this many times in a tick
        const prioritizedPartners = [
            this.activeProviders,
            this.passiveProviders,
            this.equilibriumNodes,
            this.passiveRequestors,
        ];
        const partnerSets = _.map(
            prioritizedPartners,
            (partners) => partners[resource] || [],
        );
        // Do a dry run of handling the request instance
        const success = this.handleRequestInstance(
            requestor,
            resource,
            requestAmount,
            partnerSets,
            opts,
        );
        return success;
    }
    getpartnerSets(prioritizedPartners, res) {
        return _.map(prioritizedPartners, (partners) => partners[res] || []);
    }
    init() {
        // Update assets
        this.assets = this.getAssets();
        // Clear out the colony states so they can be refreshed during Colony.init(), which is called after this
        for (const colony of this.colonies) {
            this.colonyStates[colony.name] = {};
        }
    }
    /**
     * Compute which colonies should act as active providers, passive providers, and requestors
     */
    assignColonyStates() {
        if (this._colonyStatesAssigned) {
            return;
        }
        // Assign a state to each colony whose state isn't already specified
        for (const colony of this.colonies) {
            for (const resource of RESOURCE_EXCHANGE_ORDER) {
                if (!this.colonyThresholds[colony.name]) {
                    this.colonyThresholds[colony.name] = {};
                }
                if (!this.colonyStates[colony.name][resource]) {
                    this.colonyStates[colony.name][
                        resource
                    ] = this.getColonyState(colony, resource);
                }
                // Populate the entry in the tier lists
                switch (this.colonyStates[colony.name][resource]) {
                    case 5 /* activeProvider */:
                        if (this.activeProviders[resource] == undefined) {
                            this.activeProviders[resource] = [];
                        }
                        this.activeProviders[resource].push(colony);
                        break;
                    case 4 /* passiveProvider */:
                        if (this.passiveProviders[resource] == undefined) {
                            this.passiveProviders[resource] = [];
                        }
                        this.passiveProviders[resource].push(colony);
                        break;
                    case 3 /* equilibrium */:
                        if (this.equilibriumNodes[resource] == undefined) {
                            this.equilibriumNodes[resource] = [];
                        }
                        this.equilibriumNodes[resource].push(colony);
                        break;
                    case 2 /* passiveRequestor */:
                        if (this.passiveRequestors[resource] == undefined) {
                            this.passiveRequestors[resource] = [];
                        }
                        this.passiveRequestors[resource].push(colony);
                        break;
                    case 1 /* activeRequestor */:
                        if (this.activeRequestors[resource] == undefined) {
                            this.activeRequestors[resource] = [];
                        }
                        this.activeRequestors[resource].push(colony);
                        break;
                    case 0 /* error */:
                        log.error(`TN_STATE.error type encountered!`);
                        break;
                    default:
                        log.error(
                            `Should not be here! colony state is ${
                                this.colonyStates[colony.name][resource]
                            }`,
                        );
                        break;
                }
            }
        }
        // Shuffle all the colony orders in each tier - this helps prevent jams
        _.forEach(
            this.activeRequestors,
            (cols, resource) =>
                (this.activeRequestors[resource] = _.shuffle(cols)),
        );
        _.forEach(
            this.passiveRequestors,
            (cols, resource) =>
                (this.passiveRequestors[resource] = _.shuffle(cols)),
        );
        _.forEach(
            this.equilibriumNodes,
            (cols, resource) =>
                (this.equilibriumNodes[resource] = _.shuffle(cols)),
        );
        _.forEach(
            this.passiveProviders,
            (cols, resource) =>
                (this.passiveProviders[resource] = _.shuffle(cols)),
        );
        _.forEach(
            this.activeProviders,
            (cols, resource) =>
                (this.activeProviders[resource] = _.shuffle(cols)),
        );
        // Mark the states as being assigned
        this._colonyStatesAssigned = true;
    }
    /**
     * Gets the best partner colony to send requested resources from based on a heuristic that minimizes transaction
     * cost while accounting for:
     * 1. If a terminal has a high output load (often on cooldown), receivers will de-prioritize it (avgCooldown term)
     * 2. If a terminal is far away, receivers will wait longer to find a less expensive sender (K term)
     * 3. Bigger transactions with higher costs will wait longer for a closer colony, while smaller transactions
     *    are less picky (BIG_COST term)
     */
    getBestSenderColony(resource, amount, colony, partners) {
        if (partners.length == 0) {
            log.error(`Passed an empty list of sender partners!`);
        }
        const K = 2; // these constants might need tuning
        const BIG_COST = 2000; // size of a typical large transaction cost
        return maxBy(partners, (partner) => {
            const sendCost = Game.market.calcTransactionCost(
                amount,
                partner.name,
                colony.name,
            );
            const avgCooldown =
                this.stats.terminals.avgCooldown[partner.name] || 0;
            const score =
                -1 * sendCost * (K + sendCost / BIG_COST + avgCooldown);
            return score;
        });
    }
    /**
     * Handle a request instance, trying to obtain the desired resource
     */
    handleRequestInstance(colony, resource, requestAmount, partnerSets, opts) {
        const originalRequestAmount = requestAmount;
        if (resource == RESOURCE_ENERGY) {
            requestAmount = Math.min(
                requestAmount,
                TerminalNetworkV2_1.settings.maxEnergySendAmount,
            );
        } else {
            requestAmount = Math.min(
                requestAmount,
                TerminalNetworkV2_1.settings.maxResourceSendAmount,
            );
        }

        if (opts.takeFromColoniesBelowTarget == true) {
            if (
                !(
                    BOOSTS_T3.indexOf(resource) >= 0 ||
                    resource == RESOURCE_POWER
                )
            ) {
                opts.takeFromColoniesBelowTarget = false;
            }
        }

        // Try to find the best single colony to obtain resources from
        for (const partners of partnerSets) {
            // First try to find a partner that has more free resources than (target + request)
            let validPartners = _.filter(
                partners,
                (partner) =>
                    partner.assets[resource] -
                        requestAmount -
                        this.lockedAmount(partner, resource) >=
                    this.thresholds(partner, resource).target,
            );
            // If that doesn't work, try to find a partner where assets - request - locked > target - tolerance
            if (validPartners.length == 0) {
                validPartners = _.filter(
                    partners,
                    (partner) =>
                        partner.assets[resource] -
                            requestAmount -
                            this.lockedAmount(partner, resource) >=
                        this.thresholds(partner, resource).target -
                            this.thresholds(partner, resource).tolerance,
                );
            }
            // If that doesn't work, try to find a partner where assets - request - locked > 0
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _.filter(
                    partners,
                    (partner) =>
                        partner.assets[resource] -
                            requestAmount -
                            this.lockedAmount(partner, resource) >
                        0,
                );
            }
            if (validPartners.length > 0) {
                const bestPartner = this.getBestSenderColony(
                    resource,
                    requestAmount,
                    colony,
                    validPartners,
                );
                const lockedAmount = this.lockedAmount(bestPartner, resource);
                const thresholds = this.thresholds(bestPartner, resource);
                const sendTerm = bestPartner.terminal;
                const recvTerm = colony.terminal;
                const sendAmount = opts.takeFromColoniesBelowTarget
                    ? Math.min(
                          requestAmount,
                          sendTerm.store[resource],
                          bestPartner.assets[resource] - lockedAmount,
                      )
                    : Math.min(
                          requestAmount,
                          sendTerm.store[resource],
                          bestPartner.assets[resource] -
                              (thresholds.target - thresholds.tolerance) -
                              lockedAmount,
                      );
                if (sendAmount <= 0) {
                    log.error(
                        `Request from ${colony.print} to ${bestPartner.print} for ${sendAmount} ${resource}`,
                    );
                    return false;
                }
                // Send the resources or mark the terminal as overloaded for this tick
                if (!opts.dryRun) {
                    if (sendTerm.isReady) {
                        this.transfer(
                            sendTerm,
                            recvTerm,
                            resource,
                            sendAmount,
                            `request`,
                        );
                    } else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                return true;
            }
        }
        // If no colony is sufficient to send you the resources, try to divvy it up among several colonies
        if (opts.allowDivvying) {
            const MAX_SEND_REQUESTS = 3;
            const allPartners = _.flatten(partnerSets);
            // find all colonies that have more than target amt of resource and pick 3 with the most amt
            let validPartners = _(allPartners)
                .filter(
                    (partner) =>
                        partner.assets[resource] -
                            this.lockedAmount(partner, resource) >
                        this.thresholds(partner, resource).target,
                )
                .sortBy(
                    (partner) =>
                        partner.assets[resource] -
                        this.lockedAmount(partner, resource) -
                        this.thresholds(partner, resource).target,
                )
                .take(MAX_SEND_REQUESTS)
                .run();
            // If still no partners and this is a super urgent request, steal from colonies that have below target amt
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _(allPartners)
                    .filter(
                        (partner) =>
                            partner.assets[resource] -
                                this.lockedAmount(partner, resource) >
                            0,
                    )
                    .sortBy(
                        (partner) =>
                            partner.assets[resource] -
                            this.lockedAmount(partner, resource),
                    )
                    .take(MAX_SEND_REQUESTS)
                    .run();
            }
            // request bits of the amount until you have enough
            let remainingAmount = requestAmount;
            let sentSome = false;
            for (const partner of validPartners) {
                const sendTerm = partner.terminal;
                const recvTerm = colony.terminal;
                const amountPartnerCanSend = opts.takeFromColoniesBelowTarget
                    ? sendTerm.store[resource] -
                      this.lockedAmount(partner, resource)
                    : sendTerm.store[resource] -
                      this.lockedAmount(partner, resource) -
                      this.thresholds(partner, resource).target;
                let sendAmount = Math.min(
                    amountPartnerCanSend,
                    remainingAmount,
                );
                if (resource == RESOURCE_ENERGY) {
                    // if we're sending energy, make sure we have amount + cost
                    const sendCost = Game.market.calcTransactionCost(
                        sendAmount,
                        colony.name,
                        partner.name,
                    );
                    if (sendAmount + sendCost > sendTerm.store[resource]) {
                        sendAmount -= sendCost;
                    }
                }
                // Send the resources or mark the terminal as overloaded for this tick
                if (opts.dryRun) {
                    remainingAmount -= sendAmount;
                } else {
                    if (sendTerm.isReady) {
                        const ret = this.transfer(
                            sendTerm,
                            recvTerm,
                            resource,
                            sendAmount,
                            `request`,
                        );
                        if (ret == OK) {
                            remainingAmount -= sendAmount;
                            sentSome = true;
                        } else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    } else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                // If you've obtained what you need from the assortment of colonies, we're done
                if (remainingAmount <= 0) {
                    return true;
                }
            }
            if (sentSome) {
                // if you were able to get at least some of resource by divvying, don't proceed to market
                return true;
            }
        }
        // If you are allowed to buy it on the market, try to do so
        if (opts.allowMarketBuy) {
            // Special cases if it's energy or boosts since these have higher buy thresholds
            if (
                resource == RESOURCE_ENERGY &&
                Game.market.credits <
                    TraderJoe.settings.market.credits.canBuyEnergyAbove
            ) {
                return false;
            }
            if (
                Abathur.isIntermediateReactant(resource) ||
                resource == RESOURCE_GHODIUM
            ) {
                return false; // just make these yourself, you lazy fuck
            }
            if (Abathur.isBoost(resource)) {
                if (
                    Game.market.credits <
                    TraderJoe.settings.market.credits.canBuyBoostsAbove
                ) {
                    return false;
                }
                const boostTier = Abathur.getBoostTier(resource);
                if (
                    boostTier != 'T3' &&
                    !TraderJoe.settings.market.resources.allowBuyT1T2boosts
                ) {
                    return false;
                }
            }
            if (
                opts.requestType == 'passive' &&
                //!Abathur.isBaseMineral(resource) && // zGeneral 31/03
                resource != RESOURCE_POWER
            ) {
                // note: power would only run out and trigger a buy if powerProcessing is enabled & have enough energy to consume it.
                return false; // can only buy base minerals and power for passive requests
            }
            // If you can still buy the thing, then buy then thing!
            const buyOpts = { dryRun: opts.dryRun };
            if (
                /*(Abathur.isBaseMineral(resource) &&
                colony.assets[resource] <
                    TerminalNetworkV2_1.settings
                        .buyBaseMineralsDirectUnder) ||*/ // zGeneral
                resource == RESOURCE_POWER &&
                colony.assets[resource] <
                    TerminalNetworkV2_1.settings.buyPowerDirectUnder
            ) {
                if (opts.requestType == 'active') {
                    buyOpts.preferDirect = true;
                    buyOpts.ignorePriceChecksForDirect = true;
                    buyOpts.ignoreMinAmounts = true;
                } else if (opts.requestType == 'passive') {
                    buyOpts.preferDirect = false; // passive requests should only place buy orders
                    buyOpts.ignoreMinAmounts = false;
                } else {
                    log.error(
                        `Need to specify active or passive request type request for ${resource}!`,
                    );
                }
            }
            const ret = Overmind.tradeNetwork.buy(
                colony.terminal,
                resource,
                originalRequestAmount,
                buyOpts,
            );
            this.debug(
                `Buying ${requestAmount} ${resource} for ${
                    colony.print
                } with opts=${JSON.stringify(buyOpts)}` +
                    `from trade network (${ret})`,
            );
            if (ret >= 0) {
                return true;
            }
        }
        // Can't handle this request instance!
        return false;
    }
    handleProvideInstance(colony, resource, provideAmount, partnerSets, opts) {
        if (resource == RESOURCE_BATTERY)
            console.log(
                ' 1- ********************RESOURCE_BATTERY******************',
            );
        // Sometimes we don't necessarily want to push to other rooms - we usually do, but not always
        if (
            opts.allowPushToOtherRooms &&
            colony.terminal.store[resource] >
                this.lockedAmount(colony, resource)
        ) {
            // Compute the amount we want to send
            let sendAmount = provideAmount;
            if (colony.state.isEvacuating) {
                sendAmount = Math.min(
                    provideAmount,
                    TerminalNetworkV2_1.settings.maxEvacuateSendAmount,
                );
            } else {
                if (resource == RESOURCE_ENERGY) {
                    sendAmount = Math.min(
                        provideAmount,
                        TerminalNetworkV2_1.settings.maxEnergySendAmount,
                    );
                } else {
                    sendAmount = Math.min(
                        provideAmount,
                        TerminalNetworkV2_1.settings.maxResourceSendAmount,
                    );
                }
            }
            // Try to find the best single colony to send resources to
            for (const partners of partnerSets) {
                // First try to find a partner that has less resources than target - sendAmount and can hold more stuff
                let validPartners = _.filter(
                    partners,
                    (partner) =>
                        partner.assets[resource] + sendAmount <=
                            this.thresholds(partner, resource).target &&
                        this.getRemainingSpace(partner) - sendAmount >=
                            TerminalNetworkV2_1.settings.minColonySpace,
                );
                // If that doesn't work, find partner where assets + sendAmount < target + tolerance and has space
                if (validPartners.length == 0) {
                    validPartners = _.filter(
                        partners,
                        (partner) =>
                            partner.assets[resource] + sendAmount <=
                                this.thresholds(partner, resource).target +
                                    this.thresholds(colony, resource)
                                        .tolerance &&
                            this.getRemainingSpace(partner) - sendAmount >=
                                TerminalNetworkV2_1.settings.minColonySpace,
                    );
                }
                // If that doesn't work, just try to find any room with space that won't become an activeProvider
                if (validPartners.length == 0) {
                    validPartners = _.filter(partners, (partner) => {
                        if (
                            this.getRemainingSpace(partner) - sendAmount <
                            TerminalNetworkV2_1.settings.minColonySpace
                        ) {
                            return false;
                        }
                        const { target, surplus, tolerance } = this.thresholds(
                            partner,
                            resource,
                        );
                        if (surplus != undefined) {
                            return (
                                partner.assets[resource] + sendAmount < surplus
                            );
                        } else {
                            return (
                                partner.assets[resource] + sendAmount <=
                                target + tolerance
                            );
                        }
                    });
                }

                // If you've found partners, send it to the best one
                if (validPartners.length > 0) {
                    if (resource == RESOURCE_BATTERY)
                        console.log(
                            ' 2- ********************RESOURCE_BATTERY******************',
                        );
                    const bestPartner = minBy(validPartners, (partner) =>
                        Game.market.calcTransactionCost(
                            sendAmount,
                            colony.name,
                            partner.name,
                        ),
                    );
                    const sendTerm = colony.terminal;
                    const recvTerm = bestPartner.terminal;
                    sendAmount = Math.min(
                        sendAmount,
                        sendTerm.store[resource] -
                            this.lockedAmount(colony, resource),
                    );
                    if (resource === RESOURCE_ENERGY) {
                        // if we're sending energy, make sure we have amount + cost
                        const sendCost = Game.market.calcTransactionCost(
                            sendAmount,
                            colony.name,
                            bestPartner.name,
                        );
                        if (sendAmount + sendCost > sendTerm.store[resource]) {
                            sendAmount -= sendCost;
                        }
                    }
                    // Send the resources or mark the terminal as overloaded for this tick
                    if (!opts.dryRun) {
                        if (sendTerm.isReady) {
                            this.transfer(
                                sendTerm,
                                recvTerm,
                                resource,
                                sendAmount,
                                `provide`,
                            );
                        } else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    }
                    return true;
                }
            }
        }
        if (resource == RESOURCE_BATTERY)
            console.log(
                ' 3- ********************RESOURCE_BATTERY******************',
            );
        // Sell on the market if that's an option
        if (opts.allowMarketSell) {
            const sellOpts = { dryRun: opts.dryRun };
            if (
                resource == RESOURCE_ENERGY || // raw resources that can pile up and kill colonies.
                Abathur.isBaseMineral(resource) ||
                resource == RESOURCE_BATTERY ||
                resource == RESOURCE_OPS
            ) {
                if (
                    this.getRemainingSpace(colony) <
                    TerminalNetworkV2_1.settings.minColonySpace
                ) {
                    sellOpts.preferDirect = true;
                    sellOpts.ignorePriceChecksForDirect = true;
                }
            }
            const ret = Overmind.tradeNetwork.sell(
                colony.terminal,
                resource,
                provideAmount,
                sellOpts,
            );
            this.debug(
                `Selling ${provideAmount} ${resource} from ${colony.print} with ` +
                    `opts=${JSON.stringify(
                        sellOpts,
                    )} via trade network (${ret})`,
            );
            if (ret >= 0) {
                return true;
            }
        }
        // Can't handle this provide instance!
        return false;
    }
    handleRequestors(requestors, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            // sendTargetPlusTolerance    : false,
            allowMarketBuy:
                Game.market.credits >
                TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of requestors[resource] || []) {
                // Skip if the terminal if it has received in this tick if option is specified
                if (
                    opts.receiveOnlyOncePerTick &&
                    colony.terminal &&
                    colony.terminal.hasReceived
                ) {
                    continue;
                }
                // Compute the request amount
                const { target, surplus, tolerance } = this.thresholds(
                    colony,
                    resource,
                );
                const requestAmount = target - colony.assets[resource];
                // if (opts.sendTargetPlusTolerance) {
                // 	requestAmount += tolerance;
                // }
                if (requestAmount <= 0) continue;
                // Generate a list of partner sets by picking the appropriate resource from the prioritizedPartners
                const partnerSets = _.map(
                    prioritizedPartners,
                    (partners) => partners[resource] || [],
                );
                const success = this.handleRequestInstance(
                    colony,
                    resource,
                    requestAmount,
                    partnerSets,
                    opts,
                );
                if (
                    !success &&
                    opts.complainIfUnfulfilled &&
                    Game.time %
                        TerminalNetworkV2_1.settings
                            .complainIfUnfulfilledFrequency ==
                        0
                ) {
                    this.notify(
                        `Unable to fulfill request instance: ${printRoomName(
                            colony.name,
                        )} ${leftArrow} ` + `${requestAmount} ${resource}`,
                    );
                }
            }
        }
    }
    handleProviders(providers, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowPushToOtherRooms: true,
            allowMarketSell: true,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of providers[resource] || []) {
                // Skip if the terminal is not ready -  prevents trying to send twice in a single tick
                if (!colony.terminal || !colony.terminal.isReady) {
                    continue;
                }
                const provideAmount =
                    colony.assets[resource] -
                    this.thresholds(colony, resource).target;
                if (provideAmount <= 0) continue;
                // Generate a list of partner sets by picking the appropriate resource from the prioritizedPartners
                const partnerSets = _.map(
                    prioritizedPartners,
                    (partners) => partners[resource] || [],
                );
                const success = this.handleProvideInstance(
                    colony,
                    resource,
                    provideAmount,
                    partnerSets,
                    opts,
                );
                if (
                    !success &&
                    opts.complainIfUnfulfilled &&
                    Game.time %
                        TerminalNetworkV2_1.settings
                            .complainIfUnfulfilledFrequency ==
                        0
                ) {
                    this.notify(
                        `Unable to fulfill provide instance: ${printRoomName(
                            colony.name,
                        )} ${rightArrow} ` + `${provideAmount} ${resource}`,
                    );
                }
            }
        }
    }
    run() {
        // TODO - Optimize! - This is a very expensive call, mainly assignColonyStates
        if (
            Game.cpu.bucket < Memory.settings.bucketThresholds.terminalNetwork
        ) {
            if (Game.time % 11 == 0) {
                log.warning(
                    `TerminalNetwork.run() is suppressed for 11 ticks to save CPU - To be optimized`,
                );
            } else {
                return;
            }
        }
        // Assign states to each colony; manual state specification should have already been done in directive.init()
        this.assignColonyStates();
        // Handle request types by descending priority: activeRequestors -> activeProviders -> xzsiveRequestors
        // (passiveProviders and equilibriumNodes have no action)
        this.handleRequestors(
            this.activeRequestors,
            [
                this.activeProviders,
                this.passiveProviders,
                this.equilibriumNodes,
                this.passiveRequestors,
            ],
            { requestType: 'active', takeFromColoniesBelowTarget: true },
        );
        this.handleProviders(
            this.activeProviders,
            [
                this.activeRequestors,
                this.passiveRequestors,
                this.equilibriumNodes,
            ],
            { allowMarketSell: true },
        );
        // There are a lot of passive requestors, and usually their requests won't be able to be fulfilled, so
        // we only run this call every few ticks
        if (Overmind.tradeNetwork.ordersProcessedThisTick()) {
            const canBuyPassively =
                Game.market.credits >=
                TraderJoe.settings.market.credits.canBuyPassivelyAbove;
            this.handleRequestors(
                this.passiveRequestors,
                [
                    this.activeProviders,
                    this.passiveProviders,
                    this.equilibriumNodes,
                ],
                {
                    requestType: 'passive',
                    complainIfUnfulfilled: false,
                    allowMarketBuy: canBuyPassively,
                },
            );
        }
        // Record stats for this tick
        this.recordStats();
        // Display a warning for colonies that are critically full
        if (Game.time % 11 == 0) {
            for (const colony of this.colonies) {
                if (
                    this.getRemainingSpace(colony) <
                        TerminalNetworkV2_1.settings.minColonySpace &&
                    !colony.state.isRebuilding
                ) {
                    log.warning(
                        `${colony.print} is critially full; requires immediate attention!`,
                    );
                }
            }
        }
        if (TerminalNetworkV2_1.toggleSummarize) this.summarize();
        // Display notifications
        if (this.notifications.length > 0) {
            this.notifications.sort();
            log.info(
                `Terminal network activity: ` +
                    alignedNewline +
                    this.notifications.join(alignedNewline),
            );
        }
    }
    isInternalTransaction(transaction) {
        return (
            !!transaction.sender &&
            !!transaction.sender.username &&
            !!transaction.recipient &&
            !!transaction.recipient.username &&
            transaction.sender.username == transaction.recipient.username
        );
    }
    recordStats() {
        // Record terminal stats
        for (const colony of this.colonies) {
            if (colony.terminal) {
                this.stats.terminals.avgCooldown[colony.name] = ema(
                    colony.terminal.cooldown,
                    this.stats.terminals.avgCooldown[colony.name] || 0,
                    TerminalNetworkV2_1.settings
                        .terminalCooldownAveragingWindow,
                );
                this.stats.terminals.overload[colony.name] = ema(
                    this.terminalOverload[colony.name] ? 1 : 0,
                    this.stats.terminals.overload[colony.name],
                    CREEP_LIFE_TIME,
                );
            }
        }
        // Rearrange and populate the states entries of stats
        const activeRequestors = {};
        const passiveRequestors = {};
        const equilibriumNodes = {};
        const passiveProviders = {};
        const activeProviders = {};
        for (const [statsTier, thisTier] of [
            [activeRequestors, this.activeRequestors],
            [passiveRequestors, this.passiveRequestors],
            [equilibriumNodes, this.equilibriumNodes],
            [passiveProviders, this.passiveProviders],
            [activeProviders, this.activeProviders],
        ]) {
            for (const resource in thisTier) {
                for (const colony of thisTier[resource]) {
                    if (!statsTier[colony.name]) {
                        statsTier[colony.name] = [resource];
                    } else {
                        statsTier[colony.name].push(resource);
                    }
                }
            }
            for (const colName in statsTier) {
                // sort the resources by the priority of exchange for consistency
                statsTier[colName] = _.sortBy(
                    statsTier[colName],
                    (resource) => _resourceExchangePrioritiesLookup[resource],
                );
            }
        }
        // Assign the transformed object to stats // TODO: graphite doesn't allow string values; need to rewrite this
        this.stats.states.activeRequestors = activeRequestors;
        this.stats.states.passiveRequestors = passiveRequestors;
        this.stats.states.equilibriumNodes = equilibriumNodes;
        this.stats.states.passiveProviders = passiveProviders;
        this.stats.states.activeProviders = activeProviders;
        // Record internal incoming/outgoing resource stats
        const lastTick = Game.time - 1;
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick) break; // only look at things from last tick
            if (!this.isInternalTransaction(transaction)) continue; // only count internal transfers here
            const resource = transaction.resourceType;
            const room = transaction.to;
            this.stats.incomingResources[resource] =
                this.stats.incomingResources[resource] || {};
            this.stats.incomingResources[resource][room] =
                this.stats.incomingResources[resource][room] || 0;
            this.stats.incomingResources[resource][room] += transaction.amount;
        }
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < lastTick) break; // only look at things from last tick
            if (!this.isInternalTransaction(transaction)) continue; // only count internal transfers here
            const resource = transaction.resourceType;
            const room = transaction.from;
            this.stats.outgoingResources[resource] =
                this.stats.outgoingResources[resource] || {};
            this.stats.outgoingResources[resource][room] =
                this.stats.outgoingResources[resource][room] || 0;
            this.stats.outgoingResources[resource][room] += transaction.amount;
            // Also count the energy send costs
            const sendCost = Game.market.calcTransactionCost(
                transaction.amount,
                transaction.from,
                transaction.to,
            );
            this.stats.sendCosts[room] = this.stats.sendCosts[room] || 0;
            this.stats.sendCosts[room] += sendCost;
            // Update fractional energy send cost, averaged over last 100 energy transfers
            if (resource == RESOURCE_ENERGY) {
                const fractionalEnergyTransferCost =
                    sendCost / transaction.amount;
                this.stats.fractionalEnergyTransferCost = ema(
                    fractionalEnergyTransferCost,
                    this.stats.fractionalEnergyTransferCost,
                    100,
                );
            }
        }
        // Record assets
        this.stats.assets = this.assets;
    }
    /**
     * Prints the current state of the terminal network to the console
     */
    summarize(resourceOrColony) {
        const {
            activeRequestors,
            passiveRequestors,
            equilibriumNodes,
            passiveProviders,
            activeProviders,
        } = this.stats.states;
        let info = '\nTerminalNetwork Summary: \n';
        if (resourceOrColony && resourceOrColony instanceof Colony) {
            const colony = resourceOrColony;
            info +=
                `${colony.print} actively providing -----------------------------------------------------\n` +
                `${bullet}${activeProviders[colony.name] || '(None)'}\n` +
                `${colony.print} passively providing ----------------------------------------------------\n` +
                `${bullet}${passiveProviders[colony.name] || '(None)'}\n` +
                `${colony.print} at equilibrium for -----------------------------------------------------\n` +
                `${bullet}${equilibriumNodes[colony.name] || '(None)'}\n` +
                `${colony.print} passively requesting ---------------------------------------------------\n` +
                `${bullet}${passiveRequestors[colony.name] || '(None)'}\n` +
                `${colony.print} actively requesting ----------------------------------------------------\n` +
                `${bullet}${activeRequestors[colony.name] || '(None)'}\n`;
        } else {
            const resource = resourceOrColony || undefined;
            if (resource) {
                info +=
                    `Active providers for ${resource} -----------------------------------------------------\n` +
                    `${bullet}${
                        _.map(
                            this.activeProviders[resource],
                            (col) =>
                                col.printAligned +
                                ` (${col.assets[resource]}), `,
                        ) || '(None)'
                    }\n` +
                    `Passive providers for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${
                        _.map(
                            this.passiveProviders[resource],
                            (col) =>
                                col.printAligned +
                                ` (${col.assets[resource]}), `,
                        ) || '(None)'
                    }\n` +
                    `Equilibrium nodes for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${
                        _.map(
                            this.equilibriumNodes[resource],
                            (col) =>
                                col.printAligned +
                                ` (${col.assets[resource]}), `,
                        ) || '(None)'
                    }\n` +
                    `Passive requestors for ${resource} ----------------------------------------------------\n` +
                    `${bullet}${
                        _.map(
                            this.passiveRequestors[resource],
                            (col) =>
                                col.printAligned +
                                ` (${col.assets[resource]}), `,
                        ) || '(None)'
                    }\n` +
                    `Active requestors for ${resource} -----------------------------------------------------\n` +
                    `${bullet}${
                        _.map(
                            this.activeRequestors[resource],
                            (col) =>
                                col.printAligned +
                                ` (${col.assets[resource]}), `,
                        ) || '(None)'
                    }\n`;
            } else {
                info +=
                    'Active providers ---------------------------------------------------------------------\n';
                for (const colonyName in activeProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${
                        activeProviders[colonyName]
                    }\n`;
                }
                info +=
                    'Passive providers --------------------------------------------------------------------\n';
                for (const colonyName in passiveProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${
                        passiveProviders[colonyName]
                    }\n`;
                }
                info +=
                    'Equilibrium nodes --------------------------------------------------------------------\n';
                for (const colonyName in equilibriumNodes) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${
                        equilibriumNodes[colonyName]
                    }\n`;
                }
                info +=
                    'Passive requestors -------------------------------------------------------------------\n';
                for (const colonyName in passiveRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${
                        passiveRequestors[colonyName]
                    }\n`;
                }
                info +=
                    'Active requestors --------------------------------------------------------------------\n';
                for (const colonyName in activeRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${
                        activeRequestors[colonyName]
                    }\n`;
                }
            }
        }
        console.log(info);
    }
});
TerminalNetworkV2.settings = {
    maxEnergySendAmount: 25000,
    maxResourceSendAmount: 3000,
    maxEvacuateSendAmount: 50000,
    minColonySpace: 20000,
    terminalCooldownAveragingWindow: 1000,
    buyBaseMineralsDirectUnder: DEFAULT_TARGET - DEFAULT_TOLERANCE,
    buyPowerDirectUnder: 100,
    complainIfUnfulfilledFrequency: 20,
};
TerminalNetworkV2 = TerminalNetworkV2_1 = __decorate(
    [profile, assimilationLocked],
    TerminalNetworkV2,
);

const getDefaultSpawnGroupMemory = () => ({
    colonies: [],
    distances: {},
    // routes    : {},
    // paths    : {},
    expiration: 0,
});
const MAX_LINEAR_DISTANCE = 10; // maximum linear distance to search for ANY spawn group
const DEFAULT_RECACHE_TIME = onPublicServer() ? 2000 : 1000;
const defaultSettings = {
    maxPathDistance: 6 * 50,
    requiredRCL: 7,
    maxLevelDifference: 0,
};
/**
 * SpawnGroup provides a decentralized method of spawning creeps from multiple nearby colonies. Use cases include
 * incubation, spawning large combat groups, etc.
 */
let SpawnGroup = class SpawnGroup {
    constructor(initializer, settings = {}) {
        this.roomName = initializer.pos.roomName;
        // this.room = initializer.room;
        if (!Memory.rooms[this.roomName]) {
            Memory.rooms[this.roomName] = {};
        }
        this.memory = Mem.wrap(
            Memory.rooms[this.roomName],
            'spawnGroup',
            getDefaultSpawnGroupMemory,
        );
        this.ref = initializer.ref + ':SG';
        this.stats = {
            avgDistance:
                _.sum(this.memory.distances) /
                    _.keys(this.memory.distances).length || 100,
        };
        this.requests = [];
        this.settings = _.defaults(settings, defaultSettings);
        if (Game.time >= this.memory.expiration) {
            this.recalculateColonies();
        }
        // Compute stats
        this.colonyNames = _.filter(
            this.memory.colonies,
            (roomName) =>
                this.memory.distances[roomName] <=
                    this.settings.maxPathDistance &&
                Game.rooms[roomName] &&
                Game.rooms[roomName].my &&
                Game.rooms[roomName].controller.level >=
                    this.settings.requiredRCL,
        );
        if (this.colonyNames.length == 0) {
            log.warning(
                `No colonies meet the requirements for SpawnGroup: ${this.ref}`,
            );
        }
        this.energyCapacityAvailable = _.max(
            _.map(
                this.colonyNames,
                (roomName) => Game.rooms[roomName].energyCapacityAvailable,
            ),
        );
        this._colonies = undefined;
        Overmind.spawnGroups[this.ref] = this;
    }
    get colonies() {
        if (!this._colonies) {
            this._colonies = _.compact(
                _.map(
                    this.colonyNames,
                    (roomName) => Overmind.colonies[roomName],
                ),
            );
        }
        return this._colonies;
    }
    /**
     * Refresh the state of the spawnGroup; called by the Overmind object.
     */
    refresh() {
        this.memory = Mem.wrap(
            Memory.rooms[this.roomName],
            'spawnGroup',
            getDefaultSpawnGroupMemory,
        );
        this.requests = [];
        this._colonies = undefined;
    }
    recalculateColonies() {
        // don't use settings when recalculating colonies as spawnGroups share memory
        // Get all colonies in range that are of required level, then filter out ones that are too far from best
        let coloniesInRange = _.filter(
            getAllColonies(),
            (colony) =>
                Game.map.getRoomLinearDistance(
                    colony.room.name,
                    this.roomName,
                ) <= MAX_LINEAR_DISTANCE,
        );
        const maxColonyLevel = _.max(
            _.map(coloniesInRange, (colony) => colony.level),
        );
        coloniesInRange = _.filter(
            coloniesInRange,
            (colony) =>
                maxColonyLevel - colony.level <=
                this.settings.maxLevelDifference,
        );
        const colonyNames = [];
        // const routes = {} as { [colonyName: string]: { [roomName: string]: boolean } };
        // let paths = {} as { [colonyName: string]: { startPos: RoomPosition, path: string[] } };
        const distances = {};
        for (const colony of coloniesInRange) {
            const spawn = colony.room.spawns[0];
            if (spawn) {
                // const route = Pathing.findRoute(colony.room.name, this.roomName);
                const path = Pathing.findPathToRoom(spawn.pos, this.roomName);
                if (
                    !path.incomplete &&
                    path.path.length <= DEFAULT_MAX_PATH_LENGTH + 25
                ) {
                    colonyNames.push(colony.room.name);
                    // routes[colony.room.name] = route;
                    // paths[room.name] = path.path;
                    distances[colony.room.name] = path.path.length;
                }
            }
        }
        this.memory.colonies = colonyNames;
        // this.memory.routes = routes;
        // this.memory.paths = TODO
        this.memory.distances = distances;
        this.memory.expiration = getCacheExpiration(DEFAULT_RECACHE_TIME, 25);
    }
    enqueue(request) {
        this.requests.push(request);
    }
    /**
     * SpawnGroup.init() must be called AFTER all hatcheries have been initialized
     */
    init() {
        // Most initialization needs to be done at init phase because colonies are still being constructed earlier
        const colonies = _.compact(
            _.map(this.colonyNames, (name) => Overmind.colonies[name]),
        );
        const hatcheries = _.compact(
            _.map(colonies, (colony) => colony.hatchery),
        );
        const distanceTo = (hatchery) =>
            this.memory.distances[hatchery.pos.roomName] + 25;
        // Enqueue each requests to the hatchery with least expected wait time, which is updated after each enqueue
        for (const request of this.requests) {
            // const maxCost = bodyCost(request.setup.generateBody(this.energyCapacityAvailable));
            // const okHatcheries = _.filter(hatcheries,
            // 							  hatchery => hatchery.room.energyCapacityAvailable >= maxCost);
            const bestHatchery = minBy(
                hatcheries,
                (hatchery) =>
                    hatchery.getWaitTimeForPriority(request.priority) +
                    distanceTo(hatchery),
            );
            if (bestHatchery) {
                bestHatchery.enqueue(request);
            } else {
                log.error(
                    `Could not enqueue creep with role ${request.setup.role} in ${this.roomName} ` +
                        `for Overlord ${request.overlord.print}!`,
                );
            }
        }
    }
    run() {
        // Nothing goes here
    }
};
SpawnGroup = __decorate([profile], SpawnGroup);

const getDefaultCombatOverlordMemory = () => ({
    ['T' /* TICK */]: Game.time,
});
/**
 * CombatOverlords extend the base Overlord class to provide additional combat-specific behavior
 */
let CombatOverlord = class CombatOverlord extends Overlord {
    constructor(directive, name, priority, requiredRCL, maxPathDistance) {
        super(directive, name, priority, getDefaultCombatOverlordMemory);
        this.directive = directive;
        this.requiredRCL = requiredRCL;
        this.spawnGroup = new SpawnGroup(this, {
            requiredRCL: this.requiredRCL,
            maxPathDistance: maxPathDistance,
        });
    }
    get age() {
        return Game.time - this.memory['T' /* TICK */];
    }
    // Standard sequence of actions for running combat creeps
    autoRun(roleCreeps, creepHandler) {
        for (const creep of roleCreeps) {
            if (creep.spawning) {
                continue; // https://github.com/bencbartlett/Overmind/pull/183
            }
            if (creep.hasValidTask) {
                creep.run();
            } else {
                if (creep.needsBoosts) {
                    this.handleBoosting(creep);
                } else {
                    creepHandler(creep);
                }
            }
        }
    }
    /**
     * Contains logic for shutting down the overlord
     */
    finish(successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
        // TODO: CombatOverlord
    }
};
CombatOverlord = __decorate([profile], CombatOverlord);

var SourceReaperOverlord_1;
/**
 * SourceReaperOverlord -- spawns offensive creeps to allow source keeper mining
 */
let SourceReaperOverlord = (SourceReaperOverlord_1 = class SourceReaperOverlord extends (
    CombatOverlord
) {
    constructor(
        directive,
        priority = OverlordPriority.remoteSKRoom.sourceReaper,
    ) {
        super(
            directive,
            'sourceReaper',
            priority,
            SourceReaperOverlord_1.requiredRCL,
        );
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.reapers = this.combatZerg(Roles.melee);
        this.defenders = this.combatZerg(Roles.ranged);
        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');
        this.computeTargetLair();
        this.isCenterRoom =
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE;
    }
    computeTargetLair() {
        this.targetLair = this.memory.targetLairID
            ? deref(this.memory.targetLairID)
            : undefined;
        if (
            !this.targetLair ||
            (this.targetLair.ticksToSpawn || Infinity) >= 299
        ) {
            if (this.room) {
                // If any lairs have an active keeper, target that
                const activeLair = _.find(
                    this.room.keeperLairs,
                    (lair) =>
                        lair.pos.findInRange(lair.room.sourceKeepers, 5)
                            .length > 0,
                );
                if (activeLair) {
                    this.targetLair = activeLair;
                } else {
                    // Otherwise target whatever is closest to spawning
                    this.targetLair = minBy(
                        this.room.keeperLairs,
                        (lair) => lair.ticksToSpawn || Infinity,
                    );
                }
            }
        }
    }
    refresh() {
        super.refresh();
        this.computeTargetLair();
    }
    init() {
        if (
            this.room &&
            (this.room.invaders.length > 0 ||
                RoomIntel.isInvasionLikely(this.room))
        ) {
            this.wishlist(1, CombatSetups.zerglings.sourceKeeper);
            this.wishlist(2, CombatSetups.hydralisks.sourceKeeper); // zGeneral 30/9/2023
        } else if (!this.isCenterRoom) {
            this.wishlist(1, CombatSetups.zerglings.sourceKeeper);
            //this.wishlist(1, CombatSetups.hydralisks.sourceKeeper);
        }
    }
    handleReaper(reaper) {
        const moveOpts = { pathOpts: { avoidSK: false } };
        // Go to keeper room
        if (
            (!this.targetLair && !this.isCenterRoom) ||
            !this.room ||
            reaper.room != this.room ||
            reaper.pos.isEdge
        ) {
            // log.debugCreep(reaper, `Going to room!`);
            reaper.healSelfIfPossible();
            reaper.goTo(this.pos, moveOpts);
            return;
        }

        // Once you're safely in the room, block off the exits
        moveOpts.pathOpts.blockExits = true;
        const nonStrongholdInvaders = this.room.invaders.filter(
            (creep) => !creep.inRampart,
        );
        if (nonStrongholdInvaders.length > 0) {
            // Handle invader actions
            if (reaper.hits >= reaper.hitsMax * 0.5) {
                const result = reaper.autoMelee(this.room.invaders);
                if (result == undefined) {
                    // didn't attack
                    reaper.autoHeal();
                }
            } else {
                reaper.healSelfIfPossible();
            }
            // Kite around ranged invaders until a defender arrives
            if (
                this.room.invaders.length > 2 &&
                _.filter(this.defenders, (def) => def.room == this.room)
                    .length == 0
            ) {
                reaper.kite(
                    _.filter(
                        this.room.hostiles,
                        (h) => h.getActiveBodyparts(RANGED_ATTACK) > 0,
                    ),
                    moveOpts,
                );
                reaper.healSelfIfPossible();
            }
            // If defender is already here or a small invasion
            else {
                const target = CombatTargeting.findTarget(
                    reaper,
                    this.room.invaders,
                );
                if (target) {
                    Movement.invasionMove(reaper, target);
                } else {
                    log.warning(
                        `KeeperReaper@${reaper.pos.print}: no invader target!`,
                    );
                }
            }
        } else {
            // Standard keeperReaper actions
            const nearestHostile = reaper.pos.findClosestByRange(
                this.room.hostiles,
            );
            if (nearestHostile && reaper.pos.isNearTo(nearestHostile)) {
                reaper.attack(nearestHostile);
                reaper.move(reaper.pos.getDirectionTo(nearestHostile));
            } else if (!this.isCenterRoom && this.targetLair) {
                const keeper = this.targetLair.pos.findClosestByLimitedRange(
                    this.room.sourceKeepers,
                    7,
                );
                if (keeper) {
                    // attack the source keeper
                    // stop and heal at range 4 if needed
                    const approachRange =
                        reaper.hits == reaper.hitsMax ||
                        reaper.pos.getRangeTo(keeper) <= 3
                            ? 1
                            : 4;
                    reaper.goTo(keeper, {
                        range: approachRange,
                        pathOpts: moveOpts.pathOpts,
                    });
                } else {
                    // travel to next lair
                    reaper.goTo(this.targetLair, {
                        range: 1,
                        pathOpts: moveOpts.pathOpts,
                    });
                }
            } else {
                reaper.goTo(this.pos);
            }
            reaper.healSelfIfPossible();
        }
    }
    handleDefender(defender) {
        // Go to keeper room
        if (
            (!this.targetLair && !this.isCenterRoom) ||
            !this.room ||
            defender.room != this.room ||
            defender.pos.isEdge
        ) {
            debug(defender, `Going to room!`);
            defender.healSelfIfPossible();
            defender.goToRoom(this.pos.roomName, {
                pathOpts: { avoidSK: false },
            });
            return;
        }
        if (this.room.invaders.length > 0) {
            // Handle invader actions
            debug(defender, `AutoCombat`);
            defender.autoSkirmish(this.room.name);
        } else {
            if (
                this.room.hostiles.length <= 1 &&
                defender.hits == defender.hitsMax &&
                this.reapers.length > 0
            ) {
                defender.park(); // zGeneral 30/9/2023 save CPU!
                return;
            }
            // console.log(this.pos.print, 'parking defender');

            debug(defender, `Standard duty`);
            // Help out with keeper reaping
            defender.autoRanged();
            defender.autoHeal(false);
            const reaper = defender.pos.findClosestByRange(this.reapers);
            if (reaper) {
                defender.goTo(reaper, {
                    movingTarget: defender.pos.getRangeTo(reaper) > 8,
                    repathChance: 0.1,
                    pathOpts: {
                        maxRooms: 1,
                        avoidSK: false,
                        blockExits: true,
                    },
                });
            } else if (this.targetLair) {
                const keeper = this.targetLair.pos.findClosestByLimitedRange(
                    this.room.sourceKeepers,
                    7,
                );
                if (keeper) {
                    // attack the source keeper
                    const range = defender.pos.getRangeTo(keeper);
                    const keepAtRange =
                        defender.hits < defender.hitsMax * 0.9 ? 4 : 3;
                    if (range < keepAtRange) {
                        defender.kite(this.room.hostiles, {
                            range: keepAtRange,
                            pathOpts: {
                                avoidSK: false,
                                blockExits: true,
                            },
                        });
                    } else if (range > keepAtRange) {
                        defender.goTo(keeper, {
                            range: keepAtRange,
                            pathOpts: {
                                avoidSK: false,
                                blockExits: true,
                            },
                        });
                    }
                } else {
                    // travel to next lair
                    defender.goTo(this.targetLair, {
                        range: 5,
                        pathOpts: {
                            avoidSK: false,
                            blockExits: true,
                        },
                    });
                }
            }
        }
    }
    run() {
        this.autoRun(this.reapers, (reaper) => this.handleReaper(reaper));
        this.autoRun(this.defenders, (defender) =>
            this.handleDefender(defender),
        );
    }
    visuals() {
        if (this.room && this.targetLair) {
            Visualizer.marker(this.targetLair.pos);
        }
    }
});
SourceReaperOverlord.requiredRCL = 7;
SourceReaperOverlord = SourceReaperOverlord_1 = __decorate(
    [profile],
    SourceReaperOverlord,
);

let DirectiveSKOutpost = class DirectiveSKOutpost extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 7);
        this.isCenterRoom =
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE;
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() {
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.overlords.sourceReaper = new SourceReaperOverlord(this);
        }
    }
    getMiddleRoom() {
        const delta = Cartographer.findRoomCoordDeltas(
            this.colony.name,
            this.pos.roomName,
        );
        switch (delta.x) {
            case 2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x - 1,
                    delta.y,
                );
                break;
            case -2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x + 1,
                    delta.y,
                );
                break;
            default:
                switch (delta.y) {
                    case 2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y - 1,
                        );
                        break;
                    case -2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y + 1,
                        );
                        break;
                }
        }
    }
    init() {
        if (
            Game.time % 10 == 1 &&
            this.room &&
            this.room.invaderCore &&
            this.room.invaderCore.level > 2
        ) {
            this.memory.c1 = COLOR_PURPLE;
            this.memory.c2 = COLOR_YELLOW;
            Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
        }
        if (
            Game.time % 10 == 1 &&
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
        ) {
            if (!this.middleRoom) {
                this.getMiddleRoom();
            }
            if (
                this.middleRoom &&
                Game.rooms[this.middleRoom] &&
                Game.rooms[this.middleRoom].invaderCore &&
                Game.rooms[this.middleRoom].invaderCore.level > 3
            ) {
                this.memory.c1 = COLOR_PURPLE;
                this.memory.c2 = COLOR_YELLOW;
                Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
            }
        }
    }
    run() {}
};
DirectiveSKOutpost.directiveName = 'outpostSK';
DirectiveSKOutpost.color = COLOR_PURPLE;
DirectiveSKOutpost.secondaryColor = COLOR_YELLOW;
DirectiveSKOutpost = __decorate([profile], DirectiveSKOutpost);

/**
 * Empire: Utilities on analyzing the overall empire
 */
let EmpireAnalysis = class EmpireAnalysis {
    static empireMineralDistribution() {
        const colonies = getAllColonies();
        const minedSKRooms = DirectiveSKOutpost.find(Object.values(Game.flags));
        const mineralDistribution = {};
        for (const colony of colonies) {
            const mineral = colony.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        for (const skRoomFlag of minedSKRooms) {
            if (!skRoomFlag.room) {
                continue;
            }
            const mineral = skRoomFlag.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        return mineralDistribution;
    }
};
EmpireAnalysis = __decorate([profile], EmpireAnalysis);

/**
 * OvermindConsole registers a number of global methods for direct use in the Screeps console
 */
class OvermindConsole {
    static init() {
        global.help = this.help();
        global.info = this.info;
        global.notifications = this.notifications;
        global.debug = this.debug;
        global.stopDebug = this.stopDebug;
        global.setMode = this.setMode;
        global.setSignature = this.setSignature;
        global.print = this.print;
        global.timeit = this.timeit;
        global.profileOverlord = this.profileOverlord;
        global.finishProfilingOverlord = this.finishProfilingOverlord;
        global.setLogLevel = log.setLogLevel;
        global.suspendColony = this.suspendColony;
        global.unsuspendColony = this.unsuspendColony;
        global.listSuspendedColonies = this.listSuspendedColonies;
        global.openRoomPlanner = this.openRoomPlanner;
        global.closeRoomPlanner = this.closeRoomPlanner;
        global.cancelRoomPlanner = this.cancelRoomPlanner;
        global.listActiveRoomPlanners = this.listActiveRoomPlanners;
        global.destroyErrantStructures = this.destroyErrantStructures;
        global.destroyAllHostileStructures = this.destroyAllHostileStructures;
        global.destroyAllBarriers = this.destroyAllBarriers;
        global.listConstructionSites = this.listConstructionSites;
        global.removeUnbuiltConstructionSites = this.removeUnbuiltConstructionSites;
        global.listDirectives = this.listDirectives;
        global.listPersistentDirectives = this.listPersistentDirectives;
        global.removeAllLogisticsDirectives = this.removeAllLogisticsDirectives;
        global.removeFlagsByColor = this.removeFlagsByColor;
        global.removeErrantFlags = this.removeErrantFlags;
        global.setRoomUpgradeRate = this.setRoomUpgradeRate;
        global.deepCleanMemory = this.deepCleanMemory;
        global.startRemoteDebugSession = this.startRemoteDebugSession;
        global.endRemoteDebugSession = this.endRemoteDebugSession;
        global.profileMemory = this.profileMemory;
        global.cancelMarketOrders = this.cancelMarketOrders;
        global.setRoomUpgradeRate = this.setRoomUpgradeRate;
        global.getEmpireMineralDistribution = this.getEmpireMineralDistribution;
        global.listPortals = this.listPortals;
        global.evaluateOutpostEfficiencies = this.evaluateOutpostEfficiencies;
        global.evaluatePotentialOutpostEfficiencies = this.evaluatePotentialOutpostEfficiencies;
        global.auditOutpostFlags = this.auditOutpostFlags;
        global.auditResources = this.auditResources;
        global.toggleTerminalNetworkSummarize = this.toggleTerminalNetworkSummarize;
        global.visuals = this.visuals;
        global.showIntelVisuals = this.showIntelVisuals;
    }
    // Help, information, and operational changes ======================================================================
    static help() {
        let msg = '\n<font color="#ff00ff">';
        for (const line of asciiLogoSmall) {
            msg += line + '\n';
        }
        msg += '</font>';
        // Generate a methods description object
        const descr = {};
        descr.help = 'show this message';
        descr['info()'] = 'display version and operation information';
        descr['notifications()'] =
            'print a list of notifications with hyperlinks to the console';
        descr['setMode(mode)'] =
            'set the operational mode to "manual_extreme", "manual", "semiautomatic", or "automatic"';
        descr['setSignature(newSignature)'] =
            'set your controller signature; no argument sets to default';
        descr['print(...args[])'] = 'log stringified objects to the console';
        descr['debug(thing)'] =
            'enable debug logging for a game object or process';
        descr['stopDebug(thing)'] =
            'disable debug logging for a game object or process';
        descr['timeit(function, repeat=1)'] =
            'time the execution of a snippet of code';
        descr['profileOverlord(overlord, ticks?)'] =
            'start profiling on an overlord instance or name';
        descr['finishProfilingOverlord(overlord)'] =
            'stop profiling on an overlord';
        descr['setLogLevel(int)'] = 'set the logging level from 0 - 4';
        descr['suspendColony(roomName)'] = 'suspend operations within a colony';
        descr['unsuspendColony(roomName)'] =
            'resume operations within a suspended colony';
        descr['listSuspendedColonies()'] = 'list currently suspended colonies';
        descr['openRoomPlanner(roomName)'] = 'open the room planner for a room';
        descr['closeRoomPlanner(roomName)'] =
            'close the room planner and save changes';
        descr['cancelRoomPlanner(roomName)'] =
            'close the room planner and discard changes';
        descr['listActiveRoomPlanners()'] =
            'display a list of colonies with open room planners';
        descr['destroyErrantStructures(roomName)'] =
            'destroys all misplaced structures within an owned room';
        descr['destroyAllHostileStructures(roomName)'] =
            'destroys all hostile structures in an owned room';
        descr['destroyAllBarriers(roomName)'] =
            'destroys all ramparts and barriers in a room';
        descr['listConstructionSites(filter?)'] =
            'list all construction sites matching an optional filter';
        descr['removeUnbuiltConstructionSites()'] =
            'removes all construction sites with 0 progress';
        descr['listDirectives(filter?)'] =
            'list directives, matching a filter if specified';
        descr['listPersistentDirectives()'] =
            'print type, name, pos of every persistent directive';
        descr['removeFlagsByColor(color, secondaryColor)'] =
            'remove flags that match the specified colors';
        descr['removeErrantFlags()'] =
            "remove all flags which don't match a directive";
        descr['setRoomUpgradeRate(roomName, rate)'] =
            'sets this rooms controller upgrade speed multiplier (from 1)';
        descr['deepCleanMemory()'] =
            'deletes all non-critical portions of memory (be careful!)';
        descr['profileMemory(root=Memory, depth=1)'] =
            'scan through memory to get the size of various objects';
        descr['startRemoteDebugSession()'] =
            'enables the remote debugger so Muon can debug your code';
        descr['cancelMarketOrders(filter?)'] =
            'cancels all market orders matching filter (if provided)';
        descr['getEmpireMineralDistribution()'] =
            'returns current census of colonies and mined sk room minerals';
        descr['getPortals(rangeFromColonies)'] =
            'returns active portals within colony range';
        descr['evaluateOutpostEfficiencies()'] =
            'prints all colony outposts efficiency';
        descr['evaluatePotentialOutpostEfficiencies()'] =
            'prints all nearby unmined outposts';
        descr['auditOutpostFlags()'] =
            'Audits outposts for Harvest/Outpost colony flag mismatch';
        descr['auditResources()'] = 'audit resources across all colonies';
        descr['toggleTerminalNetworkSummarize()'] =
            'toggle TerminalNetwork Summarize() to show terminal network status';
        descr['visuals(enable?)'] = 'enable/disable showing visuals';
        descr['showIntelVisuals(ticks?)'] =
            'show intel using visuals (ticks defaults to 100)';
        // Console list
        const descrMsg = toColumns(descr, { justify: true, padChar: '.' });
        const maxLineLength = _.max(_.map(descrMsg, (line) => line.length)) + 2;
        msg +=
            'Console Commands: '.padRight(maxLineLength, '=') +
            '\n' +
            descrMsg.join('\n');
        msg += '\n\nRefer to the repository for more information\n';
        return msg;
    }
    static printUpdateMessage(aligned = false) {
        const joinChar = aligned ? alignedNewline : '\n';
        const msg =
            `Codebase updated or global reset. Type "help" for a list of console commands.` +
            joinChar +
            color(asciiLogoSmall.join(joinChar), '#ff00ff') +
            joinChar +
            OvermindConsole.info(aligned);
        log.alert(msg);
    }
    static printTrainingMessage() {
        console.log('\n' + asciiLogoRL.join('\n') + '\n');
    }
    static info(aligned = false) {
        const b = bullet;
        const baseInfo = [
            `${b}Version:        Hive v${__VERSION__}`,
            `${b}Assimilated:    [disabled]`,
            `${b}Operating mode: ${Memory.settings.operationMode}`,
        ];
        const joinChar = aligned ? alignedNewline : '\n';
        return baseInfo.join(joinChar);
    }
    static notifications() {
        const notifications = Overmind.overseer.notifier.generateNotificationsList(
            true,
        );
        return _.map(notifications, (msg) => bullet + msg).join('\n');
    }
    static setMode(mode) {
        switch (mode) {
            case 'manual_extreme':
                Memory.settings.operationMode = 'manual_extreme';
                return `Operational mode set to manual_extreme. harvest, extract and outpost directive placements are to be done manually.`;
            case 'manual':
                Memory.settings.operationMode = 'manual';
                return (
                    `Operational mode set to manual. Only defensive directives will be placed automatically; ` +
                    `remove harvesting, claiming, room planning, and raiding must be done manually.`
                );
            case 'semiautomatic':
                Memory.settings.operationMode = 'semiautomatic';
                return (
                    `Operational mode set to semiautomatic. Claiming, room planning, and raiding must be done ` +
                    `manually; everything else is automatic.`
                );
            case 'automatic':
                Memory.settings.operationMode = 'automatic';
                return (
                    `Operational mode set to automatic. All actions are done automatically, but manually placed ` +
                    `directives will still be responded to.`
                );
            default:
                return `Invalid mode: please specify 'manual_extreme', 'manual', 'semiautomatic', or 'automatic'.`;
        }
    }
    static setSignature(signature) {
        const sig = signature ? signature : DEFAULT_OVERMIND_SIGNATURE;
        if (sig.length > 100) {
            throw new Error(
                `Invalid signature: ${signature}; length is over 100 chars.`,
            );
        } else if (
            sig.toLowerCase().includes('overmind') ||
            sig.includes(DEFAULT_OVERMIND_SIGNATURE)
        ) {
            Memory.settings.signature = sig;
            return `Controller signature set to ${sig}`;
        } else {
            throw new Error(
                `Invalid signature: ${signature}; must contain the string "Overmind" or ` +
                    `${DEFAULT_OVERMIND_SIGNATURE} (accessible on global with __DEFAULT_OVERMIND_SIGNATURE__)`,
            );
        }
    }
    // Debugging methods ===============================================================================================
    static debug(thing) {
        thing.memory.debug = true;
        return `Enabled debugging for ${
            thing.name || thing.ref || '(no name or ref)'
        }.`;
    }
    static stopDebug(thing) {
        delete thing.memory.debug;
        return `Disabled debugging for ${
            thing.name || thing.ref || '(no name or ref)'
        }.`;
    }
    static startRemoteDebugSession() {
        global.remoteDebugger.enable();
        return `Started remote debug session.`;
    }
    static endRemoteDebugSession() {
        global.remoteDebugger.disable();
        return `Ended remote debug session.`;
    }
    static print(...args) {
        let message = '';
        for (const arg of args) {
            let cache = [];
            const msg = JSON.stringify(
                arg,
                function (key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (cache.indexOf(value) !== -1) {
                            // Duplicate reference found
                            try {
                                // If this value does not reference a parent it can be deduped
                                return JSON.parse(JSON.stringify(value));
                            } catch (error) {
                                // discard key if value cannot be deduped
                                return;
                            }
                        }
                        // Store value in our collection
                        cache.push(value);
                    }
                    return value;
                },
                '\t',
            );
            cache = null;
            message += '\n' + msg;
        }
        return message;
    }
    static timeit(callback, repeat = 1) {
        let start, used, i;
        start = Game.cpu.getUsed();
        for (i = 0; i < repeat; i++) {
            callback();
        }
        used = Game.cpu.getUsed() - start;
        return `CPU used: ${used}. Repetitions: ${repeat} (${
            used / repeat
        } each).`;
    }
    // Overlord profiling ==============================================================================================
    static profileOverlord(overlord, ticks) {
        const overlordInstance =
            typeof overlord == 'string'
                ? Overmind.overlords[overlord]
                : overlord;
        if (!overlordInstance) {
            return `No overlord found for ${overlord}!`;
        } else {
            overlordInstance.startProfiling(ticks);
            return `Profiling ${overlordInstance.print} for ${
                ticks || 'indefinite'
            } ticks.`;
        }
    }
    static finishProfilingOverlord(overlord, ticks) {
        const overlordInstance =
            typeof overlord == 'string'
                ? Overmind.overlords[overlord]
                : overlord;
        if (!overlordInstance) {
            return `No overlord found for ${overlord}!`;
        } else {
            overlordInstance.finishProfiling();
            return `Profiling ${overlordInstance.print} stopped.`;
        }
    }
    // Colony suspension ===============================================================================================
    static suspendColony(roomName) {
        if (Overmind.colonies[roomName]) {
            const colonyMemory = Memory.colonies[roomName];
            if (colonyMemory) {
                colonyMemory.suspend = true;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} suspended.`;
            } else {
                return `No colony memory for ${roomName}!`;
            }
        } else {
            return `Colony ${roomName} is not a valid colony!`;
        }
    }
    static unsuspendColony(roomName) {
        const colonyMemory = Memory.colonies[roomName];
        if (colonyMemory) {
            if (!colonyMemory.suspend) {
                return `Colony ${roomName} is not suspended!`;
            } else {
                delete colonyMemory.suspend;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} unsuspended.`;
            }
        } else {
            return `No colony memory for ${roomName}!`;
        }
    }
    static listSuspendedColonies() {
        let msg = 'Colonies currently suspended: \n';
        for (const i in Memory.colonies) {
            const colonyMemory = Memory.colonies[i];
            if (colonyMemory && colonyMemory.suspend == true) {
                msg += 'Colony ' + i + ' \n';
            }
        }
        return msg;
    }
    // Room planner control ============================================================================================
    static openRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active != true) {
                Overmind.colonies[roomName].roomPlanner.active = true;
                return '';
            } else {
                return `RoomPlanner for ${roomName} is already active!`;
            }
        } else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static closeRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.finalize(true);
                return '';
            } else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        } else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static cancelRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.active = false;
                return `RoomPlanner for ${roomName} has been deactivated without saving changes`;
            } else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        } else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static listActiveRoomPlanners() {
        const coloniesWithActiveRoomPlanners = _.filter(
            _.map(
                _.keys(Overmind.colonies),
                (colonyName) => Overmind.colonies[colonyName],
            ),
            (colony) => colony.roomPlanner.active,
        );
        const names = _.map(
            coloniesWithActiveRoomPlanners,
            (colony) => colony.room.print,
        );
        if (names.length > 0) {
            console.log('Colonies with active room planners: ' + names);
            return '';
        } else {
            return `No colonies with active room planners`;
        }
    }
    static listConstructionSites(filter) {
        let msg = `${
            _.keys(Game.constructionSites).length
        } construction sites currently present: \n`;
        for (const id in Game.constructionSites) {
            const site = Game.constructionSites[id];
            if (!filter || filter(site)) {
                msg +=
                    `${bullet}Type: ${site.structureType}`.padRight(20) +
                    `Pos: ${site.pos.print}`.padRight(65) +
                    `Progress: ${site.progress} / ${site.progressTotal} \n`;
            }
        }
        return msg;
    }
    // Directive management ============================================================================================
    static listDirectives(filter) {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (!filter || filter(dir)) {
                msg +=
                    `${bullet}Name: ${dir.print}`.padRight(70) +
                    `Colony: ${dir.colony.print}`.padRight(55) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeAllLogisticsDirectives() {
        const logisticsFlags = _.filter(
            Game.flags,
            (flag) =>
                flag.color == COLOR_YELLOW &&
                flag.secondaryColor == COLOR_YELLOW,
        );
        for (const dir of logisticsFlags) {
            dir.remove();
        }
        return `Removed ${logisticsFlags.length} logistics directives.`;
    }
    static listPersistentDirectives() {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (dir.memory.persistent) {
                msg +=
                    `Type: ${dir.directiveName}`.padRight(20) +
                    `Name: ${dir.name}`.padRight(15) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeFlagsByColor(color, secondaryColor) {
        const removeFlags = _.filter(
            Game.flags,
            (flag) =>
                flag.color == color && flag.secondaryColor == secondaryColor,
        );
        for (const flag of removeFlags) {
            flag.remove();
        }
        return `Removed ${removeFlags.length} flags.`;
    }
    static removeErrantFlags() {
        let count = 0;
        for (const name in Game.flags) {
            if (!Overmind.directives[name]) {
                Game.flags[name].remove();
                count += 1;
            }
        }
        return `Removed ${count} flags.`;
    }
    static auditOutpostFlags() {
        let msg = 'Report:\n-regular Outposts:\n';
        _.forEach(Game.flags, (flag) => {
            if (
                flag.color == flag.secondaryColor &&
                flag.color == COLOR_PURPLE
            ) {
                _.forEach(Game.flags, (flag2) => {
                    if (
                        flag2.color == flag2.secondaryColor &&
                        flag2.color == COLOR_YELLOW &&
                        flag.pos.roomName == flag2.pos.roomName &&
                        flag.memory.C != flag2.memory.C
                    ) {
                        msg +=
                            `  Room: ${flag.pos.roomName}`.padRight(20) +
                            `Outpost: ${flag.name}`.padRight(15) +
                            `Colony: ${flag.memory.C}`.padRight(15) +
                            `Wrong Flag: ${flag2.name}`.padRight(15) +
                            `Wrong Ref: ${flag2.memory.C}\n`;
                    }
                });
            }
        });
        msg += '-SK Outposts:\n';
        _.forEach(Game.flags, (flag) => {
            if (
                flag.color == COLOR_PURPLE &&
                flag.secondaryColor == COLOR_YELLOW
            ) {
                _.forEach(Game.flags, (flag2) => {
                    if (
                        flag2.color == COLOR_YELLOW &&
                        (flag2.secondaryColor == COLOR_CYAN ||
                            flag2.secondaryColor == COLOR_YELLOW) &&
                        flag.pos.roomName == flag2.pos.roomName &&
                        flag.memory.C != flag2.memory.C
                    ) {
                        msg +=
                            `  Room: ${flag.pos.roomName}`.padRight(15) +
                            `Outpost: ${flag.name}`.padRight(20) +
                            `Colony: ${flag.memory.C}`.padRight(15) +
                            `Wrong Flag: ${flag2.name}`.padRight(20) +
                            `Wrong Ref: ${flag2.memory.C}\n`;
                    }
                });
            }
        });
        return msg;
    }
    static toggleTerminalNetworkSummarize() {
        TerminalNetworkV2.toggleSummarize = !TerminalNetworkV2.toggleSummarize;
    }
    static auditResources() {
        let msg = 'Report:\n';
        let count = 0;
        for (const resourceType of RESOURCE_IMPORTANCE) {
            if (
                !(
                    resourceType.length == 1 ||
                    resourceType.length == 5 ||
                    resourceType == RESOURCE_ENERGY
                )
            ) {
                continue;
            }
            count = 0;
            _.forEach(Game.rooms, (room) => {
                if (room.my && room.terminal && room.storage) {
                    count += room.storage.store[resourceType] || 0;
                    count += room.terminal.store[resourceType] || 0;
                    if (room.factory) {
                        count += room.factory.store[resourceType] || 0;
                    }
                }
            });
            if (count > 0) {
                msg += `${resourceType}`.padRight(15) + `: ${count}\n`;
            }
        }
        for (const resourceType of COMMODITIES_ALL) {
            count = 0;
            _.forEach(Game.rooms, (room) => {
                if (room.my && room.terminal && room.storage) {
                    count += room.storage.store[resourceType] || 0;
                    count += room.terminal.store[resourceType] || 0;
                    if (room.factory) {
                        count += room.factory.store[resourceType] || 0;
                    }
                }
            });
            if (count > 0) {
                msg += `${resourceType}`.padRight(15) + `: ${count}\n`;
            }
        }
        count = 0;
        _.forEach(Game.rooms, (room) => {
            if (room.my && room.terminal && room.storage) {
                count += room.storage.store[RESOURCE_OPS] || 0;
                count += room.terminal.store[RESOURCE_OPS] || 0;
                if (room.factory) {
                    count += room.factory.store[RESOURCE_OPS] || 0;
                }
            }
        });
        if (count > 0) {
            msg += `${RESOURCE_OPS}`.padRight(15) + `: ${count}\n`;
        }
        return msg;
    }
    // Structure management ============================================================================================
    static destroyErrantStructures(roomName) {
        const colony = Overmind.colonies[roomName];
        if (!colony) return `${roomName} is not a valid colony!`;
        const room = colony.room;
        const allStructures = room.find(FIND_STRUCTURES);
        let i = 0;
        for (const s of allStructures) {
            if (s.structureType == STRUCTURE_CONTROLLER) continue;
            if (
                !colony.roomPlanner.structureShouldBeHere(
                    s.structureType,
                    s.pos,
                )
            ) {
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
        }
        return `Destroyed ${i} misplaced structures in ${roomName}.`;
    }
    static destroyAllHostileStructures(roomName) {
        const room = Game.rooms[roomName];
        if (!room) return `${roomName} is undefined! (No vision?)`;
        if (!room.my) return `${roomName} is not owned by you!`;
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        for (const structure of hostileStructures) {
            structure.destroy();
        }
        return `Destroyed ${hostileStructures.length} hostile structures.`;
    }
    static destroyAllBarriers(roomName) {
        const room = Game.rooms[roomName];
        if (!room) return `${roomName} is undefined! (No vision?)`;
        if (!room.my) return `${roomName} is not owned by you!`;
        for (const barrier of room.barriers) {
            barrier.destroy();
        }
        return `Destroyed ${room.barriers.length} barriers.`;
    }
    static removeUnbuiltConstructionSites() {
        let msg = '';
        for (const id in Game.constructionSites) {
            const csite = Game.constructionSites[id];
            if (csite.progress == 0) {
                const ret = csite.remove();
                msg +=
                    `Removing construction site for ${csite.structureType} with 0% progress at ` +
                    `${csite.pos.print}; response: ${ret}\n`;
            }
        }
        return msg;
    }
    // Colony Management =================================================================================================
    static setRoomUpgradeRate(roomName, rate) {
        const colony = Overmind.colonies[roomName];
        colony.upgradeSite.memory.speedFactor = rate;
        return `Colony ${roomName} is now upgrading at a rate of ${rate}.`;
    }
    static getEmpireMineralDistribution() {
        const minerals = EmpireAnalysis.empireMineralDistribution();
        let ret = 'Empire Mineral Distribution \n';
        for (const mineral in minerals) {
            ret += `${mineral}: ${minerals[mineral]} \n`;
        }
        return ret;
    }
    static listPortals(rangeFromColonies = 5, includeIntershard = false) {
        const colonies = getAllColonies();
        const allPortals = colonies.map((colony) =>
            RoomIntel.findPortalsInRange(colony.name, rangeFromColonies),
        );
        let ret = `Empire Portal Census \n`;
        for (const colonyId in allPortals) {
            const portals = allPortals[colonyId];
            if (_.keys(portals).length > 0) {
                ret += `Colony ${colonies[colonyId].print}: \n`;
            }
            for (const portalRoomName of _.keys(portals)) {
                const samplePortal = _.first(portals[portalRoomName]); // don't need to list all 8 in a room
                ret +=
                    `\t\t Room ${printRoomName(portalRoomName)} Destination ${
                        samplePortal.dest
                    } ` +
                    `Expiration ${
                        samplePortal['X' /* EXPIRATION */] - Game.time
                    }] \n`;
            }
        }
        return ret;
    }
    static evaluateOutpostEfficiencies() {
        const colonies = getAllColonies();
        const outpostEfficiencies = {};
        let avgEnergyPerCPU = 0;
        colonies.forEach((colony) => {
            if (colony.bunker) {
                colony.outposts.forEach((outpost) => {
                    const res = ExpansionEvaluator.computeTheoreticalMiningEfficiency(
                        colony.bunker.anchor,
                        outpost.name,
                    );
                    if (typeof res === 'boolean') {
                        log.error(`Failed on outpost ${outpost.print}`);
                    } else {
                        outpostEfficiencies[outpost.name] = res;
                        avgEnergyPerCPU += res;
                    }
                });
            }
        });
        avgEnergyPerCPU =
            avgEnergyPerCPU / Object.keys(outpostEfficiencies).length;
        let ret = `Suspect Outposts +25% below avg efficiency of ${avgEnergyPerCPU}: \n`;
        for (const outpost in outpostEfficiencies) {
            if (outpostEfficiencies[outpost] < avgEnergyPerCPU * 0.75) {
                ret += `${outpost} ${outpostEfficiencies[outpost]} \n`;
            }
        }
        return ret;
    }
    static evaluatePotentialOutpostEfficiencies() {
        const colonies = getAllColonies();
        const outpostEfficiencies = {};
        let avgEnergyPerCPU = 0;
        colonies.forEach((colony) => {
            if (colony.bunker) {
                Cartographer.findRoomsInRange(colony.name, 2).forEach(
                    (outpost) => {
                        if (
                            !colony.outposts
                                .map((room) => room.name)
                                .includes(outpost)
                        ) {
                            const res = ExpansionEvaluator.computeTheoreticalMiningEfficiency(
                                colony.bunker.anchor,
                                outpost,
                            );
                            if (typeof res === 'boolean') {
                                log.error(`Failed on outpost ${outpost}`);
                            } else {
                                outpostEfficiencies[outpost] = res;
                                avgEnergyPerCPU += res;
                            }
                        }
                    },
                );
            }
        });
        avgEnergyPerCPU =
            avgEnergyPerCPU / Object.keys(outpostEfficiencies).length;
        let ret = `Possible new outposts above avg efficiency of ${avgEnergyPerCPU}: \n`;
        for (const outpost in outpostEfficiencies) {
            // 20E/cpu is a good guideline for an efficient room
            if (
                outpostEfficiencies[outpost] > avgEnergyPerCPU * 1.25 ||
                outpostEfficiencies[outpost] > 20
            ) {
                ret += `${outpost} ${outpostEfficiencies[outpost]} \n`;
            }
        }
        return ret;
    }
    // Memory management ===============================================================================================
    static deepCleanMemory() {
        // Clean colony memory
        const protectedColonyKeys = [
            'defcon',
            'roomPlanner',
            'roadPlanner',
            'barrierPlanner',
            'expansionData',
        ];
        for (const colName in Memory.colonies) {
            for (const key in Memory.colonies[colName]) {
                if (!protectedColonyKeys.includes(key)) {
                    delete Memory.colonies[colName][key];
                }
            }
        }
        // Suicide any creeps which have no memory
        for (const i in Game.creeps) {
            if (Game.creeps[i].memory == {}) {
                Game.creeps[i].suicide();
            }
        }
        // Remove profiler memory
        delete Memory.screepsProfiler;
        // Remove overlords memory from flags
        for (const i in Memory.flags) {
            if (Memory.flags[i].overlords) {
                delete Memory.flags[i].overlords;
            }
        }
        // Clean creep memory
        for (const i in Memory.creeps) {
            // Remove all creep tasks to fix memory leak in 0.3.1
            if (Memory.creeps[i].task) {
                Memory.creeps[i].task = null;
            }
        }
        return `Memory has been cleaned.`;
    }
    static recursiveMemoryProfile(memoryObject, sizes, currentDepth) {
        for (const key in memoryObject) {
            if (
                currentDepth == 0 ||
                !_.keys(memoryObject[key]) ||
                _.keys(memoryObject[key]).length == 0
            ) {
                sizes[key] = JSON.stringify(memoryObject[key]).length;
            } else {
                sizes[key] = {};
                OvermindConsole.recursiveMemoryProfile(
                    memoryObject[key],
                    sizes[key],
                    currentDepth - 1,
                );
            }
        }
    }
    static profileMemory(root = Memory, depth = 1) {
        const sizes = {};
        console.log(`Profiling memory...`);
        const start = Game.cpu.getUsed();
        OvermindConsole.recursiveMemoryProfile(root, sizes, depth);
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        return JSON.stringify(sizes, undefined, '\t');
    }
    static cancelMarketOrders(filter) {
        const ordersToCancel = !!filter
            ? _.filter(Game.market.orders, (order) => filter(order))
            : Game.market.orders;
        _.forEach(_.values(ordersToCancel), (order) =>
            Game.market.cancelOrder(order.id),
        );
        return `Canceled ${_.values(ordersToCancel).length} orders.`;
    }
    static visuals(enable = true) {
        Memory.settings.enableVisuals = enable;
        return `Visuals ${enable ? 'enabled' : 'disabled'}.`;
    }
    static showIntelVisuals(ticks = 100) {
        Memory.settings.intelVisualsUntil = Game.time + ticks;
        return `Intel visuals enabled for the next ${ticks} ticks (until ${Memory.settings.intelVisualsUntil}).`;
    }
}

/**
 * Spawns reservers to reserve an outpost room
 */
let ReservingOverlord = class ReservingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.reserve) {
        super(directive, 'reserve', priority);
        // Change priority to operate per-outpost
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.reserveBuffer = 2000;
        this.reservers = this.zerg(Roles.claim);
    }
    init() {
        if (this.colony.room.playerHostiles.length > 0) {
            // do not spawn if colony under attack
            return;
        }
        if (this.room && this.room.invaderCore) {
            // wait for it to be destroyed
            return;
        }
        let amount = 0;
        if (this.room) {
            if (this.room.controller.needsReserving(this.reserveBuffer)) {
                amount = 1;
            } else if (
                this.room.controller.reservation &&
                !this.room.controller.reservedByMe
            ) {
                amount = Math.min(
                    this.room.controller.pos.availableNeighbors(true).length,
                    2,
                );
            }
        } else if (
            RoomIntel.roomReservedBy(this.pos.roomName) == MY_USERNAME &&
            RoomIntel.roomReservationRemaining(this.pos.roomName) < 1000
        ) {
            amount = 1;
        }
        this.wishlist(amount, Setups.infestors.reserve);
    }
    handleReserver(reserver) {
        if (reserver.avoidDanger()) return;
        if (reserver.room == this.room && !reserver.pos.isEdge) {
            // If reserver is in the room and not on exit tile
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    reserver.task = Tasks.reserve(this.room.controller);
                } else {
                    reserver.task = Tasks.signController(this.room.controller);
                }
            } else {
                reserver.task = Tasks.reserve(this.room.controller);
            }
        } else {
            // reserver.task = Tasks.goTo(this.pos);
            reserver.goTo(this.pos);
        }
    }
    run() {
        this.autoRun(this.reservers, (reserver) =>
            this.handleReserver(reserver),
        );
    }
};
ReservingOverlord = __decorate([profile], ReservingOverlord);

/**
 * Sends out a stationary scout, which travels to a waypoint and remains there indefinitely
 */
let StationaryScoutOverlord = class StationaryScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.stationary) {
        super(directive, 'stationaryScout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    refresh() {
        super.refresh();
    }
    init() {
        this.wishlist(1, Setups.scout);
    }
    handleScout(scout) {
        if (!this.safeInRoom && !scout.safelyInRoom(this.pos.roomName)) {
            scout.task = Tasks.goToRoom(this.pos.roomName);
            return;
        }
        this.safeInRoom = true;
        // if target is cashed and valid, then stomp it.
        if (this.squashTarget && Game.getObjectById(this.squashTarget.id)) {
            scout.goTo(this.squashTarget);
            return;
        }
        if (Game.time % 10 > 0) {
            // no rush, pick one every 10 ticks
            return;
        }
        const enemyConstructionSites = scout.room.hostileConstructionSites.filter(
            (csite) =>
                !!Game.getObjectById(csite.id) && // ignore stale cashed data
                csite.progress > 0 &&
                csite.pos.isWalkable(true),
        );
        this.squashTarget = _.first(enemyConstructionSites);
    }
    run() {
        this.autoRun(this.scouts, (scout) => this.handleScout(scout));
    }
};
StationaryScoutOverlord = __decorate([profile], StationaryScoutOverlord);

var DirectiveOutpost_1;
/**
 * Registers an unowned mining outpost for a nearby colony
 */
let DirectiveOutpost = (DirectiveOutpost_1 = class DirectiveOutpost extends (
    Directive
) {
    spawnMoarOverlords() {
        if (
            this.colony.level >=
            DirectiveOutpost_1.settings.canSpawnReserversAtRCL
        ) {
            if (
                Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CONTROLLER
            ) {
                this.overlords.reserve = new ReservingOverlord(this);
            }
        } else {
            this.overlords.scout = new StationaryScoutOverlord(this);
        }
    }
    init() {}
    run() {
        if (RoomIntel.roomOwnedBy(this.pos.roomName)) {
            log.warning(`Removing ${this.print} since room is owned!`);
            this.remove();
        }
        if (
            RoomIntel.roomReservedBy(this.pos.roomName) !== MY_USERNAME &&
            RoomIntel.roomReservationRemaining(this.pos.roomName) > 100 &&
            RoomIntel.roomReservedBy(this.pos.roomName) != 'Invader'
        ) {
            log.warning(`Removing ${this.print} since room is reserved!`);
            // this.remove(); // zGeneral 1/2024
        }
        if (
            Game.time % 10 == 3 &&
            this.room &&
            this.room.controller &&
            !this.pos.isEqualTo(this.room.controller.pos) &&
            !this.memory.setPos
        ) {
            this.setPosition(this.room.controller.pos);
        }
    }
});
DirectiveOutpost.directiveName = 'outpost';
DirectiveOutpost.color = COLOR_PURPLE;
DirectiveOutpost.secondaryColor = COLOR_PURPLE;
DirectiveOutpost.settings = {
    canSpawnReserversAtRCL: 3,
};
DirectiveOutpost = DirectiveOutpost_1 = __decorate([profile], DirectiveOutpost);

/**
 * GameCache does initial low-level preprocessing before each tick is run
 */
let GameCache = class GameCache {
    constructor() {
        this.overlords = {};
        this.creepsByColony = {};
        this.targets = {};
        this.outpostFlags = _.filter(
            Game.flags,
            (flag) =>
                DirectiveOutpost.filter(flag) ||
                DirectiveSKOutpost.filter(flag),
        );
    }
    cacheCreepsByColony() {
        this.creepsByColony = Object.values(Game.creeps).reduce((acc, creep) => {
            const colonyRef = creep.memory['C']; // COLONY reference
            if (!acc[colonyRef]) {
                acc[colonyRef] = [];
            }
            acc[colonyRef].push(creep);
            return acc;
        }, {});
    }

    /**
     * Generates a hash table for creeps assigned to each object: key: OLref, val: (key: role, val: names[])
     */
    cacheOverlords() {
        this.overlords = {};
    
        // Directly iterate over creeps and power creeps to minimize overhead
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            const { O: overlordRef, role } = creep.memory;
            if (overlordRef) {
                if (!this.overlords[overlordRef]) {
                    this.overlords[overlordRef] = {};
                }
                if (!this.overlords[overlordRef][role]) {
                    this.overlords[overlordRef][role] = [];
                }
                this.overlords[overlordRef][role].push(name);
            }
        }
    
        for (const name in Game.powerCreeps) {
            const powerCreep = Game.powerCreeps[name];
            const { O: overlordRef, role } = powerCreep.memory;
            if (overlordRef) {
                if (!this.overlords[overlordRef]) {
                    this.overlords[overlordRef] = {};
                }
                if (!this.overlords[overlordRef][role]) {
                    this.overlords[overlordRef][role] = [];
                }
                this.overlords[overlordRef][role].push(name);
            }
        }
    }


    
    
    /**
     * Generates a hash table for targets: key: TargetRef, val: targeting creep names
     */
    cacheTargets() {
        this.targets = {};
        for (const i in Game.creeps) {
            const creep = Game.creeps[i];
            let task = creep.memory.task;
            while (task) {
                if (!this.targets[task._target.ref]) {
                    this.targets[task._target.ref] = [];
                }
                this.targets[task._target.ref].push(creep.name);
                task = task._parent;
            }
        }
    }
    cacheAll() {
        // Reset caches
        this.creepsByColony = {};
        this.overlords = {};
        this.targets = {};
    
        // Unified iteration for Game.creeps
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            // Update creepsByColony
            const colonyRef = creep.memory['C']; // COLONY reference
            if (!this.creepsByColony[colonyRef]) {
                this.creepsByColony[colonyRef] = [];
            }
            this.creepsByColony[colonyRef].push(creep);
    
            // Update overlords
            const { O: overlordRef, role } = creep.memory;
            if (overlordRef) {
                if (!this.overlords[overlordRef]) {
                    this.overlords[overlordRef] = {};
                }
                if (!this.overlords[overlordRef][role]) {
                    this.overlords[overlordRef][role] = [];
                }
                this.overlords[overlordRef][role].push(name);
            }
    
            // Update targets
            let task = creep.memory.task;
            while (task) {
                if (!this.targets[task._target.ref]) {
                    this.targets[task._target.ref] = [];
                }
                this.targets[task._target.ref].push(name);
                task = task._parent;
            }
        }
    
        // Similar unified iteration for Game.powerCreeps (if needed)
        // Note: Adjust based on whether powerCreeps need to be included in creepsByColony and targets caches
        for (const name in Game.powerCreeps) {
            const powerCreep = Game.powerCreeps[name];
            // Update overlords for powerCreeps
            const { O: overlordRef, role } = powerCreep.memory;
            if (overlordRef) {
                if (!this.overlords[overlordRef]) {
                    this.overlords[overlordRef] = {};
                }
                if (!this.overlords[overlordRef][role]) {
                    this.overlords[overlordRef][role] = [];
                }
                this.overlords[overlordRef][role].push(name);
            }
            // Assume powerCreeps don't have targets or colony assignments similar to creeps for this example
        }
    }

    build() {
        //this.cacheCreepsByColony();
        //this.cacheOverlords();
        //this.cacheTargets();
        this.cacheAll();
    }
    refresh() {
        /*
        cpuProfiler.start('cacheCreepsByColony');
        this.cacheCreepsByColony();
        cpuProfiler.end('cacheCreepsByColony');
        
        cpuProfiler.start('cacheOverlords');
        this.cacheOverlords();
        cpuProfiler.end('cacheOverlords');
        
        cpuProfiler.start('cacheTargets');
        this.cacheTargets();
        cpuProfiler.end('cacheTargets');
        */
        this.cacheAll();
    }
};
GameCache = __decorate([profile], GameCache);

/**
 * Claim an unowned room
 */
let ClaimingOverlord = class ClaimingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.claim) {
        super(directive, 'claim', priority);
        this.directive = directive;
        this.claimers = this.zerg(Roles.claim);
    }
    init() {
        const amount = $.number(this, 'claimerAmount', () => {
            if (this.room) {
                // if you have vision
                if (
                    this.room.my ||
                    getAllColonies().length >=
                        Math.min(Game.gcl.level, MAX_OWNED_ROOMS)
                ) {
                    // already claimed
                    return 0;
                } else {
                    // don't ask for claimers if you can't reach controller
                    const pathablePos = this.room.creeps[0]
                        ? this.room.creeps[0].pos
                        : Pathing.findPathablePosition(this.room.name);
                    if (
                        !Pathing.isReachable(
                            pathablePos,
                            this.room.controller.pos,
                            _.filter(
                                this.room.structures,
                                (s) => !s.isWalkable,
                            ),
                        )
                    ) {
                        return 0;
                    }
                }
            }
            return 1; // otherwise ask for 1 claimer
        });
        this.wishlist(
            amount,
            this.colony.level > 4
                ? Setups.infestors.fastClaim
                : Setups.infestors.claim,
        );
    }
    handleClaimer(claimer) {
        if (claimer.room == this.room && !claimer.pos.isEdge) {
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    claimer.task = Tasks.claim(this.room.controller);
                } else {
                    claimer.task = Tasks.signController(this.room.controller);
                }
            } else {
                claimer.task = Tasks.claim(this.room.controller);
                claimer.claimController(this.room.controller);
            }
        } else {
            claimer.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
        }
    }
    run() {
        this.autoRun(this.claimers, (claimer) => this.handleClaimer(claimer));
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.my &&
            this.room.controller.signedByMe
        ) {
            for (const claimer of this.claimers) {
                claimer.suicide();
            }
        }
    }
};
ClaimingOverlord = __decorate([profile], ClaimingOverlord);

/**
 * Prioritized list of what order resource should be hauled
 */
const HaulPriorities = [
    RESOURCE_BATTERY,
    RESOURCE_REDUCTANT,
    RESOURCE_LEMERGIUM_BAR,

    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_OPS,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_GHODIUM,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_POWER,
    RESOURCE_ENERGY,
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_BATTERY,
    // Higher commodities
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    // Basic regional commodities
    RESOURCE_WIRE,
    RESOURCE_CELL,
    RESOURCE_ALLOY,
    RESOURCE_CONDENSATE,
    // Mechanical chain
    RESOURCE_TUBE,
    RESOURCE_FIXTURES,
    RESOURCE_FRAME,
    RESOURCE_HYDRAULICS,
    RESOURCE_MACHINE,
    // Biological chain
    RESOURCE_PHLEGM,
    RESOURCE_TISSUE,
    RESOURCE_MUSCLE,
    RESOURCE_ORGANOID,
    RESOURCE_ORGANISM,
    // Electronic chain
    RESOURCE_SWITCH,
    RESOURCE_TRANSISTOR,
    RESOURCE_MICROCHIP,
    RESOURCE_CIRCUIT,
    RESOURCE_DEVICE,
    // Mystical chain
    RESOURCE_CONCENTRATE,
    RESOURCE_EXTRACT,
    RESOURCE_SPIRIT,
    RESOURCE_EMANATION,
    RESOURCE_ESSENCE,
    RESOURCE_SILICON,
    RESOURCE_BIOMASS,
    RESOURCE_METAL,
    RESOURCE_MIST,
];

/**
 * Spawns special-purpose haulers for transporting resources to/from a specified target
 */
let HaulingOverlord = class HaulingOverlord extends Overlord {
    constructor(
        directive,
        priority = directive.hasDrops
            ? OverlordPriority.collectionUrgent.haul
            : OverlordPriority.tasks.haul,
    ) {
        super(directive, 'haul', priority);
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
    }
    init() {
        if (
            !this.colony.storage ||
            sumStore(this.colony.storage.store) >
                Energetics.settings.storage.total.cap
        ) {
            return;
        }
        // Spawn a number of haulers sufficient to move all resources within a lifetime, up to a max
        const MAX_HAULERS = 5;
        // Calculate total needed amount of hauling power as (resource amount * trip distance)
        const tripDistance =
            2 *
            (Pathing.distance(
                (this.colony.storage || this.colony).pos,
                this.directive.pos,
            ) || 0);
        const haulingPowerNeeded =
            Math.min(
                this.directive.totalResources,
                this.colony.storage.storeCapacity -
                    sumStore(this.colony.storage.store),
            ) * tripDistance;
        // Calculate amount of hauling each hauler provides in a lifetime
        const haulerCarryParts = Setups.transporters.early.getBodyPotential(
            CARRY,
            this.colony,
        );
        const haulingPowerPerLifetime =
            CREEP_LIFE_TIME * haulerCarryParts * CARRY_CAPACITY;
        // Calculate number of haulers
        const numHaulers = Math.min(
            Math.ceil(haulingPowerNeeded / haulingPowerPerLifetime),
            MAX_HAULERS,
        );
        // Request the haulers
        this.wishlist(numHaulers, Setups.transporters.early);
    }
    handleHauler(hauler) {
        if (sumStore(hauler.carry) == 0) {
            // Travel to directive and collect resources
            if (hauler.inSameRoomAs(this.directive)) {
                // Pick up drops first
                /*
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop =
                        _.find(
                            allDrops,
                            (drop) => drop.resourceType != 'energy',
                        ) || allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                }
                */ // zGeneral 2/2024
                // Withdraw from store structure
                if (this.directive.storeStructure) {
                    const store = this.directive.store;
                    let totalDrawn = 0; // Fill to full
                    for (const resourceType of HaulPriorities) {
                        if (store[resourceType] && store[resourceType] > 0) {
                            if (!!hauler.task) {
                                hauler.task = Tasks.withdraw(
                                    this.directive.storeStructure,
                                    resourceType,
                                ).fork(hauler.task);
                            } else {
                                hauler.task = Tasks.withdraw(
                                    this.directive.storeStructure,
                                    resourceType,
                                );
                            }
                            totalDrawn += store[resourceType];
                            if (totalDrawn >= hauler.carryCapacity) {
                                return;
                            }
                        }
                    }
                    if (hauler.task) {
                        // If can't fill up, just go ahead and go home
                        log.notify(
                            `Can't finish filling up ${totalDrawn} ${JSON.stringify(
                                hauler.task,
                            )} ${this.room}`,
                        );
                        return;
                    }
                }
                // Shouldn't reach here
                log.warning(
                    `${hauler.name} in ${hauler.room.print}: nothing to collect!`,
                );
            } else {
                // hauler.task = Tasks.goTo(this.directive);
                hauler.goTo(this.directive, { pathOpts: { avoidSK: true } });
            }
        } else {
            // Travel to colony room and deposit resources
            if (hauler.inSameRoomAs(this.colony)) {
                // Put energy in storage and minerals in terminal if there is one
                for (const [resourceType, amount] of hauler.carry.contents) {
                    if (amount == 0) continue;
                    if (resourceType == RESOURCE_ENERGY) {
                        // prefer to put energy in storage
                        if (
                            this.colony.storage &&
                            sumStore(this.colony.storage.store) <
                                STORAGE_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.storage,
                                resourceType,
                            );
                            return;
                        } else if (
                            this.colony.terminal &&
                            sumStore(this.colony.terminal.store) <
                                TERMINAL_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.terminal,
                                resourceType,
                            );
                            return;
                        }
                    } else {
                        // prefer to put minerals in terminal
                        if (
                            this.colony.terminal &&
                            this.colony.terminal.my &&
                            sumStore(this.colony.terminal.store) <
                                TERMINAL_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.terminal,
                                resourceType,
                            );
                            return;
                        } else if (
                            this.colony.storage &&
                            sumStore(this.colony.storage.store) <
                                STORAGE_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.storage,
                                resourceType,
                            );
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(
                    `${hauler.name} in ${hauler.room.print}: nowhere to put resources!`,
                );
            } else {
                hauler.task = Tasks.goToRoom(this.colony.room.name);
            }
        }
    }
    run() {
        for (const hauler of this.haulers) {
            if (hauler.isIdle) {
                this.handleHauler(hauler);
            }
            hauler.run();
        }
        // TODO: fix the way this is done
        if (
            this.directive.memory.totalResources == 0 &&
            this.haulers.filter((hauler) => sumStore(hauler.carry) > 0)
                .length == 0
        ) {
            this.directive.remove();
        }
    }
};
HaulingOverlord = __decorate([profile], HaulingOverlord);

/**
 * Hauling directive: spawns hauler creeps to move large amounts of resources from a location (e.g. draining a storage)
 */
let DirectiveHaul = class DirectiveHaul extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.haul = new HaulingOverlord(this);
    }
    get targetedBy() {
        return Overmind.cache.targets[this.ref];
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops) {
            const drops = this.pos.lookFor(LOOK_RESOURCES) || [];
            this._drops = _.groupBy(drops, (drop) => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get storeStructure() {
        // TODO remove me console.log(`Looking for store struct in ${this.pos.roomName}
        // with ${this.pos.lookForStructure(STRUCTURE_CONTAINER)}`);
        if (this.pos.isVisible) {
            return (
                this.pos.lookForStructure(STRUCTURE_STORAGE) ||
                this.pos.lookForStructure(STRUCTURE_TERMINAL) ||
                this.pos.lookForStructure(STRUCTURE_NUKER) ||
                this.pos.lookForStructure(STRUCTURE_CONTAINER) ||
                this.pos
                    .lookFor(LOOK_RUINS)
                    .filter((ruin) => sumStore(ruin.store) > 0)[0]
            );
        }
        return undefined;
    }
    get store() {
        if (!this._store) {
            // Merge the "storage" of drops with the store of structure
            let store = {};
            if (this.storeStructure) {
                store = storeIndex(this.storeStructure.store);
            } else {
                store = { energy: 0 };
            }
            // Merge with drops
            for (const resourceType of _.keys(this.drops)) {
                const totalResourceAmount = _.sum(
                    this.drops[resourceType],
                    (drop) => drop.amount,
                );
                if (store[resourceType]) {
                    store[resourceType] += totalResourceAmount;
                } else {
                    store[resourceType] = totalResourceAmount;
                }
            }
            this._store = store;
        }
        // log.alert(`Haul directive ${this.print} has store of ${JSON.stringify(this._store)}`);
        return this._store;
    }
    /**
     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility
     */
    get totalResources() {
        if (this.pos.isVisible && this.store) {
            this.memory.totalResources = _.sum(this.store); // update total amount remaining
            this.memory._finishAtTime =
                this.memory._finishAtTime || Game.time + 3000;
        } else {
            if (this.memory.totalResources == undefined) {
                return 1000; // pick some non-zero number so that haulers will spawn
            }
        }
        return this.memory.totalResources;
    }
    init() {
        if (this.totalResources > 0) {
            this.alert(`Haul directive active - ${this.totalResources}`);
        } else {
            this.alert(
                `Haul directive active - (${
                    Game.time - this.memory._finishAtTime
                } to go – ${this.memory._finishAtTime})`,
            );
        }
    }
    run() {
        if (this.pos.isVisible) {
            if (_.sum(this.store) == 0) {
                // If everything is picked up, crudely give enough time to bring it back
                this.memory._finishAtTime =
                    this.memory._finishAtTime || Game.time + 300;
            } else {
                this.memory._finishAtTime = Game.time + 1500;
            }
        }
        if (
            Game.time >= this.memory._finishAtTime ||
            (this.totalResources == 0 &&
                this.overlords.haul.haulers.length == 0)
        ) {
            this.remove(true);
            console.log('removing haul directive!');
        }
    }
};
DirectiveHaul.directiveName = 'haul';
DirectiveHaul.color = COLOR_YELLOW;
DirectiveHaul.secondaryColor = COLOR_BLUE;
DirectiveHaul = __decorate([profile], DirectiveHaul);

/**
 * Register a target to be dismantled by workers. This is not a siege directive, and clearing rooms should
 * be done with the DirectiveRoomClear
 */
let DirectiveDismantle = class DirectiveDismantle extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {}
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
        // Add this structure to worker overlord's dismantle list
        const target = this.getTarget();
        if (
            target &&
            !this.colony.overlords.work.dismantleStructures.includes(target)
        ) {
            this.colony.overlords.work.dismantleStructures.push(target);
        }
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'yellow' });
    }
};
DirectiveDismantle.directiveName = 'dismantle';
DirectiveDismantle.color = COLOR_GREY;
DirectiveDismantle.secondaryColor = COLOR_YELLOW;
DirectiveDismantle = __decorate([profile], DirectiveDismantle);

/**
 * Claims a new room, destroys all structures in the room, then unclaims it
 */
let DirectiveClearRoom = class DirectiveClearRoom extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 3);
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(
                `${this.print}: ${printRoomName(
                    this.pos.roomName,
                )} is not a controller room; ` + `removing directive!`,
            );
            this.remove(true);
        }
        if (
            Memory.settings.resourceCollectionMode &&
            Memory.settings.resourceCollectionMode >= 1
        ) {
            this.memory.keepStorageStructures = true;
        }
        this.memory.preexistingFlags = _.filter(
            Game.flags,
            (testingflag) =>
                testingflag.pos.roomName == flag.pos.roomName &&
                testingflag.name != flag.name,
        ).map((testingFlag) => testingFlag.name);
        console.log(
            'Existing flags in clear room are ' +
                JSON.stringify(this.memory.preexistingFlags),
        );
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
    }
    init() {
        this.alert(`Clearing out room`);
    }
    removeAllStructures() {
        const keepStorageStructures =
            this.memory.keepStorageStructures !== undefined
                ? this.memory.keepStorageStructures
                : true;
        const keepRoads =
            this.memory.keepRoads !== undefined ? this.memory.keepRoads : true;
        const keepContainers =
            this.memory.keepContainers !== undefined
                ? this.memory.keepContainers
                : true;
        if (this.room && this.room.hostiles.length == 0) {
            const allStructures = this.room.find(FIND_STRUCTURES);
            let i = 0;
            for (const s of allStructures) {
                if (s.structureType == STRUCTURE_CONTROLLER) {
                    continue;
                }
                if (
                    keepStorageStructures &&
                    (s.structureType == STRUCTURE_STORAGE ||
                        s.structureType == STRUCTURE_TERMINAL) &&
                    !s.isEmpty
                ) {
                    // Create a collection flag
                    DirectiveHaul.createIfNotPresent(s.pos, 'pos');
                    continue;
                }
                if (s.structureType == STRUCTURE_NUKER && s.energy > 50000) {
                    DirectiveHaul.createIfNotPresent(s.pos, 'pos');
                }
                if (keepRoads && s.structureType == STRUCTURE_ROAD) {
                    continue;
                }
                if (keepContainers && s.structureType == STRUCTURE_CONTAINER) {
                    continue;
                }
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
            log.alert(`Destroyed ${i} structures in ${this.room.print}.`);
            this.memory.completedTime = Game.time;
            return true;
        } else {
            return false;
        }
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(
            pioneer.pos,
            pioneer.room.controller.pos,
            _.filter(pioneer.room.structures, (s) => !s.isWalkable),
        );
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            if (structure) {
                return structure;
            } else {
                log.error(
                    `${this.print}: no structure at blocking pos ${blockingPos.print}! (Why?)`,
                );
            }
        }
    }
    cleanupFlags() {
        if (!this.room) {
            return false;
        }
        for (const flag of this.room.flags) {
            if (
                !_.contains(this.memory.preexistingFlags, flag.name) &&
                flag.name != this.flag.name &&
                !DirectiveHaul.filter(flag)
            ) {
                flag.remove();
            }
        }
    }
    run() {
        // Remove if structures are done
        if (this.room && this.room.my) {
            const done = this.removeAllStructures();
            if (done) {
                const result = this.room.controller.unclaim();
                // Clear up flags that weren't there before and aren't haul
                this.cleanupFlags();
                log.notify(
                    `Removing clearRoom directive in ${this.pos.roomName}: operation completed.`,
                );
                if (result == OK) {
                    this.remove();
                    Overmind.shouldBuild = true; // rebuild to account for difference in rooms
                }
            }
            // Clear path if controller is not reachable
        } else if (this.room && this.room.creeps.length > 1) {
            const currentlyDismantlingLocations = DirectiveDismantle.find(
                this.room.flags,
            );
            if (currentlyDismantlingLocations.length == 0) {
                const pathablePos = this.room.creeps[0]
                    ? this.room.creeps[0].pos
                    : Pathing.findPathablePosition(this.room.name);
                const blockingLocation = Pathing.findBlockingPos(
                    pathablePos,
                    this.room.controller.pos,
                    _.filter(this.room.structures, (s) => !s.isWalkable),
                );
                if (
                    blockingLocation &&
                    !Directive.isPresent(blockingLocation)
                ) {
                    log.notify(
                        `Adding dismantle directive for ${this.pos.roomName} to reach controller.`,
                    );
                    DirectiveDismantle.create(blockingLocation);
                }
            }
        }
        // Remove if owned by other player
        if (
            Game.time % 10 == 2 &&
            this.room &&
            !!this.room.owner &&
            this.room.owner != MY_USERNAME
        ) {
            log.notify(
                `Removing clearRoom directive in ${this.pos.roomName}: room already owned by another player.`,
            );
            this.remove();
        }
    }
};
DirectiveClearRoom.directiveName = 'clearRoom';
DirectiveClearRoom.color = COLOR_PURPLE;
DirectiveClearRoom.secondaryColor = COLOR_ORANGE;
DirectiveClearRoom = __decorate([profile], DirectiveClearRoom);

var RoomPoisonerOverlord_1;
/**
 * Spawn roomPoisoner - upgrqde controller to lvl2, wall in controller then sources.
 */
let RoomPoisonerOverlord = (RoomPoisonerOverlord_1 = class RoomPoisonerOverlord extends (
    Overlord
) {
    constructor(
        directive,
        priority = OverlordPriority.outpostOffense.roomPoisoner,
    ) {
        super(directive, 'PoisonRoom', priority);
        this.roomPoisoners = this.zerg(Roles.roomPoisoner);
    }
    init() {
        // Re-compute the list of positions to block
        if (this.room) {
            const thingsToBlock = _.compact([
                this.room.controller,
                ...this.room.sources,
            ]);
            const neighborTiles = _.unique(
                _.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)),
                (pos) => packPos(pos),
            );
            this.blockPositions = _.filter(neighborTiles, (pos) =>
                pos.isWalkable(true),
            );
        } else {
            this.blockPositions = [];
        }
        if (this.room && this.room.dangerousPlayerHostiles.length == 0) {
            this.wishlist(1, Setups.roomPoisoner);
        }
    }
    handleRoomPoisoner(posioner) {
        // Recharge if needed
        if (posioner.carry.energy <= 0) {
            posioner.task = Tasks.recharge();
            return;
        }
        // Go to Target Room
        if (!posioner.inSameRoomAs(this)) {
            posioner.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
            return;
        }
        // If you're in the room
        if (this.room && this.room.controller && this.room.controller.my) {
            // Upgrade controller to level 2
            if (this.room.controller.level < 2) {
                posioner.task = Tasks.upgrade(this.room.controller);
                return;
            }
            // Fortify any walls below threshold (can't used cached room.walls here)
            const wallsUncached = this.room.find(FIND_STRUCTURES, {
                filter: { structureType: STRUCTURE_WALL },
            });
            const fortifyTarget = _.find(
                wallsUncached,
                (wall) => wall.hits < 10,
            ); // zGeneral 6/2022 changed it to 10, rega fucked the logic up
            if (fortifyTarget) {
                posioner.task = Tasks.fortify(fortifyTarget, 10); // zGeneral 6/2022 changed it to 10, rega fucked the logic up
                return;
            }
            // Construct walls
            const wallConstructionSite = _.first(this.room.constructionSites);
            if (wallConstructionSite) {
                posioner.task = Tasks.build(wallConstructionSite);
                return;
            }
            // If nothing to do, then move away from possible construction site locations
            posioner.flee(this.blockPositions, {}, { fleeRange: 4 });
        }
    }
    run() {
        this.autoRun(this.roomPoisoners, (roomPoisoner) =>
            this.handleRoomPoisoner(roomPoisoner),
        );
    }
});
RoomPoisonerOverlord = RoomPoisonerOverlord_1 = __decorate(
    [profile],
    RoomPoisonerOverlord,
);

/**
 * General purpose skirmishing overlord for dealing with player combat in an outpost
 */
let OutpostDefenseOverlord = class OutpostDefenseOverlord extends CombatOverlord {
    constructor(
        directive,
        priority = OverlordPriority.outpostDefense.outpostDefense,
    ) {
        super(directive, 'outpostDefense', priority, 1);
        // this.spawnGroup.settings.flexibleEnergy = true;
        this.zerglings = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.healers = this.combatZerg(Roles.healer);
    }
    handleCombat(zerg) {
        if (this.room && this.room.hostiles.length == 0) {
            zerg.doMedicActions(this.room.name);
        } else {
            zerg.autoSkirmish(this.pos.roomName);
        }
    }
    handleHealer(healer) {
        if (
            CombatIntel.isHealer(healer) &&
            healer.getActiveBodyparts(HEAL) == 0
        ) {
            if (this.colony.towers.length > 0) {
                return healer.goToRoom(this.colony.room.name); // go get healed
            } else {
                return healer.suicide(); // you're useless at this point // TODO: this isn't smart
            }
        } else {
            if (
                this.room &&
                _.any(
                    [...this.zerglings, ...this.hydralisks],
                    (creep) => creep.room == this.room,
                )
            ) {
                this.handleCombat(healer); // go to room if there are any fighters in there
            } else {
                healer.autoSkirmish(healer.room.name);
            }
        }
    }
    // private computeNeededHydraliskAmount(setup: CombatCreepSetup, enemyRangedPotential: number): number {
    // 	const hydraliskPotential = setup.getBodyPotential(RANGED_ATTACK, this.colony);
    // 	// TODO: body potential from spawnGroup energy?
    // 	// let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
    // 	// TODO this was reduced from 1.5 due to draining, but should be re-evaluated when we have infra in place to track
    // 	// If a directive is being too costly
    // 	return Math.ceil(1.1 * enemyRangedPotential / hydraliskPotential);
    // }
    //
    // // TODO: division by 0 error!
    // private computeNeededBroodlingAmount(setup: CombatCreepSetup, enemyAttackPotential: number): number {
    // 	const broodlingPotential = setup.getBodyPotential(ATTACK, this.colony);
    // 	// let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
    // 	return Math.ceil(1.1 * enemyAttackPotential / broodlingPotential);
    // }
    //
    // private computeNeededHealerAmount(setup: CombatCreepSetup, enemyHealPotential: number): number {
    // 	const healerPotential = setup.getBodyPotential(HEAL, this.colony);
    // 	return Math.ceil(1.1 * enemyHealPotential / healerPotential);
    // }
    getEnemyPotentials() {
        if (this.room) {
            return CombatIntel.getCombatPotentials(this.room.hostiles);
        } else {
            return { attack: 0, ranged: 1, heal: 0 };
        }
    }
    init() {
        const enemyPotentials = this.getEnemyPotentials();
        const needAttack = enemyPotentials.attack * 1.1;
        const needRanged = enemyPotentials.ranged * 1.3;
        const needHeal = enemyPotentials.heal * 1.2;
        if (needAttack > 100 || needRanged > 100 || needHeal > 100) {
            return; // fuck it let's not fight this
        }
        // Only try to obtain one additional creep at a time
        if (this.reassignIdleCreeps(Roles.melee, 1)) return;
        if (this.reassignIdleCreeps(Roles.ranged, 1)) return;
        if (this.reassignIdleCreeps(Roles.healer, 1)) return;
        const noBigColoniesNearby = _.all(
            this.spawnGroup.colonies,
            (col) => col.room.energyCapacityAvailable < 800,
        );
        const myPotentials = CombatIntel.getMyCombatPotentials([
            ...this.zerglings,
            ...this.hydralisks,
            ...this.healers,
        ]);
        // if (attack > 30 || rangedAttack > 30) {
        // 	// Handle boost worthy attackers
        // 	this.wishlist(1, CombatSetups.hydralisks.boosted_T3);
        // }
        const hydraliskSetup = noBigColoniesNearby
            ? CombatSetups.hydralisks.noHeal
            : CombatSetups.hydralisks.default;
        const zerglingSetup = noBigColoniesNearby
            ? CombatSetups.zerglings.default
            : CombatSetups.zerglings.healing;
        const healerSetup = CombatSetups.transfusers.default;
        if (myPotentials.ranged < needRanged) {
            this.requestCreep(hydraliskSetup);
        } else if (myPotentials.heal < needHeal) {
            this.requestCreep(healerSetup);
        } else if (myPotentials.attack < needAttack) {
            this.requestCreep(zerglingSetup);
        }
    }
    run() {
        this.autoRun(this.zerglings, (zergling) => this.handleCombat(zergling));
        this.autoRun(this.hydralisks, (hydralisk) =>
            this.handleCombat(hydralisk),
        );
        this.autoRun(this.healers, (healer) => this.handleHealer(healer));
    }
};
OutpostDefenseOverlord = __decorate([profile], OutpostDefenseOverlord);

/**
 * Defend an outpost against an incoming player invasion
 */
let DirectiveOutpostDefense = class DirectiveOutpostDefense extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        // if (this.room && _.contains(this.room.dangerousHostiles, hostile => hostile.owner.username == 'inakrin')) {
        // 	this.overlords.outpostDefense = new OutpostDefenseOverlord(this);
        // }
        this.overlords.outpostDefense = new OutpostDefenseOverlord(this);
    }
    init() {
        const numHostiles = this.room
            ? this.room.hostiles.length.toString()
            : '???';
        this.alert(
            `Outpost defense (hostiles: ${numHostiles})`,
            NotifierPriority.High,
        );
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 100
        ) {
            if (
                _.filter(
                    this.room.creeps,
                    (creep) => creep.hits < creep.hitsMax,
                ).length == 0
            ) {
                this.remove();
            }
        }
    }
};
DirectiveOutpostDefense.directiveName = 'outpostDefense';
DirectiveOutpostDefense.color = COLOR_BLUE;
DirectiveOutpostDefense.secondaryColor = COLOR_RED;
DirectiveOutpostDefense = __decorate([profile], DirectiveOutpostDefense);

const getDefaultControllerAttackerOverlordMemory = () => ({
    boosted: false,
});
let ControllerAttackerOverlord = class ControllerAttackerOverlord extends Overlord {
    constructor(
        directive,
        priority = OverlordPriority.offense.controllerAttack,
    ) {
        super(directive, 'controllerAttack', priority),
            getDefaultControllerAttackerOverlordMemory;
        this.directive = directive;
        this.controllerAttackers = this.zerg(Roles.claim);
        this.spawnGroup = new SpawnGroup(this, {
            requiredRCL: 4,
            maxPathDistance: 10 * 50,
        });
        this.refresh();
    }
    refresh() {
        super.refresh();
        if (this.room && this.room.controller) {
            this.attackPositions = this.room.controller.pos.availableNeighbors(
                true,
            );
            this.readyTick =
                Game.time +
                (this.room.controller.upgradeBlocked || 0) -
                this.directive.distanceFromColony.terrainWeighted -
                200;
            if (
                this.attackPositions.length > 0 &&
                this.room.controller.level > 5 &&
                this.room.spawns.length > 0 &&
                this.room.towers.length > 0
            ) {
                this.memory.boosted = true;
            } else {
                this.memory.boosted = false;
            }
        } else {
            this.attackPositions = [];
            this.readyTick = Game.time;
        }
        this.assignments = this.getPositionAssignments();
    }
    getPositionAssignments() {
        const assignments = {};
        const maxLoops = Math.min(
            this.attackPositions.length,
            this.controllerAttackers.length,
        );
        const controllerAttackers = _.sortBy(
            this.controllerAttackers,
            (zerg) => zerg.name,
        );
        for (let i = 0; i < maxLoops; i++) {
            assignments[controllerAttackers[i].name] = this.attackPositions[i];
        }
        return assignments;
    }
    init() {
        // TODO: Prespawn attackers to arrive as cooldown disappears
        if (this.attackPositions.length > 0 && Game.time >= this.readyTick) {
            if (this.memory.boosted == false) {
                this.wishlist(
                    this.attackPositions.length,
                    Setups.infestors.controllerAttacker,
                    { noLifetimeFilter: true },
                );
            } else {
                const boostedControllerAttackerSetup =
                    CombatSetups.infestors.boosted.default;
                this.wishlist(1, boostedControllerAttackerSetup, {
                    noLifetimeFilter: true,
                });
            }
        }
        // TODO: Add one more creep to guard and camp at the controller
        // TODO: this should be a seperate overlord. called by the same directive
    }
    run() {
        for (const controllerAttacker of this.controllerAttackers) {
            if (controllerAttacker.hasValidTask) {
                controllerAttacker.run();
                continue;
            } else {
                if (controllerAttacker.needsBoosts) {
                    this.handleBoosting(controllerAttacker);
                    continue;
                }
            }
            // can not attack controller and heal at the same time, heal takes pri, so only apply it when needed
            // TODO: give pri to attack controller when it is time, regardless of damage
            if (
                controllerAttacker.getActiveBodyparts(HEAL) > 0 &&
                controllerAttacker.hits < controllerAttacker.hitsMax
            ) {
                controllerAttacker.heal(controllerAttacker);
            }
            const attackPos = this.assignments[controllerAttacker.name];
            if (attackPos) {
                controllerAttacker.goTo(attackPos);
            } else {
                log.debug(
                    `No attack position for ${controllerAttacker.print}!`,
                );
            }
        }
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.reservation &&
            !this.room.controller.reservedByMe
        ) {
            this.launchAttack();
        } else if (
            this.room &&
            this.room.controller &&
            !this.room.controller.upgradeBlocked
        ) {
            if (
                _.all(
                    this.controllerAttackers,
                    (creep) =>
                        !!this.assignments[creep.name] &&
                        creep.pos.isEqualTo(this.assignments[creep.name]),
                ) ||
                _.any(
                    this.controllerAttackers,
                    (creep) =>
                        creep.pos.isNearTo(this.room.controller) &&
                        (creep.ticksToLive || 10) <= 2,
                )
            ) {
                this.launchAttack();
            }
        }
    }
    launchAttack() {
        let signed = false;
        if (this.room && this.room.controller) {
            for (const infestor of this.controllerAttackers) {
                infestor.attackController(this.room.controller);
                if (!signed) {
                    signed =
                        infestor.signController(
                            this.room.controller,
                            'For the swarm',
                        ) == OK;
                }
            }
        }
    }
};
ControllerAttackerOverlord = __decorate([profile], ControllerAttackerOverlord);

/**
 * Attack a controller, downgrading it to level 0
 */
let DirectiveControllerAttack = class DirectiveControllerAttack extends Directive {
    constructor(flag) {
        var _a;
        super(flag);
        // request observation on creation - and on every reset if not visible already
        if (
            !this.room &&
            RoomIntel.getSafetyData(this.pos.roomName).lastSeen < Game.time
        ) {
            (_a = this.colony.commandCenter) === null || _a === void 0
                ? void 0
                : _a.requestRoomObservation(this.pos.roomName);
        }
    }
    spawnMoarOverlords() {
        if (!RoomIntel.inSafeMode(this.pos.roomName)) {
            // zGeneral 30/1/2022
            this.overlords.scout = new StationaryScoutOverlord(this); // TODO: Not have a scout at all times
            this.overlords.controllerAttack = new ControllerAttackerOverlord(
                this,
            );
        }
    }
    init() {
        const level =
            this.room && this.room.controller
                ? this.room.controller.level.toString()
                : '???';
        this.alert(`Downgrading controller (RCL${level})`);
    }
    run() {
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.level == 0 &&
            (!this.room.controller.reservation ||
                this.room.controller.reservation.ticksToEnd < 5)
        ) {
            log.notify(
                `Removing ${this.name} since controller has reached level 0.`,
            );
            this.remove();
        }
    }
};
DirectiveControllerAttack.directiveName = 'controllerAttack';
DirectiveControllerAttack.color = COLOR_RED;
DirectiveControllerAttack.secondaryColor = COLOR_PURPLE;
DirectiveControllerAttack = __decorate([profile], DirectiveControllerAttack);

var DirectivePoisonRoom_1;
/**
 * Poison sources in remote rooms by claiming controller, walling in its sources and controller then unclaiming it.
 */
let DirectivePoisonRoom = (DirectivePoisonRoom_1 = class DirectivePoisonRoom extends (
    Directive
) {
    constructor(flag) {
        super(
            flag,
            (colony) => colony.level >= DirectivePoisonRoom_1.requiredRCL,
        );
        // Remove if misplaced
        let remove = false;
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.error(
                `${this.print}: not placed is not a controller room; removing directive!`,
            );
            remove = true;
        }
        // failsafe - if already owned and controller level > 2, remove flag
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.my &&
            this.room.controller.level > 2
        ) {
            log.error(
                `Removing ${this.print}: room owned by self and above RCL 2!`,
            );
            remove = true;
        }
        // Remove if owned by other player
        if (this.room && this.room.owner && this.room.owner != MY_USERNAME) {
            log.error(
                `Removing poisonRoom directive in ${this.pos.roomName}: room already owned by another player.`,
            );
            remove = true;
        }
        if (remove) {
            this.remove(true);
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.roomPoisoner = new RoomPoisonerOverlord(this);
    }
    /**
     * Returns whether the room has already been poisoned
     */
    static roomAlreadyPoisoned(room) {
        const thingsToBlock = _.compact([room.controller, ...room.sources]);
        const neighborTiles = _.unique(
            _.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)),
            (pos) => packPos(pos),
        );
        const blockPositions = _.filter(neighborTiles, (pos) =>
            pos.isWalkable(true),
        );
        return blockPositions.length == 0;
    }
    /**
     * Returns whether you can poison a specific room; assumes that poisoning is enabled and that you can claim another
     * room and can poison another room (these checks should be done once on Overseer)
     */
    static canAutoPoison(room, allowReserved = true) {
        // zGeneral 2/6/2022
        if (room.isColony || room.isOutpost) {
            return false;
        }
        if (!room.controller) {
            return false;
        }
        if (
            allowReserved &&
            room.controller.reservation &&
            (isAlly(room.controller.reservation.username) ||
                room.controller.reservation.username == 'Invader')
        ) {
            // zGeneral 2/6/2022 if allowed to check for reserved, then do not poison ally room (including self)
            return false;
        }
        if (!allowReserved && room.controller.reservation) {
            // zGeneral 2/6/2022 if not allowed to poison reserved, then if reserved retrun false
            return false;
        }
        if (room.controller.level) {
            // zGeneral 2/6/2022 do not poison owned!
            return false;
        }
        if (room.dangerousHostiles.length > 0) {
            return false;
        }
        if (
            _.filter(room.controller.pos.neighbors, (pos) =>
                pos.isWalkable(true),
            ).length == 0
        ) {
            return false;
        }
        return true;
    }
    init() {
        this.alert(`Poisoning room`);
        // Re-compute the list of positions to block
        if (this.room) {
            const thingsToBlock = _.compact([
                this.room.controller,
                ...this.room.sources,
            ]);
            const neighborTiles = _.unique(
                _.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)),
                (pos) => packPos(pos),
            );
            this.blockPositions = _.filter(neighborTiles, (pos) =>
                pos.isWalkable(true),
            );
        } else {
            this.blockPositions = [];
        }
    }
    prePoisonActions() {
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.level != 1
        ) {
            return; // failsafe to prevent you from accidentally killing your own room
        }
        if (this.room) {
            const removeStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) =>
                    s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER,
            });
            _.forEach(removeStructures, (s) => s.destroy());
            _.forEach(
                this.room.find(FIND_HOSTILE_CONSTRUCTION_SITES),
                (csite) => csite.remove(),
            );
        }
    }
    poisonActions() {
        if (
            !(
                this.room &&
                this.room.controller &&
                this.room.controller.level == 2
            )
        ) {
            return;
        }
        const positionToBlock = _.first(this.blockPositions);
        if (!positionToBlock) {
            return; // all blocked off
        }
        // Don't lock off the last position unless there's a creep with energy to build the site
        const enoughEnergyToBuildFinalWall = _.any(
            this.overlords.roomPoisoner.roomPoisoners,
            (creep) => creep.carry.energy >= BUILD_POWER,
        );
        if (this.blockPositions.length == 1 && !enoughEnergyToBuildFinalWall) {
            return;
        }
        // Otherwise build one site at a time
        positionToBlock.createConstructionSite(STRUCTURE_WALL);
    }
    clearRoom() {
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) =>
                    s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER,
            });
            _.forEach(allStructures, (s) => s.destroy());
        }
    }
    run() {
        if (
            this.room &&
            this.room.controller &&
            Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0
        ) {
            // Remove hostile reservation if needed
            if (
                this.room.controller.reservation &&
                this.room.controller.reservation.ticksToEnd > 500
            ) {
                DirectiveControllerAttack.createIfNotPresent(
                    this.room.controller.pos,
                    'room',
                );
            }
            // Send fighters if needed
            if (this.room.playerHostiles.length > 0) {
                DirectiveOutpostDefense.createIfNotPresent(
                    this.room.controller.pos,
                    'room',
                );
            }
        }
        if (this.room && this.room.controller && this.room.controller.my) {
            if (
                Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0 ||
                this.room.constructionSites.length == 0
            ) {
                // At RCL 1, prepare room by removing structures and hostile construction sites
                if (this.room.controller.level == 1) {
                    this.prePoisonActions();
                    return;
                }
                // At RCL 2, build walls to make the room useless
                if (this.room.controller.level == 2) {
                    if (this.blockPositions.length > 0) {
                        this.poisonActions();
                    } else {
                        this.room.controller.unclaim();
                        log.notify(
                            `Removing poisonRoom directive in ${this.pos.roomName}: operation completed.`,
                        );
                        this.remove();
                    }
                }
            }
        }
        if (Game.time - this.memory.T > 1500) {
            // zGeneral 6/2022 new feature, expire stuck directives
            console.log(
                'Poison Directive timer expiered in room ' + this.pos.roomName,
            );
            this.remove();
        }
    }
});
DirectivePoisonRoom.directiveName = 'poisonRoom';
DirectivePoisonRoom.color = COLOR_PURPLE;
DirectivePoisonRoom.secondaryColor = COLOR_RED;
DirectivePoisonRoom.requiredRCL = 5;
DirectivePoisonRoom.settings = {
    // zGen bugfix
    runFrequency: 12,
};
DirectivePoisonRoom = DirectivePoisonRoom_1 = __decorate(
    [profile],
    DirectivePoisonRoom,
);

/**
 * Spawn pioneers - early workers which help to build a spawn in a new colony, then get converted to workers or drones
 */
let PioneerOverlord = class PioneerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.pioneer) {
        super(directive, 'pioneer', priority);
        this.directive = directive;
        this.pioneers = this.zerg(Roles.pioneer);
        this.spawnSite = this.room
            ? _.filter(
                  this.room.constructionSites,
                  (s) => s.structureType == STRUCTURE_SPAWN,
              )[0]
            : undefined;
    }
    refresh() {
        super.refresh();
        this.spawnSite = this.room
            ? _.filter(
                  this.room.constructionSites,
                  (s) => s.structureType == STRUCTURE_SPAWN,
              )[0]
            : undefined;
    }
    init() {
        let pioneerAmount = 4;
        if (this.colony.level >= 6) {
            pioneerAmount -= 1;
        }
        if (this.colony.level >= 8) {
            pioneerAmount += 1;
        }
        const tooManyRooms =
            !(this.directive.room && this.directive.room.my) &&
            getAllColonies().length >=
                Math.min(Game.gcl.level, MAX_OWNED_ROOMS);
        if (this.directive.memory.pauseSpawning || tooManyRooms) {
            pioneerAmount = 0;
        }
        this.wishlist(pioneerAmount, Setups.pioneer);
    }
    findStructureBlockingPosition(pioneer, pos) {
        const blockingPos = Pathing.findBlockingPos(
            pioneer.pos,
            pos,
            _.filter(pioneer.room.structures, (s) => !s.isWalkable),
        );
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            return (
                structure ||
                this.directive.debug(
                    `${this.print}: no structure at blocking pos ${blockingPos.print}!`,
                )
            );
        }
    }
    canControlerUpgrade() {
        return (
            this.room &&
            this.room.controller &&
            this.room.my &&
            !(this.room.controller.upgradeBlocked > 0)
        );
    }
    fillStructures(pioneer) {
        const allyStructure = pioneer.room
            .find(FIND_STRUCTURES)
            .filter(
                (s) =>
                    (s.structureType == STRUCTURE_SPAWN ||
                        s.structureType == STRUCTURE_EXTENSION ||
                        s.structureType == STRUCTURE_TOWER) &&
                    isAlly(s.owner.username) &&
                    s.store.getFreeCapacity(RESOURCE_ENERGY) >
                        s.store.getCapacity(RESOURCE_ENERGY) / 2,
            );
        const structure = _.first(allyStructure);
        if (structure) {
            pioneer.task = Tasks.transfer(structure, RESOURCE_ENERGY);
            return true;
        }
        return false;
    }
    supportAlly(pioneer) {
        if (!pioneer.room.isAllyColony) return false;
        // recharge actions
        // TODO: make it avoid cstites.progress > 0
        if (this.rechargeIfNeeded(pioneer)) return true;
        const groupedSites = _.groupBy(
            pioneer.room.allyConstructionSites,
            (site) => site.structureType,
        );
        // Build Structures
        // TODO: make it avoid cstites.porgress > 0
        if (this.buildStructures(pioneer, groupedSites)) return true;
        if (this.fillStructures(pioneer)) return true;
        // nothing else to do but return true (stay here)
        pioneer.park();
        return true;
    }
    clearControllerAndSources(pioneer) {
        // Remove any blocking structures preventing claimer from reaching controller
        if (this.directive.memory.controllerCleared) return false;
        if (this.room && this.room.structures.length > 0) {
            const targets = [
                this.room.controller.pos,
                ...this.room.sources.map((source) => source.pos),
            ];
            for (const target of targets) {
                const dismantleTarget = this.findStructureBlockingPosition(
                    pioneer,
                    target,
                );
                if (dismantleTarget) {
                    pioneer.task = Tasks.dismantle(dismantleTarget);
                    return true;
                }
            }
        }
        this.directive.memory.controllerCleared = true;
        return false;
    }
    rechargeIfNeeded(pioneer) {
        if (pioneer.carry.energy == 0) {
            pioneer.task = Tasks.recharge(pioneer.carryCapacity / 2);
            this.directive.debug(`pioneer ${pioneer.print} will recharge now`);
            return true;
        }
        return false;
    }
    criticalControllerUpgrade(pioneer) {
        if (
            this.room &&
            this.room.controller &&
            this.canControlerUpgrade() &&
            (this.room.controller.ticksToDowngrade <
                0.5 * CONTROLLER_DOWNGRADE[this.room.controller.level] ||
                this.room.controller.level < 2 ||
                // invasion happening, at least you can upgrade a bit
                this.directive.memory.defendController)
        ) {
            // Save controller if it's about to downgrade or if you have nothing else to do
            pioneer.task = Tasks.upgrade(this.room.controller);
            this.directive.debug(
                `pioneer ${
                    pioneer.print
                } will emergency upgrade the controller with ${
                    this.room.controller.ticksToDowngrade
                } < ${0.5 * CONTROLLER_DOWNGRADE[this.room.controller.level]}`,
            );
            return true;
        }
        return false;
    }
    buildRampsFirst(pioneer, groupedSites) {
        for (const rampart of pioneer.room.ramparts) {
            if (rampart.hits < 10000) {
                pioneer.task = Tasks.repair(rampart);
                // make sure to repair many ramparts
                pioneer.task.settings.timeout = 10;
                this.directive.debug(
                    `pioneer ${pioneer.print} found repair target ${rampart.structureType}`,
                );
                return true;
            }
        }
        if (groupedSites[STRUCTURE_RAMPART]) {
            const target = pioneer.pos.findClosestByMultiRoomRange(
                groupedSites[STRUCTURE_RAMPART],
            );
            if (target) {
                pioneer.task = Tasks.build(target);
                this.directive.debug(
                    `pioneer ${pioneer.print} found build target ${target.structureType}`,
                );
                return true;
            }
        }
        return false;
    }
    buildStructures(pioneer, groupedSites) {
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = pioneer.pos.findClosestByMultiRoomRange(
                    groupedSites[structureType],
                );
                if (target) {
                    pioneer.task = Tasks.build(target);
                    this.directive.debug(
                        `pioneer ${pioneer.print} found build target ${target.structureType}`,
                    );
                    return true;
                }
            }
        }
        return false;
    }
    upgradeController(pioneer) {
        if (this.room && this.room.controller && this.canControlerUpgrade()) {
            pioneer.task = Tasks.upgrade(this.room.controller);
            this.directive.debug(
                `pioneer ${pioneer.print} will idle upgrade the controller`,
            );
            return true;
        }
        return false;
    }
    handlePioneer(pioneer) {
        // Ensure you are in the assigned room
        if (!pioneer.safelyInRoom(this.pos.roomName)) {
            pioneer.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
            return;
        }
        // All actions below are done in target room
        // support ally in building his colony
        if (this.supportAlly(pioneer)) return;
        // clear controller if required for claiming
        if (this.clearControllerAndSources(pioneer)) return;
        // recharge actions
        if (this.rechargeIfNeeded(pioneer)) return;
        // Actions below assume pioneer.carry.energy > 0
        // upgrade controller
        if (this.criticalControllerUpgrade(pioneer)) return;
        const groupedSites = _.groupBy(
            pioneer.room.constructionSites,
            (site) => site.structureType,
        );
        // Build ramps first
        if (this.buildRampsFirst(pioneer, groupedSites)) return;
        // Build Strcutures
        if (this.buildStructures(pioneer, groupedSites)) return;
        // upgrade controller
        if (this.upgradeController(pioneer)) return;
        // nothing else to do
        pioneer.park();
    }
    run() {
        this.autoRun(this.pioneers, (pioneer) => this.handlePioneer(pioneer));
    }
};
PioneerOverlord = __decorate([profile], PioneerOverlord);

/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let PioneerDirective = class PioneerDirective extends Directive {
    constructor(flag, requiredRCL) {
        flag.memory.allowPortals = true;
        super(
            flag,
            (colony) =>
                colony.level >= requiredRCL &&
                colony.name != Directive.getPos(flag).roomName &&
                colony.spawns.length > 0,
        );
        // todo: initialise with defaults object
        if (this.memory.completeBuildings === undefined) {
            this.memory.completeBuildings = true;
        }
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(
                `${this.print}: ${printRoomName(
                    this.pos.roomName,
                )} is not a controller room; ` + `removing directive!`,
            );
            this.remove(true);
            return;
        }
    }
};
PioneerDirective = __decorate([profile], PioneerDirective);

var DirectiveColonize_1;
/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let DirectiveColonize = (DirectiveColonize_1 = class DirectiveColonize extends (
    PioneerDirective
) {
    constructor(flag) {
        super(flag, DirectiveColonize_1.requiredRCL);
        if (this.room) {
            // Register incubation status
            this.toColonize =
                Overmind.colonies[Overmind.colonyMap[this.room.name]];
            if (this.room.memory['e' /* EXPANSION_DATA */] === 0) {
                this.room.memory['e' /* EXPANSION_DATA */] = undefined;
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        this.alert(`Colonization in progress`);
    }
    run(verbose = false) {
        // Check if this room is currently under attack and defend controller
        if (this.room && this.room.my) {
            const safety = RoomIntel.getSafetyData(this.room.name);
            if (safety.unsafeFor > 10) {
                this.memory.defendController = true;
                this.memory.pauseSpawning = true;
            } else if (safety.safeFor > 10) {
                this.memory.pauseSpawning = false;
                if (safety.safeFor > 1500) {
                    this.memory.defendController = false;
                }
            }
        }
        // TODO bug where can't claim a reservation room -> this.flag.pos.roomName == this.toColonize.name
        const buildingsComplete = this.memory.completeBuildings
            ? (this.room && this.room.constructionSites.length) == 0
            : true;
        if (
            this.toColonize &&
            this.toColonize.spawns.length > 0 &&
            this.room &&
            this.room.controller &&
            this.room.controller.level >= 2 &&
            buildingsComplete
        ) {
            // Reassign all pioneers to be miners and workers
            const miningOverlords = _.map(
                this.toColonize.miningSites,
                (site) => site.overlords.mine,
            );
            for (const pioneer of this.overlords.pioneer.pioneers) {
                const miningOverlord = miningOverlords.shift();
                if (miningOverlord) {
                    log.info(
                        `Reassigning: ${pioneer.print} to mine: ${miningOverlord.print}`,
                    );
                    pioneer.reassign(miningOverlord, Roles.drone, true);
                } else {
                    log.info(
                        `Reassigning: ${pioneer.print} to work: ${this.toColonize.overlords.work.print}`,
                    );
                    pioneer.reassign(
                        this.toColonize.overlords.work,
                        Roles.worker,
                        true,
                    );
                }
            }
            // Remove the directive
            this.remove();
        }
        if (
            Game.time % 10 == 2 &&
            this.room &&
            !!this.room.owner &&
            this.room.owner != MY_USERNAME
        ) {
            log.notify(
                `Removing Colonize directive in ${this.pos.roomName}: room already owned by another player.`,
            );
            this.remove();
        }
    }
});
DirectiveColonize.directiveName = 'colonize';
DirectiveColonize.color = COLOR_PURPLE;
DirectiveColonize.secondaryColor = COLOR_GREY;
DirectiveColonize.requiredRCL = 3;
DirectiveColonize = DirectiveColonize_1 = __decorate(
    [profile],
    DirectiveColonize,
);

/**
 * Claims a new room and incubates it from the nearest (or specified) colony
 */
let DirectiveIncubate = class DirectiveIncubate extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 4);
        // Register incubation status
        this.incubatee = this.room
            ? Overmind.colonies[Overmind.colonyMap[this.room.name]]
            : undefined;
        this.refresh();
    }
    refresh() {
        if (this.incubatee) {
            this.incubatee.state.isIncubating = true;
            this.incubatee.spawnGroup = new SpawnGroup(this.incubatee, {
                // Workers will take maxPath * 2 in lifetime penalty, so short path preferred
                maxPathDistance: 300,
                // incubate does not need high rcl
                requiredRCL: 4,
            });
        }
    }
    spawnMoarOverlords() {
        if (!this.incubatee) {
            // colony isn't claimed yet
            this.overlords.claim = new ClaimingOverlord(this);
        }
    }
    init() {}
    run() {
        if (this.incubatee) {
            if (
                this.incubatee.level >= 4 &&
                this.incubatee.storage &&
                this.incubatee.terminal
            ) {
                this.remove();
            }
        }
    }
};
DirectiveIncubate.directiveName = 'incubate';
DirectiveIncubate.color = COLOR_PURPLE;
DirectiveIncubate.secondaryColor = COLOR_WHITE;
DirectiveIncubate = __decorate([profile], DirectiveIncubate);

const getDefaultEmptyOverlordMemory = () => ({
    crossRoadRoom: undefined,
});
let InterShardOverlord = class InterShardOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.interShard.scout) {
        super(directive, 'interShard', priority, getDefaultEmptyOverlordMemory);
        this.directive = directive;
        this.scout = this.zerg(Roles.interShardScout);
        this.claim = this.zerg(Roles.interShardClaim);
        this.pioneer = this.zerg(Roles.interShardPioneer);
        this.hauler = this.zerg(Roles.interShardHauler);
    }
    refresh() {
        super.refresh();
    }
    init() {
        if (
            Object.keys(Overmind.colonies).length > 0 &&
            this.directive.colony.name != 'InterShard'
        ) {
            if (!this.directive.memory.shouldFinish) {
                if (this.directive.room != this.colony.room) {
                    // TODO: disable for now as keeps spawning none stop
                    this.wishlist(0, Setups.interShard.scout, {
                        priority: OverlordPriority.interShard.scout,
                    });
                    // TODO: disable for now as keeps spawning none stop
                    this.wishlist(0, Setups.interShard.claim, {
                        priority: OverlordPriority.interShard.claim,
                    });
                    // TODO: limit to 4 for now as it keeps spawning none stop
                    const pioneerSetup =
                        this.directive.colony.level > 5
                            ? Setups.interShard.pioneerBoosted
                            : Setups.interShard.pioneer;
                    this.wishlist(4, pioneerSetup, {
                        priority: OverlordPriority.interShard.pioneer,
                    });
                    const haulerSetup =
                        this.directive.colony.level > 5
                            ? Setups.interShard.haulerBoosted
                            : Setups.interShard.hauler;
                    // TODO: limit to 4 for now as it keeps spawning none stop
                    this.wishlist(4, haulerSetup, {
                        priority: OverlordPriority.interShard.hauler,
                    });
                } else {
                    this.createOrphanedCreeps();
                }
            }
            this.reassignIdleCreeps(Roles.interShardPioneer);
        } else {
            this.createOrphanedCreeps();
        }
    }
    createOrphanedCreeps() {
        for (const creepName in Game.creeps) {
            const creep = Game.creeps[creepName];
            if (!creep.memory.role) {
                log.info(
                    `Reassign creep ${creepName}: ${creep.pos} to overlord ${this.print}`,
                );
                const creepMemory = {
                    ['C' /* COLONY */]: this.colony.name,
                    ['O' /* OVERLORD */]: this.ref,
                    role: creepName.split('_')[0],
                    task: null,
                    data: {
                        // rarely-changed data about the creep
                        origin: this.colony.name,
                    },
                };
                creep.memory = creepMemory;
                // TODO: find a better place to do this
                // record cross portal road roam name
                if (this.memory.crossRoadRoom === undefined) {
                    this.memory.crossRoadRoom = creep.room.name;
                }
            }
        }
    }
    handleClaimer(claimer) {
        if (
            claimer.room == this.room &&
            !claimer.pos.isEdge &&
            claimer.room.controller &&
            !claimer.room.my
        ) {
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs
                // prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    claimer.task = Tasks.claim(this.room.controller);
                } else {
                    claimer.task = Tasks.signController(this.room.controller);
                }
            } else {
                claimer.task = Tasks.claim(this.room.controller);
                claimer.claimController(this.room.controller);
            }
        } else {
            const range = claimer.room == this.room && claimer.room.my ? 2 : 0;
            claimer.goTo(this.pos, {
                range: range,
                pathOpts: {
                    ensurePath: true,
                    avoidSK: true,
                    allowPortals: true,
                },
            });
        }
    }
    handleScout(scout) {
        scout.goTo(this.pos, {
            pathOpts: { ensurePath: true, avoidSK: true, allowPortals: true },
        });
    }
    findStructureBlockingPosition(pioneer, pos) {
        const blockingPos = Pathing.findBlockingPos(
            pioneer.pos,
            pos,
            _.filter(pioneer.room.structures, (s) => !s.isWalkable),
        );
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            return (
                structure ||
                this.directive.debug(
                    `${this.print}: no structure at blocking pos ${blockingPos.print}!`,
                )
            );
        }
    }
    canControlerUpgrade() {
        return (
            this.room &&
            this.room.controller &&
            this.room.my &&
            !(this.room.controller.upgradeBlocked > 0)
        );
    }
    fillStructures(pioneer) {
        const allyStructure = pioneer.room
            .find(FIND_STRUCTURES)
            .filter(
                (s) =>
                    (s.structureType == STRUCTURE_SPAWN ||
                        s.structureType == STRUCTURE_EXTENSION ||
                        s.structureType == STRUCTURE_TOWER) &&
                    isAlly(s.owner.username) &&
                    s.store.getFreeCapacity(RESOURCE_ENERGY) >
                        s.store.getCapacity(RESOURCE_ENERGY) / 2,
            );
        const structure = _.first(allyStructure);
        if (structure) {
            pioneer.task = Tasks.transfer(structure, RESOURCE_ENERGY);
            return true;
        }
        return false;
    }
    supportAlly(pioneer) {
        if (!pioneer.room.isAllyColony) return false;
        // recharge actions
        // TODO: make it avoid cstites.progress > 0
        if (this.rechargeIfNeeded(pioneer)) return true;
        const groupedSites = _.groupBy(
            pioneer.room.allyConstructionSites,
            (site) => site.structureType,
        );
        // Build Structures
        // TODO: make it avoid cstites.porgress > 0
        if (this.buildStructures(pioneer, groupedSites)) return true;
        if (this.fillStructures(pioneer)) return true;
        // nothing else to do but return true (stay here)
        pioneer.park();
        return true;
    }
    clearControllerAndSources(pioneer) {
        // Remove any blocking structures preventing claimer from reaching controller
        if (this.directive.memory.controllerCleared) return false;
        if (this.room && this.room.structures.length > 0) {
            const targets = [
                this.room.controller.pos,
                ...this.room.sources.map((source) => source.pos),
            ];
            for (const target of targets) {
                const dismantleTarget = this.findStructureBlockingPosition(
                    pioneer,
                    target,
                );
                if (dismantleTarget) {
                    pioneer.task = Tasks.dismantle(dismantleTarget);
                    return true;
                }
            }
        }
        this.directive.memory.controllerCleared = true;
        return false;
    }
    rechargeIfNeeded(pioneer) {
        if (pioneer.carry.energy == 0) {
            pioneer.task = Tasks.recharge(pioneer.carryCapacity / 2);
            this.directive.debug(`pioneer ${pioneer.print} will recharge now`);
            return true;
        }
        return false;
    }
    criticalControllerUpgrade(pioneer) {
        if (
            this.room &&
            this.room.controller &&
            this.canControlerUpgrade() &&
            (this.room.controller.ticksToDowngrade <
                0.5 * CONTROLLER_DOWNGRADE[this.room.controller.level] ||
                this.room.controller.level < 2 ||
                // invasion happening, at least you can upgrade a bit
                this.directive.memory.defendController)
        ) {
            // Save controller if it's about to downgrade or if you have nothing else to do
            pioneer.task = Tasks.upgrade(this.room.controller);
            this.directive.debug(
                `pioneer ${
                    pioneer.print
                } will emergency upgrade the controller with ${
                    this.room.controller.ticksToDowngrade
                } < ${0.5 * CONTROLLER_DOWNGRADE[this.room.controller.level]}`,
            );
            return true;
        }
        return false;
    }
    buildRampsFirst(pioneer, groupedSites) {
        for (const rampart of pioneer.room.ramparts) {
            if (rampart.hits < 10000) {
                pioneer.task = Tasks.repair(rampart);
                // make sure to repair many ramparts
                pioneer.task.settings.timeout = 10;
                this.directive.debug(
                    `pioneer ${pioneer.print} found repair target ${rampart.structureType}`,
                );
                return true;
            }
        }
        if (groupedSites[STRUCTURE_RAMPART]) {
            const target = pioneer.pos.findClosestByMultiRoomRange(
                groupedSites[STRUCTURE_RAMPART],
            );
            if (target) {
                pioneer.task = Tasks.build(target);
                this.directive.debug(
                    `pioneer ${pioneer.print} found build target ${target.structureType}`,
                );
                return true;
            }
        }
        return false;
    }
    buildStructures(pioneer, groupedSites) {
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = pioneer.pos.findClosestByMultiRoomRange(
                    groupedSites[structureType],
                );
                if (target) {
                    pioneer.task = Tasks.build(target);
                    this.directive.debug(
                        `pioneer ${pioneer.print} found build target ${target.structureType}`,
                    );
                    return true;
                }
            }
        }
        return false;
    }
    upgradeController(pioneer) {
        if (pioneer.carry.energy == 0) {
            return false;
        }
        if (this.room && this.room.controller && this.canControlerUpgrade()) {
            pioneer.task = Tasks.upgrade(this.room.controller);
            this.directive.debug(
                `pioneer ${pioneer.print} will idle upgrade the controller`,
            );
            return true;
        }
        return false;
    }
    handlePioneer(pioneer) {
        // Collect energy from home shard before traveling
        // TODO: need to check double hopping flags and ignore
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CROSSROAD) {
            if (this.rechargeIfNeeded(pioneer)) return;
        }
        // Ensure you are in the assigned room
        if (
            !pioneer.safelyInRoom(this.pos.roomName) ||
            !pioneer.room.controller
        ) {
            pioneer.goTo(this.pos, {
                pathOpts: {
                    ensurePath: true,
                    avoidSK: true,
                    allowPortals: true,
                },
            });
            return;
        }
        // recharge can be from cross room or colony room
        if (this.rechargeIfNeeded(pioneer)) return;
        // support ally in building his colony
        if (this.supportAlly(pioneer)) return;
        // clear controller if required for claiming
        if (this.clearControllerAndSources(pioneer)) return;
        // Actions below assume pioneer.carry.energy > 0
        // upgrade controller
        if (this.criticalControllerUpgrade(pioneer)) return;
        const groupedSites = _.groupBy(
            pioneer.room.constructionSites,
            (site) => site.structureType,
        );
        // Build ramps first
        if (this.buildRampsFirst(pioneer, groupedSites)) return;
        // Build Strcutures
        if (this.buildStructures(pioneer, groupedSites)) return;
        // upgrade controller
        if (this.upgradeController(pioneer)) return;
        // nothing else to do
        pioneer.park();
    }
    haulEnergy(hauler) {
        if (!hauler.isFull()) {
            return false;
        }
        // go to final shard room
        if (!hauler.safelyInRoom(this.pos.roomName)) {
            hauler.goTo(this.pos);
            return true;
        }
        // in colony room now
        if (hauler.room.storage) {
            hauler.task = Tasks.transferAll(hauler.room.storage);
            return true;
        } else {
            const droplLocation = this.pos;
            hauler.task = Tasks.drop(droplLocation);
            log.warning(
                `no storage to drop interShard hauled energy, dropping at flag.pos ${this.pos.print}`,
            );
            return true;
        }
    }
    collectDroppedResourcedFromCrossRoad(creep, resource) {
        if (creep.isFull()) {
            return false;
        }
        // go to final shard room
        const crossRoadRoom = this.memory.crossRoadRoom;
        if (crossRoadRoom && !creep.safelyInRoom(crossRoadRoom)) {
            creep.goToRoom(crossRoadRoom);
            return true;
        }
        const loadedrechargeables = _.filter(
            creep.room.rechargeables,
            (rechargeable) =>
                (isResource(rechargeable) && rechargeable.amount > 100) ||
                (!isResource(rechargeable) &&
                    sumStore(rechargeable.store) > 100),
        );
        const target = maxBy(loadedrechargeables, (x) => {
            return isResource(x) ? x.amount : sumStore(x.store);
        });
        if (target) {
            if (creep.pos.isNearTo(target)) {
                if (isResource(target)) {
                    creep.task = Tasks.pickup(target);
                    return true;
                } else if (sumStore(target.store) > 0) {
                    creep.task = Tasks.withdrawAll(target);
                    return true;
                }
                return false; // may be no resources left by then / decayed
            } else {
                creep.goTo(target, { range: 1 });
                return true;
            }
        }
        return false;
    }
    handleHauler(hauler) {
        // Collect energy from home shard before traveling
        // TODO: need to check double hopping flags and ignore
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CROSSROAD) {
            if (this.rechargeIfNeeded(hauler)) return;
        }
        // Ensure you are in the assigned room
        if (
            (!hauler.safelyInRoom(this.pos.roomName) ||
                !hauler.room.controller) &&
            hauler.isFull()
        ) {
            hauler.goTo(this.pos, {
                pathOpts: {
                    ensurePath: true,
                    avoidSK: true,
                    allowPortals: true,
                },
            });
            return;
        }
        // All actions below are done in target room
        // support ally in building his colony
        if (this.haulEnergy(hauler)) return;
        if (this.collectDroppedResourcedFromCrossRoad(hauler)) return;
        // nothing to do, wait for the dead to arrive!
        hauler.park();
    }
    run() {
        this.autoRun(this.scout, (scout) => this.handleScout(scout));
        this.autoRun(this.claim, (scout) => this.handleClaimer(scout));
        this.autoRun(this.pioneer, (pioneer) => this.handlePioneer(pioneer));
        this.autoRun(this.hauler, (hauler) => this.handleHauler(hauler));
        if (this.directive.memory.shouldFinish) {
            if (
                this.scout.length === 0 &&
                this.claim.length === 0 &&
                this.pioneer.length === 0
            ) {
                this.directive.remove();
            }
        }
    }
};
__decorate([customProfile], InterShardOverlord.prototype, 'init', null);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'createOrphanedCreeps',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'handleClaimer',
    null,
);
__decorate([customProfile], InterShardOverlord.prototype, 'handleScout', null);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'findStructureBlockingPosition',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'canControlerUpgrade',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'fillStructures',
    null,
);
__decorate([customProfile], InterShardOverlord.prototype, 'supportAlly', null);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'clearControllerAndSources',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'rechargeIfNeeded',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'criticalControllerUpgrade',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'buildRampsFirst',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'buildStructures',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'upgradeController',
    null,
);
__decorate(
    [customProfile],
    InterShardOverlord.prototype,
    'handlePioneer',
    null,
);
__decorate([customProfile], InterShardOverlord.prototype, 'handleHauler', null);
__decorate([customProfile], InterShardOverlord.prototype, 'run', null);
InterShardOverlord = __decorate([profile], InterShardOverlord);

/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let DirectiveInterShard = class DirectiveInterShard extends Directive {
    constructor(flag) {
        super(flag);
        if (this.memory.completeBuildings === undefined) {
            this.memory.completeBuildings = true;
        }
        if (this.memory.shouldFinish === undefined) {
            this.memory.shouldFinish = false;
        }
    }
    spawnMoarOverlords() {
        this.overlords.interShard = new InterShardOverlord(this);
    }
    get colony() {
        if (this._colony) {
            return this._colony;
        }
        const flags = [];
        return {
            name: 'InterShard',
            flags: flags,
            level: 1,
            room: {},
        };
    }
    set colony(value) {
        super.colony = value;
    }
    init() {
        this.alert(`InterShard Colonization in progress`);
    }
    run(verbose = false) {}
};
DirectiveInterShard.directiveName = 'interShard';
DirectiveInterShard.color = COLOR_PURPLE;
DirectiveInterShard.secondaryColor = COLOR_BROWN;
DirectiveInterShard.requiredRCL = 3;
DirectiveInterShard = __decorate([profile], DirectiveInterShard);

var DirectiveRogueColony_1;
const getDefaultDirectiveRogueColonyMemory = () => ({});
let DirectiveRogueColony = (DirectiveRogueColony_1 = class DirectiveRogueColony extends (
    PioneerDirective
) {
    constructor(flag) {
        super(flag, DirectiveRogueColony_1.requriedRCL);
        _.defaultsDeep(this.memory, getDefaultDirectiveRogueColonyMemory());
    }
    spawnMoarOverlords() {
        const owner = RoomIntel.roomOwnedBy(this.pos.roomName) || '';
        if (owner != MY_USERNAME && !isAlly(owner)) {
            this.overlords.claim = new ClaimingOverlord(this);
        }
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        this.alert(`Rogue colony active`);
    }
    /**
     * run() tips:
     * - Directive removal logic should go on run() (and only on run) if necessary
     */
    run() {}
});
// All directives must have these three static properties
DirectiveRogueColony.directiveName = 'rogueColony';
DirectiveRogueColony.color = COLOR_PURPLE;
DirectiveRogueColony.secondaryColor = COLOR_GREEN;
DirectiveRogueColony.requriedRCL = 7;
DirectiveRogueColony = DirectiveRogueColony_1 = __decorate(
    [profile],
    DirectiveRogueColony,
);

/**
 * Guard swarm overlord: spawns lots of smaller guards to deal with swarm-like attacks or harassments
 */
let GuardSwarmOverlord = class GuardSwarmOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'swarmGuard', priority);
        this.directive = directive;
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    findAttackTarget(guard) {
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(
                guard.room.hostiles,
                (hostile) => hostile.pos.rangeToEdge > 0,
            );
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            return guard.pos.findClosestByRange(guard.room.hostileStructures);
        }
    }
    handleGuard(guard) {
        if (guard.pos.roomName != this.pos.roomName) {
            // TODO: make edge-safe
            // Move into the assigned room if there is a guard flag present
            guard.goToRoom(this.pos.roomName);
        } else {
            // If you're in the assigned room or if there is no assignment, try to attack or heal
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                guard.attackAndChase(attackTarget);
            } else {
                guard.park(this.pos); // Move off-road
            }
        }
    }
    init() {
        if (this.directive.memory.amount) {
            this.wishlist(
                this.directive.memory.amount,
                CombatSetups.broodlings.early,
            );
        } else {
            if (this.room) {
                const smallHostiles = _.filter(
                    this.room.dangerousHostiles,
                    (creep) => creep.body.length < 10,
                );
                if (smallHostiles.length > 2) {
                    this.wishlist(
                        Math.round(smallHostiles.length),
                        CombatSetups.broodlings.early,
                    );
                }
            } else {
                this.wishlist(2, CombatSetups.broodlings.early);
            }
        }
    }
    run() {
        for (const guard of this.guards) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (guard.hasValidTask) {
                guard.run();
            } else {
                this.handleGuard(guard);
            }
        }
    }
};
GuardSwarmOverlord = __decorate([profile], GuardSwarmOverlord);

/**
 * [LEGACY] Manually specify targets to be prioritized during a siege
 */
let DirectiveTargetSiege = class DirectiveTargetSiege extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {}
    getTarget() {
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {}
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'orange' });
    }
};
DirectiveTargetSiege.directiveName = 'target:siege';
DirectiveTargetSiege.color = COLOR_GREY;
DirectiveTargetSiege.secondaryColor = COLOR_ORANGE;
DirectiveTargetSiege = __decorate([profile], DirectiveTargetSiege);

/**
 * NPC defense overlord: spawns specially-optimized guards as needed to deal with standard NPC invasions
 */
let DefenseNPCOverlord = class DefenseNPCOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'guard', priority);
        if (directive.memory.invaderCore) {
            this.invaderCore = true;
        }
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    // private reassignIdleGuards(): void {
    // 	// Find all idle guards
    // 	let idleGuards = _.filter(this.colony.getCreepsByRole('guard'), (guard: Zerg) => !guard.overlord);
    // 	// Reassign them all to this flag
    // 	for (let guard of idleGuards) {
    // 		guard.overlord = this;
    // 	}
    // 	// Refresh the list of guards
    // 	this.guards = this.creeps('guard');
    // }
    findAttackTarget(guard) {
        const targetingDirectives = DirectiveTargetSiege.find(guard.room.flags);
        const targetedStructures = _.compact(
            _.map(targetingDirectives, (directive) => directive.getTarget()),
        );
        if (targetedStructures.length > 0) {
            return guard.pos.findClosestByRange(targetedStructures);
        }
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(
                guard.room.hostiles,
                (hostile) => hostile.pos.rangeToEdge > 0,
            );
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            const haulFlags = DirectiveHaul.find(guard.room.flags);
            if (haulFlags.length == 0) {
                return guard.pos.findClosestByRange(
                    guard.room.hostileStructures,
                );
            }
        }
    }
    /**
     * Attack and chase the specified target
     */
    combatActions(guard, target) {
        // Attack the target if you can, else move to get in range
        guard.attackAndChase(target);
        // Heal yourself if it won't interfere with attacking
        guard.healSelfIfPossible();
    }
    handleGuard(guard) {
        if (!guard.inSameRoomAs(this) || guard.pos.isEdge) {
            // Move into the assigned room if there is a guard flag present
            guard.goToRoom(this.pos.roomName);
        } else {
            // If you're in the assigned room or if there is no assignment, try to attack or heal
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                this.combatActions(guard, attackTarget);
            } else {
                guard.doMedicActions(this.pos.roomName);
            }
        }
    }
    init() {
        let amount = 0;
        if (
            this.invaderCore ||
            !this.room ||
            this.room.invaders.length > 0 ||
            RoomIntel.isInvasionLikely(this.room)
        ) {
            if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE) {
                amount = 3;
            } else {
                amount = 1;
            }
        }
        this.wishlist(amount, CombatSetups.broodlings.default, {
            reassignIdle: true,
        });
    }
    run() {
        for (const guard of this.guards) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (guard.hasValidTask) {
                guard.run();
            } else {
                this.handleGuard(guard);
            }
        }
    }
};
DefenseNPCOverlord.requiredRCL = 4;
DefenseNPCOverlord = __decorate([profile], DefenseNPCOverlord);

/**
 * NPC defense directive for outpost rooms with invaders
 */
let DirectiveGuard = class DirectiveGuard extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        if (this.colony.level >= DefenseNPCOverlord.requiredRCL) {
            // if (this.memory.enhanced || this.name.includes('enhanced')) {
            // 	this.overlords.guardPair = new GuardPairOverlord(this);
            // } else {
            this.overlords.guard = new DefenseNPCOverlord(this);
            // }
        } else {
            this.overlords.swarmGuard = new GuardSwarmOverlord(this);
        }
    }
    init() {
        if (this.room && this.room.invaderCore) {
            this.memory.invaderCore = true;
        }
        if (this.memory.invaderCore) {
            this.alert(`Attacking invader core`, NotifierPriority.Low);
        }
    }
    run() {
        // If there are no hostiles or hostiles structures left in the room, possibly remove
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0
        ) {
            // If everyone's healed up and the room is safe, remove
            const creepsNeedingHealing = _.filter(
                this.room.creeps,
                (creep) => creep.hits < creep.hitsMax,
            );
            if (creepsNeedingHealing.length == 0 && this.room.isSafe) {
                this.remove();
            }
        }
    }
};
DirectiveGuard.directiveName = 'guard';
DirectiveGuard.color = COLOR_BLUE;
DirectiveGuard.secondaryColor = COLOR_BLUE;
DirectiveGuard = __decorate([profile], DirectiveGuard);

/**
 * Spawns bunker-only defenders to defend against incoming sieges // TODO: needs some revision
 */
let BunkerDefenseOverlord = class BunkerDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.meleeDefense) {
        // Only spawn inside room
        super(directive, 'bunkerDefense', priority, 1, 30);
        this.defenders = this.combatZerg(Roles.bunkerDefender);
    }
    handleDefender(lurker) {
        const cpuBefore = Game.cpu.getUsed();
        log.debug(`Running BunkerDefender in room ${this.room.print}`);
        if (!lurker.inRampart) {
            const nearbyRampart = _.find(
                lurker.room.walkableRamparts,
                (rampart) => rampart.pos.getRangeTo(lurker) < 5,
            );
            if (nearbyRampart) {
                lurker.goTo(nearbyRampart);
            }
        }
        if (lurker.room.hostiles.length > 0) {
            lurker.autoBunkerCombat(lurker.room.name);
        }
        console.log(
            `Bunker defender cpu used is ${Game.cpu.getUsed() - cpuBefore}`,
        );
    }
    init() {
        this.reassignIdleCreeps(Roles.bunkerDefender);
        this.wishlist(1, CombatSetups.bunkerDefender.boosted);
    }
    run() {
        this.autoRun(this.defenders, (defender) =>
            this.handleDefender(defender),
        );
    }
};
BunkerDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
BunkerDefenseOverlord = __decorate([profile], BunkerDefenseOverlord);

var DistractionOverlord_1;
/**
 * 5 Move 1 RA creep that avoids all enemies and distracts attackers.
 * Just for fun
 * TODO: Make them prefer swamps when at max hp
 */
let DistractionOverlord = (DistractionOverlord_1 = class DistractionOverlord extends (
    CombatOverlord
) {
    constructor(
        directive,
        boosted = false,
        priority = OverlordPriority.defense.rangedDefense,
    ) {
        super(directive, 'distraction', priority, 1);
        this.distractions = this.combatZerg(Roles.rangedDistractor);
    }
    handleDistraction(distraction) {
        if (this.room && this.room.hostiles.length > 0) {
            distraction.autoCombat(this.room.name, false, 5, {
                preferRamparts: false,
            });
            DistractionOverlord_1.taunt(
                distraction,
                this.room.hostiles[0].owner.username,
            );
            const nearbyHostiles = this.room.hostiles.filter(
                (hostile) => hostile.pos.getRangeTo(distraction) <= 6,
            );
            if (nearbyHostiles.length > 0) {
                distraction.kite(nearbyHostiles);
            }
        }
    }
    static taunt(distraction, name) {
        const taunts = [
            'Heylisten!',
            'Pssssst',
            'So close',
            '🎣',
            'Try harder',
            'Get good;)',
            'Base ⬆️',
            '🔜',
            '⚠️Swamp⚠️',
            'Follow me!',
            'Catch Me!',
            `Hi ${name || ''}`,
            '🍑🍑🍑',
            '🏎️ VROOM',
        ];
        distraction.sayRandom(taunts, true);
    }
    init() {
        // this.reassignIdleCreeps(Roles.ranged); until it's it's own role don't reassign
        const setup = CombatSetups.distractors.ranged;
        this.wishlist(1, setup);
    }
    run() {
        // need to check room exists
        // console.log(`Distraction overlord running in ${this.room.print} with ${this.distractions}!`);
        this.autoRun(this.distractions, (distraction) =>
            this.handleDistraction(distraction),
        );
    }
});
DistractionOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
DistractionOverlord = DistractionOverlord_1 = __decorate(
    [profile],
    DistractionOverlord,
);

/**
 * Spawns ranged defenders to defend against incoming player invasions in an owned room
 */
let RangedDefenseOverlord = class RangedDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'rangedDefense', priority, 1);
        this.hydralisks = this.combatZerg(Roles.ranged);
    }
    handleDefender(hydralisk) {
        if (this.room.hostiles.length > 0) {
            hydralisk.heal(hydralisk); // heal self if no other targets
            hydralisk.autoCombat(this.room.name);
        } else {
            if (
                !hydralisk.doMedicActions(this.room.name) &&
                hydralisk.pos.getRangeTo(this.directive.pos) > 4
            ) {
                hydralisk.goTo(this.directive.pos);
            }
        }
    }
    /**
     * Computes how much *additional* ranged parts we need
     */
    computeNeededAdditionalRangedPotential() {
        const healAmount = CombatIntel.maxHealingByCreeps(this.room.hostiles);
        const towerDamage = this.room.hostiles[0]
            ? CombatIntel.towerDamageAtPos(this.room.hostiles[0].pos) || 0
            : 0;
        const worstDamageMultiplier = _.min(
            _.map(this.room.hostiles, (creep) =>
                CombatIntel.minimumDamageTakenMultiplier(creep),
            ),
        );
        const hydraliskDamage =
            RANGED_ATTACK_POWER *
            CombatIntel.getMyCombatPotentials(this.hydralisks).ranged;
        const maxDamageReceived =
            worstDamageMultiplier * (hydraliskDamage + towerDamage + 1);
        const needAdditionalDamage = Math.max(
            healAmount - maxDamageReceived,
            0,
        );
        const neededRangedParts = needAdditionalDamage / RANGED_ATTACK_POWER;
        return neededRangedParts;
    }
    init() {
        if (this.reassignIdleCreeps(Roles.ranged, 1)) return;
        let setup = CombatSetups.hydralisks.default;
        if (
            _.all(
                this.spawnGroup.colonies,
                (col) => col.room.energyCapacityAvailable < 800,
            )
        ) {
            setup = CombatSetups.hydralisks.noHeal; // can't spawn default hydras at very low rcl
        } else {
            const { attack, ranged, heal } = CombatIntel.getCombatPotentials(
                this.room.hostiles,
            );
            // if there's a lot of big baddies or this assault has lasted a long time, pull out the boosts
            if (attack + ranged + heal > 100 || this.age > 1000) {
                setup = CombatSetups.hydralisks.boosted.default;
            }
        }
        const neededAdditionalRangedPotential = this.computeNeededAdditionalRangedPotential();
        if (neededAdditionalRangedPotential) {
            this.requestCreep(setup);
        }
    }
    run() {
        this.autoRun(this.hydralisks, (hydralisk) =>
            this.handleDefender(hydralisk),
        );
    }
};
RangedDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
RangedDefenseOverlord = __decorate([profile], RangedDefenseOverlord);

/**
 * Defend an owned room against an incoming player invasion
 */
let DirectiveInvasionDefense = class DirectiveInvasionDefense extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 3 && colony.spawns.length > 0);
    }
    spawnMoarOverlords() {
        if (!this.room) {
            return;
        }
        const expectedDamage = CombatIntel.maxDamageByCreeps(
            this.room.dangerousPlayerHostiles,
        );
        const expectedHealing = CombatIntel.maxHealingByCreeps(
            this.room.dangerousPlayerHostiles,
        );
        const useBoosts =
            expectedDamage > ATTACK_POWER * 50 ||
            (expectedHealing > RANGED_ATTACK_POWER * 100 &&
                !!this.colony.terminal &&
                !!this.colony.evolutionChamber);
        const percentWalls =
            _.filter(
                this.room.barriers,
                (s) => s.structureType == STRUCTURE_WALL,
            ).length / this.room.barriers.length;
        const meleeHostiles = _.filter(
            this.room.hostiles,
            (hostile) =>
                hostile.getActiveBodyparts(ATTACK) > 0 ||
                hostile.getActiveBodyparts(WORK) > 0,
        );
        const rangedHostiles = _.filter(
            this.room.hostiles,
            (hostile) => hostile.getActiveBodyparts(RANGED_ATTACK) > 0,
        );
        this.overlords.rangedDefense = new RangedDefenseOverlord(this);
        // If serious bunker busting attempt, spawn lurkers
        // TODO understand dismantlers damage output
        if (
            meleeHostiles.length > 0 &&
            expectedDamage > ATTACK_POWER * 70 &&
            (this.colony.level >= BarrierPlanner.settings.bunkerizeRCL ||
                rangedHostiles.length > 3)
        ) {
            this.overlords.bunkerDefense = new BunkerDefenseOverlord(this);
        }
        // If melee attackers, try distractions
        // TODO drop these if they don't work, need to detect effectiveness. Although the says make for great 🍿
        if (meleeHostiles.length > 0 && expectedDamage > 40 * ATTACK_POWER) {
            this.overlords.distraction = new DistractionOverlord(this);
        }
    }
    init() {
        const numHostiles = this.room
            ? this.room.hostiles.length.toString()
            : '???';
        this.alert(
            `Invasion (hostiles: ${numHostiles}) ${
                Game.time - this.memory.safeSince
            }`,
            NotifierPriority.Critical,
        );
    }
    // TODO record baddies needs to be redone in a more systemic fashion. But here for the 🍿
    recordBaddies() {
        if (!this.room) {
            return;
        }
        const mem = Memory.playerCreepTracker;
        const hostiles = this.room.hostiles;
        hostiles.forEach((creep) => {
            if (!mem[creep.owner.username]) {
                mem[creep.owner.username] = {
                    creeps: {},
                    types: {},
                    parts: {},
                    boosts: {},
                };
            }
            const playerMem = mem[creep.owner.username];
            if (!playerMem.creeps[creep.name]) {
                playerMem.creeps[creep.name] = Game.time;
                const creepType = creep.name.substr(0, creep.name.indexOf(' '));
                if (creepType == creep.name) {
                    // memory protection if they don't split name
                    return;
                }
                playerMem.types[creepType] =
                    playerMem.types[creepType] + 1 || 1;
                for (const bodyPart of creep.body) {
                    playerMem.parts[bodyPart.type] =
                        playerMem.parts[bodyPart.type] + 1 || 1;
                    if (bodyPart.boost) {
                        playerMem.boosts[bodyPart.boost] =
                            playerMem.boosts[bodyPart.boost] + 1 || 1;
                    }
                }
            }
        });
    }
    printPlayerExpenditure() {
        let t3Count = 0;
        let energyCount = 0;
        const mem = Memory.playerCreepTracker.inakrin;
        for (const boostid in mem.boosts) {
            const boost = mem.boosts[boostid];
            console.log(`${boostid} : ${boost * 30}`);
            t3Count += boost * 30;
            energyCount += 20;
        }
        for (const partType in mem.parts) {
            const partCount = mem.parts[partType];
            const cost = BODYPART_COST[partType];
            console.log(`${partType} : ${cost * partCount}`);
            energyCount += cost * partCount;
        }
        console.log(`Total T3 Cost: ${t3Count}`);
        console.log(`Total Energy Cost: ${energyCount}`);
    }
    cleanUpPlayerMem() {
        const mem = Memory.playerCreepTracker;
        for (const player of _.keys(mem)) {
            const tracker = mem[player];
            for (const creep of _.keys(tracker.creeps)) {
                if (tracker.creeps[creep] + 1500 < Game.time) {
                    delete tracker.creeps[creep];
                }
            }
        }
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
            this.recordBaddies();
        }
        // this.printPlayerExpenditure();
        if (Game.time % 5000 == 0) {
            // clean up, ya this shit
            this.cleanUpPlayerMem();
        }
        if (this.room && false);
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > this.safeEndTime
        ) {
            if (
                _.filter(
                    this.room.creeps,
                    (creep) => creep.hits < creep.hitsMax,
                ).length == 0
            ) {
                this.remove();
            }
        } else if (Game.time - this.memory.safeSince > 3000) {
            this.remove();
        }
    }
};
DirectiveInvasionDefense.directiveName = 'invasionDefense';
DirectiveInvasionDefense.color = COLOR_BLUE;
DirectiveInvasionDefense.secondaryColor = COLOR_PURPLE;
DirectiveInvasionDefense = __decorate([profile], DirectiveInvasionDefense);

/**
 * Spawns ranged defenders to defend against incoming player invasions in an owned room
 */
let SupportDefenseOverlord = class SupportDefenseOverlord extends CombatOverlord {
    constructor(
        directive,
        boosted = false,
        priority = OverlordPriority.defense.rangedDefense,
        minAmount = 1,
    ) {
        super(directive, 'rangedDefense', priority, 1);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.minAmount = minAmount;
    }
    handleDefender(hydralisk) {
        if (!this.room) {
            hydralisk.autoCombat(this.directive.pos.roomName);
        } else if (this.room.hostiles.length > 0) {
            hydralisk.autoCombat(this.room.name);
        } else {
            hydralisk.doMedicActions(this.room.name);
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.ranged);
        this.wishlist(1, CombatSetups.hydralisks.default);
    }
    run() {
        this.autoRun(this.hydralisks, (hydralisk) =>
            this.handleDefender(hydralisk),
        );
    }
};
SupportDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
SupportDefenseOverlord = __decorate([profile], SupportDefenseOverlord);

/**
 * Defend an owned room against an incoming player invasion
 */
let DirectiveSupportDefense = class DirectiveSupportDefense extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.spawns.length > 0);
    }
    spawnMoarOverlords() {
        this.overlords.rangedDefense = new SupportDefenseOverlord(
            this,
            false,
            OverlordPriority.defense.rangedDefense,
            this.memory.minAmount || 1,
        );
    }
    init() {
        const numHostiles = this.room
            ? this.room.hostiles.length.toString()
            : '???';
        this.alert(
            `Invasion (hostiles: ${numHostiles}) (stationary: ${
                this.memory.minAmount || 1
            }) (colony: ${this.colony.name})`,
            NotifierPriority.Critical,
        );
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 2500 &&
            this.room.hostileStructures.length == 0
        ) {
            if (
                _.filter(
                    this.room.creeps,
                    (creep) => creep.hits < creep.hitsMax,
                ).length == 0
            ) {
                this.remove();
            }
        }
    }
};
DirectiveSupportDefense.directiveName = 'supportDefense';
DirectiveSupportDefense.color = COLOR_BLUE;
DirectiveSupportDefense.secondaryColor = COLOR_GREEN;
DirectiveSupportDefense = __decorate([profile], DirectiveSupportDefense);

var DrainOverlord_1;
/**
 *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room
 */
let DrainOverlord = (DrainOverlord_1 = class DrainOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'drain', priority);
        this.directive = directive;
        this.spawnGroup = new SpawnGroup(this, { maxPathDistance: 10 * 50 });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
        });
    }
    handleHealer(healer) {
        healer.heal(healer);
        if (
            healer.needsToRecover(DrainOverlord_1.settings.retreatHitsPercent)
        ) {
            // Healer leads retreat to fallback position
            healer.goTo(CombatIntel.getFallbackFrom(this.directive.pos));
        } else {
            healer.goTo(this.pos);
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        } else {
            amount = 2;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        const healerSetup = CombatSetups.transfusers.drain;
        this.wishlist(amount, healerSetup);
    }
    run() {
        this.reassignIdleCreeps(Roles.healer);
        for (const healer of this.healers) {
            if (healer.hasValidTask) {
                healer.run();
            } else {
                if (healer.needsBoosts) {
                    this.handleBoosting(healer);
                } else {
                    this.handleHealer(healer);
                }
            }
        }
    }
});
DrainOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
DrainOverlord = DrainOverlord_1 = __decorate([profile], DrainOverlord);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectiveDrain = class DirectiveDrain extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlord = new DrainOverlord(this);
    }
    init() {
        this.alert('drain directive active');
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (
            this.room &&
            this.room.hostiles.length === 0 &&
            this.room.hostileStructures.length === 0
        ) {
            log.notify(
                `Pair siege mission at ${this.pos.roomName} completed successfully.`,
            );
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
        const fallback = CombatIntel.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: 'green' });
    }
};
DirectiveDrain.directiveName = 'drain';
DirectiveDrain.color = COLOR_RED;
DirectiveDrain.secondaryColor = COLOR_GREY;
DirectiveDrain = __decorate([profile], DirectiveDrain);

var HarassOverlord_1;
/**
 * Spawns ranged harassers to stop mining for an enemy room
 */
let HarassOverlord = (HarassOverlord_1 = class HarassOverlord extends (
    CombatOverlord
) {
    constructor(directive, priority = OverlordPriority.offense.harass) {
        super(directive, 'harass', priority, 1, 800);
        this.directive = directive;
        this.nibblers = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.spawnGroup.settings.maxPathDistance = 10 * 50;
    }
    handleHarass(hydralisk) {
        hydralisk.autoCombat(
            this.directive.memory.targetRemoteToHarass || hydralisk.room.name,
        );
        // this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
        if (!this.directive.memory.targetRemoteToHarass) {
            this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
        }
        if (
            this.directive.memory.targetRemoteToHarass &&
            hydralisk.room.name != this.directive.memory.targetRemoteToHarass
        ) {
            hydralisk.goToRoom(this.directive.memory.targetRemoteToHarass);
        } else if (hydralisk.room.dangerousHostiles.length > 2) {
            // Time to move on
            // Track when defense spawned
            hydralisk.room.dangerousHostiles.forEach((hostile) => {
                const nextSafeSpawn =
                    Game.time -
                    HarassOverlord_1.settings.prespawn +
                    (hostile.ticksToLive || 0);
                if (nextSafeSpawn > this.directive.memory.nextSpawnTime) {
                    this.directive.memory.nextSpawnTime = nextSafeSpawn;
                }
            });
            if (!this.directive.memory.targetRemoteToHarass) {
                this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
            } else if (
                this.room.name != this.directive.memory.targetRemoteToHarass
            ) {
                hydralisk.goToRoom(this.directive.memory.targetRemoteToHarass);
            }
        }
        // Clean up construction sites then move on to another room
    }
    chooseRemoteToHarass(hydralisk, currentRoom) {
        if (
            !this.directive.memory.roomsToHarass ||
            this.directive.memory.roomsToHarass.length == 0
        ) {
            this.directive.memory.roomsToHarass = this.directive.findNearbyReservedRoomsForHarassment();
        }
        const nextRoom = this.directive.memory.roomsToHarass.shift();
        if (nextRoom) {
            this.directive.memory.roomsToHarass.push(nextRoom);
            this.directive.memory.targetRemoteToHarass = nextRoom;
            log.info(
                `Selecting new target of ${this.directive.memory.targetRemoteToHarass} for ${hydralisk.print} from ${this.directive.memory.roomsToHarass}`,
            );
            hydralisk.say(`Tgt ${this.directive.memory.targetRemoteToHarass}`);
            hydralisk.goToRoom(this.directive.memory.targetRemoteToHarass);
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.ranged);
        this.reassignIdleCreeps(Roles.melee);
        const setup = this.directive.memory.mini
            ? CombatSetups.hydralisks.pita
            : CombatSetups.hydralisks.default;
        const numtoSpawn =
            !this.directive.memory.nextSpawnTime ||
            Game.time >= this.directive.memory.nextSpawnTime
                ? 1
                : 0;
        this.wishlist(numtoSpawn, setup);
    }
    run() {
        this.autoRun(this.hydralisks, (hydralisk) =>
            this.handleHarass(hydralisk),
        );
        this.autoRun(this.nibblers, (hydralisk) =>
            this.handleHarass(hydralisk),
        );
    }
});
HarassOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
    prespawn: 200,
};
HarassOverlord = HarassOverlord_1 = __decorate([profile], HarassOverlord);

/**
 * Harass Directive that wanders through enemy rooms killing stuff
 * Placed on an enemy room, it will harass all of it's remotes periodically
 */
let DirectiveHarass = class DirectiveHarass extends Directive {
    constructor(flag) {
        super(flag);
        this.memory.targetPlayer = RoomIntel.roomOwnedBy(flag.pos.roomName);
        this.memory.nextSpawnTime = Game.time;
        if (this.memory.targetPlayer == MY_USERNAME) {
            log.error(`Ahhhhhh harassing self in room ${flag.pos.roomName}`);
            this.remove();
        } else {
            log.alert(
                `Starting harass on ${flag.pos.roomName} owned by ${this.memory.targetPlayer}`,
            );
        }
        if (this.memory.targetPlayer) {
            this.memory.roomsToHarass = this.findNearbyReservedRooms(
                flag.pos.roomName,
                this.memory.targetPlayer,
            );
        } else {
            this.memory.roomsToHarass = [this.pos.roomName];
            this.memory.targetRemoteToHarass = this.pos.roomName;
        }
    }
    spawnMoarOverlords() {
        // For now, just spawn from RCL 5+ rooms
        this.overlords.harassOverlord = new HarassOverlord(this);
    }
    init() {
        // if
        // if (!this.memory.roomsToHarass && this.memory.targetPlayer)
    }
    findNearbyReservedRoomsForHarassment() {
        if (this.memory.targetPlayer) {
            return this.findNearbyReservedRooms(
                this.flag.pos.roomName,
                this.memory.targetPlayer,
            );
        }
        return [];
    }
    /**
     * Finds the rooms to harass
     *
     * @param roomName
     * @param playerName
     */
    findNearbyReservedRooms(roomName, playerName) {
        if (!this.memory.targetPlayer) {
            log.error(
                `Unable to find which player to harass in room ${roomName}`,
            );
            return [];
        }
        const whitelist = Memory.settings.allies;
        const reservedByTargetPlayer = [];
        const adjacentRooms = _.values(Game.map.describeExits(roomName));
        adjacentRooms.forEach((room) => {
            const reservation = RoomIntel.roomReservedBy(room);
            console.log('Checking for harass in room ' + room);
            if (
                reservation && this.memory.aggressive
                    ? !whitelist.includes(reservation)
                    : reservation == playerName
            ) {
                reservedByTargetPlayer.push(room);
                // This will double add rooms next to owned rooms, making it more likely to harass them
                _.values(Game.map.describeExits(room)).forEach((room) => {
                    if (RoomIntel.roomReservedBy(room) == playerName) {
                        reservedByTargetPlayer.push(room);
                    }
                    reservedByTargetPlayer.push(room);
                });
            }
        });
        let j, x, i;
        for (i = reservedByTargetPlayer.length - 1; i > 0; i--) {
            j = Math.floor(Math.random() * (i + 1));
            x = reservedByTargetPlayer[i];
            reservedByTargetPlayer[i] = reservedByTargetPlayer[j];
            reservedByTargetPlayer[j] = x;
        }
        Game.notify(
            `Looking for nearby rooms to harass, found ${reservedByTargetPlayer}`,
        );
        return reservedByTargetPlayer;
    }
    run() {
        // Probably something modifying frequency of harassment
        this.alert(
            `Harassing ${this.memory.targetPlayer} current: ${this.memory.targetRemoteToHarass}) `,
            NotifierPriority.High,
        );
    }
};
DirectiveHarass.directiveName = 'harass';
DirectiveHarass.color = COLOR_RED;
DirectiveHarass.secondaryColor = COLOR_WHITE;
DirectiveHarass = __decorate([profile], DirectiveHarass);

var PairDestroyerOverlord_1;
/**
 *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room
 */
let PairDestroyerOverlord = (PairDestroyerOverlord_1 = class PairDestroyerOverlord extends (
    Overlord
) {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority);
        this.directive = directive;
        this.attackers = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
        });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
        });
    }
    refresh() {
        super.refresh();
    }
    findTarget(attacker) {
        if (this.room === attacker.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(
                this.room.flags,
            );
            const targetedStructures = _.compact(
                _.map(targetingDirectives, (directive) =>
                    directive.getTarget(),
                ),
            );
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(
                    attacker.pos,
                    targetedStructures,
                );
            } else {
                // Target nearby hostile creeps
                const creepTarget = CombatTargeting.findClosestHostile(
                    attacker,
                    {
                        checkReachable: true,
                        ignoreCreepsAtEdge: true,
                        playerOnly: true,
                        onlyUnramparted: true,
                    },
                );
                if (creepTarget) return creepTarget;
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(
                    attacker,
                );
                if (structureTarget) return structureTarget;
            }
        }
    }
    attackActions(attacker, healer) {
        let target = this.findTarget(attacker);

        if (target) {
            if (attacker.pos.isNearTo(target)) {
                attacker.attack(target);
            } else {
                Movement.pairwiseMove(attacker, healer, target);
                attacker.autoMelee();
            }
        }
    }
    handleSquad(attacker) {
        const healer = attacker.findPartner(this.healers);
        // Case 1: you don't have an active healer
        if (!healer || healer.spawning || healer.needsBoosts) {
            // Wait near the colony controller if you don't have a healer
            if (
                attacker.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5
            ) {
                attacker.goTo(this.colony.controller, { range: 5 });
            } else {
                attacker.park();
            }
        }
        // Case 2: you have an active healer
        else {
            // Activate retreat condition if necessary
            // Handle recovery if low on HP
            if (
                attacker.needsToRecover(
                    PairDestroyerOverlord_1.settings.retreatHitsPercent,
                ) ||
                healer.needsToRecover(
                    PairDestroyerOverlord_1.settings.retreatHitsPercent,
                )
            ) {
                // Healer leads retreat to fallback position
                Movement.pairwiseMove(
                    healer,
                    attacker,
                    CombatIntel.getFallbackFrom(this.directive.pos),
                );
            } else {
                // Move to room and then perform attacking actions
                let target = this.findTarget(attacker);
                if (
                    attacker.pos.isEdge &&
                    target &&
                    attacker.pos.isNearTo(target)
                ) {
                    attacker.attack(target);
                } else if (!attacker.inSameRoomAs(this)) {
                    Movement.pairwiseMove(attacker, healer, this.pos);
                } else {
                    this.attackActions(attacker, healer);
                }
            }
        }
    }
    handleHealer(healer) {
        // If there are no hostiles in the designated room, run medic actions
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0
        ) {
            healer.doMedicActions(this.room.name);
            return;
        }
        const attacker = healer.findPartner(this.attackers);
        // Case 1: you don't have an attacker partner
        if (!attacker || attacker.spawning || attacker.needsBoosts) {
            if (healer.hits < healer.hitsMax) {
                healer.heal(healer);
            }
            // Wait near the colony controller if you don't have an attacker
            if (
                healer.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5
            ) {
                healer.goTo(this.colony.controller, { range: 5 });
            } else {
                healer.park();
            }
        }
        // Case 2: you have an attacker partner
        else {
            if (
                attacker.hitsMax - attacker.hits >
                healer.hitsMax - healer.hits
            ) {
                healer.heal(attacker);
            } else {
                healer.heal(healer);
            }
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        } else {
            amount = 1;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName) && this.pos.roomName != 'xxW59N31') {
            amount = 0;
        }
        const attackerPriority =
            this.attackers.length < this.healers.length
                ? this.priority - 0.1
                : this.priority + 0.1;
        const attackerSetup = CombatSetups.zerglings.boosted.armored;
        this.wishlist(amount, attackerSetup, { priority: attackerPriority });
        const healerPriority =
            this.healers.length < this.attackers.length
                ? this.priority - 0.1
                : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.default;
        this.wishlist(amount, healerSetup, { priority: healerPriority });
    }
    run() {
        this.reassignIdleCreeps(Roles.healer);
        this.reassignIdleCreeps(Roles.melee);
        for (const attacker of this.attackers) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (attacker.hasValidTask) {
                attacker.run();
            } else {
                if (attacker.needsBoosts) {
                    this.handleBoosting(attacker);
                } else {
                    this.handleSquad(attacker);
                }
            }
        }
        for (const healer of this.healers) {
            if (healer.hasValidTask) {
                healer.run();
            } else {
                if (healer.needsBoosts) {
                    this.handleBoosting(healer);
                } else {
                    this.handleHealer(healer);
                }
            }
        }
    }
});
PairDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
PairDestroyerOverlord = PairDestroyerOverlord_1 = __decorate(
    [profile],
    PairDestroyerOverlord,
);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectivePairDestroy = class DirectivePairDestroy extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new PairDestroyerOverlord(this);
    }
    init() {
        this.alert(`Pair destroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0
        ) {
            log.notify(
                `Pair destroyer mission at ${this.pos.roomName} completed successfully.`,
            );
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
        const fallback = CombatIntel.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: 'green' });
    }
};
DirectivePairDestroy.directiveName = 'destroy';
DirectivePairDestroy.color = COLOR_RED;
DirectivePairDestroy.secondaryColor = COLOR_CYAN;
DirectivePairDestroy = __decorate([profile], DirectivePairDestroy);

var RangedPairOverlord_1;
/**
 *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room
 */
let RangedPairOverlord = (RangedPairOverlord_1 = class RangedPairOverlord extends (
    Overlord
) {
    constructor(directive, priority = OverlordPriority.offense.rangedPair) {
        super(directive, 'rangedPair', priority);
        this.directive = directive;
        this.spawnGroup = new SpawnGroup(this, { maxPathDistance: 10 * 50 });
        this.rangedPairs = this.combatZerg(Roles.rangedPair, {
            notifyWhenAttacked: false,
        });
    }
    refresh() {
        super.refresh();
    }
    findTarget(rangedPair) {
        if (this.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(
                this.room.flags,
            );
            const targetedStructures = _.compact(
                _.map(targetingDirectives, (directive) =>
                    directive.getTarget(),
                ),
            );
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(
                    rangedPair.pos,
                    targetedStructures,
                );
            } else {
                // Target nearby hostile creeps
                const creepTarget = CombatTargeting.findClosestHostile(
                    rangedPair,
                    {
                        checkReachable: true,
                        ignoreCreepsAtEdge: true,
                        playerOnly: false,
                        onlyUnramparted: true,
                    },
                );
                if (creepTarget) return creepTarget;
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(
                    rangedPair,
                );
                if (structureTarget) return structureTarget;
            }
        } // TODO consider targets along path
    }
    
    
    findMoveAwayPosition(closeCreep, otherCreep) {
    let leader = closeCreep;
    if (!leader) {
        console.log('Debug: leader is null or undefined');
        return null;
    }

    let bestPosition = null;
    let highestSafetyScore = -Infinity;
    const centerPosition = new RoomPosition(25, 25, leader.pos.roomName);
    const terrain = Game.map.getRoomTerrain(leader.pos.roomName);
    const SWAMP_PENALTY = 9;

    let adjacentPositions = leader.pos.availableNeighbors();

    // Filter positions to be adjacent to the other creep
    adjacentPositions = adjacentPositions.filter(pos => pos.isNearTo(otherCreep.pos));

    console.log(`Debug: adjacentPositions length = ${adjacentPositions.length}`);

    _.forEach(adjacentPositions, (pos) => {
        let safetyScore = 0;

        if (!leader.room || !leader.room.hostiles) {
            console.log('Debug: leader.room or leader.room.hostiles is null or undefined');
            return;
        }

        _.forEach(leader.room.hostiles, (hostile) => {
            const distanceToHostile = pos.getRangeTo(hostile);
            safetyScore += distanceToHostile * distanceToHostile;
        });

        if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_SWAMP) {
            safetyScore -= SWAMP_PENALTY;
        }

        console.log(`Debug: safetyScore for position ${pos} = ${safetyScore}`);

        if (safetyScore > highestSafetyScore) {
            highestSafetyScore = safetyScore;
            bestPosition = pos;
        } else if (safetyScore === highestSafetyScore) {
            if (pos.getRangeTo(centerPosition) < bestPosition.getRangeTo(centerPosition)) {
                bestPosition = pos;
            }
        }
    });

    console.log(`Debug: bestPosition = ${bestPosition}`);
    return bestPosition;
}



    
    
    
    
    
    find2MoveAwayPosition(leader, follower, attackRange) {
        if (!leader || !follower) {
            console.log('Debug: leader or follower is null or undefined');
            return [null, null];
        }

        let bestPositions = [null, null];
        let highestCombinedSafetyScore = -Infinity;

        const leaderAdjacentPositions = leader.pos.availableNeighbors();
        const followerAdjacentPositions = follower.pos.availableNeighbors();
        // const leaderAdjacentPositions = [...leader.pos.availableNeighbors(), leader.pos];
        // const followerAdjacentPositions = [...follower.pos.availableNeighbors(), follower.pos];

        // Cache hostile positions for leader and follower
        let leaderHostiles = leader.room ? leader.room.hostiles : [];
        let followerHostiles = follower.room ? follower.room.hostiles : [];
        const centerPosition = new RoomPosition(25, 25, leader.pos.roomName);
        const terrain = Game.map.getRoomTerrain(leader.pos.roomName);
        const SWAMP_PENALTY = 9;
        
        leaderAdjacentPositions.forEach((leaderPos) => {
            let leaderSafetyScore = 0;
            leaderHostiles.forEach((hostile) => {
                let rangeToHostile = leaderPos.getRangeTo(hostile);
                leaderSafetyScore += rangeToHostile * rangeToHostile;
            });
            // Apply penalty for swamps for the leader
            if (terrain.get(leaderPos.x, leaderPos.y) & TERRAIN_MASK_SWAMP) {
                leaderSafetyScore -= SWAMP_PENALTY;
            }
            followerAdjacentPositions.forEach((followerPos) => {
                // Skip non-adjacent or equal positions
                if (
                    !leaderPos.isNearTo(followerPos) ||
                    leaderPos.isEqualTo(followerPos)
                ) {
                    return;
                }

                let followerSafetyScore = 0;
                followerHostiles.forEach((hostile) => {
                    let rangeToHostile = followerPos.getRangeTo(hostile);
                    followerSafetyScore += rangeToHostile * rangeToHostile;
                });

                // Apply penalty for swamps for the follower
                if (terrain.get(followerPos.x, followerPos.y) & TERRAIN_MASK_SWAMP) {
                    followerSafetyScore -= SWAMP_PENALTY;
                }
                let combinedSafetyScore =
                    leaderSafetyScore + followerSafetyScore;

                // Update best positions if this combination is safer
                if (combinedSafetyScore > highestCombinedSafetyScore) {
                    highestCombinedSafetyScore = combinedSafetyScore;
                    bestPositions = [leaderPos, followerPos];
                } else if (combinedSafetyScore === highestCombinedSafetyScore) {
                    if (leaderPos.getRangeTo(centerPosition) + followerPos.getRangeTo(centerPosition) <
                        bestPositions[0].getRangeTo(centerPosition) + bestPositions[1].getRangeTo(centerPosition)) {
                        bestPositions = [leaderPos, followerPos];
                        leader.say('c50');
                        follower.say('c50');
                    }
                }
            });
        });

        // console.log(`Debug: bestPositions = ${bestPositions}`);
        return bestPositions;
    }

    /*
    find2MoveAwayPosition(leader, follower, attackRange) {
    if (!leader || !follower) {
        console.log('Debug: leader or follower is null or undefined');
        return [null, null];
    }

    let bestPositions = [null, null];
    let highestCombinedSafetyScore = -Infinity;

    const leaderAdjacentPositions = [...leader.pos.availableNeighbors(), leader.pos];
    const followerAdjacentPositions = [...follower.pos.availableNeighbors(), follower.pos];

    let leaderHostiles = leader.room ? leader.room.hostiles : [];
    let followerHostiles = follower.room ? follower.room.hostiles : [];
    const centerPosition = new RoomPosition(25, 25, leader.pos.roomName);
    const terrain = Game.map.getRoomTerrain(leader.pos.roomName);
    const SWAMP_PENALTY = 9;
    
    leaderAdjacentPositions.forEach((leaderPos) => {
        let leaderSafetyScore = 0;
        leaderHostiles.forEach((hostile) => {
            let rangeToHostile = leaderPos.getRangeTo(hostile);
            leaderSafetyScore += rangeToHostile * rangeToHostile;
        });
        if (terrain.get(leaderPos.x, leaderPos.y) & TERRAIN_MASK_SWAMP) {
            leaderSafetyScore -= SWAMP_PENALTY;
        }
        followerAdjacentPositions.forEach((followerPos) => {
            if (leaderPos.isEqualTo(followerPos)) {
                return;
            }
            let rangeToLeader = leaderPos.getRangeTo(followerPos);
            if (rangeToLeader > 2) {
                return;
            }

            let followerSafetyScore = 0;
            followerHostiles.forEach((hostile) => {
                let rangeToHostile = followerPos.getRangeTo(hostile);
                followerSafetyScore += rangeToHostile * rangeToHostile;
            });
            if (terrain.get(followerPos.x, followerPos.y) & TERRAIN_MASK_SWAMP) {
                followerSafetyScore -= SWAMP_PENALTY;
            }
            let combinedSafetyScore = leaderSafetyScore + followerSafetyScore;

            if (combinedSafetyScore > highestCombinedSafetyScore) {
                highestCombinedSafetyScore = combinedSafetyScore;
                bestPositions = [leaderPos, followerPos];
            } else if (combinedSafetyScore === highestCombinedSafetyScore) {
                if (leaderPos.getRangeTo(centerPosition) + followerPos.getRangeTo(centerPosition) <
                    bestPositions[0].getRangeTo(centerPosition) + bestPositions[1].getRangeTo(centerPosition)) {
                    bestPositions = [leaderPos, followerPos];
                    leader.say('c50');
                    follower.say('c50');
                }
            }
        });
    });

    // Check if a creep needs to move out of its current position
    if (bestPositions[0].isEqualTo(follower.pos) || bestPositions[1].isEqualTo(leader.pos)) {
        let newLeaderPosition = leaderAdjacentPositions.find(pos => !pos.isEqualTo(leader.pos) && !pos.isEqualTo(bestPositions[1]));
        if (newLeaderPosition) {
            bestPositions[0] = newLeaderPosition;
        }
    }

    return bestPositions;
}
*/
/*
    attackActions(leader, follower) {
        let tooClose = false;
        // Find a target for the leader to attack.
        const target = this.findTarget(leader);
        if (!target) return; // Exit if no target is found.

        const attackRange = 3; // Define the optimal attack range.

        // Enable auto-ranged attack for both leader and follower.
        follower.autoRanged();
        leader.autoRanged();

        // Calculate the distance from both leader and follower to the target.
        let leaderRangeToTarget = leader.pos.getRangeTo(target);
        let followerRangeToTarget = follower.pos.getRangeTo(target);

        // Decide whether to swap leader and follower based on their proximity to the target or remaining life.
        if (
            (leaderRangeToTarget > 5 &&
                followerRangeToTarget < leaderRangeToTarget) ||
            (followerRangeToTarget === leaderRangeToTarget &&
                follower.ticksToLive > leader.ticksToLive)
        ) {
            [leader, follower] = [follower, leader]; // Swap leader and follower.
        }

        // Determine which unit might need to move away from the target.
        let unitToMove =
            leaderRangeToTarget < attackRange
                ? leader
                : followerRangeToTarget < attackRange
                ? follower
                : null;
        let otherUnit = unitToMove === leader ? follower : leader;

        // Both creeps are within attack range; find positions that are adjacent and at attack range
        if (
            leaderRangeToTarget < attackRange &&
            followerRangeToTarget < attackRange
        ) {
            const [leaderBestPos, followerBestPos] = this.find2MoveAwayPosition(
                leader,
                follower,
                attackRange,
            );

            if (leaderBestPos && followerBestPos) {
                leader.move(leader.pos.getDirectionTo(leaderBestPos));
                follower.move(follower.pos.getDirectionTo(followerBestPos));
                leader.say('dance');
                follower.say('dance');
                return;
            } else {
                // Explicitly handle the case where no good adjacent positions are found
                // This could involve another type of movement, logging a warning, etc.
                console.log(
                    'Warning: No suitable adjacent positions found for both units.',
                );
                // Fallback to other strategies or remain in place
            }
        }
        // If both creeps are outside the attack range, use pairwise move to approach the target
        else if (
            leaderRangeToTarget > attackRange &&
            followerRangeToTarget > attackRange
        ) {
            Movement.pairwiseMove(leader, follower, target, {
                range: attackRange,
            });
            return;
        }
        // If one of the units is too close to the target, move that unit away.
        else if (unitToMove) {
            const moveAwayPosition = this.findMoveAwayPosition(unitToMove);

            // Ensure that moving one unit away doesn't separate the pair.
            if (moveAwayPosition && moveAwayPosition.isNearTo(otherUnit.pos)) {
                unitToMove.say('tc');
                tooClose = true;
                unitToMove.move(
                    unitToMove.pos.getDirectionTo(moveAwayPosition),
                );
            } else if (moveAwayPosition) {
                Movement.pairwiseMove(leader, follower, moveAwayPosition); // Keep them together.
                return;
            }
        }

        // If both units are adjacent and at the optimal attack range, no further action is required.
        if (
            leader.pos.isNearTo(follower.pos) &&
            leaderRangeToTarget === attackRange &&
            followerRangeToTarget == attackRange
        ) {
            return;
        }

        // Find an optimal position for the follower to be closer to the target but still adjacent to the leader.
        // Convert followerNeighbors to a Set for quick lookups
        const followerNeighborsSet = new Set(
            follower.pos.availableNeighbors().map((pos) => JSON.stringify(pos)),
        );

        // Find overlapping neighboring positions using the Set
        const overlappingNeighbors = leader.pos
            .availableNeighbors()
            .filter((leaderPos) =>
                followerNeighborsSet.has(JSON.stringify(leaderPos)),
            );

        // Find optimal position
        const optimalPosition = overlappingNeighbors.find(
            (pos) =>
                pos.getRangeTo(target) < follower.pos.getRangeTo(target) &&
                pos.getRangeTo(target) <= leaderRangeToTarget,
        );

        // Move the follower to the optimal position if found.
        if (optimalPosition && !tooClose) {
            follower.say('gc' + follower.pos.getDirectionTo(optimalPosition));
            follower.move(follower.pos.getDirectionTo(optimalPosition));
        } else {
            // TODO (CHECK): swap leader and follower, and move closer
            follower.say('move closer!');
            if (!tooClose) {
                Movement.pairwiseMove(leader, follower, target, {
                    range: attackRange - 1,
                }); // Keep them together.
            }
        }
    }*/
findOptimalAttackPosition(creepAtThree, otherCreep, target) {
    if (!creepAtThree || !otherCreep || !target) {
        console.log('Debug: One or more of the parameters is null or undefined.');
        return null;
    }

    let bestPosition = null;
    let highestSafetyScore = -Infinity;
    const terrain = Game.map.getRoomTerrain(creepAtThree.pos.roomName);
    const SWAMP_PENALTY = 9;
    const DISTANCE_3_BONUS = 10000;  // Large bonus for positions at a distance of 3 from the target

    // We will only consider positions adjacent to the creepAtThree
    const adjacentPositions = creepAtThree.pos.availableNeighbors();

    _.forEach(adjacentPositions, (pos) => {
        // Ensure that the position is adjacent to both creeps
        if (!pos.isNearTo(otherCreep.pos)) {
            return;
        }

        let safetyScore = 0;

        if (!creepAtThree.room || !creepAtThree.room.hostiles) {
            console.log('Debug: creepAtThree.room or creepAtThree.room.hostiles is null or undefined');
            return;
        }

        // Sum up the squared distances to all hostiles to calculate the safety score
        _.forEach(creepAtThree.room.hostiles, (hostile) => {
            const distanceToHostile = pos.getRangeTo(hostile);
            safetyScore += distanceToHostile * distanceToHostile;
        });

        // Apply penalty for swamps
        if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_SWAMP) {
            safetyScore -= SWAMP_PENALTY;
        }

        // Add bonus for positions at a distance of 3 from the target
        if (pos.getRangeTo(target) === 3) {
            safetyScore += DISTANCE_3_BONUS;
        }

        // Update best position if this one is safer
        if (safetyScore > highestSafetyScore) {
            highestSafetyScore = safetyScore;
            bestPosition = pos;
        }
    });

    // If no position at a distance of 3 is found, find the closest position to the target
    if (!bestPosition || bestPosition.getRangeTo(target) !== 3) {
        const closestPosition = _.min(adjacentPositions, pos => {
            if (pos.isNearTo(otherCreep.pos)) {
                return pos.getRangeTo(target);
            }
            return Infinity; // If not adjacent to the other creep, make it a less preferred choice
        });

        if (closestPosition.getRangeTo(target) < creepAtThree.pos.getRangeTo(target)) {
            bestPosition = closestPosition;
        }
    }

    return bestPosition;
}


findOptimalThreePosition(creep1, creep2) {
    const terrain = Game.map.getRoomTerrain(creep1.pos.roomName);

    let bestPositionCreep1 = null;
    let bestPositionCreep2 = null;

    const hostilesInRange = creep1.pos.findInRange(creep1.room.hostiles, 3);

    // If only one hostile in range
    if (hostilesInRange.length === 1) {
        const singleHostile = hostilesInRange[0];
        const canAttack = singleHostile.getActiveBodyparts(ATTACK) > 0 || singleHostile.getActiveBodyparts(RANGED_ATTACK) > 0;

        if (!canAttack) {
            // Get positions that are closer (2 away) to the non-attacking hostile
            const getOptimalPosition = (creep, excludePositions = []) => {
                const positions = [creep.pos].concat(creep.pos.availableNeighbors()).filter(pos => !excludePositions.includes(pos));
                return positions.find(pos => {
                    return pos.getRangeTo(singleHostile) === 2;
                });
            };

            bestPositionCreep1 = getOptimalPosition(creep1);
            bestPositionCreep2 = getOptimalPosition(creep2, [bestPositionCreep1]);
            return [bestPositionCreep1, bestPositionCreep2];
        }

        // If the single hostile can attack, no need to move
        return [creep1.pos, creep2.pos];
    }

    // Check if any of the hostiles in range have damaged MOVE parts
    const damagedMoveHostiles = hostilesInRange.filter(hostile => {
        const moveParts = hostile.body.filter(part => part.type === MOVE);
        return moveParts.some(part => part.hits === 0);
    });
    
    if (false && damagedMoveHostiles.length > 0) {
        const closestMovingHostile = creep1.pos.findClosestByRange(creep1.room.hostiles.filter(hostile => hostile.getActiveBodyparts(MOVE)));
    
        const getOptimalPosition = (creep, adjacentTo = null, excludePositions = []) => {
            const positions = [creep.pos].concat(creep.pos.availableNeighbors()).filter(pos => !excludePositions.includes(pos));
            return positions.find(pos => {
                const isAdjacent = !adjacentTo || pos.getRangeTo(adjacentTo) === 1;
                return isAdjacent && pos.getRangeTo(closestMovingHostile) === 4;
            });
        };
    
        bestPositionCreep1 = getOptimalPosition(creep1);
        bestPositionCreep2 = getOptimalPosition(creep2, bestPositionCreep1, [creep1.pos, creep2.pos, bestPositionCreep1]);
    }
    
    // If best positions aren't found, it means the creeps should do nothing as per the requirement
    if (!bestPositionCreep1 || !bestPositionCreep2) {
        return [creep1.pos, creep2.pos];
    }
    
    return [bestPositionCreep1, bestPositionCreep2];

}













attackActions(leader, follower) {
    // Flag to check if a unit is too close to the target
    let tooClose = false;

    // Find a target for the leader to attack.
    const target = this.findTarget(leader);

    // If no target, exit the function
    if (!target) {
        leader.say("NoTgt");
        return;
    }

    const attackRange = 3; // Optimal range to maintain from the target for attacks

    // Prepare both units for a ranged attack
    follower.autoRanged();
    leader.autoRanged();

    // Calculate the distance of both units to the target
    let leaderRangeToTarget = leader.pos.getRangeTo(target);
    let followerRangeToTarget = follower.pos.getRangeTo(target);

    // Decide whether to swap roles of leader and follower based on proximity or life.
    if (
        (leaderRangeToTarget > 5 && followerRangeToTarget < leaderRangeToTarget) ||
        (followerRangeToTarget === leaderRangeToTarget && follower.ticksToLive > leader.ticksToLive)
    ) {
        [leader, follower] = [follower, leader]; // Swap roles
        leader.say("SwapL");
        follower.say("SwapF");
    }

    // If both units are too close to the target (< 3)
    if (leaderRangeToTarget < attackRange && followerRangeToTarget < attackRange) {
        const [leaderBestPos, followerBestPos] = this.find2MoveAwayPosition(leader, follower, attackRange);
        if (leaderBestPos && followerBestPos) {
            leader.move(leader.pos.getDirectionTo(leaderBestPos));
            follower.move(follower.pos.getDirectionTo(followerBestPos));
            leader.say("L:Dnc");
            follower.say("F:Dnc");
            return;
        } else {
            console.log('Warning: No suitable adjacent positions found.');
            return; // Exit as no suitable positions are found
        }
    }

    // If both units are outside the attack range (> 3)
    if (leaderRangeToTarget > attackRange && followerRangeToTarget > attackRange) {
        Movement.pairwiseMove(leader, follower, target, { range: attackRange });
        leader.say("L:Move");
        follower.say("F:Move");
        return;
    }

	// Case: One unit is at distance 3 and the other is < 3
	if ((leaderRangeToTarget === attackRange && followerRangeToTarget < attackRange) ||
		(followerRangeToTarget === attackRange && leaderRangeToTarget < attackRange)) {
		
		// Determine which unit is too close to the target
		let unitToAdjust = 
			leaderRangeToTarget < attackRange ? leader 
			: followerRangeToTarget < attackRange ? follower 
			: null;
        let otherCreep = unitToAdjust === leader ? follower : leader;

		if (unitToAdjust) {
			const adjustPosition = this.findMoveAwayPosition(unitToAdjust,otherCreep);
			if (adjustPosition) {
				unitToAdjust.say("Adjst");
				unitToAdjust.move(unitToAdjust.pos.getDirectionTo(adjustPosition));
				return;
			}
		}
	}

	// Case: One unit is at distance 3 and the other is > 3
	if ((leaderRangeToTarget === attackRange && followerRangeToTarget > attackRange) ||
		(followerRangeToTarget === attackRange && leaderRangeToTarget > attackRange)) {

		let creepAtThree = (leaderRangeToTarget === attackRange) ? leader : follower;
		let otherCreep = (creepAtThree === leader) ? follower : leader;

		// Check if the two creeps are adjacent
		if (creepAtThree.pos.isNearTo(otherCreep.pos)) {
			const optimalPosition = this.findOptimalAttackPosition(creepAtThree, otherCreep, target);
			
			if (optimalPosition) {
				otherCreep.say("OptPos");
				otherCreep.move(otherCreep.pos.getDirectionTo(optimalPosition));
			} else {
				otherCreep.say("Stay");
			}
		}
	}



    // If both units are at the optimal attack range (== 3), no action is needed
    if (leaderRangeToTarget === 3 && followerRangeToTarget === 3) {
        const [leaderOptimalPos, followerOptimalPos] = this.findOptimalThreePosition(leader, follower, target);
        
        if (leaderOptimalPos && followerOptimalPos) {
            leader.move(leader.pos.getDirectionTo(leaderOptimalPos));
            follower.move(follower.pos.getDirectionTo(followerOptimalPos));
            leader.say("L:Opt3");
            follower.say("F:Opt3");
        }
    }

}

    stompConstructionSite(rangedPair) {
        const enemyConstructionSites = rangedPair.room.find(
            FIND_HOSTILE_CONSTRUCTION_SITES,
            {
                filter: function (csite) {
                    return csite.progress > 0 && csite.pos.isWalkable(true);
                },
            },
        );
        const squashTarget = _.first(enemyConstructionSites);
        if (squashTarget) {
            rangedPair.goTo(squashTarget);
            return true;
        }
        return false;
    }
    HandlePairs(rangedPair, order) {
        if (this.pos.roomName != rangedPair.pos.roomName) {
            // zGeneral - 8/2023 attack on the path
            rangedPair.autoRanged();
        }
        // If there are no hostiles in the designated room, run medic actions then move to flag
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            (this.room.hostileStructures.length == 0 ||
                Cartographer.roomType(this.room.name) != ROOMTYPE_CONTROLLER)
        ) {
            if (!rangedPair.doMedicActions(this.room.name)) {
                if (this.stompConstructionSite(rangedPair) == false) {
                    if (rangedPair.pos.getRangeTo(this.pos) > 6) {
                        rangedPair.goTo(this.pos, { range: 5 }); // they might get separated but it is ok
                    }
                }
            }
            return;
        }
        const possiblePartners = this.rangedPairs.filter(
            (creep) => creep.id != rangedPair.id,
        );
        const partner = rangedPair.findPartner(possiblePartners);
        // Case 1: you don't have a partner
        if (!partner || partner.spawning || partner.needsBoosts) {
            if (rangedPair.hits < rangedPair.hitsMax) {
                rangedPair.heal(rangedPair);
            }
            // Wait near the colony controller if you don't have partner
            if (
                rangedPair.pos.getMultiRoomRangeTo(this.colony.controller.pos) >
                5
            ) {
                rangedPair.goTo(this.colony.controller, { range: 5 });
            } else {
                rangedPair.park();
            }
        }
        // Case 2: you have a partner
        else {
            // heal actions
            if (
                partner.hitsMax - partner.hits >
                rangedPair.hitsMax - rangedPair.hits
            ) {
                rangedPair.heal(partner);
            } else if (rangedPair.hits < rangedPair.hitsMax) {
                rangedPair.heal(rangedPair);
            } else {
                // over heal
                if (
                    rangedPair.room.hostiles.length > 0 ||
                    partner.room.hostiles.length > 0
                ) {
                    rangedPair.heal(rangedPair);
                    // partner.heal(rangedPair);
                }
            }
            // Activate retreat condition if necessary
            // Handle recovery if low on HP
            // The leader is the oldest of the pair
            if (
                rangedPair.needsToRecover(
                    RangedPairOverlord_1.settings.retreatHitsPercent,
                ) ||
                partner.needsToRecover(
                    RangedPairOverlord_1.settings.retreatHitsPercent,
                )
            ) {
                if (rangedPair.hits >= partner.hits) {
                    Movement.pairwiseMove(
                        rangedPair,
                        partner,
                        CombatIntel.getFallbackFrom(this.directive.pos),
                    );
                } else {
                    Movement.pairwiseMove(
                        partner,
                        rangedPair,
                        CombatIntel.getFallbackFrom(this.directive.pos),
                    );
                }
                
                rangedPair.autoRanged();
                partner.autoRanged();
            } else if (rangedPair.pos.isEdge || partner.pos.isEdge) {
                //trying to catch edge bousning bug
                // TODO: there was an edge bouncing bug that got hack here, to investigate and solve properly.
                rangedPair.goTo(this.pos);
                partner.goTo(this.pos);
                partner.autoRanged();
                rangedPair.autoRanged();
            } else if (
                rangedPair.ticksToLive &&
                partner.ticksToLive &&
                rangedPair.ticksToLive >= partner.ticksToLive
            ) {
                // Move to room and then perform attacking actions
                if (
                    !rangedPair.inSameRoomAs(this) ||
                    !partner.inSameRoomAs(this)
                ) {
                    Movement.pairwiseMove(rangedPair, partner, this.pos);
                    rangedPair.autoRanged();
                    partner.autoRanged();
                } else {
                    this.attackActions(rangedPair, partner);
                }
            }
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        } else {
            amount = 2;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName) && this.pos.roomName != 'xxW59N31') {
            amount = 0;
        }
        if (
            this.room &&
            this.directive.memory.boosted == false &&
            // RoomIntel.getSafetyData(this.pos.roomName).numBoostedHostiles
            _.filter(this.room.hostiles, (hostile) => hostile.boosts.length > 0)
                .length > 0
        ) {
            this.directive.memory.boosted = true;
        }
        const rangedPairSetup = this.directive.memory.boosted
            ? CombatSetups.hydralisks.boosted.default
            : CombatSetups.hydralisks.default;
        this.wishlist(amount, rangedPairSetup, { priority: this.priority });
    }
    run() {
        this.reassignIdleCreeps(Roles.rangedPair);
        let order = 0;
        for (const rangedPair of this.rangedPairs) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (rangedPair.hasValidTask) {
                rangedPair.run();
            } else {
                order++;
                if (rangedPair.needsBoosts) {
                    this.handleBoosting(rangedPair);
                } else {
                    this.HandlePairs(rangedPair, order);
                }
            }
        }
    }
});
RangedPairOverlord.settings = {
    retreatHitsPercent: 0.70,
    reengageHitsPercent: 0.92,
};
RangedPairOverlord = RangedPairOverlord_1 = __decorate(
    [profile],
    RangedPairOverlord,
);

var DirectiveRangedPair_1;
/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectiveRangedPair = (DirectiveRangedPair_1 = class DirectiveRangedPair extends (
    Directive
) {
    constructor(flag) {
        super(flag);
        if (this.memory.boosted === undefined) {
            if (this.flag.name.includes('lite')) {
                this.memory.boosted = false;
            } else {
                this.memory.boosted = true;
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords.rangedPairs = new RangedPairOverlord(this);
    }
    init() {
        this.alert(`Ranged Pairs directive active`);
    }
    run() {
        if (
            !this.room ||
            this.room.playerHostiles.length > 0 ||
            this.room.invaders.length > 0
        ) {
            return;
        }
        const roomType = Cartographer.roomType(this.room.name);
        switch (roomType) {
            case ROOMTYPE_CONTROLLER:
                if (
                    this.room.controller.level == 0 &&
                    this.room.hostiles.length == 0 &&
                    this.room.hostileStructures.length == 0 &&
                    RoomIntel.getSafetyData(this.pos.roomName).safeFor >
                        DirectiveRangedPair_1.settings.safeTimerLimit &&
                    _.filter(
                        this.room.creeps,
                        (creep) => creep.hits < creep.hitsMax,
                    ).length == 0
                ) {
                    log.notify(
                        `Ranged Pair mission at ${this.pos.roomName} completed successfully.`,
                    );
                    this.remove();
                }
                break;
            case ROOMTYPE_SOURCEKEEPER:
            case ROOMTYPE_CORE:
                if (this.room.invaders.length == 0) {
                    log.notify(
                        `Ranged Pair mission at ${this.pos.roomName} completed successfully.`,
                    );
                    this.remove();
                }
                break;
            case ROOMTYPE_ALLEY:
            case ROOMTYPE_CROSSROAD:
                if (
                    this.room.hostiles.length == 0 &&
                    !(this.flag && this.flag.pos.lookForStructure(STRUCTURE_POWER_BANK)) // zgeneral 16/10/2023
                ) {
                    log.notify(
                        `Ranged Pair mission at ${this.pos.roomName} completed successfully.`,
                    );
                    this.remove();
                }
                break;
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
        const fallback = CombatIntel.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: 'green' });
    }
});
DirectiveRangedPair.directiveName = 'rangedPair';
DirectiveRangedPair.color = COLOR_RED;
DirectiveRangedPair.secondaryColor = COLOR_BLUE;
DirectiveRangedPair.settings = {
    safeTimerLimit: 200,
};
DirectiveRangedPair = DirectiveRangedPair_1 = __decorate(
    [profile],
    DirectiveRangedPair,
);

/**
 *  Siege overlord - spawns dismantler pairs for destruction of structures within a hostile room
 */
let PairSiegeOverlord = class PairSiegeOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.remoteSiege) {
        super(directive, 'lurker', priority);
        this.directive = directive;
        this.spawnGroup = new SpawnGroup(this, { maxPathDistance: 10 * 50 });
        this.attackers = this.combatZerg(Roles.dismantler, {
            notifyWhenAttacked: false,
        });
    }
    findTarget(attacker) {
        if (this.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(
                this.room.flags,
            );
            const targetedStructures = _.compact(
                _.map(targetingDirectives, (directive) =>
                    directive.getTarget(),
                ),
            );
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(
                    attacker.pos,
                    targetedStructures,
                );
            } else {
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(
                    attacker,
                );
                if (structureTarget) {
                    return structureTarget;
                }
            }
        }
    }
    attackActions(attacker) {
        const target = this.findTarget(attacker);
        if (target) {
            if (attacker.pos.isNearTo(target)) {
                attacker.dismantle(target);
            } else {
                Movement.goTo(attacker, target);
                attacker.autoMelee();
            }
        }
    }
    handleSquad(attacker) {
        // Move to room and then perform attacking actions
        if (!attacker.inSameRoomAs(this)) {
            Movement.goTo(attacker, this.pos);
        } else {
            this.attackActions(attacker);
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        } else {
            amount = 2;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        this.wishlist(amount, CombatSetups.dismantlers.strong, {
            priority: this.priority,
        });
    }
    run() {
        for (const attacker of this.attackers) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (attacker.hasValidTask) {
                attacker.run();
            } else {
                this.handleSquad(attacker);
            }
        }
    }
};
PairSiegeOverlord = __decorate([profile], PairSiegeOverlord);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectivePairSiege = class DirectivePairSiege extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.siege = new PairSiegeOverlord(this);
    }
    init() {
        this.alert('Pair siege directive active');
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (
            this.room &&
            this.room.hostiles.length === 0 &&
            this.room.hostileStructures.length === 0
        ) {
            log.notify(
                `Pair siege mission at ${this.pos.roomName} completed successfully.`,
            );
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
};
DirectivePairSiege.directiveName = 'siege';
DirectivePairSiege.color = COLOR_RED;
DirectivePairSiege.secondaryColor = COLOR_YELLOW;
DirectivePairSiege = __decorate([profile], DirectivePairSiege);

/**
 * SwarmOverlords extend the base CombatOverlord class, providing additional methods for spawning and controlling swarms
 */
let SwarmOverlord = class SwarmOverlord extends CombatOverlord {
    /* Wishlist of creeps to simplify spawning logic; includes automatic reporting */
    // TODO: at the moment, this assumes that every swarm within an overlord is the same configuration
    swarmWishlist(swarmQuantity, config) {
        // Make tables to log current and needed creep quantities
        const creepQuantities = {};
        const neededQuantities = {};
        // Handle filling out existing swarms first
        const validSwarms = _.filter(this.swarms, (swarm) => !swarm.isExpired);
        for (const swarm of validSwarms) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                const existingCreepsOfRole = _.filter(
                    swarm.creeps,
                    (creep) => creep.roleName == setup.role,
                );
                // Log current and needed amounts for reporting
                if (!creepQuantities[setup.role]) {
                    creepQuantities[setup.role] = 0;
                }
                creepQuantities[setup.role] += existingCreepsOfRole.length;
                if (!neededQuantities[setup.role]) {
                    neededQuantities[setup.role] = 0;
                }
                neededQuantities[setup.role] += amount;
                // Spawn the needed quantity of creeps
                const spawnQuantity = amount - existingCreepsOfRole.length;
                for (let i = 0; i < spawnQuantity; i++) {
                    this.requestCreep(setup, { priority: priority });
                }
            }
        }
        // Spawn new swarms as needed
        const numRemainingSwarms = swarmQuantity - validSwarms.length;
        for (let n = 0; n < numRemainingSwarms; n++) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                if (!neededQuantities[setup.role]) {
                    neededQuantities[setup.role] = 0;
                }
                neededQuantities[setup.role] += amount;
                for (let i = 0; i < amount; i++) {
                    this.requestCreep(setup, { priority: priority + 0.5 });
                }
            }
        }
        // Report creep amounts
        for (const role of _.keys(neededQuantities)) {
            this.creepReport(
                role,
                creepQuantities[role] || 0,
                neededQuantities[role],
            );
        }
    }
};
SwarmOverlord = __decorate([profile], SwarmOverlord);

/**
 * Spawns squads of attackers and healers to siege a hostile room, moving with swarm logic in a coordinated fashion
 */
let SwarmDestroyerOverlord = class SwarmDestroyerOverlord extends SwarmOverlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority, 8);
        this.directive = directive;
        this.spawnGroup.settings.maxPathDistance = 10 * 50;
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.intel = new CombatIntel(this.directive);
        this.zerglings = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
        });
        // this.hydralisks = this.combatZerg(Roles.ranged, {
        // 	notifyWhenAttacked: false,
        // 	boostWishlist     : [BOOST_TIERS.ranged[3], BOOST_TIERS.tough[3], BOOST_TIERS.move[3]]
        // });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
        });
        // Make swarms
        this.makeSwarms();
        // Compute fallback positions and assembly points
        this.fallback = $.pos(
            this,
            'fallback',
            () =>
                this.intel.findSwarmAssemblyPointInColony({
                    width: 2,
                    height: 2,
                }),
            200,
        );
        this.assemblyPoints = [];
        // Bug note, it does not guarantee walkable positions, swam can get stuck trying to form a quad at colony
        for (let i = 0; i < _.keys(this.swarms).length + 1; i++) {
            this.assemblyPoints.push(
                $.pos(
                    this,
                    `assemble_${i}`,
                    () =>
                        this.intel.findSwarmAssemblyPointInColony(
                            { width: 2, height: 2 },
                            i + 1,
                        ),
                    200,
                ),
            );
        }
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.makeSwarms();
    }
    makeSwarms() {
        this.swarms = {};
        const meleeZerg = [...this.zerglings, ...this.healers];
        // let rangedZerg: CombatZerg[] = this.hydralisks;
        const maxPerSwarm = {
            [Roles.melee]: 2,
            [Roles.healer]: 2,
            [Roles.ranged]: 4,
        };
        const meleeZergBySwarm = _.groupBy(meleeZerg, (zerg) =>
            zerg.findSwarm(meleeZerg, maxPerSwarm),
        );
        // let rangedZergBySwarm = _.groupBy(rangedZerg, zerg => zerg.findSwarm(rangedZerg, maxPerSwarm));
        // let zergBySwarm = _.merge(meleeZergBySwarm, rangedZergBySwarm);
        for (const ref in meleeZergBySwarm) {
            if (ref != undefined) {
                this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
            }
        }
        // for (let ref in rangedZergBySwarm) { // todo: finish changing
        // 	if (ref != undefined) {
        // 		if (DEBUG) log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);
        // 		this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
        // 	}
        // }
    }
    handleSwarm(swarm, index, waypoint = this.directive.pos) {
        // Swarm initially groups up at fallback location
        if (!swarm.memory.initialAssembly) {
            const assemblyPoint = this.assemblyPoints[index] || this.fallback;
            log.debug(`Assmbling at ${assemblyPoint.print}`);
            swarm.memory.initialAssembly = swarm.assemble(assemblyPoint);
            return;
        }
        // Swarm has now initially assembled with all members present
        // log.debug(`Done assmbling`);
        const room = swarm.rooms[0];
        if (!room) {
            log.warning(`${this.print} No room! (Why?)`);
        }
        // Siege the room
        const nearbyHostiles = _.filter(
            room.hostiles,
            (creep) => swarm.minRangeTo(creep) <= 3 + 1,
        );
        const attack = _.sum(nearbyHostiles, (creep) =>
            CombatIntel.getAttackDamage(creep),
        );
        const rangedAttack = _.sum(nearbyHostiles, (creep) =>
            CombatIntel.getRangedAttackDamage(creep),
        );
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(
            _.map(swarm.creeps, (c) => c.creep),
        );
        const canPopShield =
            (attack +
                rangedAttack +
                CombatIntel.towerDamageAtPos(swarm.anchor)) *
                myDamageMultiplier >
            _.min(
                _.map(
                    swarm.creeps,
                    (creep) => 100 * creep.getActiveBodyparts(TOUGH),
                ),
            );
        if (
            canPopShield ||
            room.hostileStructures.length == 0 ||
            _.values(this.swarms).length > 1
        ) {
            swarm.autoCombat(this.pos.roomName, waypoint);
        } else {
            swarm.autoSiege(this.pos.roomName, waypoint);
        }
    }
    init() {
        let numSwarms = this.directive.memory.amount || 1;
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            numSwarms = 0;
        }
        const zerglingPriority =
            this.zerglings.length <= this.healers.length
                ? this.priority - 0.1
                : this.priority + 0.1;
        const zerglingSetup = CombatSetups.zerglings.boosted.armored;
        const healerPriority =
            this.healers.length < this.zerglings.length
                ? this.priority - 0.1
                : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.armored;
        const hydraliskPriority =
            this.healers.length < this.zerglings.length
                ? this.priority - 0.1
                : this.priority + 0.1;
        const swarmConfig = [
            { setup: zerglingSetup, amount: 2, priority: zerglingPriority },
            { setup: healerSetup, amount: 2, priority: healerPriority },
        ];
        this.swarmWishlist(numSwarms, swarmConfig);
        // const rangedSwarmConfig = [{setup: hydraliskSetup, amount: 4, priority: hydraliskPriority}];
        // this.swarmWishlist(numSwarms, rangedSwarmConfig);
    }
    run() {
        this.autoRun(this.zerglings, (zergling) => undefined); // zergling => undefined is to handle boosting
        this.autoRun(this.healers, (healer) => undefined);
        // this.autoRun(this.hydralisks, hydralisk => undefined);
        // Run swarms in order
        const refs = _.keys(this.swarms).sort();
        let i = 0;
        for (const ref of refs) {
            this.handleSwarm(this.swarms[ref], i);
            i++;
        }
    }
    visuals() {
        Visualizer.marker(this.fallback, { color: 'green' });
        for (const ref in this.swarms) {
            const swarm = this.swarms[ref];
            Visualizer.marker(swarm.anchor, { color: 'blue' });
            if (swarm.target) {
                Visualizer.marker(swarm.target.pos, { color: 'orange' });
            }
        }
    }
};
SwarmDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
SwarmDestroyerOverlord = __decorate([profile], SwarmDestroyerOverlord);

var DirectiveSwarmDestroy_1;
/**
 * Spawns a 2x2 squad of coordinated creeps to destroy a room
 */
let DirectiveSwarmDestroy = (DirectiveSwarmDestroy_1 = class DirectiveSwarmDestroy extends (
    Directive
) {
    constructor(flag) {
        super(
            flag,
            (colony) => colony.level >= DirectiveSwarmDestroy_1.requiredRCL,
        );
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new SwarmDestroyerOverlord(this);
    }
    init() {
        this.alert(`Swarm destroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (
            this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0
        ) {
            log.notify(
                `Swarm destroyer mission at ${this.pos.roomName} completed successfully.`,
            );
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
});
DirectiveSwarmDestroy.directiveName = 'destroy';
DirectiveSwarmDestroy.color = COLOR_RED;
DirectiveSwarmDestroy.secondaryColor = COLOR_RED;
DirectiveSwarmDestroy.requiredRCL = 6;
DirectiveSwarmDestroy = DirectiveSwarmDestroy_1 = __decorate(
    [profile],
    DirectiveSwarmDestroy,
);

/**
 *  Siege overlord - spawns dismantler pairs for destruction of structures within a hostile room
 */
let SwarmDismantleOverlord = class SwarmDismantleOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.remoteSiege) {
        super(directive, 'lurker', priority);
        this.directive = directive;
        this.spawnGroup = new SpawnGroup(this, { maxPathDistance: 15 * 50 });
        this.needsContainer = !!(
            this.room && !(this.room.owner && !this.room.my)
        );
        if (this.room && this.needsContainer) {
            this.container = this.directive.pos.findClosestByLimitedRange(
                this.room.containers,
                5,
            );
            this.constructionSite = _.first(
                this.directive.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 5),
            );
            if (!this.container && !this.constructionSite) {
                const result = this.room.createConstructionSite(
                    this.directive.pos,
                    STRUCTURE_CONTAINER,
                );
                if (result !== OK) {
                    this.needsContainer = false;
                }
            }
        }
        this.attackers = this.combatZerg(Roles.dismantler, {
            notifyWhenAttacked: false,
        });
    }
    findTarget(attacker) {
        if (this.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(
                this.room.flags,
            );
            const targetedStructures = _.compact(
                _.map(targetingDirectives, (directive) =>
                    directive.getTarget(),
                ),
            );
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(
                    attacker.pos,
                    targetedStructures,
                );
            } else {
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedDismantleStructure(
                    attacker,
                    true,
                );
                if (structureTarget) {
                    return structureTarget;
                } else if (this.room.constructedWalls.length > 0) {
                    const closestReachable = CombatTargeting.findClosestReachable(
                        attacker.pos,
                        this.room.constructedWalls,
                    );
                    if (closestReachable) return closestReachable;
                }
            }
        }
    }
    attackActions(dismantler) {
        const target = this.findTarget(dismantler);
        if (target) {
            // will auto timeout after 100 ticks
            dismantler.task = Tasks.dismantle(target);
        }
    }
    handleSquad(dismantler) {
        // Move to room and then perform attacking actions
        if (!dismantler.inSameRoomAs(this)) {
            Movement.goTo(dismantler, this.pos);
        } else {
            /*
            if (this.needsContainer &&
                dismantler.carry.energy >= dismantler.carryCapacity &&
                dismantler.carryCapacity > 0) {
                if (this.constructionSite) {
                    dismantler.task = Tasks.build(this.constructionSite);
                    return;
                }
                else if (this.container) {
                    if (this.container.hits < this.container.hitsMax * 0.8) {
                        dismantler.task = Tasks.repair(this.container);
                        return;
                    }
                    else {
                        dismantler.task = Tasks.transferAll(this.container);
                        return;
                    }
                }
            }
            */
            this.attackActions(dismantler);
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        } else {
            amount = 2;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        this.wishlist(amount, CombatSetups.dismantlers.default, {
            priority: this.priority,
        });
        /*
        if (this.needsContainer &&
            this.colony.room.energyCapacityAvailable >=
                patternCost(CombatSetups.dismantlers.fast)) {
            this.wishlist(amount, CombatSetups.dismantlers.fast, {
                priority: this.priority,
            });
        }
        else if (this.needsContainer &&
            this.colony.room.energyCapacityAvailable >=
                patternCost(CombatSetups.dismantlers.slow)) {
            this.wishlist(amount, CombatSetups.dismantlers.slow, {
                priority: this.priority,
            });
        }
        else {
            this.wishlist(amount, CombatSetups.dismantlers.default, {
                priority: this.priority,
            });
        }
        if (this.container) {
            const transportCapacity = 200 * this.colony.level;
            const threshold = this.colony.stage > ColonyStage.Larva ? 0.8 : 0.5;
            if (sumStore(this.container.store) >
                threshold * transportCapacity) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    amount: sumStore(this.container.store),
                    dAmountdt: 1,
                });
            }
        }*/
    }
    run() {
        for (const attacker of this.attackers) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (attacker.hasValidTask) {
                attacker.run();
            } else {
                this.handleSquad(attacker);
            }
        }
    }
};
SwarmDismantleOverlord = __decorate([profile], SwarmDismantleOverlord);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectiveSwarmDismantle = class DirectiveSwarmDismantle extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.siege = new SwarmDismantleOverlord(this);
    }
    init() {
        this.alert('Swarm room clear dismantle directive active');
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (
            this.room &&
            this.room.hostiles.length === 0 &&
            this.room.hostileStructures.length === 0 &&
            this.room.constructedWalls.length === 0
        ) {
            log.notify(
                `Swarm room clear dismantle mission at ${this.pos.roomName} completed successfully.`,
            );
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
};
DirectiveSwarmDismantle.directiveName = 'swarmdismantle';
DirectiveSwarmDismantle.color = COLOR_RED;
DirectiveSwarmDismantle.secondaryColor = COLOR_GREEN;
DirectiveSwarmDismantle = __decorate([profile], DirectiveSwarmDismantle);

function setOverlord$1(creep, newOverlord) {
    // Remove cache references to old assignments
    const roleName = creep.memory.role;
    const ref = creep.memory['O' /* OVERLORD */];
    const oldOverlord = ref ? Overmind.overlords[ref] : null;
    if (
        ref &&
        Overmind.cache.overlords[ref] &&
        Overmind.cache.overlords[ref][roleName]
    ) {
        _.remove(
            Overmind.cache.overlords[ref][roleName],
            (name) => name == creep.name,
        );
    }
    if (newOverlord) {
        // Change to the new overlord's colony
        creep.memory['C' /* COLONY */] = newOverlord.colony.name;
        // Change assignments in memory
        creep.memory['O' /* OVERLORD */] = newOverlord.ref;
        // Update the cache references
        if (!Overmind.cache.overlords[newOverlord.ref]) {
            Overmind.cache.overlords[newOverlord.ref] = {};
        }
        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
            Overmind.cache.overlords[newOverlord.ref][roleName] = [];
        }
        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);
    } else {
        creep.memory['O' /* OVERLORD */] = null;
    }
    if (oldOverlord) oldOverlord.recalculatePowerCreeps();
    if (newOverlord) newOverlord.recalculatePowerCreeps();
}
function getOverlord$1(creep) {
    if (creep.memory['O' /* OVERLORD */]) {
        return Overmind.overlords[creep.memory['O' /* OVERLORD */]] || null;
    } else {
        return null;
    }
}
/**
 * Base class for all PowerCreeps. Note that PowerZerg will only wrap a power creep which is actively spawned in the
 * world since Power Creeps are always present in Game.powerCreeps, regardless if they are spawned in.
 */
let PowerZerg = class PowerZerg extends AnyZerg {
    constructor(powerCreep, notifyWhenAttacked = true) {
        super(powerCreep, notifyWhenAttacked);
        this.isPowerZerg = true;
        // Copy all power creep properties which are not contained in AnyZerg
        this.className = powerCreep.className;
        this.deleteTime = powerCreep.deleteTime;
        this.level = powerCreep.level;
        this.powers = powerCreep.powers;
        this.shard = powerCreep.shard;
        this.spawnCooldownTime = powerCreep.spawnCooldownTime;
        this.isSpawned = !!this.shard && !!this.ticksToLive;
        // PowerZerg room is casted to its overlord's colony's room if it is not spawned in
        if (this.room == undefined && this.overlord) {
            this.room = this.overlord.colony.room;
        }
        if (this.pos == undefined && this.overlord) {
            this.pos = this.overlord.colony.powerSpawn
                ? this.overlord.colony.powerSpawn.pos
                : this.overlord.colony.pos;
        }
        Overmind.powerZerg[this.name] = this;
    }
    refresh() {
        // super.refresh(); // doesn't call super.refresh()
        const powerCreep = Game.powerCreeps[this.name];
        if (powerCreep) {
            this.creep = powerCreep;
            this.pos = powerCreep.pos;
            this.nextPos = powerCreep.pos;
            this.carry = powerCreep.carry;
            this.store = powerCreep.store;
            this.carryCapacity = powerCreep.carryCapacity;
            this.hits = powerCreep.hits;
            this.memory = powerCreep.memory;
            this.room = powerCreep.room; // not actually as Room
            this.saying = powerCreep.saying;
            this.ticksToLive = powerCreep.ticksToLive;
            this.actionLog = {};
            this.blockMovement = false;
            this.deleteTime = powerCreep.deleteTime;
            this.level = powerCreep.level;
            this.powers = powerCreep.powers;
            this.shard = powerCreep.shard;
            this.spawnCooldownTime = powerCreep.spawnCooldownTime;
            this.isSpawned = !!this.shard && !!this.ticksToLive;
            if (this.room == undefined && this.overlord) {
                this.room = this.overlord.colony.room;
            }
            if (this.pos == undefined && this.overlord) {
                this.pos = this.overlord.colony.powerSpawn
                    ? this.overlord.colony.powerSpawn.pos
                    : this.overlord.colony.pos;
            }
        } else {
            log.debug(`Deleting ${this.print} from global`);
            delete Overmind.powerZerg[this.name];
            delete global[this.name];
        }
    }
    /**
     * Delete the power creep permanently from your account. It should NOT be spawned in the world. The creep is not
     * deleted immediately, but a 24-hour delete time is started (see `deleteTime`).
     * You can cancel deletion by calling `delete(true)`.
     */
    delete(cancel) {
        return this.creep.delete(cancel);
    }
    /**
     * Enable power usage in this room. The room controller should be at adjacent tile.
     */
    enableRoom(controller) {
        return this.creep.enableRoom(controller);
    }
    // /**
    //  * Rename the power creep. It must not be spawned in the world.
    //  */
    // rename(name: string): OK | ERR_NOT_OWNER | ERR_NAME_EXISTS | ERR_BUSY {
    // 	return this.creep.rename(name);
    // }
    /**
     * Instantly restore time to live to the maximum using a Power Spawn or a Power Bank nearby.
     */
    renew(target) {
        return this.creep.renew(target);
    }
    spawn(powerSpawn) {
        return this.creep.spawn(powerSpawn);
    }
    /**
     * Upgrade the creep, adding a new power ability to it or increasing the level of the existing power.
     * You need one free Power Level in your account to perform this action.
     */
    upgrade(power) {
        return this.creep.upgrade(power);
    }
    // /**
    //  * Apply one of the creep's powers on the specified target.
    //  */
    // protected usePower(power: PowerConstant, target?: RoomObject): ScreepsReturnCode {
    // 	return this.creep.usePower(power, target);
    // }
    /**
     * Generate 1/2/4/6/8 ops resource units. Cooldown 50 ticks. Required creep level: 0/2/7/14/22.
     * (I assume this method will be common to all power creep classes.)
     */
    generateOps() {
        return this.creep.usePower(PWR_GENERATE_OPS);
    }
    canUsePowers(powerId, cooldownThreshold = 0) {
        // get power usage cost in ops from POWER_INFO list
        const cost = _.get(POWER_INFO[powerId], 'ops', 0);
        return (
            !!this.creep.room &&
            this.creep.store[RESOURCE_OPS] >= cost &&
            this.creep.powers[powerId] &&
            this.creep.powers[powerId].level > 0 &&
            this.creep.powers[powerId].cooldown <= cooldownThreshold
        );
    }
};
PowerZerg = __decorate([profile], PowerZerg);

const PowerCreepNames = [
    'Zagara',
    'Dehaka',
    'Maar',
    'Zurvan',
    'Yagdra',
    'Brakk',
    'Dakrun',
    'Niadra',
    'Naktul',
    'Murvar',
    'Kraith',
    'Alexei',
    'Aleksander',
    'Torrasque',
    'Kukulza',
    'Frayne',
    'Matriarch',
    'Morik',
];
if (PowerCreepNames.length != _.unique(PowerCreepNames).length) {
    log.error(`PowerCreepNames not unique!`);
}
const PowerCreepSetups = {
    economy: {
        role: 'energizer',
        powerRequirements: [
            // TODO: for now just spawn any
            { power: PWR_GENERATE_OPS, minLevel: 1, maxLevel: 5 },
        ],
    },
};
// for (const role in PowerCreepSetups) {
// 	const setup = PowerCreepSetups[role];
// 	verifyPowerCreepSetup(role, setup, true);
// }
/**
 * Checks that a setup is valid, such that each of the powers can be leveled to the max level specified
 */
// function verifyPowerCreepSetup(role: string, setup: PowerCreepSetup, verbose = false): void {
// 	const priorities = setup.upgradePriorities;
// 	const powerLevels: { [power: string]: number } = {};
// 	let level = 0;
// 	while (true) {
// 		const upgradePower = _.find(priorities, powerPriority => {
// 			const {power, maxLevel} = powerPriority;
// 			powerLevels[power] = powerLevels[power] || 0;
// 			const powerLevel = powerLevels[power];
// 			if (powerLevel < maxLevel) {
// 				const requiredLevel = POWER_INFO[power].level[powerLevel];
// 				if (level >= requiredLevel) {
// 					return true;
// 				}
// 			}
// 		});
// 		if (upgradePower) {
// 			// Simulate upgrading the power
// 			if (verbose) {
// 				log.info(`Upgrading power ${upgradePower.power} to level ${powerLevels[upgradePower.power] + 1}, ` +
// 						 `Total level: ${level + 1}`);
// 			}
// 			powerLevels[upgradePower.power]++;
// 			level++;
// 		} else {
// 			// Check that everything has reached max level
// 			for (const powerPriority of priorities) {
// 				const {power, maxLevel} = powerPriority;
// 				if (powerLevels[power] != maxLevel) {
// 					log.error(`Invalid power creep setup: ${role}! Power ${power} at level ${powerLevels[power]}, ` +
// 							  `not max level ${maxLevel}!`);
// 				}
// 			}
// 			break;
// 		}
// 	}
// }

/**
 * Wrapper for the operator class of power creeps. Contains wrapped methods for all powers this creep can do.
 */
let PowerZergOperator = class PowerZergOperator extends PowerZerg {
    setTask(powerId, targetId) {
        // TODO find proper typing solution instead of <any>
        this.memory.powerTask = powerId;
        this.memory.targetId = targetId;
    }
    clearTask() {
        // TODO find proper typing solution instead of <any>
        this.memory.powerTask = undefined;
        this.memory.targetId = undefined;
    }
    runPower() {
        const powerId = this.memory.powerTask;
        const targetId = this.memory.targetId;
        const target =
            targetId && Game.getObjectById(targetId)
                ? // TODO find proper typing solution instead of <any>
                  Game.getObjectById(targetId)
                : null;
        if (target) {
            if (
                !this.pos.inRangeToPos(
                    target.pos,
                    _.get(POWER_INFO[powerId], 'range', 1),
                )
            ) {
                //this.say(target.id);
                this.goTo(target, { pathOpts: { avoidSK: true } });
                return ERR_NOT_IN_RANGE;
            }
        }
        switch (powerId) {
            case PWR_GENERATE_OPS:
                return this.generateOps();
            case PWR_SHIELD:
                return this.shield();
            case PWR_OPERATE_LAB:
                return this.operateLab(target);
            case PWR_OPERATE_EXTENSION:
                return this.operateExtension(target);
            case PWR_REGEN_SOURCE:
                return this.regenSource(target);
            case PWR_OPERATE_SPAWN:
                return this.operateSpawn(target);
            case PWR_OPERATE_CONTROLLER:
                return this.operateController(target);
            case PWR_OPERATE_FACTORY:
                return this.operateFactory(target);
            case PWR_OPERATE_OBSERVER:
                return this.operateObserver(target);
            case PWR_OPERATE_POWER:
                return this.operatePowerSpawn(target);
            case PWR_OPERATE_STORAGE:
                return this.operateStorage(target);
            case PWR_OPERATE_TERMINAL:
                return this.operateTerminal(target);
            case PWR_OPERATE_TOWER:
                return this.operateTower(target);
            case PWR_DISRUPT_SOURCE:
                return this.disruptSource(target);
            case PWR_DISRUPT_SPAWN:
                return this.disruptSpawn(target);
            case PWR_DISRUPT_TERMINAL:
                return this.disruptTerminal(target);
            case PWR_DISRUPT_TOWER:
                return this.disruptTower(target);
            case PWR_REGEN_MINERAL:
                return this.regenMineral(target);
            case PWR_FORTIFY:
                return this.fortify(target);
            default:
                return ERR_NOT_FOUND;
        }
    }
    /**
     * Increase max limit of energy that can be used for upgrading a Level 8 controller each tick by 10/20/30/40/50
     * energy units. Effect duration 1000 ticks. Cooldown 800 ticks. Range 3 squares. Consumes 200 ops resource units.
     * Required creep level: 20/21/22/23/24.
     */
    operateController(controller) {
        return this.creep.usePower(PWR_OPERATE_CONTROLLER, controller);
    }
    /**
     * 	Instantly fill 20/40/60/80/100% of all extensions in the room using energy from the target structure
     * 	(container, storage, or terminal). Cooldown 50 ticks.
     * 	Range 3 squares. Consumes 2 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateExtension(energySource) {
        return this.creep.usePower(PWR_OPERATE_EXTENSION, energySource);
    }
    /**
     * Set the level of the factory to the level of the power. This action is permanent, it cannot be undone, and
     * another power level cannot be applied. Apply the same power again to renew its effect.
     * Effect duration 1000 ticks. Cooldown 800 ticks. Range 3 squares. Consumes 100 ops resource units.
     * Required creep level: 0/2/7/14/22.
     */
    operateFactory(factory) {
        return this.creep.usePower(PWR_OPERATE_FACTORY, factory);
    }
    /**
     * Increase reaction amount by 2/4/6/8/10 units. Effect duration 1000 ticks. Cooldown 50 ticks.
     * Range 3 squares. Consumes 10 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateLab(lab) {
        return this.creep.usePower(PWR_OPERATE_LAB, lab);
    }
    /**
     * Grant unlimited range. Effect duration 200/400/600/800/1000 ticks. Cooldown 400 ticks.
     * Range 3 squares. Consumes 10 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateObserver(observer) {
        return this.creep.usePower(PWR_OPERATE_OBSERVER, observer);
    }
    /**
     * Increase power processing speed of a Power Spawn by 1/2/3/4/5 units per tick. Effect duration 1000 ticks.
     * Cooldown 800 ticks. Range 3 squares. Consumes 200 ops resource units. Required creep level: 10/11/12/14/22.
     */
    operatePowerSpawn(powerSpawn) {
        return this.creep.usePower(PWR_OPERATE_POWER, powerSpawn);
    }
    /**
     * Reduce spawn time by 10/30/50/65/80%. Effect duration 1000 ticks. Cooldown 300 ticks.
     * Range 3 squares. Consumes 100 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateSpawn(spawn) {
        return this.creep.usePower(PWR_OPERATE_SPAWN, spawn);
    }
    /**
     * Increase capacity by 500K/1M/2M/4M/7M units. Effect duration 1000 ticks. Cooldown 800 ticks.
     * Range 3 squares. Consumes 100 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateStorage(storage) {
        return this.creep.usePower(PWR_OPERATE_STORAGE, storage);
    }
    /**
     * Decrease transfer energy cost and cooldown by 10/20/30/40/50%. Effect duration 1000 ticks. Cooldown 500 ticks.
     * Range 3 squares. Consumes 100 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateTerminal(terminal) {
        return this.creep.usePower(PWR_OPERATE_TERMINAL, terminal);
    }
    /**
     * Increase damage, repair and heal amount by 10/20/30/40/50%. Effect duration 100 ticks. Cooldown 10 ticks.
     * Range 3 squares. Consumes 10 ops resource units. Required creep level: 0/2/7/14/22.
     */
    operateTower(tower) {
        return this.creep.usePower(PWR_OPERATE_TOWER, tower);
    }
    /**
     * Pause energy regeneration. Effect duration 100/200/300/400/500 ticks. Cooldown 100 ticks.
     * Range 3 squares. Consumes 100 ops resource units. Required creep level: 0/2/7/14/22.
     */
    disruptSource(source) {
        return this.creep.usePower(PWR_DISRUPT_SOURCE, source);
    }
    /**
     * Pause spawning process. Effect duration 1/2/3/4/5 ticks. Cooldown 5 ticks. Range 20 squares.
     * Consumes 10 ops resource units. Required creep level: 0/2/7/14/22.
     */
    disruptSpawn(spawn) {
        return this.creep.usePower(PWR_DISRUPT_SPAWN, spawn);
    }
    /**
     * Block withdrawing or using resources from the terminal. Effect duration 10 ticks. Cooldown 8 ticks.
     * Range 50 squares. Consumes 50/40/30/20/10 ops resource units. Required creep level: 20/21/22/23/24.
     */
    disruptTerminal(terminal) {
        return this.creep.usePower(PWR_DISRUPT_TERMINAL, terminal);
    }
    /**
     * Reduce effectiveness by 10/20/30/40/50%. Effect duration 5 ticks. No cooldown.
     * Range 50 squares. Consumes 10 ops resource units. Required creep level: 0/2/7/14/22.
     */
    disruptTower(tower) {
        return this.creep.usePower(PWR_DISRUPT_TOWER, tower);
    }
    /**
     * Regenerate 2/4/6/8/10 mineral units in a deposit every 10 ticks. Effect duration 100 ticks.
     * Cooldown 100 ticks. Range 3 squares. Required creep level: 10/11/12/14/22.
     */
    regenMineral(mineral) {
        return this.creep.usePower(PWR_REGEN_MINERAL, mineral);
    }
    /**
     * Regenerate 50/100/150/200/250 energy units in a source every 15 ticks. Effect duration 300 ticks.
     * Cooldown 100 ticks. Range 3 squares. Required creep level: 10/11/12/14/22.
     */
    regenSource(source) {
        return this.creep.usePower(PWR_REGEN_SOURCE, source);
    }
    /**
     * Make a wall or rampart tile invulnerable to all creep attacks and powers. Effect duration 1/2/3/4/5 ticks.
     * Cooldown 5 ticks. Range 3 squares. Consumes 5 ops resource units. Required creep level: 0/2/7/14/22.
     */
    fortify(barrier) {
        return this.creep.usePower(PWR_FORTIFY, barrier);
    }
    /**
     * Create a temporary non-repairable rampart with 5K/10K/15K/20K/25K hits on the same position as the PowerCreep.
     * Cannot be used on top of another rampart. Consumes 100 energy resource units. Effect duration 50 ticks.
     * Cooldown 20 ticks. Required creep level: 0/2/7/14/22.
     */
    shield() {
        return this.creep.usePower(PWR_SHIELD);
    }
};
PowerZergOperator = __decorate([profile], PowerZergOperator);

const getDefaultPowerOverlordMemory = () => ({
    ['T' /* TICK */]: Game.time,
});
/**
 * CombatOverlords extend the base Overlord class to provide additional combat-specific behavior
 */
let PowerOverlord = class PowerOverlord extends Overlord {
    constructor(
        initializer,
        name,
        priority,
        memDefauts = getDefaultPowerOverlordMemory,
    ) {
        super(initializer, name, priority, memDefauts);
        this._powerCreeps = {};
        this._powerZerg = {};
        this.recalculatePowerCreeps();
    }
    get age() {
        return Game.time - this.memory['T' /* TICK */];
    }
    refresh() {
        // Refresh memory
        this.memory = Mem.wrap(this.initializer.memory, this.name);
        // Refresh room
        this.room = Game.rooms[this.pos.roomName];
        // Refresh zerg
        this.recalculatePowerCreeps();
        for (const role in this._powerCreeps) {
            for (const powerCreep of this._powerCreeps[role]) {
                if (Overmind.powerZerg[powerCreep.name]) {
                    Overmind.powerZerg[powerCreep.name].refresh();
                } else {
                    log.warning(
                        `${this.print}: could not find and refresh power zerg with name ${powerCreep.name}!`,
                    );
                }
            }
        }
    }
    zerg(role, opts = {}) {
        log.error(`${this.print}: cannot call PowerOverlord.zerg()!`);
        return [];
    }
    combatZerg(role, opts = {}) {
        log.error(`${this.print}: cannot call PowerOverlord.combatZerg()!`);
        return [];
    }
    /**
     * Wraps all powerCreeps of a given role to PowerZerg objects and updates the contents in future ticks to avoid
     * having to explicitly refresh groups of PowerZerg
     */
    powerZerg(role, opts = {}) {
        if (!this._powerZerg[role]) {
            this._powerZerg[role] = [];
            this.synchronizePowerZerg(role, opts.notifyWhenAttacked);
        }
        return this._powerZerg[role];
    }
    recalculatePowerCreeps() {
        // Recalculate the sets of creeps for each role in this overlord
        // TODO: FIX, zGeneral: this is a hack for some reason,
        //  the cash get cleared somewhere, and the power creep does not work well
        // TODO:... for example. goTo will be stuck!
        if (Overmind.cache.overlords[this.ref] != undefined) {
            // this condition is a hack, fix it!
            this._powerCreeps = _.mapValues(
                Overmind.cache.overlords[this.ref],
                (creepsOfRole) =>
                    _.map(
                        creepsOfRole,
                        (creepName) => Game.powerCreeps[creepName],
                    ),
            );
        }
        // Update zerg and combatZerg records
        for (const role in this._powerZerg) {
            this.synchronizePowerZerg(role);
        }
    }
    synchronizePowerZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of Zerg
        const zergNames = _.zipObject(
            _.map(this._powerZerg[role] || [], (zerg) => [zerg.name, true]),
        );
        const creepNames = _.zipObject(
            _.map(this._powerCreeps[role] || [], (creep) => [creep.name, true]),
        );
        // Add new creeps which aren't in the _zerg record
        for (const creep of this._powerCreeps[role] || []) {
            if (!zergNames[creep.name]) {
                if (Overmind.powerZerg[creep.name]) {
                    this._powerZerg[role].push(Overmind.powerZerg[creep.name]);
                } else {
                    switch (creep.className) {
                        case POWER_CLASS.OPERATOR:
                            this._powerZerg[role].push(
                                new PowerZergOperator(
                                    creep,
                                    notifyWhenAttacked,
                                ),
                            );
                            break;
                        default:
                            log.error(`NOT IMPLEMENTED`);
                            break;
                    }
                }
            }
        }
        // Remove dead/reassigned creeps from the _zerg record
        const removeZergNames = [];
        for (const powerZerg of this._powerZerg[role]) {
            if (!creepNames[powerZerg.name]) {
                removeZergNames.push(powerZerg.name);
            }
        }
        _.remove(this._powerZerg[role], (deadZerg) =>
            removeZergNames.includes(deadZerg.name),
        );
    }
    /**
     * Requests a power creep
     */
    requestPowerCreep(setup) {
        // TODO
    }
    /**
     * Wishlist of creeps to simplify spawning logic; includes automatic reporting
     */
    wishlistPC(setup = {}, quantity = 1) {
        // TODO
        // Hack by zGeneral: need some feedback from Muon
        _.defaults(setup, PowerCreepSetups.economy);
        // get number currently spawned powerCreeps under this overlord
        const currentPCs = _.filter(
            Game.powerCreeps,
            (pc) =>
                pc.ticksToLive && // it is alive
                pc.room && // spawned in room
                !!getOverlord$1(pc) && // has an overlord
                pc.memory.role == setup.role && // same role
                pc.memory.C == this.colony.name && // same colony
                pc.memory.O == this.ref,
        );
        _.forEach(currentPCs, (pc) => setOverlord$1(pc, this));
        // TODO: reassign power creeps
        // search for powerCreeps from limbo pool to be spawned
        const currentQuantities = currentPCs.length;
        if (quantity - currentQuantities > 0) {
            const potentialPCs = _.filter(
                Game.powerCreeps,
                (pc) =>
                    !pc.ticksToLive && // not spawned
                    !pc.spawnCooldownTime && // not in spawn cooldown timer
                    // has all power requirements
                    _.every(
                        setup.powerRequirements,
                        (p) =>
                            pc.powers[p.power] &&
                            pc.powers[p.power].level >= p.minLevel &&
                            pc.powers[p.power].level <= p.maxLevel,
                    ),
            );
            if (potentialPCs.length > 0) {
                const powerCreepsToSpawn = _.sample(potentialPCs); // sample one at a time per tick
                if (this.colony.powerSpawn && powerCreepsToSpawn) {
                    powerCreepsToSpawn.spawn(this.colony.powerSpawn);
                    powerCreepsToSpawn.memory.role = setup.role;
                    powerCreepsToSpawn.memory.targetId = undefined;
                    powerCreepsToSpawn.memory.powerTask = undefined;
                    setOverlord$1(powerCreepsToSpawn, this);
                }
            } else {
                log.warning(
                    `No power creep available to spawn - check power requirements or cooldownTimer`,
                );
            }
        }
    }
};
PowerOverlord = __decorate([profile], PowerOverlord);

var MiningOverlord_1;
const StandardMinerSetupCost = bodyCost(
    Setups.drones.miners.standard.generateBody(Infinity),
);
const StandardCPUMinerSetupCost = bodyCost(
    Setups.drones.miners.standardCPU.generateBody(Infinity),
);
const DoubleMinerSetupCost = bodyCost(
    Setups.drones.miners.double.generateBody(Infinity),
);
const BUILD_OUTPUT_FREQUENCY = 150;
const SUICIDE_CHECK_FREQUENCY = 15;
const MINER_SUICIDE_THRESHOLD = 200;
const DISMANTLE_CHECK_FREQUENCY = 1500;
const DISMANTLE_CHECK = 'dc';
/**
 * Spawns miners to harvest from remote, owned, or sourcekeeper energy deposits. Standard mining actions have been
 * heavily CPU-optimized
 */
let MiningOverlord = (MiningOverlord_1 = class MiningOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, 'mine', priority);
        this.distance = directive.distance;
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.miners = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
        // Check if dismantling is needed
        if (
            this.memory.dismantleNeeded ||
            Game.time > (this.memory[DISMANTLE_CHECK] || 0)
        ) {
            if (this.room) {
                this.dismantlePositions = this.getDismantlePositions();
                if (this.dismantlePositions.length > 0) {
                    this.memory.dismantleNeeded = true;
                    this.dismantlePositions = this.getDismantlePositions();
                } else {
                    this.memory[DISMANTLE_CHECK] = getCacheExpiration(
                        DISMANTLE_CHECK_FREQUENCY,
                        DISMANTLE_CHECK_FREQUENCY / 5,
                    );
                }
            }
        }
        // Compute energy output
        if (
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER ||
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
        ) {
            this.energyPerTick =
                SOURCE_ENERGY_KEEPER_CAPACITY / ENERGY_REGEN_TIME;
        } else if (
            this.colony.level >=
            DirectiveOutpost.settings.canSpawnReserversAtRCL
        ) {
            this.energyPerTick = SOURCE_ENERGY_CAPACITY / ENERGY_REGEN_TIME;
        } else {
            this.energyPerTick =
                SOURCE_ENERGY_NEUTRAL_CAPACITY / ENERGY_REGEN_TIME;
        }
        const hasRegenSource =
            this.source &&
            this.source.effects &&
            this.source.effects.length > 0;
        this.miningPowerNeeded =
            Math.ceil(this.energyPerTick / HARVEST_POWER) + 1;
        // this.checkForNearbyMines();
        // Decide operating mode
        if (
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER ||
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
        ) {
            this.mode = 'SK';
            this.setup = Setups.drones.miners.sourceKeeper;
        } else if (
            this.colony.room.energyCapacityAvailable < StandardMinerSetupCost
        ) {
            this.mode = 'early';
            this.setup = Setups.drones.miners.default;
        }
        // else if (this.isDoubleSource() && this.colony.room.energyCapacityAvailable > DoubleMinerSetupCost) {
        // 	this.mode = 'double';
        // 	this.setup = Setups.drones.miners.double;
        // }
        else if (this.link) {
            this.mode = 'link';
            if (this.colony.assets.energy >= 100000) {
                this.setup = Setups.drones.miners.linkOptimized;
            } else {
                this.setup = Setups.drones.miners.default;
            }
        } else {
            this.mode = 'standard';
            this.setup =
                this.colony.level === 8
                    ? Setups.drones.miners.standardCPU
                    : Setups.drones.miners.standard;
            // todo: double miner condition
        }
        if (hasRegenSource) {
            this.setup = Setups.drones.miners.regenSource;
        }
        const miningPowerEach = this.setup.getBodyPotential(WORK, this.colony);
        // this.minersNeeded = this.isDisabled ? 0 : Math.min(Math.ceil(this.miningPowerNeeded / miningPowerEach),
        // 							 this.pos.availableNeighbors(true).length);
        this.minersNeeded = Math.min(
            Math.ceil(this.miningPowerNeeded / miningPowerEach),
            Math.max(this.pos.availableNeighbors(true).length, 1),
        );
        this.minersNeeded = this.isDisabled ? 0 : this.minersNeeded;
        // Allow drop mining at low levels
        this.allowDropMining =
            this.colony.level < MiningOverlord_1.settings.dropMineUntilRCL;
        if (this.mode != 'early' && !this.allowDropMining) {
            if (this.container) {
                this.harvestPos = this.container.pos;
            } else if (this.link) {
                this.harvestPos = _.find(
                    this.link.pos.availableNeighbors(true),
                    (pos) => pos.getRangeTo(this) == 1,
                );
            } else {
                this.harvestPos = this.calculateContainerPos();
            }
        }
    }
    /**
     * Calculates if this source has another one very nearby that should be handled by the same miner
     * TODO: plug in
     */
    isDoubleSource() {
        if (this.memory.doubleSource !== undefined) {
            return this.memory.doubleSource;
        }
        const room = Game.rooms[this.pos.roomName];
        if (room) {
            this.source = this.source || _.first(room.sources);
            const otherSource = _.find(
                this.source.pos.findInRange(FIND_SOURCES, 2),
                (source) => source.id != (this.source ? this.source.id : ''),
            );
            if (otherSource) {
                this.secondSource = otherSource;
                // If its over 1 spot away, is there spot in between to mine?
                if (this.source.pos.getRangeTo(this.secondSource) > 1) {
                    const miningPos = this.source.pos.getPositionAtDirection(
                        this.source.pos.getDirectionTo(this.secondSource.pos),
                    );
                    if (!miningPos.isWalkable()) {
                        // console.log(`Double mining found but there is no spot between ${this.secondSource}
                        // ${this.secondSource.pos.print} isWalkable ${miningPos}`);
                        return false;
                    }
                }
                // Disable mining from the source with greater id
                if (this.source.id > this.secondSource.id) {
                    // console.log(`This is a disabled mining ${this.directive.name} via source id`);
                    this.isDisabled = true;
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if dismantling is needed in the operating room
     */
    getDismantlePositions() {
        const dismantleStructures = [];
        if (this.room) {
            const targets = _.compact([
                ...this.room.sources,
                this.room.controller,
            ]);
            for (const target of targets) {
                // Add blocking structures
                const blockingStructure = this.findBlockingStructure(target);
                if (blockingStructure) {
                    dismantleStructures.push(blockingStructure);
                }
                // Add unwalkable structures with low hits in 2 range
                for (const pos of target.pos.getPositionsInRange(
                    2,
                    false,
                    false,
                )) {
                    const unwalkableStructure = _.find(
                        pos.lookFor(LOOK_STRUCTURES),
                        (s) =>
                            !s.isWalkable &&
                            s.structureType != STRUCTURE_INVADER_CORE,
                    );
                    if (unwalkableStructure && !unwalkableStructure.my) {
                        dismantleStructures.push(unwalkableStructure);
                    }
                }
            }
        } else {
            log.error(
                `MiningOverlord.getDismantleStructures() called with no vision in room ${this.pos.roomName}!`,
            );
        }
        return _.unique(_.map(dismantleStructures, (s) => s.pos));
    }
    /**
     * Finds the structure which is blocking access to a source or controller
     */
    findBlockingStructure(target) {
        if (!this.room) return;
        // zGen: replace colony with mineral to avoid multi room search
        const pos = Pathing.findBlockingPos(
            Game.rooms[target.pos.roomName].mineral.pos,
            target.pos,
            _.filter(this.room.structures, (s) => !s.isWalkable),
        );
        if (pos) {
            const structure = _.find(
                pos.lookFor(LOOK_STRUCTURES),
                (s) => !s.isWalkable,
            );
            return (
                structure ||
                log.error(
                    `${this.print}: no structure at blocking pos ${pos.print}!`,
                )
            );
        }
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.source = _.first(this.pos.lookFor(LOOK_SOURCES));
            this.constructionSite = _.first(
                _.filter(
                    this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2),
                    (site) =>
                        site.structureType == STRUCTURE_CONTAINER ||
                        site.structureType == STRUCTURE_LINK,
                ),
            );
            this.container = this.pos.findClosestByLimitedRange(
                Game.rooms[this.pos.roomName].containers,
                1,
            );
            this.link = this.pos.findClosestByLimitedRange(
                this.colony.availableLinks,
                2,
            );
        }
    }
    // Initialization function to run when the miner enters the SK room
    initializeMiner(source) {
        if (!this.memory.lairId || !this.memory.safePosition) {
            // Find the closest Keeper Lair to the source and store its ID
            const closestLair = source.pos.findClosestByRange(
                FIND_HOSTILE_STRUCTURES,
                {
                    filter: (structure) =>
                        structure.structureType === STRUCTURE_KEEPER_LAIR,
                },
            );

            if (closestLair) {
                this.memory.lairId = closestLair.id;

                // Get terrain data
                const terrain = Game.map.getRoomTerrain(source.room.name);

                // Calculate and store the safe position
                const surroundingTiles = [];
                for (let dx = -6; dx <= 6; dx++) {
                    for (let dy = -6; dy <= 6; dy++) {
                        const x = source.pos.x + dx;
                        const y = source.pos.y + dy;
                        if (Math.abs(dx) !== 6 && Math.abs(dy) !== 6) {
                            continue;
                        }

                        // Check if the position is within room boundaries
                        if (x > 0 && x < 49 && y > 0 && y < 49) {
                            const pos = new RoomPosition(
                                x,
                                y,
                                source.room.name,
                            );
                            if (
                                terrain.get(x, y) !== TERRAIN_MASK_WALL &&
                                terrain.get(x, y) !== TERRAIN_MASK_SWAMP
                            ) {
                                // Check for roads at the position
                                const lookResult = pos.lookFor(LOOK_STRUCTURES);
                                const hasRoad = lookResult.some(
                                    (structure) =>
                                        structure.structureType ===
                                        STRUCTURE_ROAD,
                                );

                                if (
                                    !hasRoad &&
                                    pos.getRangeTo(closestLair) >= 6
                                ) {
                                    // Skip tiles with roads
                                    const pathToSource = PathFinder.search(
                                        source.pos,
                                        { pos: pos, range: 1 },
                                    );
                                    const pathToLair = PathFinder.search(
                                        closestLair.pos,
                                        { pos: pos, range: 1 },
                                    );

                                    if (
                                        pathToSource.cost < 14 &&
                                        pathToLair.cost < 14
                                    ) {
                                        surroundingTiles.push({
                                            pos: pos,
                                            distanceToLair: pathToLair.cost,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Sort by distance to the lair, furthest first
                surroundingTiles.sort(
                    (a, b) => b.distanceToLair - a.distanceToLair,
                );

                const safeTile =
                    surroundingTiles.length > 0
                        ? surroundingTiles[0].pos
                        : null;
                this.memory.safePosition = safeTile
                    ? { x: safeTile.x, y: safeTile.y }
                    : null;
            }

            if (!this.memory.lairId || !this.memory.safePosition) {
                console.log(this.room.name, 'could not find safe position');
            }
        }

        //else {
        //    const safePos = new RoomPosition(this.memory.safePosition.x, this.memory.safePosition.y, source.room.name);
        //    new RoomVisual(source.room.name).circle(safePos.x, safePos.y, {radius: 0.5, fill: '#ff0000', stroke: '#ffffff', strokeWidth: 0.1});
        //}
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            // if you just gained vision of this room
            this.populateStructures();
        }
        super.refresh();
        // Refresh your references to the objects
        $.refresh(this, 'source', 'container', 'link', 'constructionSite');
    }
    /**
     * Calculate where the container output will be built for this site
     */
    calculateContainerPos() {
        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        } else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, (pos) => pos.getRangeTo(this) == 1);
            if (pos) return pos;
        }
        // Shouldn't ever get here
        log.warning(
            `Last resort container position calculation for ${this.print}!`,
        );
        return _.first(this.pos.availableNeighbors(true));
    }
    /**
     * Add or remove containers as needed to keep exactly one of container | link
     */
    addRemoveContainer() {
        if (this.allowDropMining) {
            return; // only build containers in reserved, owned, or SK rooms
        }
        // Create container if there is not already one being built and no link
        if (!this.container && !this.constructionSite && !this.link) {
            const containerPos = this.calculateContainerPos();
            if (!containerPos) {
                log.error(
                    `${this.print}: can't build container at ${this.room}`,
                );
                return;
            }
            const container = containerPos
                ? containerPos.lookForStructure(STRUCTURE_CONTAINER)
                : undefined;
            if (container) {
                log.warning(
                    `${this.print}: this.container out of sync at ${containerPos.print}`,
                );
                this.container = container;
                return;
            }
            log.info(
                `${this.print}: building container at ${containerPos.print}`,
            );
            const result = containerPos.createConstructionSite(
                STRUCTURE_CONTAINER,
            );
            if (result != OK) {
                log.error(
                    `${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`,
                );
            }
            return;
        }
        // Destroy container if link is nearby
        if (this.container && this.link) {
            // safety checks
            if (
                this.colony.hatchery &&
                this.container.pos.getRangeTo(this.colony.hatchery) > 2 &&
                this.container.pos.getRangeTo(this.colony.upgradeSite) > 3
            ) {
                log.info(
                    `${this.print}: container and link present; destroying container at ${this.container.pos.print}`,
                );
                this.container.destroy();
            }
        }
    }
    registerEnergyRequests() {
        if (this.container) {
            const transportCapacity = 200 * this.colony.level;
            const threshold = this.colony.stage > ColonyStage.Larva ? 0.9 : 0.5; // zGeneral 8/2023 test 0.8 to 0.9
            if (this.container.store.getUsedCapacity() >= 1600) {
                // zGeneral 9/2023
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: 'all',
                    //dAmountdt: this.energyPerTick,
                });
            }
        }
        if (this.link) {
            // If the link will be full with next deposit from the miner
            const minerCapacity = 150;
            if (this.link.energy + minerCapacity > this.link.energyCapacity) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    init() {
        // Do not spawn drones if colony is under attack or outpost is under attack
        if (
            this.colony.room.dangerousPlayerHostiles.length > 0 ||
            (this.room &&
                !this.room.my &&
                (this.room.invaders.length > 1 ||
                    this.room.dangerousPlayerHostiles.length > 0))
        ) {
            return;
        }
        if (
            this.room &&
            Cartographer.roomType(this.room.name) == ROOMTYPE_SOURCEKEEPER
        ) {
            this.initializeMiner(this.source);
        }
        const bucketThreshold = Math.min(8000 + this.outpostIndex * 200, 10000);
        const spacedProbs =
            bucketThreshold > 9500 || Game.cpu.bucket >= bucketThreshold;
        const invaderBlocked =
            RoomIntel.roomReservedBy(this.pos.roomName) === 'Invader' &&
            RoomIntel.roomReservationRemaining(this.pos.roomName) > 100;
        // Scale miners with Bucket availability
        // if bucket is full or is colony room, spawn miners freely
        // if bucket is less than 10000 but > 9500, then -space- spawn miners in outposts
        if (
            this.colony.name == this.pos.roomName ||
            (Game.cpu.bucket >= bucketThreshold &&
                spacedProbs &&
                !invaderBlocked)
        ) {
            this.wishlist(this.minersNeeded, this.setup);
        } else {
            this.wishlist(0, this.setup);
        }
        this.registerEnergyRequests();
    }
    /**
     * Actions for handling mining at early RCL, when multiple miners and drop mining are used
     */
    earlyMiningActions(miner) {
        // Don't use goToMiningSite() here because miners will push each other around and waste CPU
        if (!miner.pos.inRangeToPos(this.pos, 1)) {
            return miner.goTo(this);
        }
        // Container mining
        if (this.container) {
            if (
                this.container.hits < this.container.hitsMax * 0.75 &&
                miner.carry.energy >=
                    Math.min(
                        miner.carryCapacity,
                        REPAIR_POWER * miner.getActiveBodyparts(WORK),
                    )
            ) {
                return miner.goRepair(this.container);
            } else {
                if (sumStore(miner.carry) < miner.carryCapacity) {
                    return miner.goHarvest(this.source);
                } else {
                    return miner.goTransfer(this.container);
                }
            }
        }
        // Build output site
        if (this.constructionSite) {
            if (
                miner.carry.energy >=
                Math.min(
                    miner.carryCapacity,
                    BUILD_POWER * miner.getActiveBodyparts(WORK),
                )
            ) {
                return miner.goBuild(this.constructionSite);
            } else {
                return miner.goHarvest(this.source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            miner.goHarvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                // try to drop on top of largest drop if full
                /*
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), (drop) => drop.amount);
                if (biggestDrop) {
                    miner.goDrop(biggestDrop.pos, RESOURCE_ENERGY);
                }
                */
            }
            return;
        }
    }
    /**
     * Suicide outdated miners when their replacements arrive
     */
    suicideOldMiners() {
        if (this.miners.length > this.minersNeeded && this.source) {
            // if you have multiple miners and the source is visible
            const targetPos = this.harvestPos || this.source.pos;
            const minersNearSource = _.filter(
                this.miners,
                (miner) =>
                    miner.pos.getRangeTo(targetPos) <= SUICIDE_CHECK_FREQUENCY,
            );
            if (minersNearSource.length > this.minersNeeded) {
                // if you have more miners by the source than you need
                const oldestMiner = minBy(
                    minersNearSource,
                    (miner) => miner.ticksToLive || 9999,
                );
                if (
                    oldestMiner &&
                    (oldestMiner.ticksToLive || 9999) < MINER_SUICIDE_THRESHOLD
                ) {
                    // if the oldest miner will die sufficiently soon
                    oldestMiner.suicide();
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Actions for handling link mining
     */
    linkMiningActions(miner) {
        // Sleep until your source regens
        if (this.isSleeping(miner)) return;
        // Approach mining site
        if (this.goToMiningSite(miner, false)) return;
        // Link mining
        if (this.link) {
            const res = this.harvestefficiently(miner, this.source);
            if (miner.carry.energy > 0.9 * miner.carryCapacity) {
                miner.transfer(this.link, RESOURCE_ENERGY);
            }
            // If for whatever reason there's no reciever link, you can get stuck in a bootstrapping loop, so
            // occasionally check for this and drop energy on the ground if needed
            if (Game.time % 10 == 0) {
                const commandCenterLink = this.colony.commandCenter
                    ? this.colony.commandCenter.link
                    : undefined;
                if (!commandCenterLink) {
                    miner.drop(RESOURCE_ENERGY);
                }
            }
        } else {
            log.warning(
                `${this.print}: Link miner ${miner.print} has no link! (Why?)`,
            );
        }
    }
    /**
     * Actions for handling mining at RCL high enough to spawn ideal miner body to saturate source
     */
    standardMiningActions(miner) {
        // TODO re-eval to do mining first, try intent and if fail then more for cpu gain
        // Sleep until your source regens
        if (this.isSleeping(miner)) return;
        // Approach mining site
        if (this.goToMiningSite(miner)) return;
        // At this point the miner is in the room so we have vision of the source
        const source = this.source;
        // Container mining
        if (this.container) {
            if (
                (this.container.hits < this.container.hitsMax && this.container.store.getFreeCapacity() == 0 ) &&
                miner.carry.energy > 0
            ) {
                //(this.container.hits < this.container.hitsMax && this.container.store.getFreeCapacity() == 0 && source.ticksToRegeneration < 50 && source.energy >= 250) && console.log(this.pos.roomName, source.id);
                
                return miner.repair(this.container);
            } else {
                return this.harvestefficiently(miner, source);
            }
        }
        // Build output site
        if (this.constructionSite) {
            // standard miners won't have both a container and a construction site
            if (
                miner.carry.energy >=
                Math.min(
                    miner.carryCapacity,
                    BUILD_POWER * miner.getActiveBodyparts(WORK),
                )
            ) {
                return miner.build(this.constructionSite);
            } else {
                return this.harvestOrSleep(miner, source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            this.harvestOrSleep(miner, source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                // move over the drop when you're close to full
                /*
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), (drop) => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
                */
            }
            /*if (miner.carry.energy == miner.carryCapacity) {
                // drop when you are full
                miner.drop(RESOURCE_ENERGY);
            }*/
            return;
        }
    }
    /**
     * Actions for handling mining in source keeper rooms
     */

    skMiningActions(miner) {
        // Sleep until your source regens
        if (this.isSleeping(miner)) {
            // miner.say(miner.memory.sleepUntil - Game.time)
            return;
        }
        // Approach mining site

        // At this point the miner is in the room so we have vision of the source
        const source = this.source;
        if (this.room && this.memory.lairId && this.memory.safePosition) {
            const safePosition = new RoomPosition(
                this.memory.safePosition.x,
                this.memory.safePosition.y,
                this.source.room.name,
            );
            const lair = Game.getObjectById(this.memory.lairId);
            const source = this.source;

            let shouldGoToSafePosition = false;
            let sleepUntilTime = 0;

            // Check if the Source Keeper is about to spawn or has recently spawned
            if (lair && (lair.ticksToSpawn < 15 || !lair.ticksToSpawn)) {
                // !lair.ticksToSpawn means spawned and not damaged
                shouldGoToSafePosition = true;
                const ticksToSpawn = lair.ticksToSpawn || 0;
                sleepUntilTime = Game.time + ticksToSpawn + 15;
            }
            // Check if the source is depleted
            else if (
                source &&
                source.energy === 0 &&
                source.ticksToRegeneration > 15 &&
                lair.ticksToSpawn < source.ticksToRegeneration
            ) {
                shouldGoToSafePosition = true;
                sleepUntilTime = Game.time + lair.ticksToSpawn + 15;
                // console.log(this.pos.print, 'lair.ticksToSpawn < source.ticksToRegeneration')
            }

            if (shouldGoToSafePosition) {
                // Drop any carried energy if any
                if (miner.carry.energy > 0) {
                    miner.drop(RESOURCE_ENERGY);
                }

                // Check if the miner is already at the safe position
                if (miner.pos.isEqualTo(safePosition)) {
                    miner.memory.sleepUntil = sleepUntilTime;
                    return; // No further action needed
                }

                // Move to the safe position
                miner.goTo(safePosition);
                return; // Exit the function early
            }
        }

        if (this.goToMiningSite(miner, false)) return;
        // Container mining
        if (this.container) {
            if (
                this.container.hits < this.container.hitsMax * 0.75 &&
                miner.carry.energy >=
                    Math.min(
                        miner.carryCapacity,
                        REPAIR_POWER * miner.getActiveBodyparts(WORK),
                    )
            ) {
                return miner.repair(this.container);
            } else {
                return this.harvestefficiently(miner, source);
            }
        }
        // Build output site
        if (this.constructionSite) {
            // standard miners won't have both a container and a construction site
            if (
                miner.carry.energy >=
                Math.min(
                    miner.carryCapacity,
                    BUILD_POWER * miner.getActiveBodyparts(WORK),
                )
            ) {
                return miner.build(this.constructionSite);
            } else {
                return this.harvestOrSleep(miner, source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            this.harvestOrSleep(miner, source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                // move over the drop when you're close to full
                /*
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), (drop) => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
                */
            }
            /*
            if (miner.carry.energy == miner.carryCapacity) {
                // drop when you are full
                miner.drop(RESOURCE_ENERGY);
            }
            */
            return;
        }
    }
    /**
     * Actions for handling double mining TODO: plug this in
     */
    doubleMiningActions(miner) {
        // Approach mining site
        if (this.goToMiningSite(miner)) return;
        // Link mining
        if (this.link) {
            if (this.source && this.source.energy > 0) {
                miner.harvest(this.source);
            } else {
                miner.harvest(this.secondSource);
            }
            if (miner.carry.energy > 0.9 * miner.carryCapacity) {
                miner.transfer(this.link, RESOURCE_ENERGY);
            }
            return;
        } else {
            log.warning(`Link miner ${miner.print} has no link!`);
        }
        // Container mining
        if (this.container) {
            if (
                this.container.hits < this.container.hitsMax * 0.75 &&
                miner.carry.energy >=
                    Math.min(
                        miner.carryCapacity,
                        REPAIR_POWER * miner.getActiveBodyparts(WORK),
                    )
            ) {
                return miner.repair(this.container);
            } else if (this.source && this.source.energy > 0) {
                return miner.harvest(this.source);
            } else {
                return miner.harvest(this.secondSource);
            }
        }
        // Build output site
        if (this.constructionSite) {
            if (
                miner.carry.energy >=
                Math.min(
                    miner.carryCapacity,
                    BUILD_POWER * miner.getActiveBodyparts(WORK),
                )
            ) {
                return miner.build(this.constructionSite);
            } else {
                return miner.harvest(this.source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            miner.harvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) {
                // move over the drop when you're close to full
                /*
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), (drop) => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
                */
            }
            if (miner.carry.energy == miner.carryCapacity) {
                // drop when you are full
                miner.drop(RESOURCE_ENERGY);
            }
            return;
        }
    }
    /**
     * Actions for handling mining at RCL high enough to spawn ideal miner body to saturate source
     */
    dismantleActions(miner) {
        // Go to the room
        if (!miner.safelyInRoom(this.pos.roomName)) {
            return miner.goToRoom(this.pos.roomName);
        }
        // We're done if there are no dismantle positions left
        if (!this.dismantlePositions || this.dismantlePositions.length == 0) {
            log.info(`Miner dismantling completed in room ${miner.room.print}`);
            delete this.memory.dismantleNeeded;
            this.memory[DISMANTLE_CHECK] = getCacheExpiration(
                DISMANTLE_CHECK_FREQUENCY,
                DISMANTLE_CHECK_FREQUENCY / 5,
            );
            return;
        }
        // Find the first reachable position to dismantle stuff
        const dismantlePos = _.find(this.dismantlePositions, (pos) =>
            Pathing.isReachable(
                miner.pos,
                pos,
                _.filter(miner.room.structures, (s) => !s.isWalkable),
            ),
        );
        if (dismantlePos) {
            // Find the first blocking structure on the target position
            const dismantleTarget = _.find(
                dismantlePos.lookFor(LOOK_STRUCTURES),
                (s) => !s.isWalkable && !s.my,
            );
            // Dismantle it
            if (dismantleTarget) {
                if (dismantleTarget.hits > 1000 && Game.time % 10 == 0) {
                    log.alert(
                        `${miner.print} attempting to dismantle large structure!@ ${dismantleTarget.pos.print}`,
                    );
                }
                return miner.goDismantle(dismantleTarget);
            }
            // Otherwise reclaculate dismantle positions and call again to get next target
            else {
                this.dismantlePositions = this.getDismantlePositions();
                return this.dismantleActions(miner);
            }
        } else {
            log.warning(`No reachable dismantle positions for ${miner.print}!`);
        }
    }
    /**
     * Move onto harvesting position or near to source
     */
    goToMiningSite(miner, avoidSK = true) {
        if (this.harvestPos) {
            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {
                miner.goTo(this.harvestPos, {
                    range: 0,
                    pathOpts: { avoidSK: avoidSK },
                });
                return true;
            }
        } else {
            if (!miner.pos.inRangeToPos(this.pos, 1)) {
                miner.goTo(this.pos, {
                    range: 1,
                    pathOpts: { avoidSK: avoidSK },
                });
                return true;
            }
        }
        return false;
    }
    isSleeping(miner) {
        if (miner.memory.sleepUntil) {
            if (Game.time >= miner.memory.sleepUntil) {
                delete miner.memory.sleepUntil;
                return false;
            }
            return true;
        }
        return false;
    }
    /**
     * Harvests from a source and sleeps the creep until regeneration if needed. This method doesn't run many safety
     * checks, so the creep will need to be in range
     */
    harvestefficiently(miner, source, allowSuicide = true) {
        if (this.container) {
            if (
                this.container.store[RESOURCE_ENERGY] < CONTAINER_CAPACITY || miner.store.getUsedCapacity() == 0|| 
                (this.source &&
                    this.source.energy / this.source.ticksToRegeneration >
                        miner.getActiveBodyparts(WORK) * 1.8)
            ) {
                this.harvestOrSleep(miner, source);
            }
        } else if (
            this.link &&
            this.colony.commandCenter &&
            this.colony.commandCenter.link
        ) {
            if (
                this.link.energy < LINK_CAPACITY ||
                (this.source &&
                    this.source.energy / this.source.ticksToRegeneration >
                        miner.getActiveBodyparts(WORK) * 1.8)
            ) {
                this.harvestOrSleep(miner, source);
            }
        } else {
            this.harvestOrSleep(miner, source);
        } // TODO: add sources that are power enabled
    }
    /**
     * Harvests from a source and sleeps the creep until regeneration if needed. This method doesn't run many safety
     * checks, so the creep will need to be in range
     */
    harvestOrSleep(miner, source, allowSuicide = true) {
        const ret = miner.harvest(source);
        let maxSleepTime = Infinity;

        if (this.memory.lairId) {
            const lair = Game.getObjectById(this.memory.lairId);
            if (lair && lair.ticksToSpawn) {
                maxSleepTime = lair.ticksToSpawn - 16;
            }
        }

        if (ret != OK) {
            switch (ret) {
                case ERR_NOT_ENOUGH_RESOURCES: // energy depleted
                    if (
                        allowSuicide &&
                        source.ticksToRegeneration >
                            Math.min(
                                miner.ticksToLive || Infinity,
                                maxSleepTime,
                            )
                    ) {
                        miner.suicide();
                    } else {
                        // Do not sleep if source is PWR_REGEN_SOURCE enabled
                        if (!(source.effects && source.effects[0])) {
                            miner.memory.sleepUntil =
                                Game.time +
                                Math.min(
                                    source.ticksToRegeneration,
                                    maxSleepTime,
                                );
                        }
                    }
                    break;
                case ERR_NO_BODYPART:
                    if (allowSuicide) {
                        miner.suicide();
                    }
                    break;
                case ERR_NOT_OWNER:
                    if (Game.time % 20 == 0) {
                        log.alert(
                            `${miner.print}: room "${miner.room.name}" is reserved by hostiles!`,
                        ); // zGen PR#190
                    }
                    break;
                default:
                    log.error(
                        `${miner.print}: unhandled miner.harvest() exception: ${ret}`,
                    );
                    break;
            }
        }
    }

    handleMiner(miner) {
        // Stay safe out there!
        if (miner.avoidDanger({ timer: 6, dropEnergy: true })) {
            //zGeneral 31/12/2021  flee for 6 seconds only
            return;
        }
        if (
            miner.room &&
            this.room &&
            miner.room.name == this.room.name &&
            this.source &&
            this.source.energy === 0 &&
            this.source.ticksToRegeneration > miner.ticksToLive && 
            !(this.source.effects && this.source.effects.length > 0)
        ) {
            // zGeneral 30/9/2023
            miner.drop();
            console.log(miner.pos.print, 'kill miner, can not make it!');
            miner.suicide();
        }
        // Check if stuff needs to be dismantled to clean up the room
        /*
        if (this.memory.dismantleNeeded) {
            return this.dismantleActions(miner);
        }
        */
        // Run the appropriate mining actions
        switch (this.mode) {
            case 'early':
                return this.earlyMiningActions(miner);
            case 'link':
                return this.linkMiningActions(miner);
            case 'standard':
                return this.standardMiningActions(miner);
            case 'SK':
                return this.skMiningActions(miner);
            case 'double':
                return this.doubleMiningActions(miner);
            default:
                log.error(
                    `UNHANDLED MINER STATE FOR ${miner.print} (MODE: ${this.mode})`,
                );
        }
    }
    run() {
        for (const miner of this.miners) {
            this.handleMiner(miner);
        }
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 0) {
            this.addRemoveContainer();
        }
        if (Game.time % SUICIDE_CHECK_FREQUENCY == 0) {
            this.suicideOldMiners();
        }
    }
});
MiningOverlord.settings = {
    minLinkDistance: 10,
    dropMineUntilRCL: 3,
};
MiningOverlord = MiningOverlord_1 = __decorate([profile], MiningOverlord);

const defaultDirectiveHarvestMemory = {
    ['u' /* USAGE */]: 1,
    ['d' /* DOWNTIME */]: 0,
};
/**
 * Standard mining directive. Mines from an owned, remote, or source keeper room
 */
let DirectiveHarvest = class DirectiveHarvest extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.miningSites[this.name] = this;
            this.colony.destinations.push({
                pos: this.pos,
                order: this.memory['T' /* TICK */] || Game.time,
            });
        }
        _.defaultsDeep(this.memory, defaultDirectiveHarvestMemory);
    }
    // Hauling distance
    get distance() {
        if (
            !this.memory['P' /* PATHING */] ||
            Game.time >= this.memory['P' /* PATHING */]['X' /* EXPIRATION */]
        ) {
            const distance =
                Pathing.distance(this.colony.pos, this.pos) || Infinity;
            const expiration = getCacheExpiration(
                this.colony.storage ? 5000 : 1000,
            );
            this.memory['P' /* PATHING */] = {
                ['D' /* DISTANCE */]: distance,
                ['X' /* EXPIRATION */]: expiration,
            };
        }
        return this.memory['P' /* PATHING */]['D' /* DISTANCE */];
    }
    spawnMoarOverlords() {
        // Create a mining overlord for this
        let priority = OverlordPriority.ownedRoom.mine;
        if (!(this.room && this.room.my)) {
            priority =
                Cartographer.roomType(this.pos.roomName) ==
                    ROOMTYPE_SOURCEKEEPER ||
                Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
                    ? OverlordPriority.remoteSKRoom.mine
                    : OverlordPriority.remoteRoom.mine;
        }
        this.overlords.mine = new MiningOverlord(this, priority);
    }
    getMiddleRoom() {
        const delta = Cartographer.findRoomCoordDeltas(
            this.colony.name,
            this.pos.roomName,
        );
        switch (delta.x) {
            case 2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x - 1,
                    delta.y,
                );
                break;
            case -2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x + 1,
                    delta.y,
                );
                break;
            default:
                switch (delta.y) {
                    case 2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y - 1,
                        );
                        break;
                    case -2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y + 1,
                        );
                        break;
                }
        }
    }
    init() {
        if (
            Game.time % 10 == 1 &&
            this.room &&
            this.room.invaderCore &&
            this.room.invaderCore.level > 2
        ) {
            this.memory.c1 = COLOR_YELLOW;
            this.memory.c2 = COLOR_YELLOW;
            Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
        }
        if (
            Game.time % 10 == 1 &&
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
        ) {
            if (!this.middleRoom) {
                this.getMiddleRoom();
            }
            if (
                this.middleRoom &&
                Game.rooms[this.middleRoom] &&
                Game.rooms[this.middleRoom].invaderCore &&
                Game.rooms[this.middleRoom].invaderCore.level > 3
            ) {
                this.memory.c1 = COLOR_YELLOW;
                this.memory.c2 = COLOR_YELLOW;
                Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
            }
        }
    }
    run() {
        this.computeStats();
    }
    computeStats() {
        const source = this.overlords.mine.source;
        if (source && source.ticksToRegeneration == 1) {
            this.memory['u' /* USAGE */] =
                (source.energyCapacity - source.energy) / source.energyCapacity;
        }
        const container = this.overlords.mine.container;
        this.memory['d' /* DOWNTIME */] = +ema(
            container ? +container.isFull : 0,
            this.memory['d' /* DOWNTIME */],
            CREEP_LIFE_TIME,
        ).toFixed(5);
    }
};
DirectiveHarvest.directiveName = 'harvest';
DirectiveHarvest.color = COLOR_YELLOW;
DirectiveHarvest.secondaryColor = COLOR_YELLOW;
DirectiveHarvest = __decorate([profile], DirectiveHarvest);

const getDefaultOperatorOverlordMemory = () => ({
    ['T' /* TICK */]: Game.time,
    sourcesId: [],
});
class OperatorOverlord extends PowerOverlord {
    constructor(directive, priority = OverlordPriority.powerCreeps.default) {
        super(
            directive,
            'operator',
            priority,
            getDefaultOperatorOverlordMemory,
        );
        this.operators = this.powerZerg(PowerCreepSetups.economy.role);
    }
    refresh() {
        super.refresh();
    }
    init() {
        if (!this.colony.powerSpawn && this.colony.level != 8) return;
        // not done properly, powerCreep would not work without it!
        this.wishlistPC(PowerCreepSetups.economy, 1);
    }
    handleOperator(pc) {
        // prerequisites
        if (
            !pc.isSpawned ||
            !this.colony.powerSpawn ||
            this.colony.level != 8
        ) {
            return;
        }
        // pre power actions
        if (this.renew(pc)) return;
        if (this.needHealing(pc)) return; // fallback under controller ramps
        if (this.avoidDanger(pc)) return; // not using civilian avoid danger - just hide under controller ramps
        if (this.enableControllers(pc)) return;
        if (this.balanceOps(pc)) return;
        // run powers from task memory
        const retRunPower = pc.runPower();
        if (retRunPower == ERR_NOT_IN_RANGE) {
            // return until reaching target
            return;
        } else {
            // i.e. either tried and done successfully, or failed for any reason => in any case, remove task
            pc.clearTask();
        }
        // calculate if we have saved up enough ops in storage to waste a few
        this.overMaxOps =
            !!this.colony.storage &&
            this.colony.storage.store[RESOURCE_OPS] >
                OperatorOverlord.settings.maxStorageOps;
        // assign new power task
        if (this.generateOps(pc)) return;
        if (this.operateSpawns(pc)) return;
        if (this.operateExtensions(pc)) return;
        if (this.regenSources(pc)) return;
        if (this.operateLabs(pc)) return;
        // park in colony room.
        this.park(pc);
    }
    generateOps(pc) {
        const powerId = PWR_GENERATE_OPS;
        if (!pc.canUsePowers(powerId) || pc.isFull()) {
            return false;
        }
        if (this.overMaxOps) {
            log.warning(
                `powerCreep ${pc.print} @ ${pc.room.print} paused generating ops - overflow limit reached`,
            );
            return false;
        }
        pc.setTask(powerId);
        return true;
    }
    operateSpawns(pc) {
        const powerId = PWR_OPERATE_SPAWN;
        if (
            !pc.canUsePowers(
                powerId,
                OperatorOverlord.settings[powerId].cooldownThreshold,
            )
        ) {
            return false;
        }
        // Calculates if the hatchery is spawning non-stop
        const hatcheryUptimeOverThreshold =
            Memory.colonies[this.colony.name].hatchery.stats.uptime >
            OperatorOverlord.settings[powerId].activationThreshold;
        // checks if any of the currently spawning creeps is a priority
        const spawnWithPrioCreeps = _.find(
            this.colony.spawns,
            (spawn) =>
                spawn.spawning &&
                OperatorOverlord.settings[powerId].combatBodyPri.indexOf(
                    spawn.spawning.name.split('_')[0],
                ),
        );
        const wantToUse =
            this.overMaxOps ||
            hatcheryUptimeOverThreshold ||
            spawnWithPrioCreeps || this.colony.name == 'xxW59N31'; // zGeneral temp 16/10/2023
        // only use operateSpawn if you really want to use it
        if (!wantToUse) {
            return false;
        }
        if (
            !!this.colony.storage &&
            this.colony.storage.store[RESOURCE_OPS] < 2500 // zGeneral temp return to 2500 16/10/2023
        ) {
            // zGeneral 30/11/2021 do not operate spawn if ops below 2500, need the ops for ext operation better
            return false;
        }
        // find target to operate
        const spawns = _.filter(this.colony.spawns, (spawn) => {
            return (
                /*
             todo: Do we really only want to target spawns that are spawning?
             It might not work for the currently spawning creep
             So maybe select the ones that are not spawning and have the
             hatchery logic pick the spawn with the best effect?
            */
                !!spawn.spawning &&
                spawn.firstEffectRemaining <
                    OperatorOverlord.settings[powerId].ticksRemainingThreshold
            );
        });
        // operate spawn and return true
        const target = _.first(spawns);
        if (!(target && target.id)) return false;
        pc.setTask(powerId, target.id);
        return true;
    }
    regenSources(pc) {
        const powerId = PWR_REGEN_SOURCE;
        if (
            !pc.canUsePowers(
                powerId,
                OperatorOverlord.settings[powerId].cooldownThreshold,
            )
        ) {
            return false;
        }
        // identify 3 colony ssources to operate on - closest by distance
        if (
            this.memory.sourcesId == undefined ||
            this.memory.sourcesId.length == 0 ||
            Game.time % 10000 == 0
        ) {
            const colonyHarvestDirectives = _.filter(
                // TODO: watch for this when implementing the new outpost directive
                DirectiveHarvest.findInColony(this.colony),
                (dir) =>
                    Game.rooms[dir.flag.pos.roomName] && // visible rooms only
                    Game.rooms[dir.flag.pos.roomName].controller,
            );
            const sortedByDistance = _.sortBy(
                colonyHarvestDirectives,
                (dir) => dir.distance,
            );
            this.memory.sourcesId = _.take(
                // note: only works on visible rooms
                _.map(sortedByDistance, (dir) => dir.overlords.mine.source.id),
                3,
            );
        }
        // trigger = any source not under effect
        // find target to operate (colony.room.sources)
        let sources = _.compact(
            _.map(this.memory.sourcesId, (id) => Game.getObjectById(id)),
        );
        sources = _.filter(
            sources,
            (target) =>
                target instanceof Source &&
                target.firstEffectRemaining <
                    OperatorOverlord.settings[powerId].ticksRemainingThreshold,
        );
        // operate spawn and return true
        const target = _.first(sources);
        if (!(target && target.id)) return false;
        pc.setTask(powerId, target.id);
        return true;
    }
    operateExtensions(pc) {
        const powerId = PWR_OPERATE_EXTENSION;
        if (
            !pc.canUsePowers(
                powerId,
                OperatorOverlord.settings[powerId].cooldownThreshold,
            )
        ) {
            return false;
        }
        // trigger = ext energy < threshold
        if (
            this.colony.room.energyAvailable >
            this.colony.room.energyCapacityAvailable *
                OperatorOverlord.settings[powerId].activationThreshold
        ) {
            return false;
        }
        const requiredEnergy =
            this.colony.room.energyCapacityAvailable *
                OperatorOverlord.settings[powerId].activationThreshold -
            this.colony.room.energyAvailable;
        // find target to operate
        const target =
            this.colony.storage &&
            this.colony.storage.store[RESOURCE_ENERGY] > requiredEnergy
                ? this.colony.storage
                : this.colony.terminal &&
                  this.colony.terminal.store[RESOURCE_ENERGY] > requiredEnergy
                ? this.colony.terminal
                : undefined;
        // operate spawn and return true
        if (!target) {
            log.warning(
                this.colony.room.name +
                    ` not enough energy in storage/terminal to operate extensions`,
            );
            _.forEach(Overmind.colonies, (c) =>
                c.terminal.send('energy', 5000, this.colony.room.name),
            ); // zGeneral 8/2023
            return false;
        }
        if (!(target && target.id)) return false;
        pc.setTask(powerId, target.id);
        return true;
    }
    operateLabs(pc) {
        const powerId = PWR_OPERATE_LAB;
        if (
            !pc.canUsePowers(
                powerId,
                OperatorOverlord.settings[powerId].cooldownThreshold,
            )
        ) {
            return false;
        }
        // trigger = Labs with cooldown > 0 i.e. not idle
        // find lab to operate
        const labs = _.filter(
            this.colony.labs,
            (lab) =>
                lab.cooldown > 0 &&
                lab.firstEffectRemaining <
                    OperatorOverlord.settings[powerId].ticksRemainingThreshold,
        );
        // operate lab and return true
        const target = _.first(labs);
        if (!(target && target.id)) return false;
        pc.setTask(powerId, target.id);
        return true;
    }
    renew(pc) {
        if (pc.ticksToLive < 200) {
            if (pc.pos.inRangeToPos(this.colony.powerSpawn.pos, 1)) {
                pc.renew(this.colony.powerSpawn);
            } else {
                pc.goTo(this.colony.powerSpawn);
            }
            return true;
        }
        return false;
    }
    needHealing(pc) {
        if (pc.hits < pc.hitsMax && !pc.inRampart) {
            pc.goTo(this.colony.controller, { range: 1 }); // TODO this assumes that controllers are ramped, needs more work
            return true;
        }
        return false;
    }
    avoidDanger(pc) {
        if (
            pc.inColonyRoom &&
            this.colony.room.dangerousHostiles.length > 0 &&
            !pc.inRampart
        ) {
            pc.goTo(this.colony.controller, { range: 1 }); // TODO this assumes that controllers are ramped, needs more work
            return true;
        }
        return false;
    }
    enableControllers(pc) {
        if (this.controllersEnabled) return false;
        const sources = _.compact(
            _.map(this.memory.sourcesId, (id) => Game.getObjectById(id)),
        );
        const sourcesController = _.map(sources, (s) => s.room.controller);
        const controllers = _.compact([
            this.colony.controller,
            ...sourcesController,
        ]);
        const unenabledController = _.find(
            controllers,
            (controller) => !controller.isPowerEnabled,
        );
        if (unenabledController == undefined) {
            this.controllersEnabled = true;
            return false;
        }
        if (pc.pos.inRangeToPos(unenabledController.pos, 1)) {
            pc.enableRoom(unenabledController);
        } else {
            pc.goTo(unenabledController, { range: 1 });
        }
        return true;
    }
    balanceOps(pc) {
        // transfer extra ops to storage
        if (pc.store[RESOURCE_OPS] >= pc.carryCapacity - 8) {
            if (
                this.colony.storage &&
                _.sum(this.colony.storage.store) < STORAGE_CAPACITY
            ) {
                if (pc.pos.inRangeToPos(this.colony.storage.pos, 1)) {
                    const amount = Math.ceil(
                        pc.carryCapacity *
                            OperatorOverlord.settings[PWR_GENERATE_OPS]
                                .maxDepositeOps,
                    );
                    pc.transfer(this.colony.storage, RESOURCE_OPS, amount); // keep 20% for ops uses
                } else {
                    pc.goTo(this.colony.storage.pos, { range: 1 });
                }
            } else {
                pc.drop(RESOURCE_OPS);
            }
            return true;
        }
        // refill powerCreep with Ops if needed
        const minCarryOpsLimit = Math.ceil(
            pc.carryCapacity * OperatorOverlord.settings.minCarryOps,
        );
        if (pc.store[RESOURCE_OPS] < minCarryOpsLimit) {
            // refill by 40% if carrying less than 20%
            const storageOpsLimit = Math.ceil(
                pc.carryCapacity * OperatorOverlord.settings.refillLimit,
            );
            if (
                this.colony.storage &&
                this.colony.storage.store[RESOURCE_OPS] > storageOpsLimit
            ) {
                if (pc.pos.inRangeToPos(this.colony.storage.pos, 1)) {
                    pc.withdraw(
                        this.colony.storage,
                        RESOURCE_OPS,
                        Math.ceil(
                            pc.carryCapacity * 0.4 - pc.store[RESOURCE_OPS],
                        ),
                    );
                } else {
                    pc.goTo(this.colony.storage.pos, { range: 1 });
                }
                return true;
            }
        }
        return false;
    }
    park(pc) {
        if (pc.safelyInRoom(this.colony.room.name)) {
            pc.goTo(this);
            // TODO: BUG: powerZerg does not move out of the way, replace park() with Goto(flag) for now
            // pc.park();
        } else {
            pc.goTo(this);
        }
    }
    run() {
        _.forEach(this.operators, (operator) => this.handleOperator(operator));
    }
}
OperatorOverlord.settings = {
    maxStorageOps: 50000,
    minCarryOps: 0.2,
    refillLimit: 0.4,
    [PWR_GENERATE_OPS]: {
        maxDepositeOps: 0.8,
    },
    [PWR_OPERATE_SPAWN]: {
        activationThreshold: 0.8,
        cooldownThreshold: 25,
        ticksRemainingThreshold: 25,
        combatBodyPri: [
            'hydralisk',
            'strongman',
            'broodling',
            'zergling',
            'transfuser',
            'coolant',
        ],
    },
    [PWR_OPERATE_EXTENSION]: {
        activationThreshold: 0.3, // zgeneral 7/12/2021 was 0.5
        cooldownThreshold: 0,
    },
    [PWR_REGEN_SOURCE]: {
        cooldownThreshold: 25,
        ticksRemainingThreshold: 25,
    },
    [PWR_OPERATE_LAB]: {
        cooldownThreshold: 12,
        ticksRemainingThreshold: 12,
    },
};

/**
 * Simple directive to run a power creep where the flag name is the power creep name
 */
let DirectiveBaseOperator = class DirectiveBaseOperator extends Directive {
    constructor(flag) {
        super(
            flag,
            (colony) =>
                colony.level == 8 &&
                colony.powerSpawn != undefined &&
                colony.name == Directive.getPos(flag).roomName,
        ); // only allow placing in colony room
        super.refresh();
    }
    spawnMoarOverlords() {
        this.overlords.powerCreeps = new OperatorOverlord(this);
    }
    refresh() {
        super.refresh();
    }
    init() {}
    visuals() {}
    run() {}
};
DirectiveBaseOperator.directiveName = 'BaseOperator';
DirectiveBaseOperator.color = COLOR_CYAN;
DirectiveBaseOperator.secondaryColor = COLOR_PURPLE;
DirectiveBaseOperator = __decorate([profile], DirectiveBaseOperator);

var ExtractorOverlord_1;
const BUILD_OUTPUT_FREQUENCY$1 = 15;
/**
 * Spawns extractors to harvest minerals in an owned or sourcekeeper room
 */
let ExtractorOverlord = (ExtractorOverlord_1 = class ExtractorOverlord extends (
    Overlord
) {
    constructor(directive, priority) {
        super(directive, 'mineral', priority);
        this.directive = directive;
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.drones = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
    }
    // If mineral is ready to be mined, make a container
    shouldHaveContainer() {
        return (
            this.mineral &&
            (this.mineral.mineralAmount > 0 ||
                (this.mineral.ticksToRegeneration || 0) < 2000)
        ); // zGeneral 8/2023
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.extractor = this.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            this.mineral = this.pos.lookFor(LOOK_MINERALS)[0];
            this.container = this.pos.findClosestByLimitedRange(
                Game.rooms[this.pos.roomName].containers,
                1,
            );
        }
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            // if you just gained vision of this room
            this.populateStructures();
        }
        super.refresh();
        $.refresh(this, 'extractor', 'mineral', 'container');
    }
    registerOutputRequests() {
        if (this.container) {
            const outputThreshold = 1300; // zGeneral 8/2023
            if (this.container.store.getUsedCapacity() >= outputThreshold) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: 'all',
                });
            }
        }
    }
    /* Calculate where the container output will be built for this site */
    calculateContainerPos() {
        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        } else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, (pos) => pos.getRangeTo(this) == 1);
            if (pos) return pos;
        }
        // Shouldn't ever get here
        log.warning(
            `Last resort container position calculation for ${this.print}!`,
        );
        return _.first(this.pos.availableNeighbors(true));
    }
    buildOutputIfNeeded() {
        // Create container if there is not already one being built
        if (!this.container && this.shouldHaveContainer()) {
            const containerSite = _.first(
                _.filter(
                    this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2),
                    (site) => site.structureType == STRUCTURE_CONTAINER,
                ),
            );
            if (!containerSite) {
                const containerPos = this.calculateContainerPos();
                log.info(
                    `${this.print}: building container at ${containerPos.print}`,
                );
                const result = containerPos.createConstructionSite(
                    STRUCTURE_CONTAINER,
                );
                if (result != OK) {
                    log.error(
                        `${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`,
                    );
                }
                return;
            }
        }
    }
    init() {
        if (
            this.colony.room.dangerousPlayerHostiles.length > 0 ||
            (this.room &&
                !this.room.my &&
                (this.room.invaders.length > 2 ||
                    this.room.dangerousPlayerHostiles.length > 0))
        ) {
            // Do not spawn drones if colony is under attack or outpost is under attack
            return;
        }
        this.registerOutputRequests();
        if (
            this.room &&
            this.colony.room.storage &&
            this.room.mineral &&
            this.colony.assets[this.room.mineral.mineralType] > 25000
        ) {
            // zGeneral 8/12/2020
            return; // do not extract minerals if colony is full of it
        }

        const amount =
            this.mineral &&
            this.mineral.mineralAmount > 0 &&
            this.extractor &&
            this.container
                ? Math.min(
                      this.mineral.pos.availableNeighbors().length,
                      ExtractorOverlord_1.settings.maxDrones,
                  )
                : 0;
        this.wishlist(amount, Setups.drones.extractor);
    }
    handleDrone(drone) {
        // Stay safe out there!
        if (drone.avoidDanger({ timer: 10, dropEnergy: true })) {
            return;
        }
        // Ensure you are in the assigned room
        if (drone.room == this.room && !drone.pos.isEdge) {
            if (this.mineral && !drone.pos.inRangeToPos(this.mineral.pos, 1)) {
                return drone.goTo(this.mineral.pos);
            }
            if (this.mineral) {
                // Do harvest first - needs to check if in range anyway so this is more CPU efficient
                const ret = drone.harvest(this.mineral);
                if (ret == ERR_NOT_IN_RANGE) {
                    return drone.goTo(this.mineral);
                }
                if (this.container) {
                    // Transfer to container if you need to (can do at same tick as harvest)
                    if (
                        drone.store.getUsedCapacity() >
                        0.9 * drone.store.getCapacity()
                    ) {
                        const transfer = drone.transferAll(this.container);
                        if (transfer == ERR_NOT_IN_RANGE) {
                            return drone.goTo(this.container, { range: 1 });
                        }
                    }
                    // Move onto the container pos if you need to
                    if (
                        this.drones.length == 1 &&
                        !drone.pos.isEqualTo(this.container.pos)
                    ) {
                        return drone.goTo(this.container, { range: 0 });
                    }
                }
            } else {
                log.error(`${this.print}: room defined and no mineral! (Why?)`);
            }
        } else {
            drone.goTo(this);
        }
    }
    run() {
        _.forEach(this.drones, (drone) => this.handleDrone(drone));
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY$1 == 2) {
            this.buildOutputIfNeeded();
        }
    }
});
ExtractorOverlord.settings = {
    maxDrones: 2,
};
ExtractorOverlord = ExtractorOverlord_1 = __decorate(
    [profile],
    ExtractorOverlord,
);

let DirectiveExtract = class DirectiveExtract extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.destinations.push({
                pos: this.pos,
                order: this.memory['T' /* TICK */] || Game.time,
            });
        }
    }
    spawnMoarOverlords() {
        let priority;
        if (this.room && this.room.my) {
            if (this.colony.level == 8) {
                priority = OverlordPriority.ownedRoom.mineralRCL8;
            } else {
                priority = OverlordPriority.ownedRoom.mineral;
            }
        } else {
            priority = OverlordPriority.remoteSKRoom.mineral;
        }
        this.overlords.extract = new ExtractorOverlord(this, priority);
    }
    getMiddleRoom() {
        const delta = Cartographer.findRoomCoordDeltas(
            this.colony.name,
            this.pos.roomName,
        );
        switch (delta.x) {
            case 2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x - 1,
                    delta.y,
                );
                break;
            case -2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x + 1,
                    delta.y,
                );
                break;
            default:
                switch (delta.y) {
                    case 2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y - 1,
                        );
                        break;
                    case -2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y + 1,
                        );
                        break;
                }
        }
    }
    init() {
        if (
            Game.time % 10 == 1 &&
            this.room &&
            this.room.invaderCore &&
            this.room.invaderCore.level > 2
        ) {
            this.memory.c1 = COLOR_YELLOW;
            this.memory.c2 = COLOR_CYAN;
            Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
        }
        if (
            Game.time % 10 == 1 &&
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE
        ) {
            if (!this.middleRoom) {
                this.getMiddleRoom();
            }
            if (
                this.middleRoom &&
                Game.rooms[this.middleRoom] &&
                Game.rooms[this.middleRoom].invaderCore &&
                Game.rooms[this.middleRoom].invaderCore.level > 3
            ) {
                this.memory.c1 = COLOR_YELLOW;
                this.memory.c2 = COLOR_CYAN;
                Game.flags[this.ref].setColor(COLOR_WHITE, COLOR_GREY);
            }
        }
    }
    run() {
        if (this.colony.level < 6) {
            log.notify(
                `Removing extraction directive in ${this.pos.roomName}: room RCL insufficient.`,
            );
            this.remove();
        } else if (!this.colony.terminal) {
            log.notify(
                `Removing extraction directive in ${this.pos.roomName}: room is missing terminal.`,
            );
            this.remove();
        }
    }
};
DirectiveExtract.directiveName = 'extract';
DirectiveExtract.color = COLOR_YELLOW;
DirectiveExtract.secondaryColor = COLOR_CYAN;
DirectiveExtract = __decorate([profile], DirectiveExtract);

let LeecherOverlord = class LeecherOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.default) {
        super(directive, 'leech', priority);
        this.directive = directive;
        this.leechers = this.zerg(Roles.transport, {
            notifyWhenAttacked: false,
        });
    }
    refresh() {
        super.refresh();
    }
    init() {
        const roomName = this.directive.pos.roomName;
        const amount =
            RoomIntel.getSourceInfo(roomName) != undefined
                ? RoomIntel.getSourceInfo(roomName).length
                : 1;
        this.wishlist(amount, Setups.transporters.early);
    }
    run() {
        this.autoRun(this.leechers, (leacher) => this.handleLeecher(leacher));
    }
    handleLeecher(leecher) {
        if (leecher.avoidDanger({ dropEnergy: false })) return;
        if (
            sumStore(leecher.store) == 0 &&
            !leecher.safelyInRoom(this.pos.roomName)
        ) {
            leecher.goTo(this.pos);
            return;
        }
        if (!leecher.isFull() && this.room) {
            const target = maxBy(this.room.rechargeables, (x) => {
                return isResource(x) ? x.amount : sumStore(x.store);
            });
            if (target) {
                if (leecher.pos.isNearTo(target)) {
                    if (!isResource(target)) {
                        leecher.task = Tasks.withdrawAll(target);
                    } else {
                        leecher.task = Tasks.pickup(target);
                    }
                    return;
                } else {
                    leecher.goTo(target, { range: 1 });
                    return;
                }
            }
            if (this.room.containers.length == 0) {
                log.warning(
                    `leech directive ${this.directive.print} has no containers`,
                );
            }
        }
        if (leecher.isFull() && this.colony.storage) {
            leecher.task = Tasks.transferAll(this.colony.storage);
            return;
        }
    }
};
LeecherOverlord = __decorate([profile], LeecherOverlord);

let DirectiveLeech = class DirectiveLeech extends Directive {
    constructor(flag) {
        super(flag);
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            this.remove();
            log.notify(
                `Removing leech directive in ${this.pos.roomName}: must be a controller room`,
            );
        }
    }
    spawnMoarOverlords() {
        this.overlords.leech = new LeecherOverlord(this);
    }
    init() {
        this.alert(`Leeching room  ${this.pos.roomName}`);
    }
    run() {
        // leaving the below constantly on for observation
        // if( true && // Game.time % 50 == 0 &&
        //    this.memory.totalLeech && this.memory.totalCost &&
        //    this.memory.totalLeech < this.memory.totalCost &&
        //    this.memory.totalCost > 2500) {
        // 	log.notify(`Removing leech directive in ${this.pos.roomName
        // 	}: making loss ${this.memory.totalLeech - this.memory.totalCost}`);
        // 	console.log(`Removing leech directive in ${this.pos.roomName
        // 	}: making loss ${this.memory.totalLeech - this.memory.totalCost}`);
        // 	// this.remove();
        //    }
    }
};
DirectiveLeech.directiveName = 'leech';
DirectiveLeech.color = COLOR_YELLOW;
DirectiveLeech.secondaryColor = COLOR_ORANGE;
DirectiveLeech = __decorate([profile], DirectiveLeech);

var PowerDrillOverlord_1;
/**
 * PowerDrillOverlord -- spawns drills and coolant to mine power banks
 */
let PowerDrillOverlord = (PowerDrillOverlord_1 = class PowerDrillOverlord extends (
    CombatOverlord
) {
    constructor(directive, priority = OverlordPriority.powerMine.drill) {
        super(
            directive,
            'powerDrill',
            priority,
            PowerDrillOverlord_1.requiredRCL,
        );
        this.directive = directive;
        this.priority +=
            this.outpostIndex * OverlordPriority.powerMine.roomIncrement;
        this.drills = this.combatZerg(Roles.drill);
        this.coolant = this.combatZerg(Roles.coolant);
        this.memory = Mem.wrap(this.directive.memory, 'powerDrill');
        this.partnerMap = new Map();
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, 'powerDrill');
    }
    init() {
        if (this.room) {
            if (
                !(
                    this.room.dangerousHostiles &&
                    this.room.dangerousHostiles.length > 0
                )
            ) {
                this.wishlist(1, CombatSetups.drill.default);
                this.wishlist(1, CombatSetups.coolant.default);
            }
        } else {
            this.wishlist(1, CombatSetups.drill.default);
            this.wishlist(1, CombatSetups.coolant.default);
        }
    }
    getHostileDrill(powerBank) {
        return (
            powerBank.hits < powerBank.hitsMax &&
            powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 2)[0]
        );
    }
    handleHostileDrill(hostileDrill, powerBank) {
        Game.notify(
            `${hostileDrill.owner.username} power harvesting ${powerBank.room.name}, competing for same power bank.`,
        );
        // this.directive.remove();
    }
    handleDrill(drill) {
        if (drill.spawning) {
            return;
        }
        if (!this.directive.powerBank) {
            if (!this.room);
            else {
                // If power bank is dead
                if (
                    this.directive.powerBank == undefined &&
                    this.directive.memory.state < 2
                ) {
                    Game.notify(`Power bank in ${this.room.print} is dead.`);
                    drill.say('💀 RIP 💀');
                    const result = drill.retire();
                    if (result == ERR_BUSY);
                    log.notify(
                        'FINISHED POWER MINING IN ' +
                            this.room +
                            ' DELETING CREEP at time: ' +
                            Game.time.toString() +
                            ' result: ' +
                            result,
                    );
                    return;
                }
            }
        }
        // Go to power room
        if (
            !this.room ||
            drill.room != this.room ||
            drill.pos.isEdge ||
            !this.directive.powerBank
        ) {
            // log.debugCreep(drill, `Going to room!`);
            // log.notify("Drill is moving to power site in " + this.pos.roomName + ".");
            drill.goTo(this.pos);
            return;
        }
        if (this.room.dangerousPlayerHostiles.length > 0 ) {
            drill.autoMelee();
            return;
        }
        if (
            drill.hits > drill.hitsMax * 0.5 &&
            drill.pos.isNearTo(this.directive.powerBank)
        ) {
            // zgeneral 8/2023
            if (!this.partnerMap.get(drill.name)) {
                this.partnerMap.set(drill.name, []);
            }
            PowerDrillOverlord_1.periodicSay(drill, 'Drilling⚒️');
            if(Game.cpu.getUsed() >= 290 || Game.cpu.bucket < 9000) {
                    // console.log('skip drill.attack, CPU >= 300, room',Game.cpu.getUsed().toFixed(0), this.directive.pos.roomName); // zGeneral 3/2024
            } else {
                drill.attack(this.directive.powerBank);
            }
        } else {
            PowerDrillOverlord_1.periodicSay(drill, '🚗Traveling🚗');
            drill.goTo(this.directive.powerBank);
        }
    }
    handleCoolant(coolant) {
        if (coolant.spawning) {
            return;
        }
        // Go to powerbank room
        if (!this.room || coolant.room != this.room || coolant.pos.isEdge) {
            // log.debugCreep(coolant, `Going to room!`);
            coolant.healSelfIfPossible();
            coolant.goTo(this.pos);
            return;
        } else if (!this.directive.powerBank) {
            // If power bank is dead
            Game.notify('Power bank in ' + this.room + ' is dead.');
            coolant.say('💀 RIP 💀');
            coolant.retire();
            return;
        }
        if (this.room.dangerousPlayerHostiles.length > 0 ) {
            coolant.autoHeal();
            return;
        }
        if (coolant.pos.getRangeTo(this.directive.powerBank) > 3) {
            coolant.goTo(this.directive.powerBank);
        } else {
            coolant.autoHeal();
            const activeDrills = this.pos
                .findInRange(FIND_MY_CREEPS, 1)
                .filter((creep) => _.contains(creep.name, 'drill'));
            if (activeDrills.length > 0) {
                const drill = activeDrills[0];
                coolant.heal(drill);
                if (coolant.pos.getRangeTo(drill) > 1) {
                    coolant.goTo(drill, { range: 1, noPush: true });
                }
            }
        }
        // else if (coolant.pos.findInRange(FIND_MY_CREEPS, 1).filter(creep => _.contains(creep.name, "drill")).length == 0) {
        // 	let target = _.sample(_.filter(this.drills, drill => drill.hits < drill.hitsMax));
        // 	if (target) {
        // 		coolant.goTo(target, {range: 1, noPush: true});
        // 	}
        // }
        // // else if (coolant.pos.getRangeTo(this.directive.powerBank) == 1) {
        // // 	coolant.move(Math.round(Math.random()*7) as DirectionConstant);
        // // }
        // else {
        // 	let drill = _.sample(_.filter(this.drills, drill => drill.hits < drill.hitsMax));
        // 	if (drill) { coolant.goTo(drill); }
        // }
        //
        // coolant.autoHeal();
    }
    // private findDrillToPartner(coolant: CombatZerg) {
    // 	let needsHealing = _.min(Array.from(this.partnerMap.keys()), key => this.partnerMap.get(key)!.length);
    // 	if (this.partnerMap.get(needsHealing)) {
    // 		this.partnerMap.get(needsHealing)!.concat(coolant.name);
    // 		coolant.say(needsHealing.toString());
    // 		coolant.memory.partner = needsHealing;
    // 	} else {
    //
    // 	}
    // 	//console.log(JSON.stringify(this.partnerMap));
    // 	// let newPartner = _.sample(_.filter(this.drills, drill => this.room == drill.room));
    // 	// coolant.memory.partner = newPartner != undefined ? newPartner.name : undefined;
    // 	coolant.say('Partnering!');
    // }
    //
    // private runPartnerHealing(coolant: CombatZerg) {
    // 	if (coolant.memory.partner) {
    // 		let drill = Game.creeps[coolant.memory.partner];
    // 		if (!drill) {
    // 			// Partner is dead
    // 			coolant.memory.partner = undefined;
    // 			this.findDrillToPartner(coolant)
    // 		} else if (!coolant.pos.isNearTo(drill)) {
    // 			PowerDrillOverlord.periodicSay(coolant,'🚗Traveling️');
    // 			coolant.goTo(drill);
    // 		} else {
    // 			PowerDrillOverlord.periodicSay(coolant,'❄️Cooling❄️');
    // 			coolant.heal(drill);
    // 		}
    // 		if (Game.time % 10 == PowerDrillOverlord.getCreepNameOffset(coolant)) {
    // 			this.findDrillToPartner(coolant);
    // 		}
    // 		return;
    // 	} else {
    // 		this.findDrillToPartner(coolant);
    // 	}
    // }
    static periodicSay(zerg, text) {
        if (Game.time % 10 == PowerDrillOverlord_1.getCreepNameOffset(zerg)) {
            zerg.say(text, true);
        }
    }
    static getCreepNameOffset(zerg) {
        return parseInt(zerg.name.charAt(zerg.name.length - 1), 10) || 0;
    }
    run() {
        this.autoRun(this.drills, (drill) => this.handleDrill(drill));
        this.autoRun(this.coolant, (coolant) => this.handleCoolant(coolant));
        if (this.directive.memory.state >= 3) {
            Game.notify(
                'DELETING ALL POWER MINING CREEPS BECAUSE STATE IS >= 3 in ' +
                    this.directive.print,
            );
            this.drills.forEach((drill) => drill.retire());
            this.coolant.forEach((coolant) => coolant.retire());
        }
    }
    visuals() {
        if (this.room && this.directive.powerBank) {
            Visualizer.marker(this.directive.powerBank.pos);
        }
    }
});
PowerDrillOverlord.requiredRCL = 7;
PowerDrillOverlord = PowerDrillOverlord_1 = __decorate(
    [profile],
    PowerDrillOverlord,
);

/**
 * Spawns special-purpose haulers for transporting resources to/from a specified target
 */
let PowerHaulingOverlord = class PowerHaulingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.collectionUrgent.haul) {
        super(directive, 'powerHaul', priority);
        // TODO bug where haulers can come from tiny rooms not ready yet
        this.requiredRCL = 6;
        // Allow time for body to spawn
        this.prespawnAmount = 300;
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
        // Spawn haulers to collect ALL the power at the same time.
        const haulingPartsNeeded =
            this.directive.totalResources / CARRY_CAPACITY;
        // Calculate amount of hauling each hauler provides in a lifetime
        const haulerCarryParts = Setups.transporters.default.getBodyPotential(
            CARRY,
            this.colony,
        );
        // Calculate number of haulers
        this.numHaulers = Math.ceil(haulingPartsNeeded / haulerCarryParts);
        // setup time to request the haulers
        const route = Game.map.findRoute(
            this.directive.pos.roomName,
            this.colony.room.name,
        );
        const distance = route == -2 ? 50 : route.length * 50;
        this.tickToSpawnOn =
            Game.time +
            (this.directive.calculateRemainingLifespan() || 0) -
            distance -
            this.prespawnAmount;
    }
    init() {}
    handleHauler(hauler) {
        if (sumStore(hauler.carry) == 0) {
            if (this.directive.memory.state >= 4) {
                // FIXME: Maybe ditch this and put it as a separate on-finishing method to reassign
                hauler.say('💀 RIP 💀', true);
                log.warning(
                    `${hauler.name} is committing suicide as directive is done!`,
                );
                this.numHaulers = 0;
                hauler.retire();
            }
            // Travel to directive and collect resources
            if (hauler.inSameRoomAs(this.directive)) {
                // Pick up drops first
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                } else if (this.directive.powerBank) {
                    const distance =
                        this.directive.powerBank.hits > 2500 ? 4 : 3;
                    if (
                        hauler.pos.getRangeTo(this.directive.powerBank) >
                        distance
                    ) {
                        hauler.goTo(this.directive.powerBank);
                    }
                    return;
                } else if (this.room && this.room.ruins) {
                    const pb = this.room.ruins.filter(
                        (ruin) =>
                            !!ruin.store[RESOURCE_POWER] &&
                            ruin.store[RESOURCE_POWER] > 0,
                    );
                    if (pb.length > 0) {
                        hauler.task = Tasks.withdraw(pb[0], RESOURCE_POWER);
                    }
                } else if (this.room && this.room.drops) {
                    const allDrops = _.flatten(_.values(this.room.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    } else {
                        hauler.say('💀 RIP 💀', true);
                        log.warning(`${hauler.name} is committing suicide!`);
                        hauler.retire();
                        return;
                    }
                }
                // Shouldn't reach here
                log.warning(
                    `${hauler.name} in ${hauler.room.print}: nothing to collect!`,
                );
            } else {
                hauler.goTo(this.directive);
            }
        } else {
            // Travel to colony room and deposit resources
            if (hauler.inSameRoomAs(this.colony)) {
                for (const [resourceType, amount] of hauler.carry.contents) {
                    if (amount == 0) continue;
                    if (resourceType == RESOURCE_ENERGY) {
                        // prefer to put energy in storage
                        if (
                            this.colony.storage &&
                            sumStore(this.colony.storage.store) <
                                STORAGE_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.storage,
                                resourceType,
                            );
                            return;
                        } else if (
                            this.colony.terminal &&
                            sumStore(this.colony.terminal.store) <
                                TERMINAL_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.terminal,
                                resourceType,
                            );
                            return;
                        }
                    } else {
                        // prefer to put minerals in terminal
                        this.directive.memory.totalCollected +=
                            hauler.carry.power || 0;
                        if (
                            this.colony.terminal &&
                            sumStore(this.colony.terminal.store) <
                                TERMINAL_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.terminal,
                                resourceType,
                            );
                            return;
                        } else if (
                            this.colony.storage &&
                            sumStore(this.colony.storage.store) <
                                STORAGE_CAPACITY
                        ) {
                            hauler.task = Tasks.transfer(
                                this.colony.storage,
                                resourceType,
                            );
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(
                    `${hauler.name} in ${hauler.room.print}: nowhere to put resources!`,
                );
            } else {
                hauler.task = Tasks.goToRoom(this.colony.room.name);
            }
        }
    }
    checkIfStillCarryingPower() {
        return _.find(
            this.haulers,
            (hauler) =>
                hauler.carry.power != undefined && hauler.carry.power > 0,
        );
    }
    run() {
        if (
            Game.time >= this.tickToSpawnOn &&
            this.directive.memory.state < 4
        ) {
            this.wishlist(this.numHaulers, Setups.transporters.default);
        }
        for (const hauler of this.haulers) {
            if (hauler.isIdle) {
                this.handleHauler(hauler);
            }
            hauler.run();
        }
    }
};
PowerHaulingOverlord = __decorate([profile], PowerHaulingOverlord);

// Creep utilities that don't belong anywhere else
// TODO should probably live in combat intel or something similar
// Does not account for range, just total of body parts
function calculateFormationStrength(creeps) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(creeps, function (unit) {
        const individualTally = calculateBodyPotential(unit.body);
        for (const bodyType in individualTally) {
            const type = bodyType;
            tally[type] += individualTally[type];
        }
    });
    return tally;
}
function calculateBodyPotential(body) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(body, function (bodyPart) {
        // Needs boost logic
        tally[bodyPart.type] += 1;
    });
    return tally;
}

var DirectivePowerMine_1;
var PowerMineState;
(function (PowerMineState) {
    PowerMineState[(PowerMineState['init'] = 0)] = 'init';
    PowerMineState[(PowerMineState['miningStarted'] = 1)] = 'miningStarted';
    PowerMineState[(PowerMineState['haulingStarted'] = 2)] = 'haulingStarted';
    PowerMineState[(PowerMineState['miningDone'] = 3)] = 'miningDone';
    PowerMineState[(PowerMineState['haulingComplete'] = 4)] = 'haulingComplete';
})(PowerMineState || (PowerMineState = {}));
/**
 * PowerMining directive: kills power banks and collects the resources.
 */
let DirectivePowerMine = (DirectivePowerMine_1 = class DirectivePowerMine extends (
    Directive
) {
    constructor(flag) {
        super(
            flag,
            (colony) => colony.level >= DirectivePowerMine_1.requiredRCL,
        );
        this._powerBank = this.powerBank;
        this.memory.state = this.memory.state || 0;
        this.memory['X' /* EXPIRATION */] =
            this.memory['X' /* EXPIRATION */] ||
            Game.time +
                (this.powerBank ? this.powerBank.ticksToDecay + 1000 : 5500);
        this.memory.totalCollected = this.memory.totalCollected || 0;
    }
    spawnMoarOverlords() {
        if (this.memory.state < 3) {
            this.overlords.powerMine = new PowerDrillOverlord(this);
        }
        if (this.memory.state > 1) {
            this.overlords.powerHaul = new PowerHaulingOverlord(this);
        }
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops || _.keys(this._drops).length == 0) {
            const drops = this.pos.lookFor(LOOK_RESOURCES) || [];
            this._drops = _.groupBy(drops, (drop) => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get powerBank() { // zGeneral CHATGPT Optimized 2/2024
        // Check if _powerBank is already defined to avoid redundant calculations.
        if (this._powerBank !== undefined) {
            return this._powerBank;
        }
        
        // Only proceed with the lookup if the position is visible.
        if (this.pos.isVisible) {
            // Directly assign the result of lookForStructure if the flag and flag.room are present,
            // otherwise, set to undefined. This removes the unnecessary boolean conversion.
            this._powerBank = this.flag && this.flag.room
                ? this.flag.pos.lookForStructure(STRUCTURE_POWER_BANK)
                : undefined;
        } else {
            // If the position is not visible, ensure _powerBank is undefined to reflect the lack of visibility.
            this._powerBank = undefined;
        }
    
        return this._powerBank;
    }

    /**
     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility
     */
    get totalResources() {
        if (this.pos.isVisible) {
            // update total amount remaining
            this.memory.totalResources = this.powerBank
                ? this.powerBank.power
                : this.memory.totalResources;
        }
        if (this.memory.totalResources == undefined) {
            return 5000; // pick some non-zero number so that powerMiners will spawn
        }
        return this.memory.totalResources;
    }
    calculateRemainingLifespan() {
        if (!this.room) {
            return undefined;
        } else if (this.powerBank == undefined) {
            return 0;
        } else {
            const tally = calculateFormationStrength(
                this.powerBank.pos.findInRange(FIND_MY_CREEPS, 4),
            );
            const healStrength = tally.heal * HEAL_POWER || 0;
            const attackStrength = tally.attack * ATTACK_POWER || 0;
            // PB have 50% hitback, avg damage is attack strength if its enough healing, otherwise healing
            const avgDamagePerTick = Math.min(attackStrength, healStrength * 2);
            return this.powerBank.hits / avgDamagePerTick;
        }
    }
    // TODO FIXME XXX
    manageState() {
        const currentState = this.memory.state;
        log.debug(
            `Managing state ${currentState} of directive ${this.print} with PB ${this.powerBank}`,
        );
        if (
            currentState == 0 &&
            this.powerBank &&
            this.powerBank.hits < this.powerBank.hitsMax
        ) {
            if (
                this.powerBank.pos.findInRange(FIND_MY_CREEPS, 3).length == 0 &&
                this.powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length >
                    0
            ) {
                // Power bank is damage but we didn't mine it
                //log.alert(`Power bank mining ${this.print} competing with ${this.powerBank.room.hostiles[0].owner.username}.`);
                // this.remove();
            } else {
                // Set to mining started
                this.memory.state = 1;
            }
        } else if (
            (currentState == 0 || currentState == 1) &&
            this.room &&
            (!this.powerBank || this.powerBank.hits < 500000)
        ) {
            Game.notify(
                'Activating spawning haulers for power mining in room ' +
                    this.pos.roomName,
            );
            log.info(
                'Activating spawning haulers for power mining in room ' +
                    this.pos.roomName,
            );
            this.memory.state = 2;
        } else if (
            currentState == 2 &&
            this.room &&
            !this.powerBank &&
            (this.hasDrops || this.room.ruins.length == 0)
        ) {
            Game.notify(
                `Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`,
            );
            log.alert(
                `Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`,
            );
            this.memory.state = 3;
            // TODO reassign them to guard the bank
            delete this.overlords.powerMine;
            this._powerBank = undefined; // This might be fluff
        } else if (
            (currentState == 0 || currentState == 1 || currentState == 2) &&
            this.room &&
            this.pos.isVisible &&
            !this.powerBank
        ) {
            if (!this.hasDrops && this.room.ruins.length == 0) {
                // TODO this had an error where it triggered incorrectly
                Game.notify(
                    `WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.print} ` +
                        `DELETING Directive at time ${Game.time}`,
                );
                log.error(
                    `WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.room} ` +
                        `DELETING Directive at time: ${Game.time}`,
                );
                this.remove();
            } else {
                // If somehow there is no bank but there is drops where bank was
                Game.notify(
                    `Somehow the power bank died early in ${this.room} at state ${currentState}, ` +
                        `setting state to 3 ${Game.time}`,
                );
                this.memory.state = 3;
            }
        } else if (
            currentState == 3 &&
            this.room &&
            this.pos.isVisible &&
            !this.hasDrops &&
            this.room.ruins.filter(
                (ruin) =>
                    !!ruin.store[RESOURCE_POWER] &&
                    ruin.store[RESOURCE_POWER] > 0,
            ).length == 0
        ) {
            Game.notify(
                `Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`,
            );
            // Hauler pickup is now complete
            log.alert(
                `Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`,
            );
            this.memory.state = 4;
            // TODO  Stop spawning haulers
        } else if (
            currentState == 4 &&
            this.overlords.powerHaul &&
            this.overlords.powerHaul.checkIfStillCarryingPower() == undefined
        ) {
            // TODO Doesn't give enough time to pick up power
            log.notify(`Hauling complete for ${this.print} at time ${Game.time}. Final power collected was 
			${this.memory.totalCollected} out of ${this.memory.totalResources}`);
            this.remove();
        } else {
            log.debug(`Power mining ${this.print} is in state ${currentState}`);
            // Todo this isn't error but needs other stuff
        }
    }
    init() {
        let alert;
        if (this.pos.room && !!this.powerBank) {
            alert = `PM ${this.memory.state} ${
                this.totalResources
            } P${Math.floor(
                (100 * this.powerBank.hits) / this.powerBank.hitsMax,
            )}% @ ${this.powerBank.ticksToDecay}TTL`;
        } else {
            alert = `PowerMine ${this.memory.state} ${this.totalResources}`;
        }
        this.alert(alert);
    }
    run() {
        // Check frequently when almost mined and occasionally otherwise
        const frequency = this.memory.state == 2 ? 1 : 21;
        if (Game.time % frequency == 0) {
            this.manageState();
        }
    }
});
DirectivePowerMine.directiveName = 'powerMine';
DirectivePowerMine.color = COLOR_YELLOW;
DirectivePowerMine.secondaryColor = COLOR_RED;
DirectivePowerMine.requiredRCL = 7;
DirectivePowerMine = DirectivePowerMine_1 = __decorate(
    [profile],
    DirectivePowerMine,
);

/**
 * Manually place a bunker anchored at the target location for the RoomPlanner to use in semiautomatic or manual mode
 */
let DirectiveRPBunker = class DirectiveRPBunker extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {}
    init() {
        this.colony.roomPlanner.addComponent(
            'bunker',
            this.pos,
            this.memory.rotation,
        );
    }
    run() {}
    visuals() {
        Visualizer.drawLayout(bunkerLayout, this.pos);
    }
};
DirectiveRPBunker.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPBunker.color = COLOR_WHITE;
DirectiveRPBunker.secondaryColor = COLOR_RED;
DirectiveRPBunker = __decorate([profile], DirectiveRPBunker);

/**
 * [DEPRECATED] Place a command center at the target location
 */
let DirectiveRPCommandCenter = class DirectiveRPCommandCenter extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {}
    init() {
        log.info(
            `Classic overmind layout is deprecated; bunker layout is recommended.`,
        );
        this.colony.roomPlanner.addComponent(
            'commandCenter',
            this.pos,
            this.memory.rotation,
        );
    }
    run() {}
};
DirectiveRPCommandCenter.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPCommandCenter.color = COLOR_WHITE;
DirectiveRPCommandCenter.secondaryColor = COLOR_BLUE;
DirectiveRPCommandCenter = __decorate([profile], DirectiveRPCommandCenter);

/**
 * [DEPRECATED] Place a hatchery at the target location
 */
let DirectiveRPHatchery = class DirectiveRPHatchery extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {}
    init() {
        log.info(
            `Classic overmind layout is deprecated; bunker layout is recommended.`,
        );
        this.colony.roomPlanner.addComponent(
            'hatchery',
            this.pos,
            this.memory.rotation,
        );
    }
    run() {}
};
DirectiveRPHatchery.directiveName = 'roomPlanner:Hatchery';
DirectiveRPHatchery.color = COLOR_WHITE;
DirectiveRPHatchery.secondaryColor = COLOR_GREEN;
DirectiveRPHatchery = __decorate([profile], DirectiveRPHatchery);

var BootstrappingOverlord_1;
/**
 * Bootstrapping overlord: spawns small miners and suppliers to recover from a catastrophic colony crash
 */
let BootstrappingOverlord = (BootstrappingOverlord_1 = class BootstrappingOverlord extends (
    Overlord
) {
    constructor(directive, priority = OverlordPriority.emergency.bootstrap) {
        super(directive, 'bootstrap', priority);
        this.fillers = this.zerg(Roles.filler);
        // Calculate structures fillers can supply / withdraw from
        this.supplyStructures = _.filter(
            [...this.colony.spawns, ...this.colony.extensions],
            (structure) => structure.energy < structure.energyCapacity,
        );
        this.withdrawStructures = _.filter(
            _.compact([
                this.colony.storage,
                this.colony.terminal,
                this.colony.powerSpawn,
                ...this.room.containers,
                ...this.room.links,
                ...this.room.towers,
                ...this.room.labs,
            ]),
            (structure) => structure.energy > 0,
        );
    }
    spawnBootstrapMiners() {
        // Isolate mining site overlords in the room
        let miningSitesInRoom = _.filter(
            _.values(this.colony.miningSites),
            (site) => site.room == this.colony.room,
        );
        if (this.colony.spawns[0]) {
            miningSitesInRoom = _.sortBy(miningSitesInRoom, (site) =>
                site.pos.getRangeTo(this.colony.spawns[0]),
            );
        }
        // If you have no miners then create whatever is the biggest miner you can make
        const pattern = [WORK, WORK, CARRY, MOVE];
        const miningOverlordsInRoom = _.map(
            miningSitesInRoom,
            (site) => site.overlords.mine,
        );
        const allMiners = _.flatten(
            _.map(miningOverlordsInRoom, (overlord) =>
                overlord.lifetimeFilter(overlord.miners),
            ),
        );
        const allMiningPower = _.sum(allMiners, (creep) =>
            creep.getActiveBodyparts(WORK),
        );
        let sizeLimit;
        if (allMiningPower == 0) {
            sizeLimit = Math.min(
                Math.floor(
                    this.colony.room.energyAvailable / bodyCost(pattern),
                ),
                3,
            );
        } else {
            // Otherwise if you have miners then you can afford to make normal ones
            sizeLimit = 3;
        }
        const setup = new CreepSetup(Roles.drone, {
            pattern: pattern,
            sizeLimit: sizeLimit,
        });
        // Create a bootstrapMiners and donate them to the miningSite overlords as needed
        for (const overlord of miningOverlordsInRoom) {
            const filteredMiners = this.lifetimeFilter(overlord.miners);
            const miningPowerAssigned = _.sum(
                _.map(this.lifetimeFilter(overlord.miners), (creep) =>
                    creep.getActiveBodyparts(WORK),
                ),
            );
            if (
                miningPowerAssigned < overlord.miningPowerNeeded &&
                filteredMiners.length < overlord.pos.availableNeighbors().length
            ) {
                if (this.colony.hatchery) {
                    const request = {
                        setup: setup,
                        overlord: overlord,
                        priority: this.priority + 1,
                    };
                    this.colony.hatchery.enqueue(request);
                    this.debug(
                        `Enqueueing bootstrap miner with size ${sizeLimit}`,
                    );
                }
            }
        }
    }
    updateFillerWishlist() {
        // Spawn fillers
        if (
            this.colony.getCreepsByRole(Roles.queen).length == 0 &&
            this.colony.hatchery
        ) {
            // no queen
            const transporter = _.first(
                this.colony.getZergByRole(Roles.transport),
            );
            if (transporter) {
                // reassign transporter to be queen
                transporter.reassign(
                    this.colony.hatchery.overlord,
                    Roles.queen,
                );
            } else {
                // wish for a filler
                this.wishlist(1, Setups.fillers.first);
                // if starting a big room, slowly ramp up the queens
                if (this.colony.getCreepsByRole(Roles.drone).length > 1) {
                    this.wishlist(2, Setups.fillers.second);
                    // even bigger rooms need more queens
                    if (
                        this.room.energyCapacityAvailable > 600 &&
                        this.colony.getCreepsByRole(Roles.drone).length > 2
                    ) {
                        this.wishlist(3, Setups.fillers.third);
                    }
                }
            }
        }
    }
    refresh() {
        super.refresh();
        // Spawn fillers
        this.updateFillerWishlist();
    }
    init() {
        // Then spawn the rest of the needed miners
        const energyInStructures = _.sum(
            _.map(this.withdrawStructures, (structure) => structure.energy),
        );
        const droppedEnergy = _.sum(
            this.room.droppedEnergy,
            (drop) => drop.amount,
        );
        // At early levels, spawn one miner, then a filler, then the rest of the miners
        if (
            energyInStructures + droppedEnergy < 300 &&
            this.colony.stage == ColonyStage.Larva
        ) {
            if (this.colony.getCreepsByRole(Roles.drone).length == 0) {
                // Isolate mining site overlords in the room
                let miningSites = _.filter(
                    _.values(this.colony.miningSites),
                    (site) => site.room == this.colony.room,
                );
                if (this.colony.spawns[0]) {
                    miningSites = _.sortBy(miningSites, (site) =>
                        site.pos.getRangeTo(this.colony.spawns[0]),
                    );
                }
                const miningOverlords = _.map(
                    miningSites,
                    (site) => site.overlords.mine,
                );
                const firstOverlord = miningOverlords[0];
                // first
                if (this.colony.hatchery) {
                    let setup = Setups.drones.miners.first;
                    if (this.colony.controller.level > 2) {
                        setup = Setups.drones.miners.emergency;
                    }
                    const request = {
                        setup: setup,
                        overlord: firstOverlord,
                        priority: 1,
                    };
                    this.colony.hatchery.enqueue(request);
                }
                return;
            }
        }
        // Spawn fillers
        this.updateFillerWishlist();
        if (
            energyInStructures + droppedEnergy <
            BootstrappingOverlord_1.settings.spawnBootstrapMinerThreshold
        ) {
            this.spawnBootstrapMiners();
        }
    }
    supplyActions(filler) {
        const target = filler.pos.findClosestByMultiRoomRange(
            this.supplyStructures,
        );
        if (target) {
            filler.task = Tasks.transfer(target);
        } else {
            this.rechargeActions(filler);
        }
    }
    rechargeActions(filler) {
        const target = filler.pos.findClosestByMultiRoomRange(
            this.withdrawStructures,
        );
        if (target) {
            filler.task = Tasks.withdraw(target);
        } else {
            filler.task = Tasks.recharge();
        }
    }
    handleFiller(filler) {
        if (filler.carry.energy > 0) {
            this.supplyActions(filler);
        } else {
            this.rechargeActions(filler);
        }
    }
    run() {
        for (const filler of this.fillers) {
            if (filler.isIdle) {
                this.handleFiller(filler);
            }
            filler.run();
        }
    }
});
BootstrappingOverlord.settings = {
    spawnBootstrapMinerThreshold: 3000,
};
BootstrappingOverlord = BootstrappingOverlord_1 = __decorate(
    [profile],
    BootstrappingOverlord,
);

/**
 * Bootstrapping directive: recover from a colony-wide crash or bootstrap from initial spawn-in
 */
let DirectiveBootstrap = class DirectiveBootstrap extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh(); // data needs to be recomputed each tick
    }
    refresh() {
        super.refresh();
        this.colony.state.bootstrapping = true;
        this.needsMiner = this.colony.getCreepsByRole(Roles.drone).length == 0;
        this.needsManager =
            this.colony.commandCenter != undefined &&
            this.colony.commandCenter.overlord != undefined &&
            this.colony.commandCenter.link != undefined &&
            this.colony.getCreepsByRole(Roles.manager).length == 0;
        this.needsQueen = this.colony.getCreepsByRole(Roles.queen).length == 0;
    }
    spawnMoarOverlords() {
        this.overlords.bootstrap = new BootstrappingOverlord(this);
    }
    init() {
        this.alert(`Colony in bootstrap mode!`, NotifierPriority.High);
        if (Game.time % 100 == 0) {
            log.alert(
                `Colony ${this.room.print} is in emergency recovery mode.`,
            );
        }
    }
    run() {
        if (!this.needsQueen && !this.needsMiner) {
            if (this.colony.storage && this.colony.assets.energy < 15000) {
                return; // wait a little while at higher levels before stopping bootstrapping
            }
            // Suicide any fillers so they don't get in the way
            const overlord = this.overlords.bootstrap;
            const queenOverlord =
                this.colony.hatchery && this.colony.hatchery.overlord;
            for (const filler of overlord.fillers) {
                if (!queenOverlord || filler.spawning) {
                    // can't yet assign them all
                    log.info(
                        `Waiting for ${filler.print} to spawn so ${this.room.print} can exit bootstrap`,
                    );
                    return;
                }
                if (queenOverlord && this.colony.stage == ColonyStage.Larva) {
                    filler.reassign(queenOverlord, Roles.queen, false);
                } else {
                    filler.suicide();
                }
            }
            log.alert(
                `Colony ${this.room.print} has recovered from crash; removing bootstrap directive.`,
            );
            // Remove the directive
            this.remove();
        }
    }
};
DirectiveBootstrap.directiveName = 'bootstrap';
DirectiveBootstrap.color = COLOR_ORANGE;
DirectiveBootstrap.secondaryColor = COLOR_ORANGE;
DirectiveBootstrap = __decorate([profile], DirectiveBootstrap);

/**
 * Launches nuke at target location
 */
let DirectiveNukeTarget = class DirectiveNukeTarget extends Directive {
    // TODO add sending multiple nukes and spacing the nukes out by x amount
    constructor(flag) {
        super(
            flag,
            (colony) =>
                !!colony.nuker &&
                colony.nuker.cooldown <= 0 &&
                Game.map.getRoomLinearDistance(
                    colony.room.name,
                    flag.pos.roomName,
                ) <= 10,
        );
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() {}
    init() {}
    run() {
        if (this.colony.nuker && this.colony.nuker.cooldown == 0) {
            const res = this.colony.nuker.launchNuke(this.flag.pos);
            if (res == OK) {
                log.notify(
                    `Launching nuclear strike at ${this.flag.pos.print}, ETA ${
                        Game.time + NUKE_LAND_TIME
                    }`,
                );
                this.remove();
            }
        } else if (!this.colony.nuker || this.colony.nuker.cooldown > 0) {
            log.error(
                `DirectiveNuke unable to fire from ${this.colony.name} due to nuker ${this.colony.nuker} ` +
                    `being unavailable: ${this.print}`,
            );
            this.remove();
        }
    }
};
DirectiveNukeTarget.directiveName = 'nukeTarget';
DirectiveNukeTarget.color = COLOR_ORANGE;
DirectiveNukeTarget.secondaryColor = COLOR_RED;
DirectiveNukeTarget.requiredRCL = 8;
DirectiveNukeTarget = __decorate([profile], DirectiveNukeTarget);

const DEFAULT_NUM_SCOUTS$1 = 2;
/**
 * Sends out scouts which randomly traverse rooms to uncover possible expansion locations and gather intel
 */
let PortalScoutOverlord = class PortalScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.randomWalker) {
        super(directive, 'portalScout', priority);
        this.directive = directive;
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(DEFAULT_NUM_SCOUTS$1, Setups.scout);
    }
    portalSays(creep, isPublic) {
        const says = [
            'One small',
            'step for',
            `${creep.name}`,
            `one giant`,
            `leap for`,
            `all`,
            `Creepkind`,
        ];
        creep.say(says[Game.time % says.length], isPublic);
    }
    handleScout(scout) {
        const finalDestination = this.directive;
        // log.alert(`Portal walker ${scout.print} is in ${scout.room.name}`);
        if (scout.pos != finalDestination.pos) {
            scout.goTo(finalDestination, { pathOpts: { avoidSK: true } });
        }
        this.portalSays(scout, true);
    }
    run() {
        this.autoRun(this.scouts, (scout) => this.handleScout(scout));
    }
};
PortalScoutOverlord = __decorate([profile], PortalScoutOverlord);

/**
 * It's like the movie Interstellar, but the special effects budget is whatever cash I left in my jeans
 */
let DirectivePortalScout = class DirectivePortalScout extends Directive {
    constructor(flag, colonyFilter) {
        flag.memory.allowPortals = true;
        super(flag, colonyFilter);
    }
    spawnMoarOverlords() {
        this.overlords.portalScoutOverlord = new PortalScoutOverlord(this);
    }
    init() {
        this.alert(`Portal scout active`);
    }
    run() {}
};
DirectivePortalScout.directiveName = 'portalScout';
DirectivePortalScout.color = COLOR_ORANGE;
DirectivePortalScout.secondaryColor = COLOR_WHITE;
DirectivePortalScout.requiredRCL = 3;
DirectivePortalScout = __decorate([profile], DirectivePortalScout);

// The order in which resources are handled within the network
const highPriorityLoot = [...BOOSTS_T3, RESOURCE_OPS, RESOURCE_POWER];
const lowPriorityLoot = [
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    ...BASE_RESOURCES,
];
const dontLoot = [RESOURCE_ENERGY];
const everythingElse = _.filter(
    RESOURCES_ALL,
    (res) =>
        !(highPriorityLoot.includes(res) || lowPriorityLoot.includes(res)) &&
        !dontLoot.includes(res),
);
const LOOTING_ORDER = [
    ...highPriorityLoot,
    ...everythingElse,
    ...lowPriorityLoot,
];
/**
 * Spawns remote upgraders and energy carriers to travel to a distant room to upgrade the controller. The directive
 * should be placed on the controller in the child room and should only be used after the room has been claimed.
 */
let RemoteUpgradingOverlord = class RemoteUpgradingOverlord extends Overlord {
    constructor(
        directive,
        priority = OverlordPriority.colonization.remoteUpgrading,
    ) {
        super(directive, 'remoteUpgrade', priority);
        this.directive = directive;
        this.parentColony = this.colony;
        this.childColony = Overmind.colonies[this.pos.roomName];
        if (!this.childColony) {
            log.error(`${this.print}: no child colony! (Why?)`);
        }
        if (this.parentColony == this.childColony) {
            log.error(
                `${this.print}: parent and child colonies are the same! (Why?)`,
            );
        }
        this.upgradeSite = this.childColony.upgradeSite;
        // If new colony or boosts overflowing to storage
        this.carriers = this.zerg(Roles.transport);
        this.upgraders = this.zerg(Roles.upgrader);
        this.boosted = true; // TODO
    }
    /**
     * Computes the amount of carry capacity (in terms of energy units, not bodyparts) needed
     */
    computeNeededCarrierCapacity() {
        if (this.childColony.terminal && this.childColony.terminal.my) {
            return 0; // don't need this once you have a terminal
        }
        const roundTripDistance =
            1.5 /* todo */ * this.directive.distanceFromColony.terrainWeighted;
        const energyPerTick = _.sum(
            this.upgraders,
            (upgrader) =>
                UPGRADE_CONTROLLER_POWER * upgrader.getActiveBodyparts(WORK),
        );
        return energyPerTick * roundTripDistance;
    }
    init() {
        let neededCarriers = this.carriers.length;
        if (this.carriers.length == 0) {
            neededCarriers = 1;
        } else {
            const neededCarryCapacity = this.computeNeededCarrierCapacity();
            const currentCarryCapacity = _.sum(
                this.carriers,
                (carrier) =>
                    CARRY_CAPACITY *
                    CombatIntel.getCarryPotential(carrier.creep, true),
            );
            const avgCarrierCapactiy =
                currentCarryCapacity / this.carriers.length;
            this.debug(
                `Needed carry capacity: ${neededCarryCapacity}; Current carry capacity: ${currentCarryCapacity}`,
            );
            neededCarriers = Math.ceil(
                neededCarryCapacity / avgCarrierCapactiy,
            );
            this.debug(`Needed carriers: ${neededCarriers}`);
        }
        if (this.boosted) {
            this.wishlist(neededCarriers, Setups.transporters.boosted, {
                priority: this.priority,
            });
            this.wishlist(8, Setups.upgraders.remote_boosted, {
                priority: this.priority + 1,
            });
        } else {
            this.wishlist(neededCarriers, Setups.transporters.default, {
                priority: this.priority,
            });
            this.wishlist(8, Setups.upgraders.remote, {
                priority: this.priority + 1,
            });
        }
    }
    handleUpgrader(upgrader) {
        // Go to the room and don't pick up energy until you're there
        if (!upgrader.safelyInRoom(this.childColony.room.name)) {
            upgrader.goToRoom(this.childColony.room.name);
            return;
        }
        // You're in the room, upgrade if you have energy
        if (upgrader.carry.energy > 0) {
            upgrader.task = Tasks.upgrade(this.upgradeSite.controller);
            return;
        }
        // If you're out of energy, recharge from link or battery
        if (this.upgradeSite.link && this.upgradeSite.link.energy > 0) {
            upgrader.task = Tasks.withdraw(this.upgradeSite.link);
            return;
        }
        if (this.upgradeSite.battery && this.upgradeSite.battery.energy > 0) {
            upgrader.task = Tasks.withdraw(this.upgradeSite.battery);
            return;
        }
        // Recharge from transporter?
        const nearbyCarriers = _.filter(
            this.carriers,
            (carrier) => upgrader.pos.getRangeTo(carrier) <= 5,
        );
        const nearbyCarriersWaitingToUnload = _.filter(
            nearbyCarriers,
            (carrier) => carrier.carry.energy > 0,
        );
        const lowestEnergyCarrier = minBy(
            nearbyCarriersWaitingToUnload,
            (carrier) => carrier.carry.energy,
        );
        if (lowestEnergyCarrier) {
            upgrader.goTo(lowestEnergyCarrier);
            return;
        } else {
            // Just recharge how you normally would
            upgrader.task = Tasks.recharge();
        }
    }
    handleCarrier(carrier) {
        if (carrier.getActiveBodyparts(HEAL) > 0) {
            carrier.heal(carrier);
        }
        // Get energy from the parent colony if you need it
        if (carrier.carry.energy == 0) {
            // If you are in the child room and there are valuable resources in a storage/terminal that isn't mine,
            // then take those back before you go home
            if (
                carrier.room == this.childColony.room &&
                carrier.carry.getFreeCapacity() > 0
            ) {
                const storeStructuresNotMy = _.filter(
                    _.compact([
                        this.childColony.room.storage,
                        this.childColony.room.terminal,
                    ]),
                    (structure) => !structure.my,
                );
                for (const resource of LOOTING_ORDER) {
                    const withdrawTarget = _.find(
                        storeStructuresNotMy,
                        (structure) =>
                            structure.store.getUsedCapacity(resource) > 0,
                    );
                    if (withdrawTarget) {
                        const amount = Math.min(
                            withdrawTarget.store.getUsedCapacity(resource),
                            carrier.carry.getFreeCapacity(),
                        );
                        carrier.task = Tasks.withdraw(
                            withdrawTarget,
                            resource,
                            amount,
                        );
                        return;
                    }
                }
            }
            // Go to the parent room for energy
            if (!carrier.safelyInRoom(this.parentColony.room.name)) {
                carrier.goToRoom(this.parentColony.room.name);
                return;
            }
            const target = _.find(
                _.compact([
                    this.parentColony.storage,
                    this.parentColony.terminal,
                ]),
                (s) => s.store[RESOURCE_ENERGY] >= carrier.carryCapacity,
            );
            if (!target) {
                log.warning(
                    `${this.print}: no energy withdraw target for ${carrier.print}!`,
                );
                return;
            }
            if (
                carrier.carry.getUsedCapacity() >
                carrier.carry.getUsedCapacity(RESOURCE_ENERGY)
            ) {
                carrier.task = Tasks.transferAll(target);
            } else {
                carrier.task = Tasks.withdraw(target);
            }
        } else {
            // Go to the room
            if (!carrier.safelyInRoom(this.childColony.room.name)) {
                carrier.goToRoom(this.childColony.room.name);
                return;
            }
            // Try to deposit in container, unless there's already a crowd waiting there;
            // otherwise put in storage if you can
            const depositPos =
                this.upgradeSite.batteryPos || this.upgradeSite.pos;
            const carriersWaitingToUnload = _.filter(
                this.carriers,
                (carrier) =>
                    carrier.carry.energy > 0 &&
                    carrier.pos.inRangeToPos(depositPos, 5),
            );
            const firstCarrierInQueue = minBy(
                carriersWaitingToUnload,
                (carrier) =>
                    carrier.carry.energy +
                    (carrier.ticksToLive || Infinity) / 10000,
            );
            // Put in storage if you can
            if (
                this.childColony.storage &&
                firstCarrierInQueue &&
                firstCarrierInQueue != carrier
            ) {
                carrier.task = Tasks.transfer(this.childColony.storage);
                return;
            }
            // Otherwise go to the dropoff point
            const range =
                firstCarrierInQueue && carrier == firstCarrierInQueue ? 0 : 3;
            if (!carrier.pos.inRangeToPos(depositPos, range)) {
                const ret = carrier.goTo(depositPos);
                return;
            }
            // Otherwise try to transfer to any empty upgraders
            if (carrier == firstCarrierInQueue) {
                // Once you're nearby try to deposit in the battery if there is one
                if (
                    this.upgradeSite.battery &&
                    this.upgradeSite.battery.store.getFreeCapacity() > 0
                ) {
                    if (carrier.transfer(this.upgradeSite.battery) == OK) {
                        return;
                    }
                }
                // Carriers should unload one at a time
                const upgraderTransferTarget = maxBy(
                    _.filter(this.upgraders, (upgrader) =>
                        upgrader.pos.isNearTo(carrier),
                    ),
                    (upgrader) => upgrader.store.getFreeCapacity(),
                );
                if (upgraderTransferTarget) {
                    if (carrier.transfer(upgraderTransferTarget) == OK) return;
                }
            }
        }
    }
    run() {
        this.autoRun(this.upgraders, (upgrader) =>
            this.handleUpgrader(upgrader),
        );
        this.autoRun(this.carriers, (carrier) => this.handleCarrier(carrier));
    }
};
RemoteUpgradingOverlord = __decorate([profile], RemoteUpgradingOverlord);

var DirectiveRemoteUpgrade_1;
/**
 * Spawns remote upgraders and energy carriers to travel to a distant room to upgrade the controller. The directive
 * should be placed on the controller in the child room and should only be used after the room has been claimed.
 */
let DirectiveRemoteUpgrade = (DirectiveRemoteUpgrade_1 = class DirectiveRemoteUpgrade extends (
    Directive
) {
    constructor(flag) {
        flag.memory.allowPortals = true;
        super(
            flag,
            (colony) => colony.level >= DirectiveRemoteUpgrade_1.requiredRCL,
        );
    }
    spawnMoarOverlords() {
        this.overlords.remoteUpgrade = new RemoteUpgradingOverlord(this);
    }
    init() {
        this.alert(`Remote upgrade active`);
    }
    run() {
        if (
            this.room &&
            this.room.controller &&
            this.room.controller.level == 8
        ) {
            this.remove();
        }
    }
});
DirectiveRemoteUpgrade.directiveName = 'remoteUpgrade';
DirectiveRemoteUpgrade.color = COLOR_ORANGE;
DirectiveRemoteUpgrade.secondaryColor = COLOR_YELLOW;
DirectiveRemoteUpgrade.requiredRCL = 8;
DirectiveRemoteUpgrade = DirectiveRemoteUpgrade_1 = __decorate(
    [profile],
    DirectiveRemoteUpgrade,
);

var StrongholdOverlord_1;
/**
 * Prioritized list of what order enemy structures should be attacked in
 */
const StrongholdAttackPriorities = [
    STRUCTURE_INVADER_CORE,
    STRUCTURE_TOWER,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
/**
 * Spawns ranged attacker against stronghold
 */
let StrongholdOverlord = (StrongholdOverlord_1 = class StrongholdOverlord extends (
    CombatOverlord
) {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'stronghold', priority, 1);
        this.strongholdKillers = this.combatZerg(Roles.strongholdKiller, {
            notifyWhenAttacked: false,
        });
    }
    /**
     * Returns [position, target] by searching for safe locations
     * @param target
     * @param range
     * @param myCreep
     */
    findAttackingPositionAndTarget(target, range, myCreep) {
        log.info(
            `Finding attacking position in ${target.room} for ${this.print}`,
        );
        if (!target.room || range == 0) {
            return;
        }
        // bug with containers
        const shootPositions = target.pos.getPositionsAtRange(
            range,
            false,
            false,
        );
        // Index is range to avoid from
        const avoidLocs = Array.from({ length: 5 }, () => []);
        avoidLocs[1] = avoidLocs[1].concat(
            target.room.ramparts.map((rampart) => rampart.pos),
        );
        avoidLocs[4] = avoidLocs[4].concat(
            target.room.sources.map((s) => s.pos),
        );
        avoidLocs[4] = avoidLocs[4].concat(
            target.room.keeperLairs.map((s) => s.pos),
        );
        if (target.room.mineral) {
            avoidLocs[4] = avoidLocs[4].concat(target.room.mineral.pos);
        }
        // Array where first index is how many hostile locations there are
        const safeSpots = this.findSafeLocation(shootPositions, avoidLocs);
        _.forEach(safeSpots, (distanceArray, hostilesIndex) =>
            distanceArray.forEach((spot) =>
                Visualizer.marker(spot, {
                    color: StrongholdOverlord_1.numberToColor(hostilesIndex),
                    frames: 2,
                }),
            ),
        );
        // If you can safely attack goal, do that
        if (safeSpots[0].length > 0) {
            const closestFirst = safeSpots[0].sort((a, b) =>
                this.bestRampartToAttackSortFunction(a, b, myCreep.pos),
            );
            return { attackPos: closestFirst[0], target: target };
        } else if (safeSpots[1].length > 0) {
            // Can't safely attack target, need to attack another position first
            const range1Spots = safeSpots[1];
            const ramparts = target.room.ramparts;
            const posToRampartMap = new Map();
            for (const spot of range1Spots) {
                for (const rampart of ramparts) {
                    if (rampart.pos.isNearTo(spot)) {
                        const temp = posToRampartMap.get(spot);
                        posToRampartMap.set(
                            spot,
                            !!temp ? temp.concat([rampart]) : [rampart],
                        );
                    }
                }
            }
            // Now select closest
            if (myCreep) {
                // TODO currently extra filtering, don't need from above
                const orderedByBest = Array.from(posToRampartMap.keys())
                    .filter(
                        (p) =>
                            posToRampartMap.get(p) &&
                            posToRampartMap.get(p).length == 1,
                    )
                    .sort((a, b) =>
                        this.bestRampartToAttackSortFunction(a, b, myCreep.pos),
                    );
                for (const pos of orderedByBest) {
                    const res = this.findAttackingPositionAndTarget(
                        posToRampartMap.get(pos)[0],
                        range - 1,
                        myCreep,
                    );
                    if (res) {
                        return res;
                    }
                }
            } else {
                for (const pos of posToRampartMap) {
                    const res = this.findAttackingPositionAndTarget(
                        pos[1][0],
                        range - 1,
                        myCreep,
                    );
                    if (res) {
                        return res;
                    }
                }
            }
        }
        return;
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        // If nothing found
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(3000) };
        } else {
            delete this.memory.target;
        }
    }
    bestRampartToAttackSortFunction(element1, element2, currentPos) {
        // const numRamparts1 = map.get(element1) == undefined ? 10 : map.get(element1)!.length;
        // const numRamparts2 = map.get(element2) == undefined ? 10 : map.get(element2)!.length;
        return (
            element1.getRangeTo(currentPos) - element2.getRangeTo(currentPos)
        ); // + (numRamparts1 - numRamparts2);
        // if (element.roomName == currentPos.roomName) {
        //
        // }
    }
    /**
     * Returns double array of number of avoids per locations
     * @param locations
     * @param avoidLocationsAtDistance
     */
    findSafeLocation(locations, avoidLocationsAtDistance) {
        // Index is number of hostiles present.
        const locationToHostilesMapping = Array.from({ length: 8 }, () => []);
        locations.forEach((loc) => {
            let count = 0;
            avoidLocationsAtDistance.forEach((avoidArray, distance) => {
                avoidArray.forEach((avoidPos) => {
                    if (avoidPos.getRangeTo(loc) <= distance) {
                        count++;
                    }
                });
            });
            if (count < locationToHostilesMapping.length) {
                locationToHostilesMapping[count].push(loc);
            }
        });
        // Should probably do cost matrix to avoid ramparts, wrote a getNearRampartsMatrix in pathing but need to use it
        return locationToHostilesMapping;
    }
    get attackPos() {
        if (this._attackPos) {
            return this._attackPos;
        }
        if (this.memory.target && this.memory.attackingPosition) {
            this._attackPos = posFromReadableName(
                this.memory.attackingPosition,
            );
            return this._attackPos;
        }
    }
    handleKiller(killer) {
        if (Game.time % 15 == 0) {
            log.info(
                `Stronghold Killer ${killer.print} for ${this.print} in room ${killer.room.print}`,
            );
        }
        if (this.room && killer.pos.roomName == this.pos.roomName) {
            if (this.directive.core && !this.memory.target) {
                const before = Game.cpu.getUsed();
                const targetingInfo = this.resetAttacking(
                    this.directive.core,
                    3,
                    killer,
                );
                log.info(
                    `CPU used for stronghold is ${Game.cpu.getUsed() - before}`,
                );
            }
        }
        // TODO creep was an idiot and walked next to rampart moving to next attack position
        killer.heal(killer);
        if (killer.pos.roomName != this.pos.roomName) {
            killer.goToRoom(this.directive.pos.roomName);
        }
        if (
            killer.hits / killer.hitsMax <
            StrongholdOverlord_1.settings.retreatHitsPercent
        ) {
            killer.flee(
                [this.directive.pos].concat(
                    killer.room.hostiles.map((sk) => sk.pos),
                ),
            );
        }
        // Shoot nearby enemies before moving on
        const unprotectedHostiles = killer.room.hostiles.filter(
            (hostile) =>
                hostile.pos.getRangeTo(killer.pos) <= 3 && !hostile.inRampart,
        );
        if (unprotectedHostiles.length > 0) {
            killer.rangedAttack(unprotectedHostiles[0]);
            return;
        }
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(
                this.memory.attackingPosition,
            );
            // In room and in position
            if (!attackPos || !killer.pos.isEqualTo(attackPos)) {
                let avoids = [];
                if (this.directive.room) {
                    avoids = avoids.concat(
                        _.flatten(
                            this.directive.room.sourceKeepers.map((source) =>
                                source.pos.getPositionsInRange(3, false, false),
                            ),
                        ),
                    );
                    avoids = avoids.concat(
                        _.flatten(
                            this.directive.room.ramparts.map(
                                (ramparts) => ramparts.pos.neighbors,
                            ),
                        ),
                    );
                    if (this.directive.room.mineral) {
                        avoids = avoids.concat(
                            this.directive.room.mineral.pos.getPositionsInRange(
                                4,
                                false,
                                false,
                            ),
                        );
                    }
                    avoids.forEach((av) => Visualizer.circle(av));
                    killer.goTo(attackPos, {
                        pathOpts: { obstacles: avoids },
                    });
                }
            }
        }
        if (killer.pos.roomName == this.directive.pos.roomName) {
            if (this.target) {
                const res = killer.rangedAttack(this.target);
                if (res == ERR_INVALID_TARGET);
            } else {
                killer.goTo(this.pos);
                killer.rangedMassAttack();
                // killer.autoCombat(this.directive.pos.roomName);
            }
        }
    }
    static numberToColor(colorNumber) {
        switch (colorNumber) {
            case 0:
                return 'green';
            case 1:
                return 'yellow';
            case 2:
                return 'orange';
            default:
                return 'red';
        }
    }
    init() {
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(
                this.memory.attackingPosition,
            );
            if (!!attackPos) {
                Visualizer.marker(attackPos, 'white');
            }
        }
        if (this.memory.target && Game.getObjectById(this.memory.target.id)) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                Visualizer.marker(target.pos, 'black');
            }
        }
        if (this.directive.memory.state >= 3) {
            return; // No need to spawn more
        }
        // TODO fix me for when strongholds typescript is out
        switch (this.directive.memory.strongholdLevel) {
            case 5:
                return; // Fuck this shit we out
            case 4:
                return;
            // setup = CombatSetups.strongholdKiller["4"];
            // break;
            case 3:
                break;
            case 2:
                break;
            case 1:
                break;
            case 0:
                return; // Forget it, no need for the lil ones
            default:
                return; // setup = CombatSetups.strongholdKiller["3"];
        }
        // if (!this.canBoostSetup(setup)) {// TODO: need to move this to the new CombatCreepSetup system
        // 	// Need boosts
        // 	return log.error(`Can't boost stronghold killer in ${this.print}!`);
        // }
        //
        // this.wishlist(1, setup, {});
    }
    resetAttacking(ultimateGoal, maxRange, myCreep) {
        const targetingInfo = this.findAttackingPositionAndTarget(
            ultimateGoal,
            3,
            myCreep,
        );
        if (targetingInfo) {
            this.target = targetingInfo.target;
            this.memory.attackingPosition =
                targetingInfo.attackPos.readableName;
        }
        return targetingInfo;
    }
    run() {
        // if (this.directive.room) {
        // 	avoids = avoids.concat(_.flatten(this.directive.room.sources.map(source =>
        // 	source.pos.getPositionsInRange(4, false, false))));
        // 	avoids = avoids.concat(_.flatten(this.directive.room.ramparts.map(ramparts => ramparts.pos.neighbors)));
        // 	if (this.directive.room.mineral) {
        // 		avoids = avoids.concat(this.directive.room.mineral.pos.getPositionsInRange(4, false, false))
        // 	}
        // }
        // avoids.forEach(av => Visualizer.circle(av, 'blue'));
        // log.info(`Running stronghold overlord ${this.print}`);
        this.autoRun(this.strongholdKillers, (killer) =>
            this.handleKiller(killer),
        );
    }
});
StrongholdOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
StrongholdOverlord = StrongholdOverlord_1 = __decorate(
    [profile],
    StrongholdOverlord,
);

/**
 * Spawns special-purpose dismantlers for transporting resources to/from a specified target
 */
let DismantleOverlord = class DismantleOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.tasks.dismantle) {
        super(directive, 'dismantle', priority);
        this.directive = directive;
        // this.target = target || Game.getObjectById(this.directive.memory.targetId) || undefined;
        this.dismantlers = this.zerg(Roles.dismantler);
    }
    init() {
        // Spawn a number of dismantlers, up to a max
        const MAX_DISMANTLERS = 2;
        let setup;
        if (!!this.directive.memory.attackInsteadOfDismantle) {
            // TODO: need to move this to the new CombatCreepSetup system
            setup = CombatSetups.dismantlers.attackDismantlers;
        }
        // else if (this.canBoostSetup(CombatSetups.dismantlers.boosted_T3)) {
        // 	setup = CombatSetups.dismantlers.boosted_T3;
        // }
        else {
            setup = CombatSetups.dismantlers.default;
        }
        setup = CombatSetups.dismantlers.default;
        const dismantlingParts = setup.getBodyPotential(
            !!this.directive.memory.attackInsteadOfDismantle ? ATTACK : WORK,
            this.colony,
        );
        const dismantlingPower =
            dismantlingParts *
            (!!this.directive.memory.attackInsteadOfDismantle
                ? ATTACK_POWER
                : DISMANTLE_POWER);
        // Calculate total needed amount of dismantling power as (resource amount * trip distance)
        const tripDistance =
            Pathing.distance(this.colony.pos, this.directive.pos) || 0;
        const dismantleLifetimePower =
            (CREEP_LIFE_TIME - tripDistance) * dismantlingPower;
        // Calculate number of dismantlers
        if (
            this.directive.room &&
            this.target &&
            !this.directive.memory.numberSpots
        ) {
            this.directive.getDismantleSpots(this.target.pos);
        }
        const nearbySpots =
            this.directive.memory.numberSpots != undefined
                ? this.directive.memory.numberSpots
                : 1;
        // needs to be reachable spots
        const dismantleNeeded = Math.ceil(
            (this.target ? this.target.hits : 50000) / dismantleLifetimePower,
        );
        const numDismantlers = Math.min(
            nearbySpots,
            MAX_DISMANTLERS,
            dismantleNeeded,
        );
        // Request the dismantlers
        this.wishlist(numDismantlers, setup);
    }
    runDismantler(dismantler) {
        if (!dismantler.inSameRoomAs(this.directive)) {
            const goal = this.target || this.directive;
            dismantler.goTo(goal, { pathOpts: { avoidSK: true } });
        } else {
            if (!this.target) {
                if (this.directive.memory.targetId) {
                    this.target =
                        Game.getObjectById(
                            this.directive.memory.targetId.toString(),
                        ) || undefined;
                }
                this.target = this.target || this.directive.getTarget();
                if (!this.target) {
                    log.error(`No target found for ${this.directive.print}`);
                }
            } else {
                const res = !!this.directive.memory.attackInsteadOfDismantle
                    ? dismantler.attack(this.target)
                    : dismantler.dismantle(this.target);
                if (res == ERR_NOT_IN_RANGE) {
                    const ret = dismantler.goTo(this.target, {});
                    // TODO this is shit ⬇
                } else if (res == ERR_NO_BODYPART);
            }
        }
    }
    run() {
        this.reassignIdleCreeps(Roles.dismantler);
        for (const dismantler of this.dismantlers) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (dismantler.hasValidTask) {
                dismantler.run();
            } else {
                if (dismantler.needsBoosts) {
                    this.handleBoosting(dismantler);
                } else {
                    this.runDismantler(dismantler);
                }
            }
        }
        for (const dismantler of this.dismantlers) {
            this.runDismantler(dismantler);
        }
    }
};
DismantleOverlord = __decorate([profile], DismantleOverlord);

/**
 * Register a target to be dismantled by specific dismantlers
 */
let DirectiveModularDismantle = class DirectiveModularDismantle extends Directive {
    constructor(flag, onlyKillRampart = false, additionalTargets) {
        super(flag);
        this.memory.onlyKillRampart =
            onlyKillRampart || this.flag.name.includes('rampart');
        this.memory.boost =
            this.memory.boost || this.flag.name.includes('boost');
        if (this.flag.room) {
            if (!this.memory.targetId) {
                const target = this.getTarget();
                this.memory.targetId = target ? target.id : undefined;
            }
            this.memory.additionalTargets = additionalTargets;
            if (!this.memory.numberSpots) {
                const spots = this.getDismantleSpots(this.flag.pos);
                if (spots) {
                    this.memory.numberSpots = spots.length;
                }
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords.dismantle = new DismantleOverlord(this);
    }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructureTypes = this.memory.onlyKillRampart
            ? [STRUCTURE_RAMPART]
            : AttackStructurePriorities;
        const targets = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structureType of targetedStructureTypes) {
            const correctTargets = targets.filter((target) => {
                if (target.structureType == structureType) {
                    return target;
                } else if (target.structureType == STRUCTURE_INVADER_CORE) {
                    this.memory.attackInsteadOfDismantle = true;
                    return target;
                }
            });
            if (correctTargets.length > 0) {
                return correctTargets[0];
            }
            // for (const structure of targets) {
            // 	if (structure.structureType == structureType) {
            // 		return structure;
            // 	}
            // 	if (structure.structureType == STRUCTURE_INVADER_CORE) {
            // 		this.memory.attackInsteadOfDismantle = true;
            // 		return structure;
            // 	}
            // }
        }
    }
    getDismantleSpots(target) {
        const nearbySpots = target.availableNeighbors(true);
        if (target.room && target.room.creeps.length > 0) {
            const startingCreep = target.room.creeps.filter(
                (creep) => creep.my,
            )[0];
            if (!!startingCreep) {
                const obstacles = _.filter(
                    target.room.structures,
                    (s) => !s.isWalkable,
                );
                return _.filter(nearbySpots, (spot) =>
                    Pathing.isReachable(startingCreep.pos, spot, obstacles),
                );
            }
        }
    }
    init() {
        let hits = '???';
        const target = this.getTarget();
        hits = target ? (target.hits / 1000).toString() + 'K' : hits;
        this.alert(`Dismantling: ${hits}`);
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'yellow' });
    }
};
DirectiveModularDismantle.directiveName = 'modularDismantle';
DirectiveModularDismantle.color = COLOR_GREY;
DirectiveModularDismantle.secondaryColor = COLOR_CYAN;
DirectiveModularDismantle = __decorate([profile], DirectiveModularDismantle);

var DirectiveStronghold_1;
/**
 * Stronghold directive contributed by @Davaned
 */
let DirectiveStronghold = (DirectiveStronghold_1 = class DirectiveStronghold extends (
    Directive
) {
    constructor(flag) {
        super(
            flag,
            (colony) => colony.level >= DirectiveStronghold_1.requiredRCL,
        );
        this.memory.state = this.memory.state || 0;
        if (this.core) {
            this.memory.strongholdLevel = this.core.level;
        }
        this.memory.waveCount = this.memory.waveCount || 0;
    }
    spawnMoarOverlords() {
        // this.overlords.strongholdKiller = new StrongholdOverlord(this);
        if (this.memory.state < 3);
        if (this.memory.state > 0 && this.memory.state <= 4) {
            this.overlords.strongholdKiller = new StrongholdOverlord(this);
        }
    }
    get core() {
        if (this.room) {
            return (
                this._core ||
                this.room
                    .find(FIND_HOSTILE_STRUCTURES)
                    .filter(
                        (struct) =>
                            struct.structureType == STRUCTURE_INVADER_CORE,
                    )[0]
            );
        }
    }
    getResourcePickupLocations() {
        if (this.room) {
            let returns = [];
            const containers = this.room.containers;
            const ruins = this.room.ruins;
            if (containers) {
                returns = returns.concat(
                    containers.filter(
                        (container) =>
                            container.pos.getRangeTo(this.pos) < 5 &&
                            sumStore(container.store) > 0,
                    ),
                );
            }
            if (ruins) {
                returns = returns.concat(
                    ruins.filter(
                        (ruin) =>
                            ruin.pos.getRangeTo(this.pos) <= 3 &&
                            sumStore(ruin.store) > 0,
                    ),
                );
            }
            return returns;
        }
    }
    manageState() {
        const currentState = this.memory.state;
        if (this.core && this.core.level == 5);
        // Starting
        if (this.room && this.core && currentState == 0) {
            // Time to start
            if (!this.core.ticksToDeploy || this.core.ticksToDeploy < 150) {
                this.memory.state = 1;
            }
        } else if (this.room && this.memory.state == 0);
        else if (
            this.pos.isVisible &&
            !this.core &&
            this.pos.lookFor(LOOK_RUINS).length > 0
        ) {
            this.memory.state = 4;
            if (Game.time % 50 == 0) {
                // log.notify(`Now looting stronghold ${this.print} in ${this.pos.roomName}`);
                this.handleLooting();
            }
        } else if (
            this.pos.isVisible &&
            !this.core &&
            this.pos.lookFor(LOOK_RUINS).length == 0
        ) {
            // Stronghold is dead
            this.remove();
        }
    }
    handleLooting() {
        const lootSpots = this.getResourcePickupLocations();
        if (lootSpots && lootSpots.length > 0) {
            lootSpots.forEach((spot) => {
                const isRamparted =
                    spot.pos
                        .lookFor(LOOK_STRUCTURES)
                        .filter(
                            (struct) =>
                                struct.structureType == STRUCTURE_RAMPART,
                        ).length > 0;
                if (isRamparted) {
                    DirectiveModularDismantle.createIfNotPresent(
                        spot.pos,
                        'pos',
                    );
                } else {
                    DirectiveHaul.createIfNotPresent(spot.pos, 'pos');
                }
            });
            const openingToCore = this.pos.getPositionAtDirection(TOP);
            const isRamparted =
                openingToCore
                    .lookFor(LOOK_STRUCTURES)
                    .filter(
                        (struct) => struct.structureType == STRUCTURE_RAMPART,
                    ).length > 0;
            if (isRamparted) {
                DirectiveModularDismantle.createIfNotPresent(
                    openingToCore,
                    'pos',
                );
            }
        }
    }
    checkStrongholdUnitComposition(defenders) {}
    handleL5() {
        // Well this, this is an L5. Can't deal with it now so just nuke it's ugly mug
        // Wait for deploy
        if (!this.pos.isVisible || !this.core || Game.time % 5 != 0) {
            return;
        }
        if (this.core.ticksToDeploy) {
            log.info(`Stronghold is still deploying! ${this.print}`);
            return;
        }
        // const remainingDuration = this.core.effects.find(effect => effect.effect == EFFECT_COLLAPSE_TIMER);
        const ramparts = this.core.room.ramparts;
        if (
            ramparts.length == 0 ||
            ramparts[0].ticksToDecay < NUKE_LAND_TIME + 10000
        ) {
            log.info(`Stronghold decaying too soon! ${this.print}`);
            return;
        }
        // if (remainingDuration != undefined && remainingDuration.ticksRemaining < NUKE_LAND_TIME + 10000) {
        // 	// It's too late, don't nuke
        // 	log.info(`Stronghold decaying too soon at ${remainingDuration.ticksRemaining}! ${this.print}`);
        // 	return;
        // }
        const bestTarget = this.pos.getPositionAtDirection(TOP_RIGHT);
        const nukes = this.core.room.find(FIND_NUKES);
        const nukesPrepped = DirectiveNukeTarget.isPresent(this.core.room.name);
        if (nukes.length < 2 && !nukesPrepped) {
            log.alert(`Nuking Stronghold! ${this.print}`);
            const res1 = DirectiveNukeTarget.create(bestTarget, {
                memory: { maxLinearRange: 10, pathNotRequired: true },
            });
            const res2 = DirectiveNukeTarget.create(bestTarget, {
                memory: { maxLinearRange: 10, pathNotRequired: true },
            });
            return res1 == OK && res2 == OK;
        } else {
            const strongholdDefenders = this.core.pos.findInRange(
                FIND_HOSTILE_CREEPS,
                4,
            );
            const reinforcers = strongholdDefenders.filter(
                (creep) =>
                    creep.body.find((bodyPart) => bodyPart.type == WORK) !=
                    undefined,
            );
            if (reinforcers.length >= nukes.length - 1) {
                log.alert(
                    `Launching additional nuke against Stronghold with reinforcers ${reinforcers.length}! ${this.print}`,
                );
                return DirectiveNukeTarget.create(bestTarget, {
                    memory: { maxLinearRange: 11, pathNotRequired: true },
                });
            }
        }
    }
    manageDirectives() {}
    lootPositions() {
        this.pos.findInRange(FIND_STRUCTURES, 4);
    }
    init() {
        let alert;
        alert = `Stronghold ${this.memory.strongholdLevel} is state ${this.memory.state}`;
        this.alert(alert);
    }
    run() {
        // Check frequently when almost mined and occasionally otherwise
        if (this.colony.commandCenter && this.colony.commandCenter.observer) {
            this.colony.commandCenter.requestRoomObservation(this.pos.roomName);
        }
        const duration = Game.time - (this.memory['T' /* TICK */] || Game.time);
        if (duration % 50000 == 0) {
            log.notify(
                `DirectiveStronghold ${this.print} in ${this.pos.roomName} has been active for ${duration} ticks`,
            );
        }
        this.manageState();
    }
});
DirectiveStronghold.directiveName = 'stronghold';
DirectiveStronghold.color = COLOR_ORANGE;
DirectiveStronghold.secondaryColor = COLOR_PURPLE;
DirectiveStronghold.requiredRCL = 7;
DirectiveStronghold = DirectiveStronghold_1 = __decorate(
    [profile],
    DirectiveStronghold,
);

let DirectiveSuspend = class DirectiveSuspend extends Directive {
    constructor(flag, colonyFilter) {
        super(flag, colonyFilter);
    }
    spawnMoarOverlords() {}
    init() {
        if (this.memory.c1 == COLOR_PURPLE && this.memory.c2 == COLOR_YELLOW) {
            this.alert(`SK Operaion Suspended - InvaderCore`);
        }
    }
    getMiddleRoom() {
        const delta = Cartographer.findRoomCoordDeltas(
            this.colony.name,
            this.pos.roomName,
        );
        switch (delta.x) {
            case 2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x - 1,
                    delta.y,
                );
                break;
            case -2:
                this.middleRoom = Cartographer.findRelativeRoomName(
                    this.colony.name,
                    delta.x + 1,
                    delta.y,
                );
                break;
            default:
                switch (delta.y) {
                    case 2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y - 1,
                        );
                        break;
                    case -2:
                        this.middleRoom = Cartographer.findRelativeRoomName(
                            this.colony.name,
                            delta.x,
                            delta.y + 1,
                        );
                        break;
                }
        }
    }
    run() {
        if (
            this.room &&
            !this.room.invaderCore &&
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER
        ) {
            Game.flags[this.ref].setColor(this.memory.c1, this.memory.c2);
        }
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CORE) {
            if (!this.middleRoom) {
                this.getMiddleRoom();
            }
            if (
                this.middleRoom &&
                Game.rooms[this.middleRoom] &&
                !Game.rooms[this.middleRoom].invaderCore
            ) {
                Game.flags[this.ref].setColor(this.memory.c1, this.memory.c2);
            }
        }
    }
};
DirectiveSuspend.directiveName = 'suspend';
DirectiveSuspend.color = COLOR_WHITE;
DirectiveSuspend.secondaryColor = COLOR_GREY;
DirectiveSuspend = __decorate([profile], DirectiveSuspend);

var DirectiveNuke_1;
/**
 * [LEGACY] Manually specify targets to be prioritized during a siege
 */
let DirectiveNuke = (DirectiveNuke_1 = class DirectiveNuke extends Directive {
    constructor(flag) {
        super(
            flag,
            (colony) =>
                colony.level >= DirectiveNuke_1.requiredRCL &&
                !!colony.nuker &&
                Game.map.getRoomLinearDistance(
                    colony.pos.roomName,
                    flag.pos.roomName,
                ) < NUKE_RANGE,
        );
    }
    spawnMoarOverlords() {}
    init() {}
    run() {
        if (this.colony.nuker) {
            const nuker = this.colony.nuker;
            if (nuker.ghodium < nuker.ghodiumCapacity) {
                this.colony.logisticsNetwork.requestInput(nuker);
            } else if (nuker.energy < nuker.energyCapacity) {
                this.colony.logisticsNetwork.requestInput(nuker, {
                    resourceType: RESOURCE_GHODIUM,
                });
            } else if (nuker.cooldown == 0) {
                const ret = nuker.launchNuke(this.pos);
                log.alert(
                    `[NUCLEAR LAUNCH] Launching nuke from ${this.colony.pos.roomName} to ${this.pos.print}! Result: ${ret}`,
                );
                Game.notify(
                    `[NUCLEAR LAUNCH] Launching nuke from ${this.colony.pos.roomName} to ${this.pos.print}! Result: ${ret}`,
                );
                this.remove(true);
            }
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
});
DirectiveNuke.directiveName = 'target:nuke';
DirectiveNuke.color = COLOR_GREY;
DirectiveNuke.secondaryColor = COLOR_RED;
DirectiveNuke.requiredRCL = 8;
DirectiveNuke = DirectiveNuke_1 = __decorate([profile], DirectiveNuke);

// export const TERMINAL_STATE_EVACUATE: TerminalState = {
// 	name     : 'evacuate',
// 	type     : 'in/out',
// 	amounts  : {[RESOURCE_ENERGY]: 10000,},
// 	tolerance: 900,
// };
const EVACUATE_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in an evacuation state, which pushes resources out of a room which is about to be breached
 */
let DirectiveTerminalEvacuateState = class DirectiveTerminalEvacuateState extends Directive {
    // colony: Colony | undefined; // this is technically unallowable, but at end of life, colony can be undefined
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isEvacuating = true;
    }
    spawnMoarOverlords() {}
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (resource == RESOURCE_ENERGY) {
                    // keep a little energy just to keep the room functioning
                    Overmind.terminalNetwork.exportResource(
                        this.colony,
                        resource,
                        {
                            target: 10000,
                            tolerance: 2000,
                            surplus: 15000,
                        },
                    );
                } else {
                    Overmind.terminalNetwork.exportResource(
                        this.colony,
                        resource,
                    );
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: evacuation terminal state active!`);
        }
        this.alert('Evacuation terminal state active!', NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (
            !this.colony ||
            !this.colony.terminal ||
            !!this.colony.controller.safeMode ||
            Game.time >
                (this.memory['T' /* TICK */] || 0) + EVACUATE_STATE_TIMEOUT
        ) {
            this.remove();
        }
    }
};
DirectiveTerminalEvacuateState.directiveName = 'evacuateState';
DirectiveTerminalEvacuateState.color = COLOR_BROWN;
DirectiveTerminalEvacuateState.secondaryColor = COLOR_RED;
DirectiveTerminalEvacuateState = __decorate(
    [profile],
    DirectiveTerminalEvacuateState,
);

const getDefaultTestOverlordMemory = () => ({});
/**
 * DOCUMENTATION GOES HERE
 */
let TestOverlord = class TestOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.default) {
        super(directive, 'test', priority, getDefaultTestOverlordMemory);
        // TODO
        this.testCreeps = this.zerg(Roles.scout); // TODO
    }
    refresh() {
        super.refresh();
        // TODO
    }
    init() {
        this.wishlist(1, Setups.scout);
    }
    handleTest(zerg) {
        zerg.say('hi');
        zerg.goTo(this.pos);
    }
    run() {
        this.autoRun(this.testCreeps, (zerg) => this.handleTest(zerg));
    }
};
TestOverlord = __decorate([profile], TestOverlord);

const getDefaultDirectiveTestMemory = () => ({});
/**
 * DOCUMENTATION GOES HERE
 */
let DirectiveTest = class DirectiveTest extends Directive {
    constructor(flag) {
        super(flag);
        _.defaultsDeep(this.memory, getDefaultDirectiveTestMemory());
        this.refresh();
        // TODO
    }
    refresh() {
        super.refresh();
        // TODO
    }
    spawnMoarOverlords() {
        // TODO
        this.overlords.testOverlord = new TestOverlord(this);
    }
    init() {}
    run() {}
};
DirectiveTest.directiveName = 'test';
DirectiveTest.color = COLOR_WHITE;
DirectiveTest.secondaryColor = COLOR_CYAN;
DirectiveTest = __decorate([profile], DirectiveTest);

// Jump table to instantiate flags based on type
/**
 * This is the initializer for directives, which maps flags by their color code to the corresponding directive
 */
function DirectiveWrapper(flag) {
    switch (flag.color) {
        // Colony directives ===========================================================================================
        case COLOR_PURPLE:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveOutpost(flag);
                case COLOR_YELLOW:
                    return new DirectiveSKOutpost(flag);
                case COLOR_WHITE:
                    return new DirectiveIncubate(flag);
                case COLOR_GREY:
                    return new DirectiveColonize(flag);
                case COLOR_ORANGE:
                    return new DirectiveClearRoom(flag);
                case COLOR_RED:
                    return new DirectivePoisonRoom(flag);
                case COLOR_GREEN:
                    return new DirectiveRogueColony(flag);
                case COLOR_BROWN:
                    return new DirectiveInterShard(flag);
            }
            break;
        // Offensive combat directives =================================================================================
        case COLOR_RED:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveSwarmDestroy(flag);
                case COLOR_CYAN:
                    return new DirectivePairDestroy(flag);
                case COLOR_YELLOW:
                    return new DirectivePairSiege(flag);
                case COLOR_GREEN:
                    return new DirectiveSwarmDismantle(flag);
                case COLOR_PURPLE:
                    return new DirectiveControllerAttack(flag);
                case COLOR_WHITE:
                    return new DirectiveHarass(flag);
                case COLOR_GREY:
                    return new DirectiveDrain(flag);
                case COLOR_BLUE:
                    return new DirectiveRangedPair(flag);
            }
            break;
        // Defensive combat directives =================================================================================
        case COLOR_BLUE:
            switch (flag.secondaryColor) {
                case COLOR_BLUE:
                    return new DirectiveGuard(flag);
                case COLOR_RED:
                    return new DirectiveOutpostDefense(flag);
                case COLOR_PURPLE:
                    return new DirectiveInvasionDefense(flag);
                case COLOR_GREEN:
                    return new DirectiveSupportDefense(flag);
            }
            break;
        // Situational directives ======================================================================================
        case COLOR_ORANGE:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveBootstrap(flag);
                case COLOR_BLUE:
                    return new DirectiveNukeResponse(flag);
                case COLOR_RED:
                    return new DirectiveNukeTarget(flag);
                case COLOR_PURPLE:
                    return new DirectiveStronghold(flag);
                case COLOR_WHITE:
                    return new DirectivePortalScout(flag);
                case COLOR_YELLOW:
                    return new DirectiveRemoteUpgrade(flag);
            }
            break;
        // Resource directives =========================================================================================
        case COLOR_YELLOW:
            switch (flag.secondaryColor) {
                case COLOR_YELLOW:
                    return new DirectiveHarvest(flag);
                case COLOR_CYAN:
                    return new DirectiveExtract(flag);
                case COLOR_BLUE:
                    return new DirectiveHaul(flag);
                case COLOR_RED:
                    return new DirectivePowerMine(flag);
                case COLOR_ORANGE:
                    return new DirectiveLeech(flag);
            }
            break;
        // Terminal state directives ===================================================================================
        case COLOR_BROWN:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveTerminalEvacuateState(flag);
                // case COLOR_ORANGE:
                // 	return new DirectiveTerminalEmergencyState(flag);
                case COLOR_YELLOW:
                    return new DirectiveTerminalRebuildState(flag);
            }
            break;
        // Targeting colors ============================================================================================
        case COLOR_GREY:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveNuke(flag);
                case COLOR_ORANGE:
                    return new DirectiveTargetSiege(flag);
                case COLOR_YELLOW:
                    return new DirectiveDismantle(flag);
                case COLOR_CYAN:
                    return new DirectiveModularDismantle(flag);
            }
            break;
        // Room planning directives ====================================================================================
        case COLOR_WHITE:
            switch (flag.secondaryColor) {
                case COLOR_GREEN:
                    return new DirectiveRPHatchery(flag);
                case COLOR_BLUE:
                    return new DirectiveRPCommandCenter(flag);
                case COLOR_RED:
                    return new DirectiveRPBunker(flag);
                case COLOR_GREY:
                    return new DirectiveSuspend(flag);
                case COLOR_CYAN:
                    return new DirectiveTest(flag);
            }
            break;
        // Power directives ====================================================================================
        case COLOR_CYAN:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveBaseOperator(flag);
            }
            break;
    }
}

const MAX_ACTIVE_SEGMENTS = 10;
const DefaultSegmenterMemory = {
    activeSegments: [],
    activeForeignSegment: undefined,
    publicSegments: [],
};
const SEGMENTS = {
    reinforcementLearning: 70,
    remoteDebugger: 97,
    assimilator: 98,
};
if (!Memory.segmenter) {
    Memory.segmenter = {};
}
_.defaultsDeep(Memory.segmenter, DefaultSegmenterMemory);
/**
 * The segmenter module controls public and private segment memory access
 */
let Segmenter = class Segmenter {
    static get memory() {
        return Memory.segmenter;
    }
    static requestSegments(...ids) {
        for (const id of ids) {
            if (!this.memory.activeSegments.includes(id)) {
                this.memory.activeSegments.push(id);
                if (this.memory.activeSegments.length > MAX_ACTIVE_SEGMENTS) {
                    const removeSegment = this.memory.activeSegments.shift();
                    console.log(
                        `Maximum active segments reached. Discarding segment ${removeSegment}.`,
                    );
                }
            }
        }
    }
    static getSegment(id) {
        if (
            (this.cache.lastAccessed[id] || 0) >
            (this.cache.lastModified[id] || 0)
        ) {
            return this.cache.segments[id];
        }
        const str = RawMemory.segments[id];
        let segment;
        try {
            segment = JSON.parse(str);
        } catch (e) {
            console.log(`Creating new object for RawMemory.segments[${id}].`);
            segment = {};
            this.cache.segments[id] = segment;
            this.cache.lastModified[id] = Game.time;
        }
        this.cache.segments[id] = segment;
        this.cache.lastAccessed[id] = Game.time;
        return this.cache.segments[id];
    }
    static getSegmentProperty(id, key) {
        const segment = this.getSegment(id);
        return segment[key];
    }
    static setSegment(id, value) {
        this.cache.segments[id] = value;
        this.cache.lastModified[id] = Game.time;
    }
    static setSegmentProperty(id, key, value) {
        const segment = this.getSegment(id);
        segment[key] = value;
        this.cache.lastModified[id] = Game.time;
    }
    static requestForeignSegment(username, id) {
        if (username) {
            this.memory.activeForeignSegment = {
                username: username,
                id: id,
            };
        }
    }
    static markSegmentAsPublic(id) {
        if (!this.memory.publicSegments.includes(id)) {
            this.memory.publicSegments.push(id);
        }
    }
    static getForeignSegment() {
        if (RawMemory.foreignSegment) {
            let segment;
            try {
                segment = JSON.parse(RawMemory.foreignSegment.data);
                return segment;
            } catch (e) {
                console.log(`Could not parse RawMemory.foreignSegment.data!`);
            }
        }
    }
    static getForeignSegmentProperty(key) {
        if (RawMemory.foreignSegment) {
            let segment;
            try {
                segment = JSON.parse(RawMemory.foreignSegment.data);
            } catch (e) {
                segment = {};
                console.log(`Could not parse RawMemory.foreignSegment.data!`);
            }
            return segment[key];
        }
    }
    static run() {
        // Set active, public, and foreign segments
        RawMemory.setActiveSegments(this.memory.activeSegments);
        RawMemory.setPublicSegments(this.memory.publicSegments);
        if (this.memory.activeForeignSegment) {
            RawMemory.setActiveForeignSegment(
                this.memory.activeForeignSegment.username,
                this.memory.activeForeignSegment.id,
            );
        } else {
            RawMemory.setActiveForeignSegment(null);
        }
        // Write things that have been modified this tick to memory
        for (const id in this.cache.lastModified) {
            if (this.cache.lastModified[id] == Game.time) {
                RawMemory.segments[id] = JSON.stringify(
                    this.cache.segments[id],
                );
            }
        }
    }
};
Segmenter.cache = {
    segments: {},
    lastAccessed: {},
    lastModified: {},
};
Segmenter = __decorate([profile], Segmenter);

class DefenseDirective extends Directive {
    constructor(flag) {
        super(flag);
        Overmind.overseer.combatPlanner.directives.push(this);
    }
}

// High-level planning for skirmishing and combats
const THREAT_DECAY_TIMESCALE = 100;
const SIEGE_ANALYSIS_EXPIRATION = 2500;
const defaultCombatPlannerMemory = {
    threats: {},
    profiles: {},
    defenses: {},
    sieges: {},
    skirmishes: {},
};
class CombatPlanner {
    constructor() {
        _.defaults(this.memory, defaultCombatPlannerMemory);
    }
    get memory() {
        return Memory.combatPlanner;
    }
    static computeHitsToSpawn(room) {
        // TODO
        return 0;
    }
    // private getNeededPotentials(): CombatPotentials {
    // 	// TODO
    // }
    spawnNeededCreeps() {}
    assembleSquads() {
        for (const creep of this.creeps) {
            if (!creep.overlord);
            else {
                const creepDirective = creep.overlord.directive;
                if (
                    creepDirective &&
                    creepDirective instanceof DefenseDirective
                ) {
                    if (this.memory.threats[creepDirective.ref]);
                }
            }
        }
    }
    static getThreat(directive) {
        if (directive.room) {
            return {
                directive: directive,
                potentials: CombatIntel.getCombatPotentials(
                    directive.room.hostiles,
                ),
                roomName: directive.room.name,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                },
            };
        } else {
            return {
                directive: directive,
                potentials: undefined,
                roomName: directive.pos.roomName,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                },
            };
        }
    }
    registerThreat(directive) {
        const threat = CombatPlanner.getThreat(directive);
        if (this.memory.threats[directive.ref]) {
            // If a threat already exists, update it or allow potentials to decay
            if (threat.potentials) {
                // you have vision
                // If you have new info on threat potentials, update the log in memory
                let attack, rangedAttack, heal;
                const lastPotentials = this.memory.threats[directive.ref]
                    .potentials;
                if (lastPotentials) {
                    attack = lastPotentials.attack;
                    rangedAttack = lastPotentials.ranged;
                    heal = lastPotentials.heal;
                } else {
                    attack = 0;
                    rangedAttack = 0;
                    heal = 0;
                }
                const decayedAttack = ema(
                    threat.potentials.attack,
                    attack,
                    THREAT_DECAY_TIMESCALE,
                );
                const decayedRangedAttack = ema(
                    threat.potentials.ranged,
                    rangedAttack,
                    THREAT_DECAY_TIMESCALE,
                );
                const decayedHeal = ema(
                    threat.potentials.heal,
                    heal,
                    THREAT_DECAY_TIMESCALE,
                );
                // TODO: adjust decay for creeps known to have moved to next visible room
                // Set new potential to maximum of current or decayed potential
                const potentials = {
                    attack: Math.max(threat.potentials.attack, decayedAttack),
                    ranged: Math.max(
                        threat.potentials.ranged,
                        decayedRangedAttack,
                    ),
                    heal: Math.max(threat.potentials.heal, decayedHeal),
                };
                // Update the existing threat
                this.memory.threats[directive.ref].potentials = potentials;
                this.memory.threats[directive.ref].lastSeen.tick = Game.time;
            }
        } else {
            // Register a new threat
            this.memory.threats[directive.ref] = threat;
        }
    }
    static getRoomLayout(room) {
        let isBunker,
            isExposed,
            isInnerWall,
            isEdgeWall = false;
        const exitPositions = RoomIntel.getExitPositions(room.name);
        const terrain = Game.map.getRoomTerrain(room.name);
        // Room is bunker if >80% of hostile structures are covered by ramparts
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        const hostileStructuresInRampart = _.filter(hostileStructures, (s) =>
            s.pos.lookForStructure(STRUCTURE_RAMPART),
        );
        isBunker =
            hostileStructuresInRampart.length / hostileStructures.length >= 0.8;
        // Room is edgewall if every exit tile has wall or barrier at 2 range to left/right/top/bottom
        const walledOffExitTiles = _.filter(exitPositions, (pos) => {
            let lookPos;
            const x = pos.x;
            const y = pos.y;
            if (x == 0) {
                lookPos = new RoomPosition(x + 2, y, room.name);
            } else if (x == 49) {
                lookPos = new RoomPosition(x - 2, y, room.name);
            } else if (y == 0) {
                lookPos = new RoomPosition(x, y + 2, room.name);
            } else if (y == 49) {
                lookPos = new RoomPosition(x, y - 2, room.name);
            } else {
                // shouldn't ever get here
                lookPos = pos;
            }
            if (terrain.get(lookPos.x, lookPos.y) == TERRAIN_MASK_WALL) {
                return true;
            } else {
                const rampart = lookPos.lookForStructure(STRUCTURE_RAMPART);
                const wall = lookPos.lookForStructure(STRUCTURE_WALL);
                return rampart != undefined || wall != undefined;
            }
        });
        if (walledOffExitTiles.length == walledOffExitTiles.length) {
            isEdgeWall = true;
        }
        // Room is inner wall if not bunker or edgewall and there is no path to spawn, otherwise exposed
        if (!isBunker && !isEdgeWall) {
            const entryPoints = _.compact([
                _.find(exitPositions, (pos) => pos.x == 0),
                _.find(exitPositions, (pos) => pos.x == 49),
                _.find(exitPositions, (pos) => pos.y == 0),
                _.find(exitPositions, (pos) => pos.y == 49),
            ]);
            const target = room.spawns[0] || room.towers[0];
            if (target) {
                const obstacles = _.filter(
                    room.structures,
                    (s) => !s.isWalkable,
                );
                const isReachable = _.find(entryPoints, (pos) =>
                    Pathing.isReachable(pos, target.pos, obstacles),
                );
                if (isReachable) {
                    isExposed = true;
                }
            }
            if (!isExposed) {
                isInnerWall = true;
            }
        }
        if (isEdgeWall) {
            return 'edgewall';
        } else if (isBunker) {
            return 'bunker';
        } else if (isExposed) {
            return 'exposed';
        } else if (isInnerWall) {
            return 'innerwall';
        } else {
            log.warning(
                `Inconclusive room layout for ${room.print}! Assuming inner wall.`,
            );
            return 'innerwall';
        }
    }
    static getSiegeAnalysis(room) {
        const owner = room.owner;
        const level = room.controller ? room.controller.level : 0;
        const towerDamageSamplePositions = _.map(
            _.range(20),
            (i) =>
                new RoomPosition(_.random(1, 48), _.random(1, 48), room.name),
        );
        const maxTowerDamage = _.max(
            _.map(towerDamageSamplePositions, (pos) =>
                CombatIntel.towerDamageAtPos(pos, true),
            ),
        );
        const minBarrierHits =
            room.barriers.length > 0
                ? _.min(_.map(room.barriers, (b) => b.hits))
                : 0;
        const avgBarrierHits =
            room.barriers.length > 0
                ? _.sum(room.barriers, (b) => b.hits) / room.barriers.length
                : 0;
        const numWalls = room.walls.length;
        const numRamparts = room.ramparts.length;
        const expiration = getCacheExpiration(SIEGE_ANALYSIS_EXPIRATION);
        const roomLayout = this.getRoomLayout(room);
        return {
            owner,
            level,
            maxTowerDamage,
            minBarrierHits,
            avgBarrierHits,
            numWalls,
            numRamparts,
            roomLayout,
            expiration,
        };
    }
    registerSiegeAnalysis(room) {
        if (!this.memory.sieges[room.name]) {
            this.memory.sieges[room.name] = {};
        }
        if (
            !this.memory.sieges[room.name].analysis ||
            Game.time > this.memory.sieges[room.name].analysis.expiration
        ) {
            this.memory.sieges[
                room.name
            ].analysis = CombatPlanner.getSiegeAnalysis(room);
        }
    }
    init() {
        // Register new interactions in visible rooms
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            // Make new siege analyses for rooms needing it
            if (room.owner && !room.my) {
                this.registerSiegeAnalysis(room);
            }
        }
        for (const directive of this.directives) {
            this.registerThreat(directive);
        }
    }
    run() {}
    visuals() {}
}

var Overseer_1;
const getDefaultOverseerMemory = () => ({});
/**
 * The Overseer object acts as a scheduler, running directives and overlords for all colonies each tick. It is also
 * in charge of starting new "processes" (directives) to respond to various situations.
 */
let Overseer = (Overseer_1 = class Overseer {
    constructor() {
        this.memory = Mem.wrap(Memory, 'overseer', getDefaultOverseerMemory);
        this.directives = [];
        this.overlords = [];
        this.overlordsByColony = {};
        this._overlordsCached = false;
        this.notifier = new Notifier();
        this.combatPlanner = new CombatPlanner();
    }
    refresh() {
        this.memory = Mem.wrap(Memory, 'overseer', getDefaultOverseerMemory);
        this.notifier.clear();
    }
    try(callback, identifier) {
        {
            try {
                callback();
            } catch (e) {
                if (identifier) {
                    e.name =
                        `Caught unhandled exception at ${
                            '' + callback
                        } (identifier: ${identifier}): \n` +
                        e.name +
                        '\n' +
                        e.stack;
                } else {
                    e.name =
                        `Caught unhandled exception at ${'' + callback}: \n` +
                        e.name +
                        '\n' +
                        e.stack;
                }
                Overmind.exceptions.push(e);
            }
        }
    }
    registerDirective(directive) {
        this.directives.push(directive);
        this._directiveCached = false;
    }
    removeDirective(directive) {
        _.remove(this.directives, (dir) => dir.name == directive.name);
        for (const name in directive.overlords) {
            this.removeOverlord(directive.overlords[name]);
        }
        this._directiveCached = false;
    }
    ensureDirectivesCached() {
        if (!this._directiveCached) {
            this.directivesByType = _.groupBy(
                this.directives,
                (directive) => directive.directiveName,
            );
            this.directivesByRoom = _.groupBy(
                this.directives,
                (directive) => directive.pos.roomName,
            );
            this.directivesByColony = _.groupBy(
                this.directives,
                (directive) => directive.colony.name || 'none',
            );
            this._directiveCached = true;
        }
    }
    getDirectivesOfType(directiveName) {
        this.ensureDirectivesCached();
        return this.directivesByType[directiveName] || [];
    }
    getDirectivesInRoom(roomName) {
        this.ensureDirectivesCached();
        return this.directivesByRoom[roomName] || [];
    }
    getDirectivesForColony(colony) {
        this.ensureDirectivesCached();
        return this.directivesByColony[colony.name] || [];
    }
    registerOverlord(overlord) {
        this.overlords.push(overlord);
        this._overlordsCached = false;
    }
    removeOverlord(overlord) {
        _.remove(this.overlords, (o) => o.ref == overlord.ref);
        this._overlordsCached = false;
    }
    ensureOverlordsCached() {
        if (!this._overlordsCached) {
            this.overlords.sort((o1, o2) => o1.priority - o2.priority);
            this.overlordsByColony = _.groupBy(
                this.overlords,
                (overlord) => overlord.colony.name,
            );
            for (const colName in this.overlordsByColony) {
                this.overlordsByColony[colName].sort(
                    (o1, o2) => o1.priority - o2.priority,
                );
            }
            this._overlordsCached = true;
        }
    }
    getOverlordsForColony(colony) {
        return this.overlordsByColony[colony.name] || [];
    }
    // Initialization ==================================================================================================
    registerLogisticsRequests(colony) {
        // Register logistics requests for all dropped resources and tombstones
        for (const room of colony.rooms) {
            // Pick up all nontrivial dropped resources
            for (const resourceType in room.drops) {
                for (const drop of room.drops[resourceType]) {
                    if (
                        drop.amount >
                            LogisticsNetwork.settings.droppedEnergyThreshold ||
                        drop.resourceType != RESOURCE_ENERGY
                    ) {
                        if (
                            colony.bunker &&
                            drop.pos.isEqualTo(colony.bunker.anchor)
                        ) {
                            continue;
                        } // resolves unreachable bug
                        colony.logisticsNetwork.requestOutput(drop);
                    }
                }
            }
        }
        for (const ruin of colony.ruins) {
            if (sumStore(ruin.store) < ruin.store.energy) {
                // get rid of any minerals first
                colony.logisticsNetwork.requestOutputMinerals(ruin);
            } else {
                if (
                    sumStore(ruin.store) >
                    LogisticsNetwork.settings.droppedEnergyThreshold
                ) {
                    colony.logisticsNetwork.requestOutput(ruin, {
                        resourceType: 'all',
                    });
                }
            }
        }
        // Place a logistics request directive for every tombstone
        // with non-empty store that isn't on a container
        for (const tombstone of colony.tombstones) {
            if (sumStore(tombstone.store) < tombstone.store.energy) {
                // get rid of any minerals first
                colony.logisticsNetwork.requestOutputMinerals(tombstone);
            } else {
                if (
                    sumStore(tombstone.store) >
                    LogisticsNetwork.settings.droppedEnergyThreshold
                ) {
                    if (
                        colony.bunker &&
                        tombstone.pos.isEqualTo(colony.bunker.anchor)
                    ) {
                        continue;
                    }

                    colony.logisticsNetwork.requestOutput(tombstone, {
                        resourceType: 'all',
                    });
                    /*
                    if(tombstone.pos.roomName == 'W45N44') { // 8/2023 debug
                        console.log('W45N44 tombstone requested from logistics network ',tombstone.deathTime,tombstone.pos.x,tombstone.pos.y);
                    }
                    */
                }
            }
        }
    }
    init() {
        this.ensureDirectivesCached();
        this.ensureOverlordsCached();
        // Initialize directives
        for (const directive of this.directives) {
            directive.init();
        }

        // Register cleanup requests to logistics network
        // Limit checks for colony.rooms of ruins/drops/tombstone to every timer x
        //let interval = Memory.settings.intervals.registerLogisticsRequests;
        //_.forEach(getAllColonies(), (colony) => (Game.time + colony.id) % interval == 0 &&
        //    this.registerLogisticsRequests(colony));

        // Register cleanup requests to logistics network
        _.forEach(getAllColonies(), (colony) => {
            this.registerLogisticsRequests(colony);
        });

        // Initialize overlords
        for (const overlord of this.overlords) {
            if (!overlord.isSuspended) {
                if (overlord.profilingActive) {
                    const start = Game.cpu.getUsed();
                    overlord.preInit();
                    this.try(() => overlord.init());
                    overlord.memory['S' /* STATS */].cpu +=
                        Game.cpu.getUsed() - start;
                } else {
                    overlord.preInit();
                    this.try(() => overlord.init());
                }
            }
        }
        /*
        _.forEach(getAllColonies(), (colony) => {
            if(colony.room.name == 'W45N43') {
                colony.logisticsNetwork.summarize(); // zgeneral make it always run 16/6/2022
            }
        });
        */
    }
    // Run phase methods ===============================================================================================
    placeHarvestingDirectives(colony) {
        if (getAutonomyLevel() > Autonomy.ManualExtreme) {
            for (const source of colony.sources) {
                DirectiveHarvest.createIfNotPresent(source.pos, 'pos');
            }
            if (colony.controller.level >= 6 && colony.terminal) {
                _.forEach(colony.extractors, (extractor) =>
                    DirectiveExtract.createIfNotPresent(extractor.pos, 'pos'),
                );
            }
        }
    }
    handleBootstrapping(colony) {
        // Bootstrap directive: in the event of catastrophic room crash, enter emergency spawn mode.
        // Doesn't apply to incubating colonies.
        if (!colony.state.isIncubating) {
            const noQueen = colony.getCreepsByRole(Roles.queen).length == 0;
            const noDrone = colony.getCreepsByRole(Roles.drone).length == 0;
            if ((noQueen || noDrone) && colony.hatchery && !colony.spawnGroup) {
                const setup = colony.hatchery.overlord.queenSetup;
                const energyToMakeQueen = bodyCost(
                    setup.generateBody(colony.room.energyCapacityAvailable),
                );
                if (
                    colony.room.energyAvailable < energyToMakeQueen ||
                    hasJustSpawned()
                ) {
                    const result = DirectiveBootstrap.createIfNotPresent(
                        colony.hatchery.pos,
                        'pos',
                    );
                    if (typeof result == 'string' || result == OK) {
                        // successfully made flag
                        colony.hatchery.settings.suppressSpawning = true;
                    }
                }
            }
        }
    }
    handleOutpostDefense(colony) {
        // TODO: plug in threatLevel infra
        // Guard directive: defend your outposts and all rooms of colonies that you are incubating
        for (const room of colony.outposts) {
            // Handle player defense
            if (
                room.dangerousPlayerHostiles.length > 0 &&
                room.dangerousHostiles.find((hostile) =>
                    CombatIntel.isDangerous(hostile),
                )
            ) {
                DirectiveOutpostDefense.createIfNotPresent(
                    Pathing.findPathablePosition(room.name),
                    'room',
                );
            }
            // Handle NPC invasion directives
            else if (
                Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER
            ) {
                //&& //zGeneral 5/6/2021
                //Cartographer.roomType(room.name) != ROOMTYPE_CORE) {
                // SK rooms can fend for themselves
                if (
                    room.invaders.length > 0 ||
                    (room.invaderCore && room.invaderCore.level == 0)
                ) {
                    const defenseDirectives = [
                        ...DirectiveGuard.find(room.flags),
                        ...DirectiveOutpostDefense.find(room.flags),
                    ];
                    if (defenseDirectives.length == 0) {
                        const placePos = (room.invaders[0] || room.invaderCore)
                            .pos;
                        DirectiveGuard.create(placePos);
                    }
                }
            } else if (
                Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER
            ) {
                if (
                    room.invaderCore &&
                    room.invaderCore.level < 3 &&
                    (!room.invaderCore.ticksToDeploy ||
                        room.invaderCore.ticksToDeploy < 300)
                ) {
                    //kamal
                    const placePos = (room.invaders[0] || room.invaderCore).pos;
                    DirectivePairDestroy.createIfNotPresent(placePos, 'room');
                }
            }
        }
    }
    // private handleStrongholds(colony: Colony) {
    // 	if (Game.time % 57 == 0) {
    // 		for (const room of colony.outposts) {
    // 			if (room.invaderCore) {
    // 				log.alert(`Found core in ${room.name} with ${room.invaderCore} level ${room.invaderCore.level}`);
    // 				if (room.invaderCore.level == 0) {
    // 					DirectiveModularDismantle.createIfNotPresent(room.invaderCore.pos, 'pos');
    // 				}
    // 				// else if (room.invaderCore.level <= 4 && room.invaderCore.ticksToDeploy) {
    // 				// 	res = DirectiveStronghold.createIfNotPresent(room.invaderCore.pos, 'room');
    // 				// 	if (!!res) {
    // 				// 		log.notify(`Creating inactiveStronghold clearing ranged attacker in room ${room.name}`);
    // 				// 	}
    // 				// }
    // 			}
    // 		}
    // 	}
    // }
    handleColonyInvasions(colony, checkPersistent = false) {
        // See if invasion is big enough to warrant creep defenses
        if (!colony.room.isSafe && colony.room.threatLevel > 0.25) {
            if (checkPersistent) {
                // Place defensive directive after hostiles have been present for a long enough time
                const safetyData = RoomIntel.getSafetyData(colony.room.name);
                // TODO: set a timer similar to unsafeFor
                const invasionIsPersistent = safetyData.unsafeFor > 20;
                if (
                    invasionIsPersistent &&
                    !DirectivePoisonRoom.isPresent(colony.pos)
                ) {
                    DirectiveInvasionDefense.createIfNotPresent(
                        colony.controller.pos,
                        'room',
                    );
                }
            } else {
                DirectiveInvasionDefense.createIfNotPresent(
                    colony.controller.pos,
                    'room',
                );
            }
        }
    }
    handleNukeResponse(colony) {
        // Place nuke response directive if there is a nuke present in colony room
        if (colony.room && colony.level >= DirectiveNukeResponse.requiredRCL) {
            for (const nuke of colony.room.find(FIND_NUKES)) {
                DirectiveNukeResponse.createIfNotPresent(nuke.pos, 'pos');
            }
        }
    }
    /**
     * Creates directives to handle mining from nearby power banks
     */
    handlePowerMining(room) {
        const powerSetting = Memory.settings.powerCollection;
        const roomType = Cartographer.roomType(room.name);
        if (
            powerSetting.enabled &&
            (roomType == ROOMTYPE_ALLEY || roomType == ROOMTYPE_CROSSROAD)
        ) {
            const powerBank = _.first(room.powerBanks);
            if (
                powerBank != undefined &&
                DirectivePowerMine.isPresent(powerBank.pos) &&
                room.dangerousPlayerHostiles.length > 0
            ) {
                if (
                    // (RoomIntel.getSafetyData(room.name).numBoostedHostiles ||
                    //     0) > 0
                    _.filter( // zGeneral 13/10/2023
                        room.hostiles,
                        (hostile) => {
                            const relevantBoostedParts = _.filter(hostile.body, (part) => 
                                (part.boost && (part.type === ATTACK || part.type === RANGED_ATTACK || part.type === HEAL))
                            ).length;
                            return relevantBoostedParts > 4;
                        }
                    ).length > 0

                ) {
                    DirectiveRangedPair.createIfNotPresent(
                        powerBank.pos,
                        'pos',
                        {
                            name: '_boost_' + room.name,
                        },
                    );
                } else {
                    DirectiveRangedPair.createIfNotPresent(
                        powerBank.pos,
                        'pos',
                        {
                            name: '_lite_' + room.name,
                        },
                    );
                }
            }
            if (
                powerBank &&
                powerBank.ticksToDecay > 4000 &&
                powerBank.power >= powerSetting.minPower
            ) {
                if (DirectivePowerMine.isPresent(powerBank.pos)) {
                    return;
                }
                const validColonies = _.filter(
                    getAllColonies(),
                    (colony) =>
                        colony.level >= DirectivePowerMine.requiredRCL &&
                        Game.map.getRoomLinearDistance(
                            colony.name,
                            room.name,
                        ) <= powerSetting.maxRange,
                );
                for (const colony of validColonies) {
                    const route = Game.map.findRoute(
                        colony.room,
                        powerBank.room,
                    );
                    if (
                        route != ERR_NO_PATH &&
                        route.length <= powerSetting.maxRange
                    ) {
                        log.info(
                            `FOUND POWER BANK IN RANGE ${route.length}, STARTING MINING ${powerBank.room}`,
                        );
                        DirectivePowerMine.create(powerBank.pos);
                        return;
                    }
                }
            }
        }
    }
    computePossibleOutposts(colony, depth = 3) {
        return _.filter(
            Cartographer.findRoomsInRange(colony.room.name, depth),
            (roomName) => {
                if (Cartographer.roomType(roomName) != ROOMTYPE_CONTROLLER) {
                    return false;
                }
                const alreadyAnOutpost = _.any(
                    Overmind.cache.outpostFlags,
                    (flag) =>
                        (flag.memory.setPos || flag.pos).roomName == roomName,
                );
                const alreadyAColony = !!Overmind.colonies[roomName];
                if (alreadyAColony || alreadyAnOutpost) {
                    return false;
                }
                const alreadyOwned = RoomIntel.roomOwnedBy(roomName);
                const alreadyReserved = RoomIntel.roomReservedBy(roomName);
                const isBlocked = Game.flags[roomName + '-Block'] != null; // TODO: this is ugly
                // todo: reevaluate this
                const disregardReservations =
                    !onPublicServer() || MY_USERNAME == MUON;
                if (
                    alreadyOwned ||
                    (alreadyReserved && !disregardReservations) ||
                    isBlocked ||
                    Pathing.shouldAvoid(roomName)
                ) {
                    return false;
                }
                const neighboringRooms = _.values(
                    Game.map.describeExits(roomName),
                );
                const isReachableFromColony = _.any(neighboringRooms, (r) =>
                    colony.roomNames.includes(r),
                );
                return (
                    isReachableFromColony &&
                    RoomIntel.getRoomStatus(roomName).status ===
                        RoomIntel.getMyZoneStatus()
                );
            },
        );
    }
    handleNewOutposts(colony) {
        const numSources = _.sum(
            colony.roomNames, // TODO: rewrite to include suspension?
            (roomName) =>
                Memory.rooms[roomName] &&
                Memory.rooms[roomName]['s' /* SOURCES */]
                    ? Memory.rooms[roomName]['s' /* SOURCES */].length
                    : 0,
        );
        const numRemotes = numSources - colony.room.sources.length;
        const spawnCapacityFree =
            numRemotes < 1 ||
            (colony.hatchery &&
                colony.hatchery.memory.stats.uptime < 0.4 &&
                colony.hatchery.memory.stats.overload < 0.2 &&
                colony.hatchery.getWaitTimeForPriority(
                    OverlordPriority.remoteRoom.mine,
                ) < 50);
        if (
            Game.cpu.bucket > Memory.settings.bucketThresholds.newOutposts &&
            numRemotes < Colony.settings.remoteSourcesByLevel[colony.level] &&
            spawnCapacityFree
        ) {
            const possibleOutposts = this.computePossibleOutposts(colony);
            const origin = colony.pos;
            const bestOutpost = minBy(possibleOutposts, function (outpostName) {
                const sourceInfo = RoomIntel.getSourceInfo(outpostName);
                if (!sourceInfo) return false;
                const sourceDistances = _.map(sourceInfo, (src) =>
                    Pathing.distance(origin, src.pos),
                );
                if (
                    _.any(
                        sourceDistances,
                        (dist) =>
                            dist == undefined ||
                            dist > Colony.settings.maxSourceDistance,
                    )
                ) {
                    return false;
                }
                return _.sum(sourceDistances) / sourceDistances.length;
            });
            if (bestOutpost) {
                const pos = Pathing.findPathablePosition(bestOutpost);
                log.info(
                    `Colony ${colony.room.print} now remote mining from ${pos.print}`,
                );
                DirectiveOutpost.createIfNotPresent(pos, 'room', {
                    memory: { ['C' /* COLONY */]: colony.name },
                });
            }
        }
    }
    handleAutoPoisoning() {
        // Can only have a max number of concurrent poisons at a time
        const poisonDirectives = this.directivesByType[
            DirectivePoisonRoom.directiveName
        ];
        if (
            poisonDirectives &&
            poisonDirectives.length >= Memory.settings.autoPoison.maxConcurrent
        ) {
            return;
        }
        // Find a room to poison
        for (const room of getAllRooms()) {
            if (DirectivePoisonRoom.canAutoPoison(room)) {
                const controller = room.controller;
                const maxRange = Memory.settings.autoPoison.maxRange;
                if (!DirectivePoisonRoom.isPresent(controller.pos)) {
                    // See if you can poison a room
                    const colonies = getAllColonies().filter(
                        (colony) =>
                            colony.level >= DirectivePoisonRoom.requiredRCL &&
                            Game.map.getRoomLinearDistance(
                                room.name,
                                colony.room.name,
                            ) <= maxRange,
                    );
                    for (const colony of colonies) {
                        const route = Game.map.findRoute(colony.room, room);
                        if (route != ERR_NO_PATH && route.length <= maxRange) {
                            log.notify(`Poisoning room ${room.print}`);
                            DirectivePoisonRoom.create(controller.pos);
                            return;
                        }
                    }
                }
            }
        }
    }
    /**
     * Place directives to respond to various conditions
     */
    placeDirectives() {
        const allRooms = getAllRooms();
        const allColonies = getAllColonies();
        if (LATEST_BUILD_TICK == Game.time) {
            _.forEach(allColonies, (colony) =>
                this.placeHarvestingDirectives(colony),
            );
        }
        let interval = Memory.settings.intervals.handleBootstrapping;
        _.forEach(
            allColonies,
            (colony) =>
                (Game.time + colony.id) % interval == 0 &&
                this.handleBootstrapping(colony),
        );
        interval = Memory.settings.intervals.handleOutpostDefense;
        _.forEach(allColonies, (colony) => this.handleOutpostDefense(colony));
        // _.forEach(allColonies, colony => this.handleStrongholds(colony));
        interval = Memory.settings.intervals.handleColonyInvasions;
        _.forEach(
            allColonies,
            (colony) =>
                (Game.time + colony.id) % interval == 0 &&
                this.handleColonyInvasions(colony),
        );
        interval = Memory.settings.intervals.handleNukeResponse;
        _.forEach(
            allColonies,
            (colony) =>
                (Game.time + colony.id) % interval == 0 &&
                this.handleNukeResponse(colony),
        );
        if (Game.time % 100 == 67) {
            _.forEach(allColonies, (colony) =>
                this.handleUnkillableStrongholds(colony),
            );
        }
        if (
            Memory.settings.powerCollection.enabled &&
            Game.cpu.bucket > Memory.settings.bucketThresholds.powerCollection
        ) {
            _.forEach(allRooms, (room) => this.handlePowerMining(room));
        }
        if (
            Memory.settings.autoAttack.enable &&
            Game.cpu.bucket > Memory.settings.bucketThresholds.autoAttack
        ) {
            _.forEach(allRooms, (room) => this.handleAutoAttack(room));
        }
        if (
            Memory.settings.autoPoison.enabled &&
            canClaimAnotherRoom() &&
            Game.cpu.bucket > Memory.settings.bucketThresholds.autoPoison
        ) {
            if (p(0.05)) this.handleAutoPoisoning();
        }
        if (getAutonomyLevel() > Autonomy.Manual) {
            _.forEach(allColonies, (colony) => {
                if (
                    Game.time % Overseer_1.settings.outpostCheckFrequency ==
                    2 * colony.id
                ) {
                    this.handleNewOutposts(colony);
                }
                // Place pioneer directives in case the colony doesn't have a spawn for some reason
                if (
                    Game.time % 25 == 0 &&
                    colony.spawns.length == 0 &&
                    !DirectiveClearRoom.isPresent(colony.pos) &&
                    !DirectivePoisonRoom.isPresent(colony.pos)
                ) {
                    // verify that there are no spawns (not just a caching glitch)
                    if (colony.room.find(FIND_MY_SPAWNS).length == 0) {
                        const pos = Pathing.findPathablePosition(
                            colony.room.name,
                        );
                        DirectiveColonize.createIfNotPresent(pos, 'room');
                    }
                }
            });
        }
    }
    // AutoAttack =================================================================================================
    handleAutoAttack(room) {
        // TODO: clean up
        if (
            room.my ||
            !room.controller ||
            (room.controller &&
                (room.controller.safeMode ||
                    room.controller.level == 0 ||
                    room.controller.level >= 6)) ||
            Memory.settings.allies.indexOf(
                _.get(room.controller, ['owner', 'username']),
            ) >= 0 ||
            Memory.settings.autoAttack.autoAttackWhiteList.indexOf(room.name) >=
                0 ||
            Game.map.getRoomStatus(room.name).status != 'normal'
        ) {
            return;
        }
        let sendPairs = false;
        let sendControllerAttack = false;
        let sendOutpostDefense = false;
        const hasSpawn = _.first(
            room
                .find(FIND_STRUCTURES)
                .filter((s) => s.structureType == STRUCTURE_SPAWN),
        );
        if (
            hasSpawn != undefined &&
            !DirectivePairDestroy.isPresent(hasSpawn.pos)
        ) {
            sendPairs = true;
        } else if (room.controller.pos.availableNeighbors(true).length > 0) {
            if (!DirectiveControllerAttack.isPresent(room.controller.pos)) {
                sendControllerAttack = true;
            }
            if (
                room.hostiles.length > 0 &&
                !DirectiveOutpostDefense.isPresent(room.controller.pos)
            ) {
                sendOutpostDefense = true;
            }
        }
        if (sendPairs || sendControllerAttack || sendOutpostDefense) {
            const colonies = getAllColonies().filter(
                (colony) => colony.level > 6,
            );
            const colony = minBy(colonies, (c) => {
                const ret = Game.map.findRoute(c.name, room.name);
                if (ret != -2 && ret.length < 12) {
                    return ret.length;
                } else {
                    return Infinity;
                }
            });
            if (colony) {
                const route = Game.map.findRoute(colony.room, room);
                if (sendPairs && route != -2 && route.length <= 12) {
                    Game.notify(
                        `Found enemy spawning in range ${route.length}, sending pairs to ${room}`,
                    );
                    DirectivePairDestroy.create(hasSpawn.pos, {
                        name: 'AutoPD' + room.name + '_' + colony.name,
                    });
                    return;
                }
                if (sendControllerAttack && route != -2 && route.length <= 8) {
                    Game.notify(
                        `Found enemy controller in range ${route.length}, sending AttackControllers to ${room}`,
                    );
                    DirectiveControllerAttack.create(room.controller.pos, {
                        name: 'AutoCA' + room.name + '_' + colony.name,
                    });
                    return;
                }
                if (sendOutpostDefense && route != -2 && route.length <= 12) {
                    Game.notify(
                        `Found enemy controller with hostile creeps in range ${route.length}, sending OutpostDefense! to ${room}`,
                    );
                    DirectiveOutpostDefense.create(room.controller.pos, {
                        name: 'AutoOD' + room.name + '_' + colony.name,
                    });
                    return;
                }
            }
        }
        if (
            Memory.settings.autoAttack.autoAttackWatchList.indexOf(room.name) >=
                0 &&
            room.hostiles.length > 0 &&
            !DirectiveOutpostDefense.isPresent(room.controller.pos)
        ) {
            DirectiveOutpostDefense.create(room.controller.pos, {
                name: 'WatchDog_' + room.name,
            });
        }
    }
    // Harass Response =================================================================================================
    handleUnkillableStrongholds(colony) {
        const suspensionDuration = 5000;
        for (const room of colony.outposts) {
            if (
                Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER &&
                room.invaderCore &&
                room.invaderCore.level > 3
            ) {
                const roomDirectives = Directive.find(room.flags);
                for (const directive of roomDirectives) {
                    for (const name in directive.overlords) {
                        directive.overlords[name].suspendFor(
                            suspensionDuration,
                        );
                    }
                }
                if (colony.isRoomActive(room.name)) {
                    log.notify(
                        `Disabling outpost ${room.print} due to Stronghold presence`,
                    );
                }
                colony.suspendOutpost(
                    room.name,
                    OutpostDisableReason.inactiveStronghold,
                    suspensionDuration,
                );
            }
        }
    }
    // Safe mode condition =============================================================================================
    handleSafeMode(colony) {
        if (colony.stage == ColonyStage.Larva && onPublicServer()) {
            return;
        }
        // Safe mode activates when there are dangerous player hostiles that can reach the spawn
        const criticalStructures = _.compact([
            ...colony.spawns,
            colony.storage,
            colony.terminal,
        ]);
        for (const structure of criticalStructures) {
            if (
                structure.hits < structure.hitsMax &&
                structure.pos.findInRange(
                    colony.room.dangerousPlayerHostiles,
                    2,
                ).length > 0
            ) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(
                            colony.terminal.pos,
                            'room',
                        );
                    }
                } else {
                    return;
                }
            }
        }
        const firstHostile = _.first(colony.room.dangerousPlayerHostiles);
        if (firstHostile && colony.spawns[0]) {
            const barriers = _.map(
                colony.room.barriers,
                (barrier) => barrier.pos,
            );
            if (
                Pathing.isReachable(
                    firstHostile.pos,
                    colony.spawns[0].pos,
                    barriers,
                )
            ) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(
                            colony.terminal.pos,
                            'room',
                        );
                    }
                } else {
                    return;
                }
            }
        }
    }
    // Operation =======================================================================================================
    run() {
        Stats.profile('overseer.directives', () => {
            for (const directive of this.directives) {
                directive.run();
            }
        });
        Stats.profile('overseer.overlords', () => {
            const names = this.overlords.reduce((store, overlord) => {
                const name = overlord.name;
                if (!store.hasOwnProperty(name)) {
                    store[name] = {
                        name,
                        count: 1,
                    };
                }
                store[name].count++;
                return store;
            }, {});
            for (const overlordName of Object.values(names)) {
                const overlords = this.overlords.filter(
                    (overlord) => overlord.name == overlordName.name,
                );
                Stats.profileWithCount(
                    `overlord.${overlordName.name}`,
                    () => {
                        for (const overlord of overlords) {
                            if (!overlord.isSuspended) {
                                if (overlord.profilingActive) {
                                    const start = Game.cpu.getUsed();
                                    this.try(() => overlord.run());
                                    overlord.memory['S' /* STATS */].cpu +=
                                        Game.cpu.getUsed() - start;
                                } else {
                                    this.try(() => overlord.run());
                                }
                            }
                        }
                    },
                    overlordName.count,
                );
            }
        });
        Stats.profile('overseer.colonychecks', () => {
            for (const colony of getAllColonies()) {
                this.handleSafeMode(colony);
            }
        });
        Stats.profile('overseer.placeDirectives', () => {
            this.placeDirectives();
        });
    }
    getCreepReport(colony) {
        const roleOccupancy = {};
        for (const overlord of this.overlordsByColony[colony.name]) {
            for (const role in overlord.creepUsageReport) {
                const report = overlord.creepUsageReport[role];
                if (report == undefined) {
                    if (Game.time % 100 == 0) {
                        log.info(
                            `Role ${role} is not reported by ${overlord.ref}!`,
                        );
                    }
                } else {
                    if (roleOccupancy[role] == undefined) {
                        roleOccupancy[role] = [0, 0];
                    }
                    roleOccupancy[role][0] += report[0];
                    roleOccupancy[role][1] += report[1];
                }
            }
        }
        // let padLength = _.max(_.map(_.keys(roleOccupancy), str => str.length)) + 2;
        const roledata = [];
        for (const role in roleOccupancy) {
            const [current, needed] = roleOccupancy[role];
            // if (needed > 0) {
            // 	stringReport.push('| ' + `${role}:`.padRight(padLength) +
            // 					  `${Math.floor(100 * current / needed)}%`.padLeft(4));
            // }
            roledata.push([role, `${current}/${needed}`]);
        }
        return roledata;
    }
    visuals() {
        for (const directive of this.directives) {
            directive.visuals();
        }
        for (const overlord of this.overlords) {
            overlord.visuals();
        }
        this.notifier.visuals();
        // for (let colony of this.colonies) {
        // 	this.drawCreepReport(colony);
        // }
    }
});
Overseer.settings = {
    outpostCheckFrequency: onPublicServer() ? 250 : 100,
};
Overseer = Overseer_1 = __decorate([profile], Overseer);

const CHECK_EXPANSION_FREQUENCY = 1000;
const UNOWNED_MINERAL_BONUS = 100;
const CATALYST_BONUS = 75;
const MAX_SCORE_BONUS = _.sum([UNOWNED_MINERAL_BONUS, CATALYST_BONUS]);
const TOO_CLOSE_PENALTY = 100;
const defaultExpansionPlannerMemory = () => ({});
let ExpansionPlanner = class ExpansionPlanner {
    constructor() {
        this.memory = Mem.wrap(
            Memory,
            'expansionPlanner',
            defaultExpansionPlannerMemory,
        );
    }
    refresh() {
        this.memory = Mem.wrap(
            Memory,
            'expansionPlanner',
            defaultExpansionPlannerMemory,
        );
    }
    handleExpansion() {
        // return for now
        const allColonies = getAllColonies();
        // If you already have max number of colonies, ignore
        // disable the planner for the moment
        if (allColonies.length >= Math.min(Game.gcl.level, MAX_OWNED_ROOMS)) {
            return;
        }
        // If you are on shard3, limit to 3 owned rooms // TODO: use CPU-based limiting metric
        if (Game.shard.name == 'shard3') {
            if (allColonies.length >= SHARD3_MAX_OWNED_ROOMS) {
                return;
            }
        }
        const roomName = this.chooseNextColonyRoom();
        if (roomName) {
            const pos = Pathing.findPathablePosition(roomName);
            DirectiveColonize.createIfNotPresent(pos, 'room');
            log.notify(
                `Room ${roomName} selected as next colony! Creating colonization directive.`,
            );
        }
    }
    chooseNextColonyRoom() {
        // Generate a list of possible colonies to expand from based on level and whether they are already expanding
        // let possibleIncubators: Colony[] = []; // TODO: support incubation
        const possibleColonizers = [];
        for (const colony of getAllColonies()) {
            // if (colony.level >= DirectiveIncubate.requiredRCL
            // 	&& _.filter(colony.flags, flag => DirectiveIncubate.filter(flag)).length == 0) {
            // 	possibleIncubators.push(colony);
            // }
            if (
                colony.level >= DirectiveColonize.requiredRCL &&
                _.filter(colony.flags, (flag) => DirectiveColonize.filter(flag))
                    .length == 0
            ) {
                possibleColonizers.push(colony);
            }
        }
        const possibleBestExpansions = _.compact(
            _.map(possibleColonizers, (col) =>
                this.getBestExpansionRoomFor(col),
            ),
        );
        log.debug(JSON.stringify(possibleBestExpansions));
        const bestExpansion = maxBy(
            possibleBestExpansions,
            (choice) => choice.score,
        );
        if (bestExpansion) {
            log.alert(
                `Next expansion chosen: ${bestExpansion.roomName} with score ${bestExpansion.score}`,
            );
            return bestExpansion.roomName;
        } else {
            log.alert(`No viable expansion rooms found!`);
        }
    }
    getBestExpansionRoomFor(colony) {
        const allColonyRooms = _.zipObject(
            _.map(getAllColonies(), (col) => [col.room.name, true]),
        );
        const allOwnedMinerals = _.map(
            getAllColonies(),
            (col) => col.room.mineral.mineralType,
        );
        let bestRoom = '';
        let bestScore = -Infinity;
        for (const roomName in colony.memory.expansionData.possibleExpansions) {
            let score =
                colony.memory.expansionData.possibleExpansions[roomName];
            if (typeof score != 'number') continue;
            // Compute modified score
            if (score + MAX_SCORE_BONUS > bestScore) {
                // Is the room too close to an existing colony?
                const range2Rooms = Cartographer.findRoomsInRange(
                    roomName,
                    MIN_EXPANSION_DISTANCE,
                );
                if (
                    _.any(range2Rooms, (roomName) => allColonyRooms[roomName])
                ) {
                    continue; // too close to another colony
                }
                const range3Rooms = Cartographer.findRoomsInRange(
                    roomName,
                    MIN_EXPANSION_DISTANCE + 1,
                );
                if (
                    _.any(range3Rooms, (roomName) => allColonyRooms[roomName])
                ) {
                    score -= TOO_CLOSE_PENALTY;
                }
                // Are there powerful hostile rooms nearby?
                const adjacentRooms = Cartographer.findRoomsInRange(
                    roomName,
                    1,
                );
                if (
                    _.any(adjacentRooms, (roomName) =>
                        Pathing.shouldAvoid(roomName),
                    )
                ) {
                    continue;
                }
                // Reward new minerals and catalyst rooms
                const mineralType = Memory.rooms[roomName]['m' /* MINERAL */]
                    ? Memory.rooms[roomName]['m' /* MINERAL */][
                          't' /* MINERALTYPE */
                      ]
                    : undefined;
                if (mineralType) {
                    if (!allOwnedMinerals.includes(mineralType)) {
                        score += UNOWNED_MINERAL_BONUS;
                    }
                    if (mineralType == RESOURCE_CATALYST) {
                        score += CATALYST_BONUS;
                    }
                }
                // Update best choices
                if (
                    score > bestScore &&
                    RoomIntel.getRoomStatus(roomName).status ===
                        RoomIntel.getMyZoneStatus()
                ) {
                    bestScore = score;
                    bestRoom = roomName;
                }
            }
        }
        if (bestRoom != '') {
            return { roomName: bestRoom, score: bestScore };
        }
    }
    init() {}
    run() {
        if (
            Game.time % CHECK_EXPANSION_FREQUENCY == 17 &&
            getAutonomyLevel() == Autonomy.Automatic
        ) {
            this.handleExpansion();
        }
    }
};
ExpansionPlanner = __decorate([assimilationLocked, profile], ExpansionPlanner);

// javascript-obfuscator:disable
let _Overmind =
    // tslint:disable-next-line:class-name
    class _Overmind {
        constructor() {
            this.memory = Memory.Overmind;
            this.overseer = new Overseer();
            this.shouldBuild = true;
            this.expiration = Game.time + NEW_OVERMIND_INTERVAL;
            this.cache = new GameCache();
            this.colonies = {};
            this.suspendedColonies = [];
            this.suppressedColonies = [];
            this.directives = {};
            this.zerg = {};
            this.powerZerg = {};
            this.overlords = {};
            this.spawnGroups = {};
            this.colonyMap = {};
            this.terminalNetwork = new TerminalNetworkV2();
            global.terminalNetwork = this.terminalNetwork;
            this.tradeNetwork = new TraderJoe();
            global.tradeNetwork = this.tradeNetwork;
            this.expansionPlanner = new ExpansionPlanner();
            this.roomIntel = new RoomIntel();
            this.exceptions = [];
        }

        /* Global instantiation of Overmind object; run once every global refresh */
        build() {
            log.debug(`Rebuilding Overmind object!`);
            this.cache.build();
            // Register all colonies and instantiate their overlords
            this.registerColonies();
            // Register directives and instantiate their overlords; must be done AFTER colonies
            this.registerDirectives();
            _.forEach(this.colonies, (colony) => colony.spawnMoarOverlords());
            _.forEach(this.directives, (directive) =>
                directive.spawnMoarOverlords(),
            );
            this.shouldBuild = false;
        }
        /* Refresh the state of the Overmind; run at the beginning of every tick */
        refresh() {
            this.shouldBuild = true; // assume refresh will be unsuccessful
            // Refresh constructor-phase objects
            
            this.memory = Memory.Overmind;
            this.exceptions = [];
            //cpuProfiler.start('this.cache.refresh()');
            this.cache.refresh();
            //cpuProfiler.end('this.cache.refresh()');
            
            //cpuProfiler.start('this.overseer.refresh()');
            this.overseer.refresh();
            //cpuProfiler.end('this.overseer.refresh()');
            
            //cpuProfiler.start('terminalNetwork.refresh()');
            this.terminalNetwork.refresh();
            //cpuProfiler.end('terminalNetwork.refresh()');
            
            //cpuProfiler.start('this.tradeNetwork.refresh()');
            this.tradeNetwork.refresh();
            //cpuProfiler.end('this.tradeNetwork.refresh()');
            
            //cpuProfiler.start('this.expansionPlanner.refresh()');
            this.expansionPlanner.refresh();
            //cpuProfiler.end('this.expansionPlanner.refresh()');
            
            // Refresh build-phase objects
            //cpuProfiler.start('this.refreshColonies.refresh()');
            this.refreshColonies();
            //cpuProfiler.end('this.refreshColonies.refresh()');
            
            //cpuProfiler.start('this.refreshDirectives.refresh()');
            this.refreshDirectives();
            //cpuProfiler.end('this.refreshDirectives.refresh()');
            
            for (const ref in this.overlords) {
                this.overlords[ref].refresh();
            }
            for (const ref in this.spawnGroups) {
                this.spawnGroups[ref].refresh();
            }
            this.shouldBuild = false; // refresh successful
            
        }
        try(callback, identifier) {
            {
                try {
                    callback();
                } catch (e) {
                    if (identifier) {
                        e.name =
                            `Caught unhandled exception at ${
                                '' + callback
                            } (identifier: ${identifier}): \n` +
                            e.name +
                            '\n' +
                            e.stack;
                    } else {
                        e.name =
                            `Caught unhandled exception at ${
                                '' + callback
                            }: \n` +
                            e.name +
                            '\n' +
                            e.stack;
                    }
                    this.exceptions.push(e);
                }
            }
        }
        handleExceptions() {
            if (this.exceptions.length == 0) {
                return;
            } else {
                log.warning(
                    `Exceptions present this tick! Rebuilding Overmind object in next tick.`,
                );
                Memory.stats.persistent.lastErrorTick = Game.time;
                this.shouldBuild = true;
                this.expiration = Game.time;
                if (this.exceptions.length == 1) {
                    throw _.first(this.exceptions);
                } else {
                    for (const e of this.exceptions) {
                        log.throw(e);
                    }
                    const error = new Error(
                        'Multiple exceptions caught this tick!',
                    );
                    error.stack = _.map(this.exceptions, (e) => e.name).join(
                        '\n',
                    );
                    throw error;
                }
            }
        }
        /* Instantiate a new colony for each owned rom */
        registerColonies() {
            const colonyOutposts = {}; // key: lead room, values: outposts[]
            this.colonyMap = {};
            // Register colonies to their outposts
            const flagsByRoom = _.groupBy(
                this.cache.outpostFlags,
                (flag) => flag.memory['C' /* COLONY */],
            );
            for (const name in Game.rooms) {
                const room = Game.rooms[name];
                if (room.my) {
                    const colonyMemory = Memory.colonies[name];
                    if (colonyMemory && colonyMemory.suspend) {
                        this.suspendedColonies.push(name);
                        continue;
                    }
                    if (room.flags) {
                        if (
                            room.flags.some(
                                (flag) =>
                                    DirectiveClearRoom.filter(flag) ||
                                    DirectivePoisonRoom.filter(flag),
                            )
                        ) {
                            this.suppressedColonies.push(name);
                            continue;
                        }
                        colonyOutposts[name] = _.map(
                            flagsByRoom[name],
                            (flag) => (flag.memory.setPos || flag.pos).roomName,
                        );
                    }
                    this.colonyMap[name] = name;
                }
            }
            // Register outposts to their colonies
            for (const colonyName in colonyOutposts) {
                for (const outpostName of colonyOutposts[colonyName]) {
                    this.colonyMap[outpostName] = colonyName;
                }
            }
            // Initialize the Colonies and pass each one its assigned creeps
            let id = 0;
            for (const name in colonyOutposts) {
                try {
                    this.colonies[name] = new Colony(
                        id,
                        name,
                        colonyOutposts[name],
                    );
                } catch (e) {
                    e.name =
                        `Caught unhandled exception instantiating colony ${name}: \n` +
                        e.name;
                    this.exceptions.push(e);
                }
                id++;
            }
        }
        refreshColonies() {
            for (const name in this.colonies) {
                // this.colonies[name].refresh();
                try {
                    //cpuProfiler.start(name);
                    this.colonies[name].refresh();
                    //cpuProfiler.end(name);
                } catch (e) {
                    e.name =
                        `Caught unhandled exception refreshing colony ${name}: \n` +
                        e.name;
                    this.exceptions.push(e);
                }
            }
        }
        /* Wrap each flag in a color coded wrapper */
        registerDirectives(spawnOverlords = false) {
            // Create a directive for each flag (registration takes place on construction)
            for (const name in Game.flags) {
                if (this.directives[name]) {
                    // skip existing directives
                    continue;
                }
                const colonyName = Game.flags[name].memory['C' /* COLONY */];
                if (colonyName) {
                    const colonyMemory = Memory.colonies[colonyName];
                    if (colonyMemory && colonyMemory.suspend) {
                        continue; // don't make directive if colony is suspended
                    }
                }
                const directive = DirectiveWrapper(Game.flags[name]);
                const directiveExists = !!this.directives[name];
                if (directive && directiveExists && spawnOverlords) {
                    directive.spawnMoarOverlords();
                }
                if (
                    !directive &&
                    !SUPPRESS_INVALID_DIRECTIVE_ALERTS &&
                    Game.time % 10 == 0
                ) {
                    log.alert(
                        `Flag [${name} @ ${Game.flags[name].pos.print}] does not match ` +
                            `a valid directive color code! (Refer to /src/directives/initializer.ts)` +
                            alignedNewline +
                            `Use removeErrantFlags() to remove flags which do not match a directive.`,
                    );
                }
            }
        }
        /* Refresh all directives, adding new ones for new flags */
        refreshDirectives() {
            for (const name in this.directives) {
                // this should be called first
                this.directives[name].refresh();
            }
            this.registerDirectives(true); // register any new directives that were placed since last rebuild
        }
        /* Intialize everything in pre-init phase of main loop. Does not call colony.init(). */
        init() {
            this.try(() => RoomIntel.init());
            // Initialize terminalNetwork and tradeNetwork
            
            this.try(() => this.tradeNetwork.init());
            
            this.try(() => this.terminalNetwork.init()); // zGeneral 11/4/2023 optimize CPU - disable
            
            // Initialize the overseer
            
            this.overseer.init();
            
            // Initialize each colony
            
            for (const colonyName in this.colonies) {
                //const start = Game.cpu.getUsed();
                this.try(() => this.colonies[colonyName].init(), colonyName);
                //Stats.log(
                //    `cpu.usage.${colonyName}.init`,
                //    Game.cpu.getUsed() - start,
                //);
            }
            
            // Initialize spawn groups
            for (const ref in this.spawnGroups) {
                this.try(() => this.spawnGroups[ref].init(), ref);
            }
            // Initialize expansionPlanner
            // this.try(() => this.expansionPlanner.init()); // zGeneral 11/4/2023 optimize CPU - disable
        }
        run() {
            /*if (Game.time % 3 == 0) {
            // This stuff has been disabled by reggaemuffin :p
            IntelManagement.run();
        }*/
            Stats.profile('run.spawngroups', () => {
                // Run spawn groups
                for (const ref in this.spawnGroups) {
                    this.try(() => this.spawnGroups[ref].run(), ref);
                }
            });
            // Run the overseer
            Stats.profile('run.overseer', () => {
                this.overseer.run();
            });
            // Run all colonies
            Stats.profile('run.colonies', () => {
                for (const colonyName in this.colonies) {
                    this.try(() => this.colonies[colonyName].run(), colonyName);
                }
            });
            // Run all contracts
            /*Stats.profile('run.contracts', () => {
            if (MY_USERNAME == MUON) { // This ensures that my contracts don't run by default on other people's accounts
                for (const contract of AllContracts) {
                    this.try(() => contract.run());
                }
            }
        });*/
            // Run terminal network
            Stats.profile('run.terminals', () => {
                // this.try(() => this.terminalNetwork.run()); // zGeneral 11/4/2023 optimize CPU - disable
            });
            // Run trade network
            Stats.profile('run.trade', () => {
                // this.try(() => this.tradeNetwork.run()); // zGeneral 11/4/2023 optimize CPU - disable
            });
            // Run expansionPlanner
            Stats.profile('run.expansionplanner', () => {
                // this.try(() => this.expansionPlanner.run()); zGeneral 11/4/2023 optimize CPU - disable
            });
            // Run room intel
            Stats.profile('run.roomintel', () => {
                this.try(() => RoomIntel.run()); // this should be at end
            });
            // This stuff has been disabled by reggaemuffin :p
            // Assimilator.run();
            Stats.profile('run.intershard', () => {
                // this.try(() => this.interShard()); zGeneral 11/4/2023 optimize CPU - disable
            });
        }
        interShard() {
            if (Object.keys(this.colonies).length === 0) {
                const waypoint = Object.values(this.directives)[0];
                if (waypoint) {
                    const overlord = Object.values(waypoint.overlords)[0];
                    if (overlord) {
                        for (const creepName in Game.creeps) {
                            const creep = Game.creeps[creepName];
                            if (!creep.memory.role) {
                                log.info(
                                    `Reassign creep ${creepName}: ${creep.pos} to overlord ${overlord.print}`,
                                );
                                const creepMemory = {
                                    ['C' /* COLONY */]: overlord.colony.name,
                                    ['O' /* OVERLORD */]: overlord.ref,
                                    role: creepName.split('_')[0],
                                    task: null,
                                    data: {
                                        // rarely-changed data about the creep
                                        origin: overlord.colony.name,
                                    },
                                };
                                creep.memory = creepMemory;
                            }
                        }
                    }
                }
            }
        }
        postRun() {
            // Run version updater
            this.try(() => VersionUpdater.run());
            // Run segmenter
            this.try(() => Segmenter.run());
            // Handle exceptions
            this.handleExceptions();
        }
        visuals() {
            if (Game.cpu.bucket > Memory.settings.bucketThresholds.visuals) {
                // Draw global visuals
                Visualizer.visuals();
                // Add notifications for outdated version
                // This stuff has been disabled by reggaemuffin :p
                /*if (VersionUpdater.memory.newestVersion) {
                const newestVersion = VersionUpdater.memory.newestVersion;
                if (VersionUpdater.isVersionOutdated(newestVersion)) {
                    this.overseer.notifier.alert(`[!] Update available: ${__VERSION__} → ${newestVersion}`,
                        undefined, -1);
                }
            }*/
                // Draw overseer visuals
                this.overseer.visuals();
                // Draw colony visuals
                for (const colonyName in this.colonies) {
                    this.colonies[colonyName].visuals();
                }
                RoomIntel.visuals();
            } else {
                if (Game.time % 10 == 0) {
                    log.info(
                        `CPU bucket is too low (${Game.cpu.bucket} < ${Memory.settings.bucketThresholds.visuals}) - skip rendering visuals.`,
                    );
                }
            }
        }
    };
_Overmind = __decorate(
    [
        profile,
        assimilationLocked,
        // tslint:disable-next-line:class-name
    ],
    _Overmind,
);
var _Overmind$1 = _Overmind;
// Version updater =====================================================================================================
class VersionUpdater {
    static run() {
        // This stuff has been disabled by reggaemuffin :p
    }
}

/* tslint:disable:no-string-literal */
/**
 * The VersionMigration class contains ad-hoc methods for migrating older versions of Overmind to newer versions
 */
class VersionMigration {
    static run() {
        /*
        if (!this.memory.versions['02Xto03X']) {
            this.migrate_02X_03X();
        }
        if (!this.memory.versions['03Xto04X']) {
            this.migrate_03X_04X();
        }
        if (!this.memory.versions['04Xto05X']) {
            this.migrate_04X_05X();
        }
        if (!this.memory.versions['04Xto05X_part2']) {
            this.migrate_04X_05X_part2();
        }
        if (!this.memory.versions['04Xto05X_part3']) {
            this.migrate_04X_05X_part3();
        }
        */
        if (!this.memory.versions['05Xto051']) {
            this.migrate_050_051();
        }
        if (!this.memory.versions['05Xto051_part2']) {
            this.migrate_050_051_part2();
        }
        if (!this.memory.versions['05Xto051_part3']) {
            this.migrate_050_051_part3();
        }
        if (!this.memory.versions['05Xto051_part4']) {
            this.migrate_050_051_part4();
        }
        if (!this.memory.versions['051to052']) {
            this.migrate_051_052();
        }
        if (!this.memory.versions['052to053']) {
            this.migrate_052_053();
        }
        if (!this.memory.versions['053to06X_part1']) {
            this.migrate_053_06X_part1();
        }
        if (!this.memory.versions['053to06X_part2']) {
            this.migrate_053_06X_part2();
        }
        if (!this.memory.versions['053to06X_part3']) {
            this.migrate_053_06X_part3();
        }
        if (!this.memory.versions['053to06X_part4']) {
            this.migrate_053_06X_part4();
        }
        if (!this.memory.versions['053to06X_part5']) {
            this.migrate_053_06X_part5();
        }
    }
    static get memory() {
        return Mem.wrap(Memory.Overmind, 'versionMigrator', () => ({
            versions: {},
        }));
    }
    /*
    static migrate_02X_03X() {
        // This technically won't run correctly because it gets run only on global reset, but no one is using v0.2.x
        // anymore anyway, so I don't feel the need to maintain support for this function
        let allColoniesUpdated = true;
        let i = 0;
        for (let name in Memory.colonies) {
            let rpMemory = Memory.colonies[name].roomPlanner;
            let lastBuilt = rpMemory.lastGenerated;
            // Reboot colony room planners one at a time every 3 ticks
            if (!lastBuilt) {
                allColoniesUpdated = false;
                if (Game.time % 100 == 3 * i) {
                    // Delete all white/white routing hints from memory
                    rpMemory.savedFlags = _.filter(rpMemory.savedFlags, (flag: {secondaryColor: number}) =>
                        flag.secondaryColor != COLOR_WHITE);
                    rpMemory.active = true;
                    log.alert(`Version migration: rebooting roomPlanner for colony ${name}!`);
                } else if (Game.time % 100 == 3 * i + 1) {
                    colony.roomPlanner.finalize(true);
                }
            }
        }
        if (allColoniesUpdated) {
            this.memory.versions['02Xto03X'] = true;
            log.alert(`Version migration from 0.2.x -> 0.3.x completed successfully.`);
        }
    }

    static migrate_03X_04X() {
        // Update creep memory
        for (let i in Memory.creeps) {
            // Migrate all old-style overlord references to new ones
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split(':')[0];
                if (hcName == 'commandCenter'
                    || hcName == 'hatchery'
                    || hcName == 'evolutionChamber'
                    || hcName == 'miningSite'
                    || hcName == 'upgradeSite') {
                    let id = Memory.creeps[i].overlord!.split(':')[1];
                    let roomObject = Game.getObjectById(id) as RoomObject | undefined;
                    if (roomObject) {
                        let overlordName = Memory.creeps[i].overlord!.split(':')[2];
                        Memory.creeps[i].overlord = hcName + '@' + roomObject.pos.name + ':' + overlordName;
                    }
                }
            }
            // Change all miner roles to drone roles
            if (Memory.creeps[i].role == 'miner') {
                Memory.creeps[i].role = 'drone';
            }
        }
        // Delete old-style miningSite overlords from memory
        OvermindConsole.deepCleanMemory();
        this.memory.versions['03Xto04X'] = true;
        log.alert(`Version migration from 0.3.x -> 0.4.x completed successfully.`);
    }

    static migrate_04X_05X() {
        let migrateClusterNames = ['commandCenter', 'evolutionChamber', 'hatchery', 'upgradeSite'];
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split('@')[0];
                if (migrateClusterNames.includes(hcName)) {
                    let overlordName = _.last(Memory.creeps[i].overlord!.split(':'));
                    if (overlordName == 'hatchery') {
                        overlordName = 'supply';
                    }
                    let colonyName = Memory.creeps[i].colony;
                    Memory.creeps[i].overlord = hcName + '@' + colonyName + ':' + overlordName;
                }
            }
        }
        for (let i in Memory.rooms) {
            delete (<any>Memory.rooms[i]).tick;
            delete (<any>Memory.rooms[i]).score;
        }
        // Change to new signature
        let oldSignature = '[Overmind]';
        if ((<any>Memory).signature && (<any>Memory).signature.includes(oldSignature)) {
            (<any>Memory).signature = (<any>Memory).signature.replace(oldSignature, DEFAULT_OVERMIND_SIGNATURE);
        }
        this.memory.versions['04Xto05X'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 1) completed successfully.`);
    }

    static migrate_04X_05X_part2() {
        // Copy old memory to new memory locations
        if (Memory.signature) {
            Memory.settings.signature = (<any>Memory).signature;
        }
        delete (<any>Memory).signature;
        delete (<any>Memory).bot;
        delete (<any>Memory).log;
        delete (<any>Memory).autoclaim;
        this.memory.versions['04Xto05X_part2'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 2) completed successfully.`);
    }

    static migrate_04X_05X_part3() {
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let ref = Memory.creeps[i].overlord as string;
                let n = ref.lastIndexOf(':');
                ref = ref.slice(0, n) + ref.slice(n).replace(':', '>');
                Memory.creeps[i].overlord = ref;
            }
        }
        this.memory.versions['04Xto05X_part3'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 3) completed successfully.`);
    }

    */
    static migrate_050_051() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const id in Game.structures) {
            const s = Game.structures[id];
            if (s.structureType == STRUCTURE_LINK) {
                const isCommandCenterLink =
                    s.pos.findInRange(
                        _.compact([s.room.storage, s.room.terminal]),
                        2,
                    ).length > 0;
                const isHatcheryLink =
                    s.pos.findInRange(s.room.spawns, 2).length > 0;
                if (!isCommandCenterLink && !isHatcheryLink) {
                    s.destroy();
                }
            }
        }
        let count = 0;
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (
                creep.memory.role == 'drone' &&
                creep.memory.overlord &&
                creep.memory.overlord.includes('miningSite')
            ) {
                creep.suicide();
                count++;
            }
        }
        this.memory.versions['05Xto051'] = true;
        log.alert(`Genocide complete: suicided ${count} innocent drones.`);
        log.alert(
            `Version migration from 0.5.0 -> 0.5.1 (part 1) completed successfully.`,
        );
    }
    static migrate_050_051_part2() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == 'reserver') {
                creep.memory.role = 'infestor';
            } else if (creep.memory.role == 'guard') {
                creep.memory.role = 'broodling';
            }
        }
        this.memory.versions['05Xto051_part2'] = true;
        log.alert(
            `Version migration from 0.5.0 -> 0.5.1 (part 2) completed successfully.`,
        );
    }
    static migrate_050_051_part3() {
        if (Memory.assimilator && Memory.assimilator.users) {
            delete Memory.assimilator.users;
        }
        this.memory.versions['05Xto051_part3'] = true;
        log.alert(
            `Version migration from 0.5.0 -> 0.5.1 (part 3) completed successfully.`,
        );
    }
    static migrate_050_051_part4() {
        const protectedKeywords = [
            'suspendUntil',
            'amount',
            'created',
            'persistent',
            'setPosition',
            'rotation',
            'colony',
            'parent',
            'pathing',
            'stats',
            'safeTick',
            'enhanced',
            'persistent',
            'recoveryWaypoint',
            'totalResources',
            'maxPathLength',
            'maxLinearRange',
        ];
        for (const name in Memory.flags) {
            for (const prop in Memory.flags[name]) {
                if (!protectedKeywords.includes(prop)) {
                    delete Memory.flags[name][prop];
                }
            }
        }
        this.memory.versions['05Xto051_part4'] = true;
        log.alert(
            `Version migration from 0.5.0 -> 0.5.1 (part 4) completed successfully.`,
        );
    }
    static migrate_051_052() {
        if (__VERSION__ == '0.5.2') {
            for (const name in Game.creeps) {
                if (name.includes('mutalisk')) {
                    Game.creeps[name].suicide();
                }
            }
        }
        this.memory.versions['051to052'] = true;
        log.alert(
            `Version migration from 0.5.1 -> 0.5.2 completed successfully.`,
        );
    }
    static migrate_052_053() {
        // Reformat flag and harvest directive memory
        const newFlagKeys = {
            created: 'T' /* TICK */,
            expiration: 'X' /* EXPIRATION */,
            overlord: 'O' /* OVERLORD */,
            colony: 'C' /* COLONY */,
        };
        for (const name in Memory.flags) {
            // Replace old keys with new ones
            Memory.flags[name] = _.mapKeys(
                Memory.flags[name],
                function (value, key) {
                    return newFlagKeys[key] || key;
                },
            );
            // Special opertions for harvest flags
            if (name.includes('harvest:')) {
                const pathing = Memory.flags[name].pathing;
                if (pathing) {
                    Memory.flags[name]['P'] = {
                        D: pathing.distance,
                        X: pathing.expiration,
                    };
                    delete Memory.flags[name].pathing;
                }
                Memory.flags[name]['u'] = Memory.flags[name].stats.usage;
                Memory.flags[name]['d'] = Memory.flags[name].stats.downtime;
                delete Memory.flags[name].stats;
            }
        }
        // Reformat creep memory
        const newCreepKeys = {
            overlord: 'O' /* OVERLORD */,
            colony: 'C' /* COLONY */,
        };
        for (const name in Memory.creeps) {
            // Replace old keys with new ones
            Memory.creeps[name] = _.mapKeys(
                Memory.creeps[name],
                function (value, key) {
                    return newCreepKeys[key] || key;
                },
            );
        }
        // Delete outdated colony memory properties
        for (const name in Memory.colonies) {
            for (const key in Memory.colonies[name]) {
                if (key.includes('miningSite@')) {
                    delete Memory.colonies[name][key];
                }
            }
        }
        // Delete ALL room memory
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions['052to053'] = true;
        log.alert(
            `Version migration from 0.5.2 -> 0.5.3 completed successfully.`,
        );
    }
    static migrate_053_06X_part1() {
        // Delete some old properties
        delete Memory.overseer.suspendUntil;
        // Delete ALL room memory
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions['053to06X_part1'] = true;
        log.alert(
            `Version migration from 0.5.3 -> 0.6.X part 1 completed successfully.`,
        );
    }
    static migrate_053_06X_part2() {
        // Delete some old properties
        if (Memory.Overmind.terminalNetwork) {
            delete Memory.Overmind.terminalNetwork;
        }
        // Remove all orders
        for (const id in Game.market.orders) {
            Game.market.cancelOrder(id);
        }
        this.memory.versions['053to06X_part2'] = true;
        log.alert(
            `Version migration from 0.5.3 -> 0.6.X part 2 completed successfully.`,
        );
    }
    static migrate_053_06X_part3() {
        // Remove all orders
        for (const colonyName in Memory.colonies) {
            if (Memory.colonies[colonyName].evolutionChamber) {
                delete Memory.colonies[colonyName].evolutionChamber
                    .activeReaction;
                delete Memory.colonies[colonyName].evolutionChamber
                    .reactionQueue;
                delete Memory.colonies[colonyName].evolutionChamber.status;
                delete Memory.colonies[colonyName].evolutionChamber.statusTick;
            }
        }
        this.memory.versions['053to06X_part3'] = true;
        log.alert(
            `Version migration from 0.5.3 -> 0.6.X part 3 completed successfully.`,
        );
    }
    static migrate_053_06X_part4() {
        // Remove orders for reaction intermediates
        for (const id in Game.market.orders) {
            const order = Game.market.orders[id];
            const deleteOrdersFor = [
                RESOURCE_GHODIUM,
                RESOURCE_ZYNTHIUM_KEANITE,
                RESOURCE_UTRIUM_LEMERGITE,
                RESOURCE_HYDROXIDE,
            ];
            if (deleteOrdersFor.includes(order.resourceType)) {
                Game.market.cancelOrder(id);
            }
        }
        this.memory.versions['053to06X_part4'] = true;
        log.alert(
            `Version migration from 0.5.3 -> 0.6.X part 4 completed successfully.`,
        );
    }
    static migrate_053_06X_part5() {
        // Find oldest tick we can find
        log.alert(`Fetching approximate empire age...`);
        if (MY_USERNAME == 'Muon') {
            Memory.tick = Game.time - 4461275; // oldest tick I could find
        } else {
            let oldestTick = Infinity;
            for (const name in Memory.colonies) {
                if (
                    Memory.colonies[name] &&
                    Memory.colonies[name].roomPlanner
                ) {
                    const rpmem = Memory.colonies[name].roomPlanner;
                    if (
                        rpmem.lastGenerated &&
                        rpmem.lastGenerated < oldestTick
                    ) {
                        oldestTick = rpmem.lastGenerated;
                    }
                }
            }
            for (const name in Memory.flags) {
                const fmem = Memory.flags[name];
                if (fmem.T && fmem.T < oldestTick) {
                    oldestTick = fmem.T;
                }
            }
            if (oldestTick < Infinity) {
                Memory.tick = Game.time - oldestTick;
            }
        }
        // Clean some properties we don't use anymore
        log.alert(`Cleaning memory...`);
        delete Memory.strategist;
        delete Memory.zoneRooms;
        Memory.roomIntel = {}; // reset this
        if (
            Memory.stats.persistent &&
            Memory.stats.persistent.terminalNetwork
        ) {
            delete Memory.stats.persistent.terminalNetwork.transfers;
            delete Memory.stats.persistent.terminalNetwork.costs;
        }
        const mem = Memory;
        delete mem.pathing.paths; // not used
        delete mem.pathing.weightedDistances;
        // Changes will need repathing
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep) {
                delete creep.memory._go;
            }
        }
        function derefCoords(coordName) {
            const [x, y] = coordName.split(':');
            return { x: parseInt(x, 10), y: parseInt(y, 10) };
        }
        for (const name in Memory.colonies) {
            const colmem = Memory.colonies[name];
            delete colmem.abathur; // outdated
            delete colmem.expansionData; // bugged
            log.alert(`Migrating room planner memories...`);
            // Clean room planner memory of some old shit
            const validRoomPlannerMemKeys = [
                'active',
                'relocating',
                'recheckStructuresAt',
                'bunkerData',
                'lastGenerated',
                'mapsByLevel',
                'savedFlags',
            ];
            if (colmem.roomPlanner) {
                for (const key in colmem.roomPlanner) {
                    if (!validRoomPlannerMemKeys.includes(key)) {
                        delete colmem.roomPlanner[key];
                    }
                }
            }
            // Migrate road planner to new format
            log.alert(`Migrating road planner memories...`);
            if (colmem.roadPlanner) {
                if (colmem.roadPlanner.roadLookup) {
                    const roadLookup = colmem.roadPlanner.roadLookup;
                    const roadCoordsPacked = {};
                    for (const roomName in roadLookup) {
                        const roadCoords = _.map(
                            _.keys(roadLookup[roomName]),
                            (coordName) => derefCoords(coordName),
                        );
                        roadCoordsPacked[roomName] = packCoordList(roadCoords);
                    }
                    colmem.roadPlanner.roadCoordsPacked = roadCoordsPacked;
                    delete colmem.roadPlanner.roadLookup;
                }
            }
            // Migrate barrier planner to new format
            log.alert(`Migrating barrier planner memories...`);
            if (colmem.barrierPlanner) {
                if (colmem.barrierPlanner.barrierLookup) {
                    const barrierLookup = colmem.barrierPlanner.barrierLookup;
                    const barrierCoords = _.map(
                        _.keys(barrierLookup),
                        (coordName) => derefCoords(coordName),
                    );
                    colmem.barrierPlanner.barrierCoordsPacked = packCoordList(
                        barrierCoords,
                    );
                    delete colmem.barrierPlanner.barrierLookup;
                }
            }
        }
        log.alert(`Clearing room memories...`);
        for (const roomName in Memory.rooms) {
            delete Memory.rooms[roomName];
        }
        this.memory.versions['053to06X_part5'] = true;
        log.alert(
            `Version migration from 0.5.3 -> 0.6.X part 5 completed successfully.`,
        );
    }
}

/* tslint:disable:no-eval */
const DEBUG_TIMEOUT = 1000;
const NO_COMMAND = 'No command';
const defaultDebuggerMemory = {
    username: undefined,
    enabled: false,
    expiration: 0,
    command: undefined,
    response: undefined,
};
/**
 * Debugging tool which lets me remotely debug other Overmind players' code by communicating through public memory
 * segments. Can be toggled on and off with console commands startRemoteDebugSession() and endRemoteDebugSession().
 */
class RemoteDebugger {
    constructor() {
        if (!Memory.remoteDebugger) {
            Memory.remoteDebugger = {};
        }
        _.defaultsDeep(Memory.remoteDebugger, defaultDebuggerMemory);
    }
    get memory() {
        return Memory.remoteDebugger;
    }
    /**
     * Push all commands from secret memory to public memory and clear secret memory commands
     */
    pushCommands_master() {
        Segmenter.setSegmentProperty(
            SEGMENTS.remoteDebugger,
            'command',
            this.memory.command,
        );
        if (this.memory.command) {
            log.info(`[DEBUGGER] Sending command: ${this.memory.command}`);
        }
        this.memory.command = undefined;
    }
    /**
     * Fetch the response from the debugee
     */
    fetchResponse_master() {
        const response = Segmenter.getForeignSegmentProperty('response');
        return response;
    }
    /**
     * Execute the commands you are given
     */
    fetchCommands_slave() {
        const cmd = Segmenter.getForeignSegmentProperty('command');
        if (cmd) {
            log.info(`[DEBUGGER] Executing command: ${cmd}`);
            const response = eval(cmd);
            log.info(`[DEBUGGER] Relaying response: ${response}`);
            this.memory.response = JSON.stringify(response);
        } else {
            this.memory.response = NO_COMMAND;
        }
    }
    /**
     * Push the response from the last run command
     */
    pushResponse_slave() {
        Segmenter.setSegmentProperty(
            SEGMENTS.remoteDebugger,
            'response',
            this.memory.response,
        );
        this.memory.response = undefined;
    }
    extendSession() {
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
    }
    enable() {
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(
            `[DEBUGGER] Starting remote debug session. Timeout: ${this.memory.expiration} ` +
                alignedNewline +
                `Warning: this enables remote arbitrary code execution!`,
        );
    }
    disable() {
        this.memory.enabled = false;
        this.memory.expiration = -1;
        log.info(`[DEBUGGER] Remote debugging session ended`);
    }
    connect(username) {
        this.memory.username = username;
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(
            `[DEBUGGER] Starting remote debug session with ${username}. Timeout: ${this.memory.expiration}`,
        );
    }
    cancelCommand() {
        this.memory.command = undefined;
    }
    /* Register a debug command to be sent to the user */
    debug(command) {
        this.memory.command = command;
        return `[DEBUGGER] Sending command next tick.`;
    }
    run_master() {
        if (Game.time % 2 == 0) {
            const response = this.fetchResponse_master();
            if (response && response != NO_COMMAND) {
                log.info(`[DEBUGGER] Response: ` + response);
            }
            this.pushCommands_master();
        }
    }
    run_slave() {
        if (Game.time % 2 == 1) {
            this.fetchCommands_slave();
            this.pushResponse_slave();
        }
    }
    run() {
        if (this.memory.enabled) {
            // todo: might be worth just disabling this
            // Run the debugger
            if (MY_USERNAME == MUON) {
                if (this.memory.username) {
                    Segmenter.requestSegments(SEGMENTS.remoteDebugger);
                    Segmenter.requestForeignSegment(
                        this.memory.username,
                        SEGMENTS.remoteDebugger,
                    );
                    Segmenter.markSegmentAsPublic(SEGMENTS.remoteDebugger);
                    this.run_master();
                }
            } else {
                Segmenter.requestSegments(SEGMENTS.remoteDebugger);
                Segmenter.requestForeignSegment(MUON, SEGMENTS.remoteDebugger);
                Segmenter.markSegmentAsPublic(SEGMENTS.remoteDebugger);
                this.run_slave();
            }
            if (Game.time % 20 == 0) {
                log.alert(
                    `[DEBUGGER] Remote session is still enabled! Expiration: ${this.memory.expiration}`,
                );
            }
            // Disable after timeout
            if (!this.memory.expiration || Game.time > this.memory.expiration) {
                this.disable();
            }
        }
    }
}

const AVOID_RANGE = 4;
const APPROACH_RANGE = 1;
/**
 * NeuralZerg augments CombatZerg with some additional simplified actions suitable for use in reinforcement learning
 * training scenarios
 */
let NeuralZerg = class NeuralZerg extends CombatZerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isNeuralZerg = true;
        this.isBot = creep.name.includes('_BOT');
    }
    approachHostiles() {
        const approach = _.map(this.room.hostiles, (hostile) => ({
            pos: hostile.pos,
            range: APPROACH_RANGE,
        }));
        return Movement.combatMove(this, approach, []);
    }
    avoidHostiles() {
        const avoid = _.map(this.room.hostiles, (hostile) => ({
            pos: hostile.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, [], avoid);
    }
    approachAllies() {
        const approach = _.map(this.room.creeps, (friendly) => ({
            pos: friendly.pos,
            range: APPROACH_RANGE,
        }));
        return Movement.combatMove(this, approach, []);
    }
    avoidAllies() {
        const avoid = _.map(this.room.creeps, (friendly) => ({
            pos: friendly.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, [], avoid);
    }
    maneuver(approachTargs, avoidTargs) {
        const approach = _.map(approachTargs, (targ) => ({
            pos: targ.pos,
            range: APPROACH_RANGE,
        }));
        const avoid = _.map(avoidTargs, (targ) => ({
            pos: targ.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, approach, avoid);
    }
    autoEngage(combatTarget) {
        const target = combatTarget ? [combatTarget.creep] : undefined;
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(target); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged(target);
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
    }
};
NeuralZerg = __decorate([profile], NeuralZerg);

class TrainingOpponents {
    /**
     * Simple combat behavior to train against. Every creep just chases the nearest opponent and attacks them.
     */
    static simpleCombat(zerg) {
        const closestOpponent = zerg.pos.findClosestByRange(zerg.room.hostiles);
        if (closestOpponent) {
            zerg.creep.moveTo(closestOpponent);
            zerg.attack(closestOpponent);
            zerg.rangedAttack(closestOpponent);
            zerg.heal(zerg);
        }
    }
    /**
     * Stupid combat behavior. Moves in a random direction and attacks a random target in range if combat is allowed
     */
    static stupidCombat(zerg, allowAttack = false, allowHeal = false) {
        const direction = _.random(1, 8);
        zerg.move(direction);
        if (allowAttack) {
            const meleeTarget = _.sample(
                zerg.pos.findInRange(zerg.room.hostiles, 1),
            );
            if (meleeTarget) zerg.attack(meleeTarget);
            const rangedTarget = _.sample(
                zerg.pos.findInRange(zerg.room.hostiles, 3),
            );
            if (rangedTarget) zerg.rangedAttack(rangedTarget);
        }
        if (allowHeal) {
            zerg.heal(zerg);
        }
    }
}

/*

 _____  _    _ _______  ______ _______ _____ __   _ ______
|     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
|_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
....... R E I N F O R C E M E N T   L E A R N I N G .......

*/
/**
 * The ActionParser provides a line of direct interaction for the external Python optimizers to control
 * creep actions via the Memory.reinforcementLearning object.
 */
class ActionParser {
    /**
     * Parse an individual action from its serialized format and command the actor to execute it.
     * Returns whether the action was valid.
     */
    static parseAction(actor, action, autoEngage = true) {
        const command = action[0];
        const predicate = action[1];
        const targ =
            typeof predicate == 'string' ? Game.getObjectById(predicate) : null;
        switch (command) {
            case 'move':
                actor.move(predicate);
                break;
            case 'goTo':
                if (targ) actor.goTo(targ);
                break;
            case 'attack':
                if (targ) actor.attack(targ);
                break;
            case 'rangedAttack':
                if (targ) actor.rangedAttack(targ);
                break;
            case 'rangedMassAttack':
                actor.rangedMassAttack();
                break;
            case 'heal':
                if (targ) {
                    actor.heal(targ);
                } else if (typeof predicate != 'string') {
                    actor.heal(actor);
                }
                break;
            case 'rangedHeal':
                if (targ) actor.rangedHeal(targ);
                break;
            case 'approachHostiles':
                actor.approachHostiles();
                break;
            case 'avoidHostiles':
                actor.avoidHostiles();
                break;
            case 'approachAllies':
                actor.approachAllies();
                break;
            case 'avoidAllies':
                actor.avoidAllies();
                break;
            case 'maneuver':
                const approachNames = predicate[0];
                const avoidNames = predicate[1];
                const approachTargs = _.map(
                    approachNames,
                    (name) => Game.creeps[name],
                );
                const avoidTargs = _.map(
                    avoidNames,
                    (name) => Game.creeps[name],
                );
                actor.maneuver(approachTargs, avoidTargs);
                break;
            case 'noop':
                break;
            default:
                console.log(`[${Game.time}] Invalid command: ${command}!`);
                return false;
        }
        if (autoEngage) {
            actor.autoEngage();
        }
        return true;
    }
    /**
     * Determine the list of actions for each Zerg to perform
     */
    static parseActions(actors, serializedActions) {
        const receivedOrders = _.mapValues(actors, (actor) => false);
        // Deserialize the actions for each actor
        for (const creepName in serializedActions) {
            const creep = actors[creepName];
            if (!creep) {
                console.log(`No creep with name ${creepName}!`);
                continue;
            }
            // Parse and execute each action, recording whether it was valid
            for (const action of serializedActions[creepName]) {
                const validAction = ActionParser.parseAction(creep, action);
                if (validAction) {
                    receivedOrders[creepName] = true;
                }
            }
        }
        // Ensure each actor was given an order (possibly noop)
        for (const actorName in actors) {
            if (!receivedOrders[actorName]) {
                console.log(
                    `[${Game.time}] Actor with name ${actorName} did not receive an order this tick!`,
                );
            }
        }
    }
    /**
     * Periodic logging functions that are used to describe state of training map and identify bugs
     */
    static logState(contents) {
        console.log(
            `[${Game.time}] My creeps: `,
            _.map(Game.creeps, (creep) => creep.name + ' ' + creep.pos),
        );
        if (Memory.reinforcementLearning) {
            console.log(`[${Game.time}] RL Segment: ${contents}`);
        }
    }
    /**
     * Wraps all creeps as Zerg
     */
    static getAllActors() {
        return _.mapValues(Game.creeps, (creep) => new NeuralZerg(creep));
    }
    /**
     * Read action commands from the designated memory segment, parse them, and run them
     */
    static run() {
        // Wrap all creep as NeuralZerg and partition actors into controllable and uncontrollable (scripted) sets
        const allActors = ActionParser.getAllActors();
        const controllableActors = {};
        const uncontrollableActors = {};
        for (const name in allActors) {
            const actor = allActors[name];
            if (allActors[name].isBot) {
                uncontrollableActors[name] = actor;
            } else {
                controllableActors[name] = actor;
            }
        }
        // Parse memory and relay actions to controllable actors
        const raw = RawMemory.segments[SEGMENTS.reinforcementLearning];
        if (raw != undefined && raw != '') {
            const actions = JSON.parse(raw);
            ActionParser.parseActions(controllableActors, actions);
        } else {
            if (_.size(controllableActors) > 0) {
                console.log(`[${Game.time}]: No actions received!`);
            }
        }
        // Run uncontrollable actors on a script
        for (const name in uncontrollableActors) {
            const bot = uncontrollableActors[name];
            // TrainingOpponents.stupidCombat(bot);
            TrainingOpponents.simpleCombat(bot);
        }
        // Log state according to verbosity
        if (RL_TRAINING_VERBOSITY == 0);
        else if (RL_TRAINING_VERBOSITY == 1) {
            if (Game.time % 100 == 0 || Game.time % 100 == 1) {
                this.logState(raw);
            }
        } else if (RL_TRAINING_VERBOSITY == 2) {
            this.logState(raw);
        }
        // Clear the segment and keep it requested
        RawMemory.segments[SEGMENTS.reinforcementLearning] = '';
        RawMemory.setActiveSegments([SEGMENTS.reinforcementLearning]);
    }
}

//
global.PHASE = 'assimilating';
global.LATEST_BUILD_TICK = Game.time;
// =====================================================================================================================
// Main loop
function exportStats() {
    // Reset stats object
    Memory.stats = {
        gcl: {},
        rooms: {},
        cpu: {},
    };

    Memory.stats.time = Game.time;

    // Collect room stats
    for (let roomName in Game.rooms) {
        let room = Game.rooms[roomName];
        let isMyRoom = room.controller ? room.controller.my : false;
        if (isMyRoom) {
            let roomStats = (Memory.stats.rooms[roomName] = {});
            roomStats.storageEnergy = room.storage
                ? room.storage.store.energy
                : 0;
            roomStats.terminalEnergy = room.terminal
                ? room.terminal.store.energy
                : 0;
            roomStats.energyAvailable = room.energyAvailable;
            roomStats.energyCapacityAvailable = room.energyCapacityAvailable;
            roomStats.controllerProgress = room.controller.progress;
            roomStats.controllerProgressTotal = room.controller.progressTotal;
            roomStats.controllerLevel = room.controller.level;
        }
    }

    // Collect GCL stats
    Memory.stats.gcl.progress = Game.gcl.progress;
    Memory.stats.gcl.progressTotal = Game.gcl.progressTotal;
    Memory.stats.gcl.level = Game.gcl.level;

    // Collect CPU stats
    Memory.stats.cpu.bucket = Game.cpu.bucket;
    Memory.stats.cpu.limit = Game.cpu.limit;
    Memory.stats.cpu.used = Game.cpu.getUsed();
}

function profileMethodWithLineNumber(object, methodName) {
    const originalMethod = object[methodName];
    const callStats = {}; // Object to store call statistics

    object[methodName] = function (...args) {
        const startCpu = Game.cpu.getUsed();

        const result = originalMethod.apply(this, args);

        const elapsedCpu = Game.cpu.getUsed() - startCpu;
        const stackLines = new Error().stack.split("\n");
        // Assuming the call to the profiled method is at the third position in the stack trace
        const callerInfo = stackLines[2] || '';
        const match = callerInfo.match(/(.*):(\d+):\d+\)?$/); // Regex to extract file name and line number
        if (match) {
            const [, file, line] = match;
            const key = `${file}:${line}`;
            if (!callStats[key]) {
                callStats[key] = { count: 0, totalCpu: 0 };
            }
            callStats[key].count++;
            callStats[key].totalCpu += elapsedCpu;
        }

        return result;
    };

    object.getCallStats = function () {
        return callStats;
    };
}

// Example usage
//profileMethodWithLineNumber(Room.prototype, 'find');

// Function to print the call statistics
function printCallStats() {
    const stats = Room.prototype.getCallStats();
    console.log("Call Stats by Line Number:");
    Object.entries(stats).forEach(([key, { count, totalCpu }]) => {
        if(totalCpu > 3) console.log(`${key} - Count: ${count}, CPU Used: ${totalCpu.toFixed(2)}`);
    });
}

/////////////
/////////////
/////////////
// Profiling data structure initialization
if (!global.profiling) {
    global.profiling = {
        creeps: { calls: 0, cpuUsed: 0 },
        reset: function() {
            this.creeps = { calls: 0, cpuUsed: 0 };
        },
        logResults: function() {
            console.log(`Creeps getter called ${this.creeps.calls} times, total CPU used: ${this.creeps.cpuUsed.toFixed(4)}`);
        }
    };
}
class CPUProfiler {
    constructor() {
        this.profiles = {};
    }

    start(referenceName) {
        if (!this.profiles[referenceName]) {
            this.profiles[referenceName] = { start: 0, end: 0, total: 0, calls: 0, average: 0 };
        }
        this.profiles[referenceName].start = Game.cpu.getUsed();
    }

    end(referenceName) {
        const profile = this.profiles[referenceName];
        if (profile && profile.start !== 0) { // Ensure a start was recorded
            profile.end = Game.cpu.getUsed();
            const cpuUsed = profile.end - profile.start;
            profile.total += cpuUsed;
            profile.calls += 1;
            profile.average = profile.total / profile.calls; // Calculate average
            profile.lastCpuUsed = cpuUsed
        } else {
            console.log(`CPUProfiler: No start recorded for ${referenceName} or profile does not exist.`);
        }
    }

    logResults() {
        if(Object.entries(this.profiles).length) {
            console.log(`CPU Profiling Results:`);
            for (const [referenceName, data] of Object.entries(this.profiles)) {
                console.log(`${referenceName}: Total CPU Used - ${data.total.toFixed(2)}, Calls - ${data.calls}, Last CPU Used - ${data.lastCpuUsed.toFixed(2)}, Average CPU per Call - ${data.average.toFixed(2)}`);
            }
        }
    }
}

const cpuProfiler = new CPUProfiler();

function main() {

    if (Game.shard.name == 'shard3') return;

    let balance_resources = [
        {
            // in only
            [RESOURCE_HYDROGEN]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_OXYGEN]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_UTRIUM]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_KEANIUM]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_LEMERGIUM]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_ZYNTHIUM]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_CATALYST]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_GHODIUM]: { min: 500, max: 1000, prod: 0 },
            [RESOURCE_SILICON]: { min: 200, max: 400, prod: 0 },
            [RESOURCE_METAL]: { min: 200, max: 400, prod: 0 },
            [RESOURCE_BIOMASS]: { min: 200, max: 400, prod: 0 },
            [RESOURCE_MIST]: { min: 200, max: 400, prod: 0 },

            // shared in/out:
            [RESOURCE_UTRIUM_BAR]: { min: 120, max: 500, prod: 1000 },
            [RESOURCE_LEMERGIUM_BAR]: { min: 120, max: 500, prod: 1000 },
            [RESOURCE_ZYNTHIUM_BAR]: { min: 120, max: 500, prod: 1000 },
            [RESOURCE_KEANIUM_BAR]: { min: 120, max: 500, prod: 1000 },

            // out only
            [RESOURCE_GHODIUM_MELT]: { min: 0, max: 0, prod: 1000 },
            [RESOURCE_OXIDANT]: { min: 0, max: 0, prod: 1000 },
            [RESOURCE_REDUCTANT]: { min: 0, max: 0, prod: 1000 },
            [RESOURCE_PURIFIER]: { min: 0, max: 0, prod: 1000 },
            [RESOURCE_WIRE]: { min: 0, max: 0, prod: 40 },
            [RESOURCE_CELL]: { min: 0, max: 0, prod: 40 },
            [RESOURCE_ALLOY]: { min: 0, max: 0, prod: 40 },
            [RESOURCE_CONDENSATE]: { min: 0, max: 0, prod: 40 },
        },
    ];

    if (Game.cpu.bucket > 9400 && Game.time % 151 == 0) {
        const DEBUG_z = false;

        // Create a list of all terminals from all colonies
        const terminals = Object.values(Overmind.colonies).map(
            (colony) => colony.terminal,
        );

        // Track excess terminals
        let excessTerminalsTracker = [];

        // Loop through all resources in balance_resources
        for (const resource in balance_resources[0]) {
            const resourceType = resource;
            const { min, max, prod } = balance_resources[0][resourceType];

            if (DEBUG_z) {
                console.log(
                    `Checking resource: ${resourceType}, min: ${min}, max: ${max}, prod: ${prod}`,
                );
            }

            // Add excess terminals to tracker
            const excessTerminals = terminals.filter(
                (terminal) =>
                    terminal.store[resourceType] > max &&
                    !excessTerminalsTracker.includes(terminal),
            );
            if (DEBUG_z) {
                console.log(
                    `Excess terminals for ${resourceType}: ${excessTerminals
                        .map((terminal) => terminal.room.name)
                        .join(', ')}`,
                );
            }

            // If no excess terminals, skip to next resource
            if (excessTerminals.length === 0) {
                if (DEBUG_z) {
                    console.log(`No excess terminals for ${resourceType}`);
                }
                continue;
            }

            // Loop through insufficient terminals for this resource
            const insufficientTerminals = terminals.filter(
                (terminal) => terminal.store[resourceType] < min,
            );
            if (DEBUG_z) {
                console.log(
                    `Insufficient terminals for ${resourceType}: ${insufficientTerminals
                        .map((terminal) => terminal.room.name)
                        .join(', ')}`,
                );
            }

            // If no insufficient terminals, skip to next resource
            if (insufficientTerminals.length === 0) {
                if (DEBUG_z) {
                    console.log(
                        `No insufficient terminals for ${resourceType}`,
                    );
                }
                continue;
            }

            // Select a random excess terminal and target terminal
            const excessTerminal = _.sample(excessTerminals);
            const targetTerminal = _.sample(insufficientTerminals);
            if (DEBUG_z) {
                console.log(
                    `Excess terminal: ${excessTerminal.room.name}, target terminal: ${targetTerminal.room.name}`,
                );
            }

            // Calculate the amount to send
            const amountToSend = Math.min(
                min - targetTerminal.store[resourceType],
                excessTerminal.store[resourceType] - max,
            );
            if (DEBUG_z) {
                console.log(
                    `Amount to send: ${amountToSend}, excessTerminal: ${excessTerminal.room.name}, targetTerminal: ${targetTerminal.room.name}`,
                );
                console.log(
                    `max - targetTerminal.store[resourceType]: ${
                        max - targetTerminal.store[resourceType]
                    }, excessTerminal.store[resourceType] - max: ${
                        excessTerminal.store[resourceType] - max
                    }, prod: ${prod}`,
                );
            }

            // Send the resources if possible
            if (amountToSend > 0 && excessTerminal.cooldown === 0) {
                const result = excessTerminal.send(
                    resourceType,
                    amountToSend,
                    targetTerminal.room.name,
                );
                console.log(
                    `Sent ${amountToSend} ${resourceType} from ${excessTerminal.room.name} to ${targetTerminal.room.name}, result: ${result}`,
                );
                if (result === OK) {
                    excessTerminalsTracker.push(excessTerminal);
                }
            }
        }
    }

    if ((Game.time + 10000 - 1) % 999 == 0) {
        Overmind.tradeNetwork.cleanOrders();
    }
    if ((Game.time + 10000) % 999 == 0) {
        let resources = ['XZHO2', 'XUHO2', 'XLHO2', 'XKHO2', RESOURCE_POWER];
        _.forEach(resources, (resource) => {
            //let price = Overmind.tradeNetwork.priceOf(resource)*0.90;
            // let price =
            //    Overmind.tradeNetwork.getPriceForBaseIngredients(resource) *
            //    1.025;
            let price = Overmind.tradeNetwork.computeCompetitivePrice(ORDER_BUY, resource, 'W44N37').toFixed(3);
            if (resource == RESOURCE_POWER) {
                let marketPrice = Overmind.tradeNetwork.priceOf(resource);
                const maxPrice = 600;   // Maximum price for 0% discount
                const midPrice = 1500;  // Price where discount reaches 10%
                const maxDiscount = 0.15; // Maximum discount percentage
                let buyPrice;
            
                if (marketPrice < maxPrice) {
                    // Buy at market price
                    buyPrice = marketPrice;
                } else if (marketPrice <= midPrice) {
                    // Calculate discount percentage based on market price
                    const discountPercentage = (marketPrice - maxPrice) * maxDiscount / (midPrice - maxPrice);
                    buyPrice = marketPrice * (1 - discountPercentage);
                } else {
                    // Stay at 10% discount
                    buyPrice = marketPrice * (1 - maxDiscount);
                }
            
                price =  buyPrice;
            }
            _.forEach(Overmind.colonies, (c) => {
                let myOrders = Game.market.getAllOrders({
                    type: ORDER_BUY,
                    resourceType: resource,
                    roomName: c.room.name,
                });
                let ops = c.assets[resource];
                let targetAmount = resource == RESOURCE_POWER ? 50000 : 25000;
                if (
                    c.room.terminal &&
                    c.assets[resource] < targetAmount &&
                    myOrders.length == 0
                ) {
                    Game.market.createOrder(
                        ORDER_BUY,
                        resource,
                        price + (targetAmount - ops) / 10000,
                        targetAmount - ops,
                        c.room.name,
                    );
                } else {
                    if (myOrders.length > 0 && price > myOrders[0].price) {
                        Game.market.changeOrderPrice(
                            myOrders[0].id,
                            price + (targetAmount - ops) / 10000,
                        );
                    }
                    if (
                        myOrders.length > 0 &&
                        c.assets[resource] < targetAmount &&
                        myOrders[0] < 1000
                    ) {
                        Game.market.extendOrder(
                            myOrders[0].id,
                            25000 - myOrders[0],
                        );
                    }
                }
            });
        });
    }
    if ((Game.time - 1) % 2500 == 0) {
        Overmind.tradeNetwork.cleanOrders();
    }
    if (Game.time % 2500 == 0) {
        let resources = ['Z', 'U', 'K', 'X', 'H', 'L', 'O',RESOURCE_BATTERY];
        let powerPrice = Overmind.tradeNetwork.priceOf(RESOURCE_POWER);
        _.forEach(resources, (resource) => {
            // let price = Overmind.tradeNetwork.priceOf(resource);
            let price = Overmind.tradeNetwork.computeCompetitivePrice(ORDER_SELL, resource, 'W44N37').toFixed(3);
            let newPrice = Overmind.tradeNetwork.priceOf(RESOURCE_ENERGY)*5*0.8;
            if(resource == RESOURCE_BATTERY && price < newPrice) {
                price = newPrice;
            }
            if(resource == RESOURCE_BATTERY) {
                    let marketPrice = price;
                    const basePrice = 400; // Base price for when market price is >= 250
                    const minPrice = 100;   // Minimum price for when market price is <= 50
                    const maxMarkup = 0.35; // Maximum markup percentage
                    let sellPrice;
                
                    if (marketPrice >= basePrice) {
                        // Sell at market price
                        sellPrice = marketPrice;
                    } else if (marketPrice <= minPrice) {
                        // Sell with an extra 10% margin
                        sellPrice = marketPrice * (1 + maxMarkup);
                    } else {
                        // Gradually decrease markup from 10% to 0% as market price increases from 50 to 250
                        const priceDifference = basePrice - marketPrice;
                        const markupPercentage = maxMarkup * (priceDifference / (basePrice - minPrice));
                        sellPrice = marketPrice * (1 + markupPercentage);
                    }
                
                    price =  sellPrice;
            }
            
            //if(resource == RESOURCE_BATTERY && price < powerPrice/5) {
            //    price = powerPrice/5;
            //}
            _.forEach(Overmind.colonies, (c) => {
                let myOrders = Game.market.getAllOrders({
                    type: ORDER_SELL,
                    resourceType: resource,
                    roomName: c.room.name,
                });
                let ops = c.assets[resource];
                if (
                    c.room.terminal &&
                    c.assets[resource] > 25000 &&
                    myOrders.length == 0
                ) {
                    if (resource == RESOURCE_BATTERY) {
                        Game.market.createOrder(
                            ORDER_SELL,
                            resource,
                            price - (ops - 25000) / 25000,
                            ops - 20000,
                            c.room.name,
                        );
                    } else {
                        Game.market.createOrder(
                            ORDER_SELL,
                            resource,
                            price - (ops - 25000) / 25000,
                            ops - 5000,
                            c.room.name,
                        );
                    }
                } else {
                    if (myOrders.length > 0 && price < myOrders[0].price) {
                        Game.market.changeOrderPrice(
                            myOrders[0].id,
                            price - (ops - 25000) / 25000,
                        );
                    }
                }
            });
        });
    }

    /*
    if(Game.time % 10 == 0) {
    _.forEach(Overmind.colonies, (c) => {
            if (_.sum(c.storage.store) > 900000) {
                console.log(c.name,_.sum(c.storage.store));
                for(const resource in c.storage.store) {
                    if(resource === RESOURCE_ENERGY) continue;
                    if(c.storage.store[resource] > 40000 && resource.length < 3 && c.terminal.cooldown == 0 && c.terminal.store[resource] > 3000) {
                        console.log('        ',c.name,_.sum(c.storage.store),resource,c.storage.store[resource]);
    					let sample = _.sample(['W32N53','W49N46','W47N45','W41N46','W39N45','W37N44','W36N49','W34N51','W32N58','W22N49','W29N58']);
                        c.terminal.send(resource,3000,sample);

                        break;
                    }
                }
            }
        });
    }
    */
    //if(Game.time % 250 == 0) {
    //_.forEach(Overmind.colonies, (c) => {
    //        let sample = _.sample(["W53N54","W54N57","W48N55"]);
    //        c.terminal.send(RESOURCE_ENERGY,1000,sample);
    //    });
    //}
    // Memory operations: load and clean memory, suspend operation as needed -------------------------------------------
    Stats.profile('main.mem_load', () => {
        Mem.load(); // Load previous parsed memory if present
    });
    if (!Mem.shouldRun()) return; // Suspend operation if necessary
    Stats.profile('main.mem_clean', () => {
        Mem.clean(); // Clean memory contents
    });
    Stats.log(`profiler.main.before`, Game.cpu.getUsed());
    Stats.beginTick();
    // Instantiation operations: build or refresh the game state -------------------------------------------------------
    if (!Overmind || Overmind.shouldBuild || Game.time >= Overmind.expiration) {
        Stats.profile('main.overmind_gc', () => {
            PHASE = 'build';
            delete global.Overmind; // Explicitly delete the old Overmind object
            Mem.garbageCollect(true); // Run quick garbage collection
            global.Overmind = new _Overmind$1(); // Instantiate the Overmind object
            Overmind.build(); // Build phase: instantiate all game components
            LATEST_BUILD_TICK = Game.time; // Record this tick as having a build reset
        });
    } else {
        Stats.profile('main.overmind_refresh', () => {
            PHASE = 'refresh';
            Overmind.refresh(); // Refresh phase: update the Overmind state
        });
    }
    // Tick loop cycle: initialize and run each component --------------------------------------------------------------
    Stats.profile('main.overmind_init', () => {
        PHASE = 'init';
        Overmind.init(); // Init phase: spawning and energy requests
    });
    Stats.profile('main.overmind_run', () => {
        PHASE = 'run';
        Overmind.run(); // Run phase: execute state-changing actions
    });
    Stats.profile('main.overmind_visuals', () => {
        PHASE = 'postRun';
        //cpuProfiler.start('Overmind.visuals()');
        //Overmind.visuals(); // Draw visuals // zGeneral 2/2024 
        //cpuProfiler.end('Overmind.visuals()');
    });
    Stats.profile('main.overmind_stats', () => {
        Stats.run(); // Record statistics
    });
    Memory.tick++; // Record successful tick
    // Post-run code: handle sandbox code and error catching -----------------------------------------------------------
    Stats.profile('main.sandbox', () => {
        sandbox(); // Sandbox: run any testing code
    });
    global.remoteDebugger.run(); // Run remote debugger code if enabled
    Stats.profile('main.overmind_postrun', () => {
        Overmind.postRun(); // Throw errors at end of tick; anything after here might not get run
    });
    Stats.endTick();
    
    //printCallStats();
    // At the end of your main loop
    // At the end of your main loop
    // global.profiling.logResults();
    // global.profiling.reset();
    //console.log('CPU', Game.cpu.getUsed().toFixed(2),'Bucket', Game.cpu.bucket);
    cpuProfiler.logResults();
    /*
    let cx = Game.getObjectById('65cb322668f9918bbfba1cab');
    let targetx = Game.getObjectById('65a41cc039057a14489e8b41');
    let posx = new RoomPosition(36,47,'W56N51');
    if(cx){
        cx.moveTo(posx);
        cx.attack(targetx);
    }
    */
    if(Game.cpu.bucket != 10000)
        console.log('bucket', Game.cpu.bucket, 'cpu', Game.cpu.getUsed().toFixed(0));

    
}
// Main loop if RL mode is enabled (~settings.ts)
function main_RL() {
    Mem.clean();
    delete global.Overmind;
    global.Overmind = new _Overmind$1();
    ActionParser.run();
}
// This gets run on each global reset
function onGlobalReset() {
    global.LATEST_GLOBAL_RESET_TICK = Game.time;
    global.LATEST_GLOBAL_RESET_DATE = new Date();
    Mem.format();
    OvermindConsole.init();
    VersionMigration.run();
    if (!Memory.stats.persistent) {
        Memory.stats.persistent = {};
    }
    Memory.stats.persistent.lastGlobalReset = Game.time;
    OvermindConsole.printUpdateMessage();
    // Make a new Overmind object
    global.Overmind = new _Overmind$1();
    // Make a remote debugger
    global.remoteDebugger = new RemoteDebugger();
}
// Global reset function if RL mode is enabled
function onGlobalReset_RL() {
    Mem.format();
}
// Decide which loop to export as the script loop
let _loop;
if (RL_TRAINING_MODE) {
    // Use stripped version for training reinforcment learning model
    _loop = main_RL;
} else {
    {
        // Use the default main loop
        _loop = main;
    }
}
const loop = _loop;
// Run the appropriate global reset function
if (RL_TRAINING_MODE) {
    OvermindConsole.printTrainingMessage();
    onGlobalReset_RL();
} else {
    // Run the global reset code
    onGlobalReset();
}

exports.loop = loop;
